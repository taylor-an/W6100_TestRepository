; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\objects\stm32f4xx_fsmc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_fsmc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\test_[SLAAC-RDNSS] -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\io6Library\Application\loopback -I..\..\Libraries\io6Library\Ethernet -I..\..\Libraries\io6Library\Ethernet\W6100 -I..\..\Libraries\io6Library\Internet\DHCP -I..\..\Libraries\io6Library\Internet\DNS -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\io6Library\Internet\DHCP6 -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Ic:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F4XX -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f4xx_fsmc.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fsmc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMDeInit PROC
;;;115      */
;;;116    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  0081              LSLS     r1,r0,#2
;;;117    {
;;;118      /* Check the parameter */
;;;119      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;120      
;;;121      /* FSMC_Bank1_NORSRAM1 */
;;;122      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;123      {
;;;124        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
;;;125      }
;;;126      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;127      else
;;;128      {   
;;;129        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000002  f1a141c0          SUB      r1,r1,#0x60000000
000006  b140              CBZ      r0,|L1.26|
000008  f24300d2          MOV      r0,#0x30d2
00000c  6008              STR      r0,[r1,#0]
                  |L1.14|
;;;130      }
;;;131      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
00000e  f06f4070          MVN      r0,#0xf0000000
000012  6048              STR      r0,[r1,#4]
;;;132      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
000014  f8c10104          STR      r0,[r1,#0x104]
;;;133    }
000018  4770              BX       lr
                  |L1.26|
00001a  f04f4220          MOV      r2,#0xa0000000        ;124
00001e  f24300db          MOV      r0,#0x30db            ;124
000022  6010              STR      r0,[r2,#0]            ;124
000024  e7f3              B        |L1.14|
;;;134    
                          ENDP

                  FSMC_NORSRAMInit PROC
;;;142      */
;;;143    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000026  b510              PUSH     {r4,lr}
;;;144    { 
000028  e9d01201          LDRD     r1,r2,[r0,#4]
;;;145      /* Check the parameters */
;;;146      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;147      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;148      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;149      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;150      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;151      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;152      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;153      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;154      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;155      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;156      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;157      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;158      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;159      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;160      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;161      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;162      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;163      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;164      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;165      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;166      
;;;167      /* Bank1 NOR/SRAM control register configuration */ 
;;;168      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
00002c  4311              ORRS     r1,r1,r2
00002e  e9d02303          LDRD     r2,r3,[r0,#0xc]
000032  431a              ORRS     r2,r2,r3
000034  4311              ORRS     r1,r1,r2
000036  6942              LDR      r2,[r0,#0x14]
000038  4311              ORRS     r1,r1,r2
00003a  6982              LDR      r2,[r0,#0x18]
00003c  4311              ORRS     r1,r1,r2
00003e  69c2              LDR      r2,[r0,#0x1c]
000040  4311              ORRS     r1,r1,r2
000042  6a02              LDR      r2,[r0,#0x20]
000044  4311              ORRS     r1,r1,r2
000046  6a42              LDR      r2,[r0,#0x24]
000048  4311              ORRS     r1,r1,r2
00004a  6a82              LDR      r2,[r0,#0x28]
00004c  4311              ORRS     r1,r1,r2
00004e  6ac2              LDR      r2,[r0,#0x2c]
000050  4311              ORRS     r1,r1,r2
000052  6b02              LDR      r2,[r0,#0x30]
000054  4311              ORRS     r1,r1,r2
000056  6802              LDR      r2,[r0,#0]
000058  0092              LSLS     r2,r2,#2
00005a  f1a242c0          SUB      r2,r2,#0x60000000
00005e  6011              STR      r1,[r2,#0]
;;;169                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;170                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;171                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;172                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;173                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;174                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;175                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;176                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;177                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;178                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;179                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;180                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;181      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
000060  6881              LDR      r1,[r0,#8]
000062  2908              CMP      r1,#8
000064  d107              BNE      |L1.118|
;;;182      {
;;;183        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
000066  6801              LDR      r1,[r0,#0]
000068  0089              LSLS     r1,r1,#2
00006a  f1a141c0          SUB      r1,r1,#0x60000000
00006e  680a              LDR      r2,[r1,#0]
000070  f0420240          ORR      r2,r2,#0x40
000074  600a              STR      r2,[r1,#0]
                  |L1.118|
;;;184      }
;;;185      /* Bank1 NOR/SRAM timing register configuration */
;;;186      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
000076  6b41              LDR      r1,[r0,#0x34]
000078  e9d12300          LDRD     r2,r3,[r1,#0]
00007c  ea421203          ORR      r2,r2,r3,LSL #4
000080  688b              LDR      r3,[r1,#8]
000082  898c              LDRH     r4,[r1,#0xc]
000084  021b              LSLS     r3,r3,#8
000086  ea434304          ORR      r3,r3,r4,LSL #16
00008a  431a              ORRS     r2,r2,r3
00008c  8a0b              LDRH     r3,[r1,#0x10]
00008e  ea425203          ORR      r2,r2,r3,LSL #20
000092  7d0b              LDRB     r3,[r1,#0x14]
000094  6989              LDR      r1,[r1,#0x18]
000096  ea426203          ORR      r2,r2,r3,LSL #24
00009a  430a              ORRS     r2,r2,r1
00009c  6801              LDR      r1,[r0,#0]
00009e  0089              LSLS     r1,r1,#2
0000a0  f1a141c0          SUB      r1,r1,#0x60000000
0000a4  604a              STR      r2,[r1,#4]
;;;187                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;188                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;189                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;190                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;191                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;192                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;193                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;194                
;;;195        
;;;196      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;197      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
0000a6  6ac1              LDR      r1,[r0,#0x2c]
0000a8  f5b14f80          CMP      r1,#0x4000
0000ac  d008              BEQ      |L1.192|
;;;198      {
;;;199        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;200        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;201        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;202        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;203        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;204        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;205        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
;;;206                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;207                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;208                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;209                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;210                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;211                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;212      }
;;;213      else
;;;214      {
;;;215        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
0000ae  6800              LDR      r0,[r0,#0]
0000b0  f06f4170          MVN      r1,#0xf0000000
0000b4  0080              LSLS     r0,r0,#2
0000b6  f1a040c0          SUB      r0,r0,#0x60000000
0000ba  f8c01104          STR      r1,[r0,#0x104]
;;;216      }
;;;217    }
0000be  bd10              POP      {r4,pc}
                  |L1.192|
0000c0  6b81              LDR      r1,[r0,#0x38]         ;205
0000c2  e9d12300          LDRD     r2,r3,[r1,#0]         ;205
0000c6  ea421203          ORR      r2,r2,r3,LSL #4       ;205
0000ca  688b              LDR      r3,[r1,#8]            ;205
0000cc  8a0c              LDRH     r4,[r1,#0x10]         ;205
0000ce  021b              LSLS     r3,r3,#8              ;205
0000d0  ea435304          ORR      r3,r3,r4,LSL #20      ;205
0000d4  431a              ORRS     r2,r2,r3              ;205
0000d6  7d0b              LDRB     r3,[r1,#0x14]         ;205
0000d8  6989              LDR      r1,[r1,#0x18]         ;205
0000da  ea426203          ORR      r2,r2,r3,LSL #24      ;205
0000de  6800              LDR      r0,[r0,#0]            ;205
0000e0  430a              ORRS     r2,r2,r1              ;205
0000e2  0080              LSLS     r0,r0,#2              ;205
0000e4  f1a040c0          SUB      r0,r0,#0x60000000     ;205
0000e8  f8c02104          STR      r2,[r0,#0x104]        ;205
0000ec  bd10              POP      {r4,pc}
;;;218    
                          ENDP

                  FSMC_NORSRAMStructInit PROC
;;;224      */
;;;225    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
0000ee  b510              PUSH     {r4,lr}
;;;226    {  
;;;227      /* Reset NOR/SRAM Init structure parameters values */
;;;228      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
0000f0  2100              MOVS     r1,#0
;;;229      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
0000f2  2202              MOVS     r2,#2
0000f4  e9c01200          STRD     r1,r2,[r0,#0]
;;;230      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;231      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
0000f8  6081              STR      r1,[r0,#8]
;;;232      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
0000fa  60c1              STR      r1,[r0,#0xc]
;;;233      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
0000fc  6101              STR      r1,[r0,#0x10]
;;;234      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
0000fe  6141              STR      r1,[r0,#0x14]
;;;235      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000100  6181              STR      r1,[r0,#0x18]
;;;236      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;237      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000102  02d2              LSLS     r2,r2,#11
000104  61c1              STR      r1,[r0,#0x1c]
000106  e9c01208          STRD     r1,r2,[r0,#0x20]
;;;238      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00010a  0052              LSLS     r2,r2,#1
00010c  e9c0210a          STRD     r2,r1,[r0,#0x28]
;;;239      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;240      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
;;;241      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000110  6301              STR      r1,[r0,#0x30]
000112  6b43              LDR      r3,[r0,#0x34]
000114  220f              MOVS     r2,#0xf
;;;242      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000116  601a              STR      r2,[r3,#0]
000118  6b43              LDR      r3,[r0,#0x34]
;;;243      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00011a  605a              STR      r2,[r3,#4]
00011c  6b44              LDR      r4,[r0,#0x34]
00011e  23ff              MOVS     r3,#0xff
;;;244      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000120  60a3              STR      r3,[r4,#8]
000122  6b44              LDR      r4,[r0,#0x34]
;;;245      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
000124  60e2              STR      r2,[r4,#0xc]
000126  6b44              LDR      r4,[r0,#0x34]
;;;246      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
000128  6122              STR      r2,[r4,#0x10]
00012a  6b44              LDR      r4,[r0,#0x34]
;;;247      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
00012c  6162              STR      r2,[r4,#0x14]
00012e  6b44              LDR      r4,[r0,#0x34]
;;;248      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000130  61a1              STR      r1,[r4,#0x18]
000132  6b84              LDR      r4,[r0,#0x38]
;;;249      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000134  6022              STR      r2,[r4,#0]
000136  6b84              LDR      r4,[r0,#0x38]
;;;250      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
000138  6062              STR      r2,[r4,#4]
00013a  6b84              LDR      r4,[r0,#0x38]
;;;251      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
00013c  60a3              STR      r3,[r4,#8]
00013e  6b83              LDR      r3,[r0,#0x38]
;;;252      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
000140  60da              STR      r2,[r3,#0xc]
000142  6b83              LDR      r3,[r0,#0x38]
;;;253      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
000144  611a              STR      r2,[r3,#0x10]
000146  6b83              LDR      r3,[r0,#0x38]
;;;254      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
000148  615a              STR      r2,[r3,#0x14]
00014a  6b80              LDR      r0,[r0,#0x38]
00014c  6181              STR      r1,[r0,#0x18]
;;;255    }
00014e  bd10              POP      {r4,pc}
;;;256    
                          ENDP

                  FSMC_NORSRAMCmd PROC
;;;267      */
;;;268    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000150  0080              LSLS     r0,r0,#2
;;;269    {
;;;270      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;271      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;272      
;;;273      if (NewState != DISABLE)
;;;274      {
;;;275        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;276        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
000152  f1a040c0          SUB      r0,r0,#0x60000000
000156  2900              CMP      r1,#0                 ;273
;;;277      }
;;;278      else
;;;279      {
;;;280        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;281        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
000158  6801              LDR      r1,[r0,#0]
00015a  d002              BEQ      |L1.354|
00015c  f0410101          ORR      r1,r1,#1              ;276
000160  e001              B        |L1.358|
                  |L1.354|
000162  4ac5              LDR      r2,|L1.1144|
000164  4011              ANDS     r1,r1,r2
                  |L1.358|
000166  6001              STR      r1,[r0,#0]            ;276
;;;282      }
;;;283    }
000168  4770              BX       lr
;;;284    /**
                          ENDP

                  FSMC_NANDDeInit PROC
;;;338      */
;;;339    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
00016a  b510              PUSH     {r4,lr}
;;;340    {
;;;341      /* Check the parameter */
;;;342      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;343      
;;;344      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;345      {
;;;346        /* Set the FSMC_Bank2 registers to their reset values */
;;;347        FSMC_Bank2->PCR2 = 0x00000018;
00016c  2318              MOVS     r3,#0x18
;;;348        FSMC_Bank2->SR2 = 0x00000040;
00016e  2440              MOVS     r4,#0x40
000170  f04f4120          MOV      r1,#0xa0000000        ;347
;;;349        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
000174  f04f32fc          MOV      r2,#0xfcfcfcfc
000178  2810              CMP      r0,#0x10              ;344
00017a  d005              BEQ      |L1.392|
;;;350        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
;;;351      }
;;;352      /* FSMC_Bank3_NAND */  
;;;353      else
;;;354      {
;;;355        /* Set the FSMC_Bank3 registers to their reset values */
;;;356        FSMC_Bank3->PCR3 = 0x00000018;
00017c  f8413f80          STR      r3,[r1,#0x80]!
;;;357        FSMC_Bank3->SR3 = 0x00000040;
000180  604c              STR      r4,[r1,#4]
;;;358        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
000182  608a              STR      r2,[r1,#8]
;;;359        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
000184  60ca              STR      r2,[r1,#0xc]
;;;360      }  
;;;361    }
000186  bd10              POP      {r4,pc}
                  |L1.392|
000188  660b              STR      r3,[r1,#0x60]         ;347
00018a  664c              STR      r4,[r1,#0x64]         ;348
00018c  668a              STR      r2,[r1,#0x68]         ;349
00018e  66ca              STR      r2,[r1,#0x6c]         ;350
000190  bd10              POP      {r4,pc}
;;;362    
                          ENDP

                  FSMC_NANDInit PROC
;;;369      */
;;;370    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000192  b530              PUSH     {r4,r5,lr}
;;;371    {
000194  e9d01201          LDRD     r1,r2,[r0,#4]
;;;372      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;373        
;;;374      /* Check the parameters */
;;;375      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;376      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;377      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;378      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;379      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;380      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;381      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;382      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;383      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;384      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;385      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;386      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;387      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;388      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;389      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;390      
;;;391      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;392      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000198  4311              ORRS     r1,r1,r2
00019a  e9d02303          LDRD     r2,r3,[r0,#0xc]
00019e  431a              ORRS     r2,r2,r3
0001a0  4311              ORRS     r1,r1,r2
0001a2  6942              LDR      r2,[r0,#0x14]
0001a4  ea412142          ORR      r1,r1,r2,LSL #9
0001a8  6982              LDR      r2,[r0,#0x18]
0001aa  ea413142          ORR      r1,r1,r2,LSL #13
0001ae  f0410408          ORR      r4,r1,#8
;;;393                PCR_MEMORYTYPE_NAND |
;;;394                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;395                FSMC_NANDInitStruct->FSMC_ECC |
;;;396                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;397                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;398                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;399                
;;;400      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;401      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
0001b2  69c1              LDR      r1,[r0,#0x1c]
0001b4  e9d12300          LDRD     r2,r3,[r1,#0]
0001b8  ea422203          ORR      r2,r2,r3,LSL #8
0001bc  890b              LDRH     r3,[r1,#8]
0001be  7b09              LDRB     r1,[r1,#0xc]
0001c0  041b              LSLS     r3,r3,#16
0001c2  ea436101          ORR      r1,r3,r1,LSL #24
0001c6  430a              ORRS     r2,r2,r1
;;;402                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;403                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;404                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;405                
;;;406      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;407      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
0001c8  6a01              LDR      r1,[r0,#0x20]
0001ca  e9d13500          LDRD     r3,r5,[r1,#0]
0001ce  ea432305          ORR      r3,r3,r5,LSL #8
0001d2  890d              LDRH     r5,[r1,#8]
0001d4  7b09              LDRB     r1,[r1,#0xc]
0001d6  042d              LSLS     r5,r5,#16
0001d8  ea456101          ORR      r1,r5,r1,LSL #24
0001dc  430b              ORRS     r3,r3,r1
;;;408                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;409                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;410                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;411      
;;;412      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
;;;413      {
;;;414        /* FSMC_Bank2_NAND registers configuration */
;;;415        FSMC_Bank2->PCR2 = tmppcr;
0001de  6801              LDR      r1,[r0,#0]
0001e0  f04f4020          MOV      r0,#0xa0000000
0001e4  2910              CMP      r1,#0x10              ;412
0001e6  d004              BEQ      |L1.498|
;;;416        FSMC_Bank2->PMEM2 = tmppmem;
;;;417        FSMC_Bank2->PATT2 = tmppatt;
;;;418      }
;;;419      else
;;;420      {
;;;421        /* FSMC_Bank3_NAND registers configuration */
;;;422        FSMC_Bank3->PCR3 = tmppcr;
0001e8  f8404f80          STR      r4,[r0,#0x80]!
;;;423        FSMC_Bank3->PMEM3 = tmppmem;
0001ec  6082              STR      r2,[r0,#8]
;;;424        FSMC_Bank3->PATT3 = tmppatt;
0001ee  60c3              STR      r3,[r0,#0xc]
;;;425      }
;;;426    }
0001f0  bd30              POP      {r4,r5,pc}
                  |L1.498|
0001f2  6604              STR      r4,[r0,#0x60]         ;415
0001f4  6682              STR      r2,[r0,#0x68]         ;416
0001f6  66c3              STR      r3,[r0,#0x6c]         ;417
0001f8  bd30              POP      {r4,r5,pc}
;;;427    
                          ENDP

                  FSMC_NANDStructInit PROC
;;;434      */
;;;435    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
0001fa  2110              MOVS     r1,#0x10
;;;436    { 
;;;437      /* Reset NAND Init structure parameters values */
;;;438      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
;;;439      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
0001fc  6001              STR      r1,[r0,#0]
0001fe  2100              MOVS     r1,#0
;;;440      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000200  6041              STR      r1,[r0,#4]
;;;441      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
000202  6081              STR      r1,[r0,#8]
;;;442      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
000204  60c1              STR      r1,[r0,#0xc]
;;;443      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
000206  6101              STR      r1,[r0,#0x10]
;;;444      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
000208  6141              STR      r1,[r0,#0x14]
;;;445      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00020a  6181              STR      r1,[r0,#0x18]
00020c  69c2              LDR      r2,[r0,#0x1c]
00020e  21fc              MOVS     r1,#0xfc
;;;446      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000210  6011              STR      r1,[r2,#0]
000212  69c2              LDR      r2,[r0,#0x1c]
;;;447      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000214  6051              STR      r1,[r2,#4]
000216  69c2              LDR      r2,[r0,#0x1c]
;;;448      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000218  6091              STR      r1,[r2,#8]
00021a  69c2              LDR      r2,[r0,#0x1c]
;;;449      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00021c  60d1              STR      r1,[r2,#0xc]
00021e  6a02              LDR      r2,[r0,#0x20]
;;;450      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000220  6011              STR      r1,[r2,#0]
000222  6a02              LDR      r2,[r0,#0x20]
;;;451      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000224  6051              STR      r1,[r2,#4]
000226  6a02              LDR      r2,[r0,#0x20]
;;;452      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
000228  6091              STR      r1,[r2,#8]
00022a  6a00              LDR      r0,[r0,#0x20]
00022c  60c1              STR      r1,[r0,#0xc]
;;;453    }
00022e  4770              BX       lr
;;;454    
                          ENDP

                  FSMC_NANDCmd PROC
;;;463      */
;;;464    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000230  f04f4220          MOV      r2,#0xa0000000
;;;465    {
000234  b151              CBZ      r1,|L1.588|
;;;466      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;467      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;468      
;;;469      if (NewState != DISABLE)
;;;470      {
;;;471        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;472        if(FSMC_Bank == FSMC_Bank2_NAND)
000236  2810              CMP      r0,#0x10
000238  d004              BEQ      |L1.580|
;;;473        {
;;;474          FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
;;;475        }
;;;476        else
;;;477        {
;;;478          FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
00023a  f8520f80          LDR      r0,[r2,#0x80]!
00023e  f0400004          ORR      r0,r0,#4
000242  e00a              B        |L1.602|
                  |L1.580|
000244  6e10              LDR      r0,[r2,#0x60]         ;474
000246  f0400004          ORR      r0,r0,#4              ;474
00024a  e00a              B        |L1.610|
                  |L1.588|
;;;479        }
;;;480      }
;;;481      else
;;;482      {
;;;483        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;484        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;485        {
;;;486          FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
00024c  498a              LDR      r1,|L1.1144|
00024e  1ec9              SUBS     r1,r1,#3
000250  2810              CMP      r0,#0x10              ;484
000252  d004              BEQ      |L1.606|
;;;487        }
;;;488        else
;;;489        {
;;;490          FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
000254  f8520f80          LDR      r0,[r2,#0x80]!
000258  4008              ANDS     r0,r0,r1
                  |L1.602|
00025a  6010              STR      r0,[r2,#0]            ;478
;;;491        }
;;;492      }
;;;493    }
00025c  4770              BX       lr
                  |L1.606|
00025e  6e10              LDR      r0,[r2,#0x60]         ;486
000260  4008              ANDS     r0,r0,r1              ;486
                  |L1.610|
000262  6610              STR      r0,[r2,#0x60]         ;474
000264  4770              BX       lr
;;;494    /**
                          ENDP

                  FSMC_NANDECCCmd PROC
;;;503      */
;;;504    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000266  f04f4220          MOV      r2,#0xa0000000
;;;505    {
00026a  b151              CBZ      r1,|L1.642|
;;;506      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;507      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;508      
;;;509      if (NewState != DISABLE)
;;;510      {
;;;511        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;512        if(FSMC_Bank == FSMC_Bank2_NAND)
00026c  2810              CMP      r0,#0x10
00026e  d004              BEQ      |L1.634|
;;;513        {
;;;514          FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
;;;515        }
;;;516        else
;;;517        {
;;;518          FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
000270  f8520f80          LDR      r0,[r2,#0x80]!
000274  f0400040          ORR      r0,r0,#0x40
000278  e00a              B        |L1.656|
                  |L1.634|
00027a  6e10              LDR      r0,[r2,#0x60]         ;514
00027c  f0400040          ORR      r0,r0,#0x40           ;514
000280  e00a              B        |L1.664|
                  |L1.642|
;;;519        }
;;;520      }
;;;521      else
;;;522      {
;;;523        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;524        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;525        {
;;;526          FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
000282  497d              LDR      r1,|L1.1144|
000284  393f              SUBS     r1,r1,#0x3f
000286  2810              CMP      r0,#0x10              ;524
000288  d004              BEQ      |L1.660|
;;;527        }
;;;528        else
;;;529        {
;;;530          FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
00028a  f8520f80          LDR      r0,[r2,#0x80]!
00028e  4008              ANDS     r0,r0,r1
                  |L1.656|
000290  6010              STR      r0,[r2,#0]            ;518
;;;531        }
;;;532      }
;;;533    }
000292  4770              BX       lr
                  |L1.660|
000294  6e10              LDR      r0,[r2,#0x60]         ;526
000296  4008              ANDS     r0,r0,r1              ;526
                  |L1.664|
000298  6610              STR      r0,[r2,#0x60]         ;514
00029a  4770              BX       lr
;;;534    
                          ENDP

                  FSMC_GetECC PROC
;;;542      */
;;;543    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
00029c  f04f4120          MOV      r1,#0xa0000000
;;;544    {
;;;545      uint32_t eccval = 0x00000000;
;;;546      
;;;547      if(FSMC_Bank == FSMC_Bank2_NAND)
0002a0  2810              CMP      r0,#0x10
0002a2  d002              BEQ      |L1.682|
;;;548      {
;;;549        /* Get the ECCR2 register value */
;;;550        eccval = FSMC_Bank2->ECCR2;
;;;551      }
;;;552      else
;;;553      {
;;;554        /* Get the ECCR3 register value */
;;;555        eccval = FSMC_Bank3->ECCR3;
0002a4  f8d10094          LDR      r0,[r1,#0x94]
;;;556      }
;;;557      /* Return the error correction code value */
;;;558      return(eccval);
;;;559    }
0002a8  4770              BX       lr
                  |L1.682|
0002aa  6f48              LDR      r0,[r1,#0x74]         ;550
0002ac  4770              BX       lr
;;;560    /**
                          ENDP

                  FSMC_PCCARDDeInit PROC
;;;606      */
;;;607    void FSMC_PCCARDDeInit(void)
0002ae  f04f4020          MOV      r0,#0xa0000000
;;;608    {
;;;609      /* Set the FSMC_Bank4 registers to their reset values */
;;;610      FSMC_Bank4->PCR4 = 0x00000018; 
0002b2  2118              MOVS     r1,#0x18
0002b4  f8401fa0          STR      r1,[r0,#0xa0]!
;;;611      FSMC_Bank4->SR4 = 0x00000000;	
0002b8  2100              MOVS     r1,#0
0002ba  6041              STR      r1,[r0,#4]
;;;612      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
0002bc  f04f31fc          MOV      r1,#0xfcfcfcfc
0002c0  6081              STR      r1,[r0,#8]
;;;613      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
0002c2  60c1              STR      r1,[r0,#0xc]
;;;614      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
0002c4  6101              STR      r1,[r0,#0x10]
;;;615    }
0002c6  4770              BX       lr
;;;616    
                          ENDP

                  FSMC_PCCARDInit PROC
;;;623      */
;;;624    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
0002c8  b510              PUSH     {r4,lr}
;;;625    {
0002ca  e9d01200          LDRD     r1,r2,[r0,#0]
;;;626      /* Check the parameters */
;;;627      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;628      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;629      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;630     
;;;631      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;632      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;633      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;634      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;635      
;;;636      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;637      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;638      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;639      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;640      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;641      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;642      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;643      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;644      
;;;645      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;646      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
0002ce  ea412142          ORR      r1,r1,r2,LSL #9
0002d2  6882              LDR      r2,[r0,#8]
0002d4  2310              MOVS     r3,#0x10
0002d6  ea433242          ORR      r2,r3,r2,LSL #13
0002da  4311              ORRS     r1,r1,r2
0002dc  f04f4220          MOV      r2,#0xa0000000
0002e0  f8421fa0          STR      r1,[r2,#0xa0]!
;;;647                         FSMC_MemoryDataWidth_16b |  
;;;648                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;649                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;650                
;;;651      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;652      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
0002e4  68c1              LDR      r1,[r0,#0xc]
0002e6  e9d13400          LDRD     r3,r4,[r1,#0]
0002ea  ea432304          ORR      r3,r3,r4,LSL #8
0002ee  890c              LDRH     r4,[r1,#8]
0002f0  7b09              LDRB     r1,[r1,#0xc]
0002f2  0424              LSLS     r4,r4,#16
0002f4  ea446101          ORR      r1,r4,r1,LSL #24
0002f8  430b              ORRS     r3,r3,r1
0002fa  6093              STR      r3,[r2,#8]
;;;653                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;654                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;655                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;656                
;;;657      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;658      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
0002fc  6901              LDR      r1,[r0,#0x10]
0002fe  e9d13400          LDRD     r3,r4,[r1,#0]
000302  ea432304          ORR      r3,r3,r4,LSL #8
000306  890c              LDRH     r4,[r1,#8]
000308  7b09              LDRB     r1,[r1,#0xc]
00030a  0424              LSLS     r4,r4,#16
00030c  ea446101          ORR      r1,r4,r1,LSL #24
000310  430b              ORRS     r3,r3,r1
000312  60d3              STR      r3,[r2,#0xc]
;;;659                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;660                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;661                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;662                
;;;663      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;664      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
000314  6940              LDR      r0,[r0,#0x14]
000316  e9d01300          LDRD     r1,r3,[r0,#0]
00031a  ea412103          ORR      r1,r1,r3,LSL #8
00031e  8903              LDRH     r3,[r0,#8]
000320  7b00              LDRB     r0,[r0,#0xc]
000322  041b              LSLS     r3,r3,#16
000324  ea436000          ORR      r0,r3,r0,LSL #24
000328  4301              ORRS     r1,r1,r0
00032a  6111              STR      r1,[r2,#0x10]
;;;665                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;666                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;667                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;668    }
00032c  bd10              POP      {r4,pc}
;;;669    
                          ENDP

                  FSMC_PCCARDStructInit PROC
;;;675      */
;;;676    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
00032e  2100              MOVS     r1,#0
;;;677    {
;;;678      /* Reset PCCARD Init structure parameters values */
;;;679      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
;;;680      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000330  6001              STR      r1,[r0,#0]
;;;681      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000332  6041              STR      r1,[r0,#4]
;;;682      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000334  6081              STR      r1,[r0,#8]
000336  68c2              LDR      r2,[r0,#0xc]
000338  21fc              MOVS     r1,#0xfc
;;;683      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00033a  6011              STR      r1,[r2,#0]
00033c  68c2              LDR      r2,[r0,#0xc]
;;;684      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00033e  6051              STR      r1,[r2,#4]
000340  68c2              LDR      r2,[r0,#0xc]
;;;685      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000342  6091              STR      r1,[r2,#8]
000344  68c2              LDR      r2,[r0,#0xc]
;;;686      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000346  60d1              STR      r1,[r2,#0xc]
000348  6902              LDR      r2,[r0,#0x10]
;;;687      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00034a  6011              STR      r1,[r2,#0]
00034c  6902              LDR      r2,[r0,#0x10]
;;;688      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00034e  6051              STR      r1,[r2,#4]
000350  6902              LDR      r2,[r0,#0x10]
;;;689      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000352  6091              STR      r1,[r2,#8]
000354  6902              LDR      r2,[r0,#0x10]
;;;690      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000356  60d1              STR      r1,[r2,#0xc]
000358  6942              LDR      r2,[r0,#0x14]
;;;691      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00035a  6011              STR      r1,[r2,#0]
00035c  6942              LDR      r2,[r0,#0x14]
;;;692      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00035e  6051              STR      r1,[r2,#4]
000360  6942              LDR      r2,[r0,#0x14]
;;;693      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000362  6091              STR      r1,[r2,#8]
000364  6940              LDR      r0,[r0,#0x14]
000366  60c1              STR      r1,[r0,#0xc]
;;;694    }
000368  4770              BX       lr
;;;695    
                          ENDP

                  FSMC_PCCARDCmd PROC
;;;701      */
;;;702    void FSMC_PCCARDCmd(FunctionalState NewState)
00036a  f04f4120          MOV      r1,#0xa0000000
;;;703    {
;;;704      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;705      
;;;706      if (NewState != DISABLE)
00036e  2800              CMP      r0,#0
;;;707      {
;;;708        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;709        FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
;;;710      }
;;;711      else
;;;712      {
;;;713        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;714        FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
000370  f8510fa0          LDR      r0,[r1,#0xa0]!
000374  d002              BEQ      |L1.892|
000376  f0400004          ORR      r0,r0,#4              ;709
00037a  e002              B        |L1.898|
                  |L1.892|
00037c  4a3e              LDR      r2,|L1.1144|
00037e  1ed2              SUBS     r2,r2,#3
000380  4010              ANDS     r0,r0,r2
                  |L1.898|
000382  6008              STR      r0,[r1,#0]            ;709
;;;715      }
;;;716    }
000384  4770              BX       lr
;;;717    /**
                          ENDP

                  FSMC_ITConfig PROC
;;;748      */
;;;749    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000386  b510              PUSH     {r4,lr}
;;;750    {
;;;751      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;752      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;753      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;754      
;;;755      if (NewState != DISABLE)
;;;756      {
;;;757        /* Enable the selected FSMC_Bank2 interrupts */
;;;758        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;759        {
;;;760          FSMC_Bank2->SR2 |= FSMC_IT;
;;;761        }
;;;762        /* Enable the selected FSMC_Bank3 interrupts */
;;;763        else if (FSMC_Bank == FSMC_Bank3_NAND)
000388  f44f7480          MOV      r4,#0x100
00038c  f04f4320          MOV      r3,#0xa0000000        ;760
000390  b172              CBZ      r2,|L1.944|
000392  2810              CMP      r0,#0x10              ;758
000394  d004              BEQ      |L1.928|
000396  42a0              CMP      r0,r4
000398  d105              BNE      |L1.934|
;;;764        {
;;;765          FSMC_Bank3->SR3 |= FSMC_IT;
00039a  f8530f84          LDR      r0,[r3,#0x84]!
00039e  e004              B        |L1.938|
                  |L1.928|
0003a0  6e58              LDR      r0,[r3,#0x64]         ;760
0003a2  4308              ORRS     r0,r0,r1              ;760
0003a4  e00d              B        |L1.962|
                  |L1.934|
;;;766        }
;;;767        /* Enable the selected FSMC_Bank4 interrupts */
;;;768        else
;;;769        {
;;;770          FSMC_Bank4->SR4 |= FSMC_IT;    
0003a6  f8530fa4          LDR      r0,[r3,#0xa4]!
                  |L1.938|
0003aa  4308              ORRS     r0,r0,r1
                  |L1.940|
0003ac  6018              STR      r0,[r3,#0]
;;;771        }
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Disable the selected FSMC_Bank2 interrupts */
;;;776        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;777        {
;;;778          
;;;779          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
;;;780        }
;;;781        /* Disable the selected FSMC_Bank3 interrupts */
;;;782        else if (FSMC_Bank == FSMC_Bank3_NAND)
;;;783        {
;;;784          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
;;;785        }
;;;786        /* Disable the selected FSMC_Bank4 interrupts */
;;;787        else
;;;788        {
;;;789          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
;;;790        }
;;;791      }
;;;792    }
0003ae  bd10              POP      {r4,pc}
                  |L1.944|
0003b0  2810              CMP      r0,#0x10              ;776
0003b2  d004              BEQ      |L1.958|
0003b4  42a0              CMP      r0,r4                 ;782
0003b6  d106              BNE      |L1.966|
0003b8  f8530f84          LDR      r0,[r3,#0x84]!        ;784
0003bc  e005              B        |L1.970|
                  |L1.958|
0003be  6e58              LDR      r0,[r3,#0x64]         ;779
0003c0  4388              BICS     r0,r0,r1              ;779
                  |L1.962|
0003c2  6658              STR      r0,[r3,#0x64]         ;760
0003c4  bd10              POP      {r4,pc}
                  |L1.966|
0003c6  f8530fa4          LDR      r0,[r3,#0xa4]!        ;789
                  |L1.970|
0003ca  4388              BICS     r0,r0,r1              ;784
0003cc  e7ee              B        |L1.940|
;;;793    
                          ENDP

                  FSMC_GetFlagStatus PROC
;;;808      */
;;;809    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
0003ce  4603              MOV      r3,r0
;;;810    {
;;;811      FlagStatus bitstatus = RESET;
0003d0  2000              MOVS     r0,#0
;;;812      uint32_t tmpsr = 0x00000000;
;;;813      
;;;814      /* Check the parameters */
;;;815      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;816      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;817      
;;;818      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;819      {
;;;820        tmpsr = FSMC_Bank2->SR2;
0003d2  f04f4220          MOV      r2,#0xa0000000
0003d6  2b10              CMP      r3,#0x10              ;818
0003d8  d008              BEQ      |L1.1004|
;;;821      }  
;;;822      else if(FSMC_Bank == FSMC_Bank3_NAND)
0003da  f5b37f80          CMP      r3,#0x100
0003de  d007              BEQ      |L1.1008|
;;;823      {
;;;824        tmpsr = FSMC_Bank3->SR3;
;;;825      }
;;;826      /* FSMC_Bank4_PCCARD*/
;;;827      else
;;;828      {
;;;829        tmpsr = FSMC_Bank4->SR4;
0003e0  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L1.996|
;;;830      } 
;;;831      
;;;832      /* Get the flag status */
;;;833      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
0003e4  420a              TST      r2,r1
0003e6  d000              BEQ      |L1.1002|
;;;834      {
;;;835        bitstatus = SET;
0003e8  2001              MOVS     r0,#1
                  |L1.1002|
;;;836      }
;;;837      else
;;;838      {
;;;839        bitstatus = RESET;
;;;840      }
;;;841      /* Return the flag status */
;;;842      return bitstatus;
;;;843    }
0003ea  4770              BX       lr
                  |L1.1004|
0003ec  6e52              LDR      r2,[r2,#0x64]         ;820
0003ee  e7f9              B        |L1.996|
                  |L1.1008|
0003f0  f8d22084          LDR      r2,[r2,#0x84]         ;824
0003f4  e7f6              B        |L1.996|
;;;844    
                          ENDP

                  FSMC_ClearFlag PROC
;;;858      */
;;;859    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
0003f6  f04f4220          MOV      r2,#0xa0000000
;;;860    {
;;;861     /* Check the parameters */
;;;862      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;863      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;864        
;;;865      if(FSMC_Bank == FSMC_Bank2_NAND)
0003fa  2810              CMP      r0,#0x10
0003fc  d007              BEQ      |L1.1038|
;;;866      {
;;;867        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
;;;868      }  
;;;869      else if(FSMC_Bank == FSMC_Bank3_NAND)
0003fe  f5b07f80          CMP      r0,#0x100
000402  d008              BEQ      |L1.1046|
;;;870      {
;;;871        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
;;;872      }
;;;873      /* FSMC_Bank4_PCCARD*/
;;;874      else
;;;875      {
;;;876        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
000404  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L1.1032|
000408  4388              BICS     r0,r0,r1
00040a  6010              STR      r0,[r2,#0]
;;;877      }
;;;878    }
00040c  4770              BX       lr
                  |L1.1038|
00040e  6e50              LDR      r0,[r2,#0x64]         ;867
000410  4388              BICS     r0,r0,r1              ;867
000412  6650              STR      r0,[r2,#0x64]         ;867
000414  4770              BX       lr
                  |L1.1046|
000416  f8520f84          LDR      r0,[r2,#0x84]!        ;871
00041a  e7f5              B        |L1.1032|
;;;879    
                          ENDP

                  FSMC_GetITStatus PROC
;;;893      */
;;;894    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
00041c  4603              MOV      r3,r0
;;;895    {
;;;896      ITStatus bitstatus = RESET;
00041e  2000              MOVS     r0,#0
;;;897      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
;;;898      
;;;899      /* Check the parameters */
;;;900      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;901      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;902      
;;;903      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;904      {
;;;905        tmpsr = FSMC_Bank2->SR2;
000420  f04f4220          MOV      r2,#0xa0000000
000424  2b10              CMP      r3,#0x10              ;903
000426  d00c              BEQ      |L1.1090|
;;;906      }  
;;;907      else if(FSMC_Bank == FSMC_Bank3_NAND)
000428  f5b37f80          CMP      r3,#0x100
00042c  d00b              BEQ      |L1.1094|
;;;908      {
;;;909        tmpsr = FSMC_Bank3->SR3;
;;;910      }
;;;911      /* FSMC_Bank4_PCCARD*/
;;;912      else
;;;913      {
;;;914        tmpsr = FSMC_Bank4->SR4;
00042e  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L1.1074|
;;;915      } 
;;;916      
;;;917      itstatus = tmpsr & FSMC_IT;
000432  420a              TST      r2,r1
;;;918      
;;;919      itenable = tmpsr & (FSMC_IT >> 3);
000434  ea0201d1          AND      r1,r2,r1,LSR #3
;;;920      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
000438  d002              BEQ      |L1.1088|
00043a  2900              CMP      r1,#0
00043c  d000              BEQ      |L1.1088|
;;;921      {
;;;922        bitstatus = SET;
00043e  2001              MOVS     r0,#1
                  |L1.1088|
;;;923      }
;;;924      else
;;;925      {
;;;926        bitstatus = RESET;
;;;927      }
;;;928      return bitstatus; 
;;;929    }
000440  4770              BX       lr
                  |L1.1090|
000442  6e52              LDR      r2,[r2,#0x64]         ;905
000444  e7f5              B        |L1.1074|
                  |L1.1094|
000446  f8d22084          LDR      r2,[r2,#0x84]         ;909
00044a  e7f2              B        |L1.1074|
;;;930    
                          ENDP

                  FSMC_ClearITPendingBit PROC
;;;944      */
;;;945    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
00044c  f04f4220          MOV      r2,#0xa0000000
;;;946    {
;;;947      /* Check the parameters */
;;;948      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;949      assert_param(IS_FSMC_IT(FSMC_IT));
;;;950        
;;;951      if(FSMC_Bank == FSMC_Bank2_NAND)
000450  2810              CMP      r0,#0x10
000452  d008              BEQ      |L1.1126|
;;;952      {
;;;953        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
;;;954      }  
;;;955      else if(FSMC_Bank == FSMC_Bank3_NAND)
000454  f5b07f80          CMP      r0,#0x100
000458  d00a              BEQ      |L1.1136|
;;;956      {
;;;957        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
;;;958      }
;;;959      /* FSMC_Bank4_PCCARD*/
;;;960      else
;;;961      {
;;;962        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
00045a  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L1.1118|
00045e  ea2000d1          BIC      r0,r0,r1,LSR #3
000462  6010              STR      r0,[r2,#0]
;;;963      }
;;;964    }
000464  4770              BX       lr
                  |L1.1126|
000466  6e50              LDR      r0,[r2,#0x64]         ;953
000468  ea2000d1          BIC      r0,r0,r1,LSR #3       ;953
00046c  6650              STR      r0,[r2,#0x64]         ;953
00046e  4770              BX       lr
                  |L1.1136|
000470  f8520f84          LDR      r0,[r2,#0x84]!        ;957
000474  e7f3              B        |L1.1118|
;;;965    
                          ENDP

000476  0000              DCW      0x0000
                  |L1.1144|
                          DCD      0x000ffffe

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_fsmc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_2e710976____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_fsmc_c_2e710976____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_2e710976____REVSH|
#line 128
|__asm___16_stm32f4xx_fsmc_c_2e710976____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
