L 1 "AddressAutoConfig.c"
N#include "AddressAutoConfig.h"
L 1 "AddressAutoConfig.h" 1
N#ifndef _ADDRESSAUTOCONFIG_
N#define _ADDRESSAUTOCONFIG_
N
N#include "stdio.h"
L 1 "c:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 5 "AddressAutoConfig.h" 2
N#include "stdint.h"
L 1 "c:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 6 "AddressAutoConfig.h" 2
N#include "w6100.h"
L 1 "..\..\Libraries\io6Library\Ethernet\W6100\w6100.h" 1
N//* ****************************************************************************
N//! \file w6100.h
N//! \brief W6100 HAL Header File.
N//! \version 1.0.0
N//! \date 2019/01/01
N//! \par  Revision history
N//!             <2019/01/01> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2019, WIZnet Co., LTD.
N//!
N//! Permission is hereby granted, free of charge, to any person obtaining a copy
N//! of this software and associated documentation files (the "Software"), to deal
N//! in the Software without restriction, including without limitation the rights 
N//! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N//! copies of the Software, and to permit persons to whom the Software is 
N//! furnished to do so, subject to the following conditions: 
N//!
N//! The above copyright notice and this permission notice shall be included in
N//! all copies or substantial portions of the Software. 
N//!
N//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
N//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
N//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
N//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
N//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
N//! SOFTWARE. 
N//!
N//*****************************************************************************
N
N
N#ifndef      _W6100_H_
N#define      _W6100_H_
N
N#include <stdint.h>
N#include "wizchip_conf.h"
L 1 "..\..\Libraries\io6Library\Ethernet\wizchip_conf.h" 1
N//* ****************************************************************************
N//! \file wizchip_conf.h
N//! \brief WIZCHIP Config Header File.
N//! \version 1.0.0
N//! \date 2019/01/01
N//! \par  Revision history
N//!       <2019/01/01> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2019, WIZnet Co., LTD.
N//!
N//! Permission is hereby granted, free of charge, to any person obtaining a copy
N//! of this software and associated documentation files (the "Software"), to deal
N//! in the Software without restriction, including without limitation the rights 
N//! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N//! copies of the Software, and to permit persons to whom the Software is 
N//! furnished to do so, subject to the following conditions: 
N//!
N//! The above copyright notice and this permission notice shall be included in
N//! all copies or substantial portions of the Software. 
N//!
N//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
N//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
N//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
N//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
N//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
N//! SOFTWARE. 
N//!
N//*****************************************************************************
N
N
N
N#ifndef  _WIZCHIP_CONF_H_
N#define  _WIZCHIP_CONF_H_
N
N#include <stdint.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @defgroup extra_functions 2. WIZnet Extra Functions
N *
N * @brief These functions is optional function. 
N * @details @ref extra_functions could be replaced with @ref WIZCHIP_IO_Functions_W6100, \n
N *          because they were made by @ref Basic_IO_function_W6100.\n
N *          These functions configure or indicate @ref _WIZCHIP_, network information, interrupt, PHY, and timer.
N */
N
N
N#define W6100                          6100     ///< W6100 Definition
N//Add to
N//
N
N#ifndef _WIZCHIP_
N/**
N * @brief Select WIZCHIP.
N * @todo You should select one, \b W6100, etc. \n\n
N *       ex> <code> #define _WIZCHIP_      W6100 </code>
N *
N */
N#define _WIZCHIP_                      W6100    // W6100
N#endif
N
N#define _WIZCHIP_IO_MODE_NONE_         0x0000
N#define _WIZCHIP_IO_MODE_BUS_          0x0100   ///< Bus interface mode.\n Refer to @ref _WIZCHIP_IO_MODE_BUS_DIR_ or @ref _WIZCHIP_IO_MODE_BUS_INDIR_.
N#define _WIZCHIP_IO_MODE_SPI_          0x0200   ///< SPI interface mode.\n Refer to @ref _WIZCHIP_IO_MODE_SPI_VDM_ or @ref _WIZCHIP_IO_MODE_SPI_FDM_.
N//#define _WIZCHIP_IO_MODE_IIC_          0x0400
N//#define _WIZCHIP_IO_MODE_SDIO_         0x0800
N// Add to
N//
N
N#define _WIZCHIP_IO_MODE_BUS_DIR_      (_WIZCHIP_IO_MODE_BUS_ + 1) ///< BUS interface mode for direct.\n Refer to @ref _WIZCHIP_IO_MODE_BUS_.
N#define _WIZCHIP_IO_MODE_BUS_INDIR_    (_WIZCHIP_IO_MODE_BUS_ + 2) ///< BUS interface mode for indirect.\n Refer to @ref _WIZCHIP_IO_MODE_BUS_.
N
N#define _WIZCHIP_IO_MODE_SPI_VDM_      (_WIZCHIP_IO_MODE_SPI_ + 1) ///< SPI interface mode for variable length data.\n Refer to @ref _WIZCHIP_IO_MODE_SPI_
N/**
N * @brief SPI interface mode for fixed length data mode.
N * @note If you want to use SPI FDM, Feel free to send a email to support@wiznet.io.
N * @sa _WIZCHIP_IO_MODE_SPI_
N */
N#define _WIZCHIP_IO_MODE_SPI_FDM_      (_WIZCHIP_IO_MODE_SPI_ + 2) 
N
N
N/**
N * @brief PHY can be accessed by @ref _PHYCR0_, _PHYCR1_.
N * @details It provides hardware access method. 
N * @note It is smaller s/w footprint than @ref _PHY_IO_MODE_MII_.
N * @sa _PHY_IO_MODE_MII_, _PHY_IO_MODE_
N * @sa ctlwizchip(), getPHYCR0(), getPHYCR1(), setPHYCR1(), getPHYSR()
N */
N#define _PHY_IO_MODE_PHYCR_            0x0000
N
N/**
N * @brief PHY can be accessed by MDC/MDIO signals of MII interface. 
N * @details It provide software access method. 
N * @note It is bigger s/w footprint than @ref _PHY_IO_MODE_PHYCR_.
N * @sa _PHY_IO_MODE_PHYCR_, _PHY_IO_MODE_
N * @sa ctlwizchip(), wiz_read_mdio(), wiz_write_mdio()
N */
N#define _PHY_IO_MODE_MII_              0x0010
N
N/**
N * @brief Select PHY Access Mode
N * @details @ref _PHY_IO_MODE_ selects PHY access method.
N * @todo You should select one of @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_.
N * @sa ctlwizchip()
N */
N#define _PHY_IO_MODE_                  _PHY_IO_MODE_PHYCR_ //_PHY_IO_MODE_MII_
N
N
N#if (_WIZCHIP_ == W6100)
X#if (6100 == 6100)
N   #define _WIZCHIP_ID_                "W6100\0"
N   /**
N   * @brief Define @ref _WIZCHIP_ interface mode.
N   * @todo You should select interface mode of @ref _WIZCHIP_.\n\n
N   *       Select one of @ref _WIZCHIP_IO_MODE_SPI_VDM_, @ref _WIZCHIP_IO_MODE_SPI_FDM_, and @ref _WIZCHIP_IO_MODE_BUS_INDIR_
N   * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N   */
N   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
N   //#define _WIZCHIP_IO_MODE_         _WIZCHIP_IO_MODE_SPI_VDM_
N   //#define _WIZCHIP_IO_MODE_         _WIZCHIP_IO_MODE_SPV_FDM_
N
N   typedef   uint8_t   iodata_t;       ///< IO access unit. bus width
N   typedef   int16_t   datasize_t;     ///< sent or received data size
N   #include "./W6100/w6100.h"
L 1 "..\..\Libraries\io6Library\Ethernet\./W6100/w6100.h" 1
N//* ****************************************************************************
N//! \file w6100.h
N//! \brief W6100 HAL Header File.
N//! \version 1.0.0
N//! \date 2019/01/01
N//! \par  Revision history
N//!             <2019/01/01> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2019, WIZnet Co., LTD.
N//!
N//! Permission is hereby granted, free of charge, to any person obtaining a copy
N//! of this software and associated documentation files (the "Software"), to deal
N//! in the Software without restriction, including without limitation the rights 
N//! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N//! copies of the Software, and to permit persons to whom the Software is 
N//! furnished to do so, subject to the following conditions: 
N//!
N//! The above copyright notice and this permission notice shall be included in
N//! all copies or substantial portions of the Software. 
N//!
N//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
N//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
N//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
N//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
N//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
N//! SOFTWARE. 
N//!
N//*****************************************************************************
N
N
N#ifndef      _W6100_H_
S#define      _W6100_H_
S
S#include <stdint.h>
S#include "wizchip_conf.h"
S
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/// @cond DOXY_APPLY_CODE
S#if      (_WIZCHIP_ == W6100)
S/// @endcond
S
S#define _W6100_SPI_READ_                  (0x00 << 2)        ///< SPI interface Read operation in Control Phase
S#define _W6100_SPI_WRITE_                 (0x01 << 2)        ///< SPI interface Write operation in Control Phase
S
S#define WIZCHIP_CREG_BLOCK                (0x00   <<3)       ///< Common register block
S#define WIZCHIP_SREG_BLOCK(N)             ((1+4*N)<<3)       ///< SOCKETn register block
S#define WIZCHIP_TXBUF_BLOCK(N)            ((2+4*N)<<3)       ///< SOCKETn Tx buffer address block
S#define WIZCHIP_RXBUF_BLOCK(N)            ((3+4*N)<<3)       ///< SOCKETn Rx buffer address block
S
S#define WIZCHIP_OFFSET_INC(ADDR, N) (ADDR + (N<<8)) ///< Increase offset address
S
S#if (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)      
S   #define IDM_AR0                        ((_WIZCHIP_IO_BASE_ + 0x0000))      ///< Indirect High Address Register
S   #define IDM_AR1                        ((_WIZCHIP_IO_BASE_ + 0x0001))      ///< Indirect Low Address Register
S   #define IDM_BSR                        ((_WIZCHIP_IO_BASE_ + 0x0002))      ///< Block Select Register
S   #define IDM_DR                         ((_WIZCHIP_IO_BASE_ + 0x0003))      ///< Indirect Data Register
S   #define _W6100_IO_BASE_       _WIZCHIP_IO_BASE_
S#elif (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
S   #define _W6100_IO_BASE_       0x00000000
S#endif
S
S
S//-----------       defgroup --------------------------------
S
S/**
S * @defgroup W6100 W6100
S * @brief @ref _WIZCHIP_ register defines and I/O functions
S * @details
S *   - @ref WIZCHIP_register_W6100 : @ref Common_register_group_W6100, @ref Socket_register_group_W6100
S *   - @ref WIZCHIP_IO_Functions_W6100 : @ref Basic_IO_function_W6100, @ref Common_register_access_function_W6100, @ref Socket_register_access_function_W6100
S */
S
S /**
S * @defgroup WIZCHIP_register_W6100 WIZCHIP register
S * @ingroup W6100
S * @brief @ref WIZCHIP_register_W6100 defines register group of @b W6100.
S * @details
S *   - @ref Common_register_group_W6100 : Common register group W6100
S *   - @ref Socket_register_group_W6100 : SOCKET n register group W6100
S */
S
S/**
S * @defgroup Basic_IO_function_W6100 Basic I/O function
S * @ingroup WIZCHIP_IO_Functions_W6100
S * @brief These are basic input/output functions to read values from register or write values to register.
S */
S
S/**
S * @defgroup Common_register_access_function_W6100 Common register access functions
S * @ingroup WIZCHIP_IO_Functions_W6100
S * @brief These are functions to access @ref Common_register_group_W6100.
S */
S
S/**
S * @defgroup Socket_register_access_function_W6100 Socket register access functions
S * @ingroup WIZCHIP_IO_Functions_W6100
S * @brief These are functions to access @ref Socket_register_group_W6100.
S */
S
S/**
S * @defgroup WIZCHIP_IO_Functions_W6100 WIZCHIP I/O functions
S * @ingroup W6100
S * @brief @ref WIZCHIP_IO_Functions_W6100 supports the basic I/O functions for @ref WIZCHIP_register_W6100.
S * @details
S *   - @ref WIZCHIP_IO_Functions_W6100 \n
S *     WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
S *   - @ref Common_register_access_function_W6100 \n
S *     - @ref _WIZCHIP_ Mode \n
S *       getCIDR(), getVER() \n
S *       getSYSR()  \n
S *       setCHPLCKR(), setNETLCKR(), setPHYLCKR() \n
S *       setSYCR0(), getSYCR1(), setSYCR1()
S *     - Network Mode \n
S *       getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR(), getNETMR(), setNETMR(), getNETMR2(), setNETMR2()
S *     - Interrupt \n
S *       getIR(), setIRCLR(), getIMR(), setIMR() \n
S *       getSIR(), getSIMR(), setSIMR() \n
S *       getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR() \n
S *       getINTPTMR(), setINTPTMR()
S *     - Network Information \n
S *       NETLOCK(), NETUNLOCK() \n
S *       getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), setSUBR(), getSIPR(), setSIPR() \n
S *       getLLAR(), setLLAR(), getGUAR(), setGUAR(), getGA6R(), setGA6R(), getSUB6R(), setSUB6R() \n
S *       getPLR(), getPFR(), getVLTR(), getPLTR(), getPAR() \n
S *     - SOCKET-less Commands for PING, ARP and IPv6 Auto-Configuration \n
S *       getSLCR(), setSLCR() \n
S *       getPINGIDR(), setPINGIDR(), getPINGSEQR(), setPINGSEQR() \n
S *       getSLDHAR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLHOPR(), setSLHOPR() \n
S *     - Retransmission  \n
S *       getRCR(), setRCR() \n
S *       getSLRCR(), setSLRCR(), getSLRTR(), setSLRTR() \n
S *     - ICMP \n
S *       getUIPR(), getUIP6R(), getUPORTR(), getUPORT6R() \n
S *       getICMP6BLKR(), setICMP6BLKR() \n
S *     - PPPoE \n
S *       getPTMR(), setPTMR(), getPMNR(), getPMNR() \n
S *       getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR()
S *     - PHY Configuration \n
S *       getPHYSR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK() \n
S *       setPHYCR0(), getPHYCR1(), setPHYCR1() \n
S *       getPHYRAR(), setPHYRAR(), setPHYDIR(), getPHYDOR(), getPHYACR(), setPHYACR(), getPHYDIVR(), setPHYDIVR()
S *     - etc \n
S *       getTCNTR(), setTCNTRCLR()
S *   - @ref Socket_register_access_function_W6100 \n
S *     - SOCKET control \n
S *       getSn_MR(), setSn_MR(), getSn_MR2(), setSn_MR2(), getSn_PSR(), setSn_PSR(), getSn_CR(), setSn_CR() \n
S *       getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR()  \n
S *       getSn_RTR(), setSn_RTR(), getSn_RCR(), setSn_RCR(), getSn_KPALVTR(), setSn_KPALVTR()
S *     - SOCKET information \n
S *       getSn_SR(), getSn_ESR() \n
S *       getSn_DHAR(), setSn_DHAR(),  getSn_PORTR(), setSn_PORTR(), getSn_DPORTR(), setSn_DPORTR() \n
S *       getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R() \n
S *       getSn_MSSR(), setSn_MSSR()
S *     - SOCKET communication \n
S *       getSn_RX_BSR(), setSn_RX_BSR(), getSn_TX_BSR(), setSn_TX_BSR() \n
S *       getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR() \n
S *       getSn_RX_RD(), setSn_RX_RD(), getSn_RX_WR() \n
S *       getSn_TX_FSR(), getSn_RX_RSR()
S *     - IP header field \n
S *       getSn_FRGR(), setSn_FRGR(),  getSn_TOSR(), setSn_TOSR() \n
S *       getSn_TTLR(), setSn_TTLR()
S */
S
S/**
S * @defgroup Common_register_group_W6100 Common register
S * @ingroup WIZCHIP_register_W6100
S * @brief Common register group \n
S * @details It set the general configuration such as interrupt, network information, ICMP, and etc.
S * @sa
S * <table width=0>
S *    <tr><td> @ref _WIZCHIP_ Information   </td><td>: _CIDR_, _VER_                                                                   </td></tr>
S *    <tr><td> @ref _WIZCHIP_ Mode          </td><td>: _SYSR_, _SYCR0_, _SYCR1_, _CHPLCKR_, _NETLCKR_, _PHYLCKR_                       </td></tr>
S *    <tr><td> Network Mode                 </td><td>: _NET4MR_, _NET6MR_, _NETMR_, _NETMR2_                                           </td></tr>
S *    <tr><td> Network Information          </td><td>: _GAR_, _SUBR_, _SHAR_, _SIPR_, _GA6R_, _LLAR_, _GUAR_, _SUB6R_                  </td></tr>
S *    <tr><td> Interrupt                    </td><td>: _IR_, _IRCLR_, _IMR_, _SIR_, _SIMR_, _SLIR_, _SLIMR_, _SLIRCLR_, _INTPTMR_      </td></tr>
S *    <tr><td> Data retransmission          </td><td>: _RTR_, _RCR_, _SLRTR_, _SLRCR_, _SLHOPR_                                        </td></tr>
S *    <tr><td> PPPoE                        </td><td>: _PHAR_, _PSIDR_, _PMRUR_, _PTMR_, _PMNR_                                        </td></tr>
S *    <tr><td> SOCKET-less command          </td><td>: _SLCR_, _SLIR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _PINGIDR_, _PINGSEQR_ </td></tr>
S *    <tr><td> ICMP v4 & v6                 </td><td>: _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_, _ICMP6BLKR_                               </td></tr>
S *    <tr><td> IPv6 Auto-configuration      </td><td>: _PLR_, _PFR_, _VLTR_, _PAR_                                                     </td></tr>
S *    <tr><td> PHY Configuration            </td><td>: _PHYSR_, _PHYCR0_, _PHYCR1_, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYDIVR_  </td></tr>
S * </table>
S */
S 
S
S/**
S * @defgroup Socket_register_group_W6100 Socket register
S * @ingroup WIZCHIP_register_W6100
S * @brief Socket register group\n
S * @details
S * SOCKETn registers configure and control SOCKETn which is necessary to data communication.
S * @sa
S * <table width=0>
S *    <tr><td> SOCKETn Control       </td><td>: _Sn_MR_, _Sn_MR2_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, _Sn_PSR_                                </td></tr>
S *    <tr><td> SOCKETn Information   </td><td>: _Sn_SR_, _Sn_ESR_, _Sn_PORTR_, _Sn_DHAR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_                       </td></tr>
S *    <tr><td> SOCKETn Retransmission </td><td>: _Sn_RTR_, _Sn_RCR_                                                                                 </td></tr>
S *    <tr><td> Internet protocol     </td><td>: _Sn_MSSR_, _Sn_TOSR_, _Sn_TTLR_, _Sn_FRGR_                                                         </td></tr>
S *    <tr><td> Data communication    </td><td>: _Sn_RX_BSR_, _Sn_TX_BSR_, _Sn_TX_FSR_, _Sn_TX_RD_, _Sn_TX_WR_, _Sn_RX_RSR_, _Sn_RX_RD_, _Sn_RX_WR_ </td></tr>
S * </table>
S */
S
S//-----------------------------------------------------------------------------------
S
S//----------------------------- W6100 Common Registers IOMAP -----------------------------
S
S/**
S * @addtogroup Common_register_group_W6100
S * @{
S */
S
S/**
S * @brief Chip Identification Register address [RO] [0x6100]
S * @sa getCIDR()
S */
S#define _CIDR_               (_W6100_IO_BASE_ + (0x0000 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Chip Version Register address [RO] [0x4661]
S * @sa getVER()
S */
S#define _VER_                (_W6100_IO_BASE_ + (0x0002 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief System Status Register address [RO] [0xEU]
S * @details @ref _SYSR_ shows the information such as CHIP, NET, PHY Locking and Host I/F
S * <table>
S *    <tr> <td>7   </td> <td>6   </td> <td>5   </td> <td>4 ~ 2   </td> <td>1  </td> <td>0  </td> </tr>
S *    <tr> <td>CHPL</td> <td>NETL</td> <td>PHYL</td> <td>Reserved</td> <td>IND</td> <td>SPI</td> </tr>
S * </table>
S *  - @ref SYSR_CHPL 
S *  - @ref SYSR_NETL 
S *  - @ref SYSR_PHYL 
S *  - @ref SYSR_IND  : HOST use Parallel BUS Interface(Indirect Bus Mode)
S *  - @ref SYSR_SPI  : HOST use SPI Interface
S *
S * @sa _CHPLCKR_, _NETLCKR_, _PHYLCKR_, 
S * @sa getSYSR(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK() \n
S *        setPHYLCKR(), getPHYLCKR(), PHYLOCK(), PHYUNLOCK()
S */
S#define _SYSR_               (_W6100_IO_BASE_ + (0x2000 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief System Config Register 0 address [WO][0x80] 
S * @details @ref _SYCR0_ softly reset to _WIZCHIP_.
S * <table>
S *    <tr> <td>7  </td> <td>6 ~ 0   </td> </tr>
S *    <tr> <td>RST</td> <td>Reserved</td> </tr>
S * </table>
S *   - @ref SYCR0_RST : Software Reset.
S *
S * @note It can be accessed only when @ref SYSR_CHPL = 1.
S * @sa _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa setSYCR0(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SYCR0_              (_W6100_IO_BASE_ + (0x2004 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief System Config Register 1 address [R=W][0x80] 
S * @details @ref _SYCR1_ controls the global interrupt enable, and selects the system clock.
S * <table>
S *    <tr> <td>7  </td> <td>6 ~ 1   </td> <td>0     </td> </tr>
S *    <tr> <td>IEN</td> <td>Reserved</td> <td>CLKSEL</td> </tr>
S * </table>
S *   - @ref SYCR1_IEN
S *   - @ref SYCR1_CLKSEL
S *
S * @note SYCR1_CLKSEL bit can be accessed only when @ref SYSR_CHPL = 1.
S * @sa _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSYCR1(), setSYCR1(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SYCR1_              (WIZCHIP_OFFSET_INC(_SYCR0_,1))
S
S/**
S * @brief Ticker Counter Register address [RO][0x0000]
S * @details @ref _TCNTR_ increase by 1 every 100us after _WIZCHIP_ reset.
S * @sa _TCNTRCLR_
S * @sa getTCNTR(), setTCNTRCLR() 
S */
S#define _TCNTR_              (_W6100_IO_BASE_ + (0x2016 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Ticker Counter Clear Register address [RO][0x00]
S * @details @ref _TCNTRCLR_ clear @ref _TCNTR_.
S * @sa setTCNTRCLR(), getTCNTR()
S */
S#define _TCNTRCLR_           (_W6100_IO_BASE_ + (0x2020 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Interrupt Register address [RO][0x00]
S * @details @ref _IR_ indicates the interrupt status.
S *          If @ref _IR_ is not equal to x00 INTn PIN is asserted to low until it is x00.
S * 
S * <table>
S *    <tr> <td>7  </td> <td>6 ~ 5   </td> <td>4   </td> <td>3       </td> <td>2     </td> <td>1   </td> <td>0    </td> </tr>
S *    <tr> <td>WOL</td> <td>Reserved</td> <td>UNR6</td> <td>Reserved</td> <td>IPCONF</td> <td>UNR4</td> <td>PTERM</td> </tr>
S * </table>
S *  - @ref IR_WOL    : Wake On LAN
S *  - @ref IR_UNR6   : Destination Port Unreachable for IPv6
S *  - @ref IR_IPCONF : @ref _SIPR_ is Conflict
S *  - @ref IR_UNR4   : Destination Port Unreachable for IPv4
S *  - @ref IR_PTERM  : PPPoE Terminated
S *
S * @sa _IMR_, _IRCLR_, SYCR1_IEN, _CHIPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getIR(), setIRCLR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR() 
S */
S#define _IR_                 (_W6100_IO_BASE_ + (0x2100 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET Interrupt Register address [RO][0x00]
S * @details @ref _SIR_ indicates whether a socket interrupt is occurred or not.\n
S *          Each bit of @ref _SIR_ be still until @ref _Sn_IR_ is cleared by @ref _Sn_IRCLR_
S * @sa _SIMR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, SYCR1_IEN , _CHIPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSIR(), getSn_IR(), setSn_IRCLR(), getSIMR(), setSIMR(), getSn_IMR(), setSn_IMR(), getSYCR1(), setSYCR1(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SIR_                (_W6100_IO_BASE_ + (0x2101 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Interrupt Register address [RO][0x00]
S * @details @ref _SLIR_ indicates the completion of @ref _SLCR_ or timeout.
S * <table>
S *    <tr> <td>7   </td> <td>6   </td> <td>5    </td> <td>4   </td> <td>3    </td> <td>2 </td> <td>1 </td> <td>0 </td> </tr>
S *    <tr> <td>TOUT</td> <td>ARP4</td> <td>PING4</td> <td>ARP6</td> <td>PING6</td> <td>NS</td> <td>RS</td> <td>RA</td> </tr>
S * </table>
S *  - @ref SLIR_TOUT  : The timeout occurrence after @ref _SLCR_ is performed
S *  - @ref SLIR_ARP4  : The completion of @ref SLCR_ARP4
S *  - @ref SLIR_PING4 : The completion of @ref SLCR_PING4
S *  - @ref SLIR_ARP6  : The completion f @ref SLCR_ARP6
S *  - @ref SLIR_PING6 : The completion of @ref SLCR_PING6
S *  - @ref SLIR_NS    : The completion of @ref SLCR_NS
S *  - @ref SLIR_RS    : The completion of @ref SLIR_RS
S *  - @ref SLIR_RA    : The reception from Router Advertisement
S *
S * @sa _SLIRCLR_, _SLIMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSLIR(), setSLIRCLR(),  getSLIR(), getSLIMR(), setSLIMR(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SLIR_               (_W6100_IO_BASE_ + (0x2102 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Interrupt Mask Register address [R=W][0x00]
S * @details @ref _IMR_ is used to mask interrupts of @ref _IR_.\n
S *          When a bit of @ref _IMR_ and the corresponding bit of @ref _IR_ is set, an interrupt will be issued.
S * @sa _IR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getIMR(), setIMR(),  getIR(), setIRCLR(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _IMR_                (_W6100_IO_BASE_ + (0x2104 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief @ref _IR_  Clear Register address [WO][0x00]
S * @details @ref _IRCLR_ clears @ref _IR_
S * @sa _IR_, _IMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa setIRCLR(), getIR(), getIMR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _IRCLR_              (_W6100_IO_BASE_ + (0x2108 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET Interrupt Mask Register address [R=W]][0x00]
S * @details @ref _SIMR_ is used to mask interrupts of @ref _SIR_.\n
S *          When a bit of @ref _SIMR_ and the corresponding bit of @ref _SIR_ is set, an interrupt will be issued.\n
S *          when @ref _Sn_IR_ is not 0,  The N-th bit of @ref _SIR_ is set. Otherwise, this bit is automatically clear.\n
S * @sa _SIR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSIMR(), setSIMR(), getSIR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SIMR_               (_W6100_IO_BASE_ + (0x2114 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Interrupt Mask Register address [R=W][0x00]
S * @details @ref _SLIMR_ is used to mask interrupts of @ref _SLIR_\n
S *          When a bit of @ref _SLIMR_ and the corresponding bit of @ref _SLIR_ is set, an interrupt will be issued.
S * @sa _SLIR_, _SLIRCLR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSLIMR(), setSLIMR(), getSLIR(), setSLIRCLR(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SLIMR_              (_W6100_IO_BASE_ + (0x2124 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Interrupt Clear Register address [WO][0x00]
S * @details @ref _SLIRCLR_ clears @ref _SLIR_
S * @sa _SLIR_, _SLIRCLR_, _SLIMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SLIRCLR_            (_W6100_IO_BASE_ + (0x2128 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Prefer Source IPv6 Address Register address [R=W][0x00]
S * @details @ref _SLPSR_ select the Source IPv6 Address to transmit a packet by @ref _SLCR_.
S *   - @ref PSR_AUTO 
S *   - @ref PSR_LLA 
S *   - @ref PSR_GUA 
S * @sa _SLCR_, _Sn_PSR_
S * @sa getSLPSR(), setSLPSR(), getSLCR(), setSLCR(), getSn_PSR(), setSn_PSR()
S */
S#define _SLPSR_              (_W6100_IO_BASE_ + (0x212C << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Command Register address [RW,AC][0x00]
S * @details @ref _SLCR_ can be request a message such like as ARP, PING, and ICMPv6 without SOCKET.
S * <table>
S *    <tr> <td>7       </td> <td>6   </td> <td>5    </td> <td>4   </td> <td>3    </td> <td>2 </td> <td>1 </td> <td>0  </td> </tr>
S *    <tr> <td>Reserved</td> <td>ARP4</td> <td>PING4</td> <td>ARP6</td> <td>PING6</td> <td>NS</td> <td>RS</td> <td>UNA</td> </tr>
S * </table>
S *   - @ref SLCR_ARP4
S *   - @ref SLCR_PING4
S *   - @ref SLCR_ARP6
S *   - @ref SLCR_PING6
S *   - @ref SLCR_NS
S *   - @ref SLCR_RS
S *   - @ref SLCR_UNA
S *
S * @sa _SLIR_, _SLIMR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDIPR(),setSLDIPR(), getSLDIP4R(),setSLDIP4R(), 
S *     getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SLCR_               (_W6100_IO_BASE_ + (0x2130 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Status Register address [RO][0x00]
S * @details @ref _PHYSR_ shows the operation mode of PHY, the link status and etc.
S *   - @ref PHYSR_CAB  : @ref PHYSR_CAB_OFF, @ref PHYSR_CAB_ON
S *   - @ref PHYSR_MODE : @ref PHYSR_MODE_AUTO, @ref PHYSR_MODE_100F, @ref PHYSR_MODE_100H, @ref PHYSR_MODE_10F, @ref PHYSR_MODE_10H
S *   - @ref PHYSR_DPX  : @ref PHYSR_DPX_FULL, @ref PHYSR_DPX_HALF
S *   - @ref PHYSR_SPD  : @ref PHYSR_SPD_100M, @ref PHYSR_SPD_10M
S *   - @ref PHYSR_LNK  : @ref PHYSR_LNK_UP, @ref PHYSR_LNK_DOWN
S *
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL
S * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), getPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
S */
S#define _PHYSR_              (_W6100_IO_BASE_ + (0x3000 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Internal Register Address Register address(R/W)
S * @details @ref _PHYRAR_ specifies the address of register in the Ethernet PHY.
S *   - @ref PHYRAR_BMCR
S *   - @ref PHYRAR_BMSR
S * @sa _PHYACR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
S * @sa getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
S */
S#define _PHYRAR_             (_W6100_IO_BASE_ + (0x3008 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Data Input Register address [R=W][0x00]
S * @details @ref _PHYDIR_ specifies the value to write to the register in PHY
S * @sa _PHYRAR_, _PHYACR_, _PHYDOR_, _PHYDIVR_
S * @sa setPHYDIR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
S */
S#define _PHYDIR_             (_W6100_IO_BASE_ + (0x300C << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Data Output Register address [WO][0x00]
S * @details @ref _PHYDOR_ read the value from the register in PHY
S * @sa _PHYRAR_, _PHYACR_, _PHYDIR_, _PHYDIVR_
S * @sa getPHYDOR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
S */
S#define _PHYDOR_             (_W6100_IO_BASE_ + (0x3010 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Access Register address [RW,AC][0x00]
S * @details @ref _PHYACR_ write(read)  to(from) the value of register in the Ethernet PHY
S *   - @ref PHYACR_READ
S *   - @ref PHYACR_WRITE
S * @sa _PHYRAR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
S * @sa getPHYACR(), setPHYACR(), getPHYDOR(), getPHYRAR(), setPHYRAR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
S */
S#define _PHYACR_             (_W6100_IO_BASE_ + (0x3014 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY's MDC Clock Division Register address [R=W][0x01]
S * @details @ref _PHYDIVR_ divides the system clock for the MDC clock of Ethernet PHY'
S *   - @ref PHYDIVR_32
S *   - @ref PHYDIVR_64
S *   - @ref PHYDIVR_128
S * @sa _PHYRAR_, _PHYACR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
S * @sa getPHYDIVR(), setPHYDIVR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR()
S */
S#define _PHYDIVR_            (_W6100_IO_BASE_ + (0x3018 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Control Register address [WO][0x00]
S * @details @ref _PHYCR0_ controls the operation mode of PHY.
S *          The result will be checked by @ref _PHYSR_ after PHY HW reset by @ref PHYCR1_RST.
S *   - @ref PHYCR0_AUTO
S *   - @ref PHYCR0_100F
S *   - @ref PHYCR0_100H
S *   - @ref PHYCR0_10F
S *   - @ref PHYCR0_10H
S *
S * @note It can be only accessed when @ref SYSR_PHYL is unlock.  
S * @sa _SYSR_, _PHYCR1_
S * @sa setPHYCR0(), getSYSR(), getPHYCR1(), setPHYCR1() 
S */
S#define _PHYCR0_             (_W6100_IO_BASE_ + (0x301C << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Control Register address [R=W][0x40]
S * @details @ref _PHYCR1_ controls the Ethernet PHY function such as HW reset, Power down and etc.
S * <table>
S *    <tr> <td>7       </td> <td>6       </td> <td>5   </td> <td>4      </td> <td>3 </td> <td>2 ~ 1   </td> <td>0  </td> </tr>
S *    <tr> <td>Reserved</td> <td>Always 1</td> <td>PWDN</td> <td>Reseved</td> <td>TE</td> <td>Reserved</td> <td>RST</td> </tr>
S * </table>
S *   - @ref PHYCR1_PWDN
S *   - @ref PHYCR1_TE
S *   - @ref PHYCR1_RST
S *
S * @note It can be only accessed when @ref SYSR_PHYL is unlock.  
S * @sa _SYSR_, _PHYCR0_
S * @sa getPHYCR1(), setPHYCR1(), setPHYCR0(), getSYSR() 
S */
S#define _PHYCR1_             WIZCHIP_OFFSET_INC(_PHYCR0_,1)
S
S/**
S * @brief Network IPv4 Mode Register address [R=W][0x00]
S * @details @ref _NET4MR_ can block the transmission such like as unreachable message, TCP reset, and ping relay.\n
S *          It can ARP request before ping relpy.
S *
S * <table>
S *    <tr> <td>7 ~ 4   </td> <td>3   </td> <td>2   </td> <td>1   </td> <td>0 </td> </tr>
S *    <tr> <td>Reserved</td> <td>UNRB</td> <td>PARP</td> <td>RSTB</td> <td>PB</td> </tr>
S * </table>
S *   - @ref NETxMR_UNRB
S *   - @ref NETxMR_PARP
S *   - @ref NETxMR_RSTB
S *   - @ref NETxMR_PB
S * @sa _NET6MR_
S * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
S */
S#define _NET4MR_             (_W6100_IO_BASE_ + (0x4000 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Network IPv6 Mode Register address [R=W][0x00]
S * @details @ref _NET6MR_ can block the transmission such like as unreachable message, TCP reset, and ping relay.\n
S *          It can ARP request before ping reply.
S *
S * <table>
S *    <tr> <td>7 ~ 4   </td> <td>3   </td> <td>2   </td> <td>1   </td> <td>0 </td> </tr>
S *    <tr> <td>Reserved</td> <td>UNRB</td> <td>PARP</td> <td>RSTB</td> <td>PB</td> </tr>
S * </table>
S *   - @ref NETxMR_UNRB
S *   - @ref NETxMR_PARP
S *   - @ref NETxMR_RSTB
S *   - @ref NETxMR_PB
S * @sa _NET4MR_
S * @sa getNET6MR(), setNET6MR(), getNET4MR(), setNET4MR() 
S */
S#define _NET6MR_             (_W6100_IO_BASE_ + (0x4004 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Network Mode Register address [R=W][0x00]
S * @details @ref _NETMR_ set WOL(Wake On Lan) mode.\n
S *          It also can block a packet such as \n
S *          IPv6 PING request from an all-node broadcasting, \n
S *          IPv6 PING request from a solicited mulitcasting address,\n
S *          IPv4 packets, \n
S *          and IPv6 packets.
S * 
S * <table>
S *    <tr> <td>7 ~ 6   </td> <td>5  </td> <td>4  </td> <td>3       </td> <td>2  </td> <td>1   </td> <td>0  </td> </tr>
S *    <tr> <td>Reserved</td> <td>ANB</td> <td>M6B</td> <td>Always 0</td> <td>WOL</td> <td>IP6B</td> <td>IP4B</td> </tr> 
S * </table>
S * - @ref NETMR_ANB
S * - @ref NETMR_M6B
S * - @ref NETMR_WOL
S * - @ref NETMR_IP6B
S * - @ref NETMR_IP4B
S * @sa getNETMR(), setNETMR()
S *
S */
S#define _NETMR_              (_W6100_IO_BASE_ + (0x4008 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Network Mode Register 2 address [R=W][0x00]
S * @details @ref _NETMR2_ set PPPoE mode.\n
S *          It also can select the destination hardware address to either Ethernet frame MAC or target MAC in the ARP-reply message
S * <table>
S *    <tr> <td>7   </td> <td>6 ~ 1</td> <td>0    </td> </tr>
S *    <tr> <td>DHAS</td> <td>6 ~ 1</td> <td>PPPoE</td> </tr>
S * </table>
S *   - @ref NETMR2_DHAS : @ref NETMR2_DHAS_ARP, @ref NETMR2_DHAS_ETH
S *   - @ref NETMR2_PPPoE
S * @sa getNETMR2(), setNETMR2()
S */
S#define _NETMR2_             (_W6100_IO_BASE_ + (0x4009 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PPP LCP request Timer Register address [R=W][0x28]
S * @details @ref _PTMR_ sets the time for sending LCP echo request.\n
S *          The unit of time is 25ms.
S * @sa _PMNR_, _PHAR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
S * @sa getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
S */
S#define _PTMR_               (_W6100_IO_BASE_ + (0x4100 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PPP LCP Magic Number Register address [R=W][0x00]
S * @details @ref _PMNR_ sets the 4bytes magic number to be used in LCP negotiation.
S * @sa _PTMR_, _PHAR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
S * @sa getPMNR(), setPMNR(), getPTMR(), setPTMR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
S */
S#define _PMNR_               (_W6100_IO_BASE_ + (0x4104 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PPPoE Hardware Address Register address [R=W][0x00]
S * @details @ref _PHAR_ sets the PPPoE server hardware address that is acquired during PPPoE connection process.
S * @sa _PTMR_, _PMNR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
S * @sa getPHAR(), setPHAR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
S */
S#define _PHAR_               (_W6100_IO_BASE_ + (0x4108 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PPP Session ID Register address [R=W][0X0000]
S * @details @ref  _PSIDR_ sets the PPPoE sever session ID acquired during PPPoE connection process.
S * @sa _PTMR_, _PMNR_, _PHAR_, _PMRUR_, NETMR2_PPPoE
S * @sa getPSIDR(), setPSIDR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
S */
S#define _PSIDR_              (_W6100_IO_BASE_ + (0x4110 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PPP Maximum Receive Unit Register address [R=W][0xFFFF]
S * @details @ref _PMRUR_ sets the maximum receive unit of PPPoE.
S * @sa _PTMR_, _PMNR_, _PHAR_, _PSIDR_, NETMR2_PPPoE
S * @sa  getPMRUR(), setPMRUR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getNETMR2(), setNETMR2()
S */
S#define _PMRUR_              (_W6100_IO_BASE_ + (0x4114 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Source Hardware Address Register address [R=W][00:00:00:00:00:00]
S * @details @ref _SHAR_ sets the source hardware address.
S * @note It can be accessed only when @ref SYSR_NETL is unlock.
S * @sa SYSR_NETL, _NETLCKR_
S * @sa getSHAR(), setSHAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK()
S */
S#define _SHAR_               (_W6100_IO_BASE_ + (0x4120 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv4 Gateway Address Register address [R=W][0.0.0.0]
S * @details @ref _GAR_ sets the default gateway IPv4 address.
S * @note It can be accessed only when @ref SYSR_NETL is unlock.
S * @sa SYSR_NETL, _NETLCKR_, _GA6R_
S * @sa getGAR(), setGAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getGA6R(), setGA6R()
S */
S#define _GAR_                (_W6100_IO_BASE_ + (0x4130 << 8) + WIZCHIP_CREG_BLOCK)
S#define _GA4R_               (_GAR_)      ///< Refer to @ref _GAR_
S/**
S * @brief IPv4 Subnet Mask Register address [R=W][0.0.0.0]
S * @details @ref _SUBR_ sets the default subnet mask address of IPv4.
S * @note It can be accessed only when @ref SYSR_NETL is unlock. 
S * @sa SYSR_NETL, _NETLCKR_, _SUB6R_
S * @sa getSUBR(), setSUBR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getSUB6R(), setSUB6R()
S */
S#define _SUBR_               (_W6100_IO_BASE_ + (0x4134 << 8) + WIZCHIP_CREG_BLOCK)
S#define _SUB4R_              (_SUBR_)      ///< Refer to @ref _SUBR_
S
S/**
S * @brief IPv4 Source IP Register address [R=W][0.0.0.0]
S * @details @ref _SIPR_ sets the source IPv4 address.
S * @note It can be accessed only when @ref SYSR_NETL is unlock. 
S * @sa SYSR_NETL, _NETLCKR_, _LLAR_, _GUAR_
S * @sa getSIPR(), setSIPR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getLLAR(), setLLAR(), getGUAR(),setGUAR()
S */
S#define _SIPR_               (_W6100_IO_BASE_ + (0x4138 << 8) + WIZCHIP_CREG_BLOCK)
S#define _SIP4R_              (_SIPR_)   ///< Refer to @ref _SIPR_.
S
S/**
S * @brief IPv6 LLA(Link Local Address) Register address [R=W][::]
S * @details @ref _LLAR_ sets the LLA address of IPv6.
S * @note It can be accessed only when @ref SYSR_NETL is unlock. 
S * @sa SYSR_NETL, _NETLCKR_, _GUAR_, _SIPR_
S * @sa getLLAR(), setLLAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getGUAR(),setGUAR(), getSIPR(), setSIPR()
S */
S#define _LLAR_               (_W6100_IO_BASE_ + (0x4140 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv6 GUA(Global Unicast Address) Register address [R=W][::]
S * @details @ref _GUAR_ sets the GUA address of IPv6.
S * @note It can be accessed only when @ref SYSR_NETL is unlock.  
S * @sa SYSR_NETL, _NETLCKR_, _LLAR_, _SIPR_
S * @sa getGUAR(), setGUAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getLLAR(),setLLAR(), getSIPR(), setSIPR()
S */
S#define _GUAR_               (_W6100_IO_BASE_ + (0x4150 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv6 Subnet Mask Register address [R=W][]
S * @details @ref _SUB6R_ sets the default subnet mask address of IPv6.
S * @note It can be accessed only when @ref SYSR_NETL is unlock. 
S * @sa SYSR_NETL, _NETLCKR_, _SUBR_
S * @sa getSUB6R(), setSUB6R(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getSUBR(), setSUBR()
S */
S#define _SUB6R_              (_W6100_IO_BASE_ + (0x4160 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv6 Gateway Address Register address [R/W][::]
S * @details @ref _GA6R_ sets the default gateway IPv6 address.
S * @sa _GAR_
S * @sa getGA6R(), setGA6R(), getGAR(), setGAR()
S */
S#define _GA6R_               (_W6100_IO_BASE_ + (0x4170 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Peer IPv6 Register address [R=W][::]
S * @details @ref _SLDIP6R_ sets the destination IP address of @ref _SLCR_.
S * @sa _SLDIP6R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_, _SLDHAR_, _SLDIPR_, _SLDIP4R_
S * @sa getSLDIP6R(), setSLDIP6R(), getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDHAR(),
S *     getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R()
S */
S#define _SLDIP6R_            (_W6100_IO_BASE_ + (0x4180 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Peer IPv6 Register address [R=W][0.0.0.0]
S * @details @ref _SLDIPR_(= @ref _SLDIP4R_) sets the destination IPv4 address of @ref _SLCR_.
S * @sa _SLDIP4R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_, _SLDHAR_, _SLDIP6R_
S * @sa getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDHAR(),
S *     getSLDIP6R(), setSLDIP6R()
S */
S#define _SLDIPR_             (_W6100_IO_BASE_ + (0x418C << 8) + WIZCHIP_CREG_BLOCK)
S#define _SLDIP4R_            (_SLDIPR_)            ///< Refer to @ref _SLDIPR_.
S
S
S/**
S * @brief SOCKET-less Peer Hardware Address Register address [RO][00:00:00:00:00:00]
S * @details @ref _SLDHAR_ gets the destination hardware address acquired by of @ref SLCR_ARP4, SLCR_ARP6, SLCR_PING4, and SLCR_PING6.
S * @sa _SLDIP4R_, _SLDIP6R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_
S * @sa getSLDHAR(), getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLCR(), setSLCR(), \n
S *     getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR() 
S */
S#define _SLDHAR_             (_W6100_IO_BASE_ + (0x4190 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Ping ID Register address [R=W][0x00]
S * @details @ref _PINGIDR_ sets the PING-request ID to be sent by @ref SLCR_PING4 or @ref SLCR_PING6.
S * @sa _SLCR_, _PINGSEQR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLIMR_
S * @sa getPINGIDR(), setPINGIDR(), getSLCR(), setSLCR(), getPINGSEQR(), setPINGSEQR(), getSLDIPR(), setSLDIPR(), 
S *     getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR()
S */
S#define _PINGIDR_            (_W6100_IO_BASE_ + (0x4198 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less ping Sequence number Register address [R=W][0x0000]
S * @details @ref _PINGIDR_ sets the PING-request sequence number to be sent by @ref SLCR_PING4 or @ref SLCR_PING6.
S * @sa _SLCR_, _PINGIDR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLIMR_
S * @sa getPINGSEQR(), setPINGSEQR(), getSLCR(), setSLCR(), getPINGIDR(), setPINGIDR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(),
S *     getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR()
S */
S#define _PINGSEQR_           (_W6100_IO_BASE_ + (0x419C << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv4 Unreachable Address Register address [RO][0.0.0.0]
S * @details @ref _UIPR_ is set when a unreachable ICMPv4 message is received.
S * @sa _UPORTR_, _UIP6R_, _UPORT6R_
S * @sa getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUIPR6(), setUIPR6(), getUPORT6R(), setUPORT6R()
S */
S#define _UIPR_               (_W6100_IO_BASE_ + (0x41A0 << 8) + WIZCHIP_CREG_BLOCK)
S#define _UIP4R_              (_UIPR_)   ///< Refer to @ref _UPORTR_
S
S/**
S * @brief IPv4 Unreachable Port number Register address [RO][0x0000]
S * @details @ref _UPORTR_ is set when a unreachable ICMPv4 message is received.
S * @sa _UIPR_, _UIP6R_, _UPORT6R_
S * @sa getUPORTR(), setUPORTR(), getUIPR(), setUIPR(), getUIPR6(), setUIPR6(), getUPORT6R(), setUPORT6R()
S */
S#define _UPORTR_             (_W6100_IO_BASE_ + (0x41A4 << 8) + WIZCHIP_CREG_BLOCK)
S#define _UPORT4R_            (_UPORTR_)   ///< Refer to @ref _UPORTR_
S/**
S * @brief IPv6 Unreachable IP Address Register address [RO][::]
S * @details @ref _UIP6R_ is set when a unreachable ICMPv6 message is received.
S * @sa _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_
S * @sa getUIPR6(), setUIPR6(), getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUPORT6R(), setUPORT6R()
S */
S#define _UIP6R_              (_W6100_IO_BASE_ + (0x41B0 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv6 Unreachable Port number Register address [RO][0x0000]
S * @details @ref _UIP6R_ is set when a unreachable ICMPv6 message is received.
S * @sa _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_
S * @sa getUIPR6(), setUIPR6(), getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUPORT6R(), setUPORT6R()
S */
S#define _UPORT6R_            (_W6100_IO_BASE_ + (0x41C0 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Interrupt Pending Time Register address [R=w][0x0000]
S * @details @ref _INTPTMR_ pends the next interrupt issued by the INTn pin of @ref _WIZCHIP_.\n
S *          It is decreased 1 every 4 SYS_CLK. \n
S *          If it is zero and some interrupt is still remained, the INTn pin is issued.
S * @sa _IR_, _IRCLR_, _IMR_, _SIR_, _Sn_IRCLR_, _SIMR_, _SLIR_, _SLIRCLR_, _SLIMR_, SYCR_IEN
S * @sa getINTPTMR(), setINTPTMR(), getIR(), setIRCLR(), getIMR(), setIMR(), getSIR(), setSn_IRCLR(), getSIMR(), setSIMR(), \n
S *     getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSYCR1(), setSYCR1()
S */
S#define _INTPTMR_            (_W6100_IO_BASE_ + (0x41C5 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief RA Prefix Length Register address [RO][0x00]
S * @details @ref _PLR_ is set when RA packet is received from a router.
S * @sa SLIR_RA, _SLIRCLR_, _PFR_, _VLTR_, _PLTR_, _PAR_
S * @sa getPLR(), getSLIR(), setSLIRCLR(), getPFR(), getVLTR(), getPLTR(), getPAR()
S */
S#define _PLR_                (_W6100_IO_BASE_ + (0x41D0 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief RA Prefix Flag Register address [RO][0x00]
S * @details @ref _PFR_ is set when RA packet is received from a router.
S * @sa SLIR_RA, _SLIRCLR_, _PLR_, _VLTR_, _PLTR_, _PAR_
S * @sa getPFR(), getSLIR(), setSLIRCLR(), getPLR(), getVLTR(), getPLTR(), getPAR()
S */
S#define _PFR_                (_W6100_IO_BASE_ + (0x41D4 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief RA Valid Life Time Register address [RO][0x00000000]
S * @details @ref _VLTR_ is set when RA packet is received from a router.
S * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _PLTR_, _PAR_
S * @sa getVLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(),  getPLTR(), getPAR()
S */
S#define _VLTR_               (_W6100_IO_BASE_ + (0x41D8 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief RA Prefered Life Time Register address [RO][0x00000000]
S * @details @ref _PLTR_ is set when RA packet is received from a router.
S * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _PLTR_, _PAR_
S * @sa getPLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(), getVLTR(), getPAR()
S */
S#define _PLTR_               (_W6100_IO_BASE_ + (0x41DC << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief RA Prefix Address Register address[RO][::]
S * @details @ref _PAR_ is set when RA packet is received from a router.
S * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _VLTR_, _PLTR_, _PAR_
S * @sa getPAR(), getPLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(), getVLTR() 
S */
S#define _PAR_                (_W6100_IO_BASE_ + (0x41E0 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief ICMPv6 Block Register address [R=W][0x00]
S * @details @ref _ICMP6BLKR_ can block ICMPv6 message such like as PING, MLD, RA, NS and NA.\n
S *          In this blocked case, @ref Sn_MR_IPRAW6 SOCKET can receive it.
S * <table>
S *    <tr> <td>7 ~ 5</td> <td>4    </td> <td>3  </td> <td>2 </td> <td>1 </td> <td>0 </td> </tr>
S *    <tr> <td>7 ~ 5</td> <td>PING6</td> <td>MLD</td> <td>RA</td> <td>NA</td> <td>NS</td> </tr>
S * </table>
S *   - @ref ICMP6BLKR_PING6 : The same as @ref NETxMR_PB
S *   - @ref ICMP6BLKR_MLD
S *   - @ref ICMP6BLKR_RA
S *   - @ref ICMP6BLKR_NA
S *   - @ref ICMP6BLKR_NS
S *
S * @note The blocked message can be accepted by SOCKETn opened with @ref Sn_MR_IPRAW6.
S * @sa NETxMR_PB
S * @sa getICMP6BLKR(), setICMP6BLKR(), getNET6MR(), setNET6MR()
S */
S#define _ICMP6BLKR_          (_W6100_IO_BASE_ + (0x41F0 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Chip configuration Lock Register address [WO][0x00]
S * @details @ref _CHPLCKR_ can lock or unlock to access @ref _SYCR0_ and @ref _SYCR1_.\n
S *          The lock state can be checked from @ref SYSR_CHPL.
S * @sa _SYCR0_, _SYCR1_, _SYSR_, SYSR_CHPL
S * @sa getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _CHPLCKR_            (_W6100_IO_BASE_ + (0x41F4 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Network configuration Lock Register address [WO][0x00]
S * @details @ref _NETLCKR_ can lock or unlock to access the network information register such as @ref _SIPR_, @ref _LLAR_, and etc.\n
S *          The lock state can be checked from @ SYSR_NETL.
S * @sa _SHAR_, _SIPR_, _SUBR_, _GAR_, _LLAR_, _GUAR_, _SUB6R_, _SYSR_, SYSR_NETL
S * @sa getNETLCKR(), setNETLCKR(), NETLOCK(), NETUNLOCK(), getSHAR(), setSHAR(), getSIPR(), getSIPR(), getSUBR(), setSUBR(), \n
S *     getGAR(), setGAR(), getLLAR(), setLLAR(), getGUAR(), setGUAR(), getSUB6R(), setSUB6R(), getSYSR()
S */
S#define _NETLCKR_            (_W6100_IO_BASE_ + (0x41F5 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY configuration Lock Register address [WO][0x00]
S * @details @ref _PHYLCKR_ can lock or unlock to access @ref _PHYCR0_ and @ref _PHYCR1_.\n
S *          The lock state can be checked from @ref SYSR_PHYL.
S * @sa _PHYCR0_, _PHYCR1_, _SYSR_, SYSR_PHYL.
S * @sa getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), setPHYCR0(), getPHYCR1(), setPHYCR1(), getSYSR()
S */
S#define _PHYLCKR_            (_W6100_IO_BASE_ + (0x41F6 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Retransmission Time Register address [R=W][0x07D0]
S * @details @ref _RTR_ sets the default timeout value of @ref _Sn_RTR_.\n
S *          When @ref _Sn_RTR_ is 0, @ref _Sn_RTR_ is reset to @ref _RTR_ after @ref Sn_CR_OPEN.
S * @sa _Sn_RTR_, _RCR_, _Sn_RCR_, _Sn_CR_, Sn_CR_OPEN, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
S * @sa getRTR(), setRTR(), getSn_RTR(), setSn_RTR(), getRCR(), setRCR(), getSn_RCR(), setSn_RCR(),  \n
S *     getSn_CR(), getSn_CR(), getSn_IR(), setSn_IRCLR()
S */
S#define _RTR_                (_W6100_IO_BASE_ + (0x4200 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Retransmission Counter Register address [R=W][0x08]
S * @details @ref _RCR_ sets the default retransmission count of @ref _Sn_RCR_.\n
S *          When @ref _Sn_RCR_ is 0, @ref _Sn_RCR_ is initialized as @ref _Sn_RTR_ after @ref Sn_CR_OPEN.
S * @sa _Sn_RCR_, _RTR_, _Sn_RTR_, _Sn_CR_, Sn_CR_OPEN, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
S * @sa getRCR(), setRCR(), getSn_RCR(), setSn_RCR(), getRTR(), setRTR(), getSn_RTR(), setSn_RTR(), \n 
S *     getSn_CR(), getSn_CR(), getSn_IR(), setSn_IRCLR()
S */
S#define _RCR_                (_W6100_IO_BASE_ + (0x4204 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Retransmission Time Register address [R=W][0x07D0]
S * @details @ref _SLRTR_ sets the timeout value of packet to be retransmitted by @ref _SLCR_.
S * @sa _SLRCR_, _SLIR_, _SLIRCLR_, SLIR_TOUT
S * @sa getSLRTR(), setSLRTR(), getSLRCR(), setSLRCR(), getSLIR(), setSLIRCLR() 
S */
S#define _SLRTR_              (_W6100_IO_BASE_ + (0x4208 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Retransmission Count Register address [R=W][0x00]
S * @details @ref _SLRCR_ sets the retry counter of packet to be retransmitted by @ref _SLCR_.
S * @sa _SLRTR_, _SLIR_, _SLIRCLR_, SLIR_TOUT
S * @sa getSLRCR(), setSLRCR(), getSLRTR(), setSLRTR(), setSLIRCLR(), getSLIR(), setSLIRCLR(),
S */
S#define _SLRCR_              (_W6100_IO_BASE_ + (0x420C << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Hop Limit Register address [R=W][0x80]
S * @details @ref _SLHOPR_ sets the hop limit value of packet to be transmitted by @ref _SLCR_.
S * @sa _SLCR_
S * @sa getSLHOPR(), setSLHOPR(), getSLCR(), setSLCR()
S */
S#define _SLHOPR_             (_W6100_IO_BASE_ + (0x420F << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @}
S */
S
S//----------------------------- W6100 Socket Registers -----------------------------
S/**
S * @addtogroup Socket_register_group_W6100
S * @{
S */
S/**
S * @brief Socket Mode Register Address [R=W][0x00]
S * @details @ref _Sn_MR_ sets the option or protocol type of SOCKETn before @ref Sn_CR_OPEN is performed.\n\n
S *          Each bit of @ref _Sn_MR_ is defined as the following.
S * <table>
S *    <tr> <td>7       </td> <td>6        </td> <td>5            </td> <td>4        </td> <td>3 ~ 0 </td> </tr>
S *    <tr> <td>MULTI/MF</td> <td>BRDB/FPSH</td> <td>ND/MC/SMB/MMB</td> <td>UNIB/MMB6</td> <td>P[3:0]</td> </tr>
S * </table>
S *   - @ref Sn_MR_MULTI : Support UDP Multicasting
S *   - @ref Sn_MR_MF    : Support MAC Filter Enable
S *   - @ref Sn_MR_BRDB  : Broadcast Block
S *   - @ref Sn_MR_FPSH  : Force PSH flag
S *   - @ref Sn_MR_ND    : No Delay ACK flag
S *   - @ref Sn_MR_MC    : IGMP ver2, ver1
S *   - @ref Sn_MR_SMB   : Solicited Multicast Block
S *   - @ref Sn_MR_MMB   : IPv4 Multicast block
S *   - @ref Sn_MR_UNIB  : Unicast Block
S *   - @ref Sn_MR_MMB6  : IPv6 UDP Multicast Block
S *   - <b>P[3:0]</b>
S * <table>
S *    <tr> <td> P[3:0] </td> <td> Protocol Mode  </td> </tr>
S *    <tr> <td> 0000   </td> <td> SOCKET Closed  </td> </tr>
S *    <tr> <td> 0001   </td> <td> TCP4           </td> </tr>
S *    <tr> <td> 0010   </td> <td> UDP4           </td> </tr>
S *    <tr> <td> 0011   </td> <td> IPRAW4         </td> </tr>
S *    <tr> <td> 0100   </tr> <td> MACRAW         </td> </tr>
S *    <tr> <td> 1001   </td> <td> TCP6           </td> </tr>
S *    <tr> <td> 1010   </td> <td> UDP6           </td> </tr>
S *    <tr> <td> 1100   </td> <td> IPRAW6         </td> </tr>
S *    <tr> <td> 1101   </td> <td> TCP Dual(TCPD) </td> </tr>
S *    <tr> <td> 1110   </td> <td> UDP Dual (UDPD)</td> </tr>
S * </table>
S *   - @ref Sn_MR_CLOSE                      : SOCKET Closed
S *   - @ref Sn_MR_TCP4(= @ref Sn_MR_TCP)     : TCP4 mode
S *   - @ref Sn_MR_UDP4(= @ref Sn_MR_UDP)     : UDP4 mode
S *   - @ref Sn_MR_IPRAW4(= @ref Sn_MR_IPRAW) : IPRAW4 mode
S *   - @ref Sn_MR_MACRAW                     : MACRAW mode
S *   - @ref Sn_MR_TCP6                       : TCP6 mode
S *   - @ref Sn_MR_UDP6                       : UDP6 mode
S *   - @ref Sn_MR_IPRAW6                     : IPRAW6 mode
S *   - @ref Sn_MR_TCPD                       : TCP Dual (TCPD) mode
S *   - @ref Sn_MR_UDPD                       : UDP Dual (UDPD) mode
S *
S * @note MACRAW mode should be only used in Socket 0.
S * @sa _Sn_CR_, Sn_CR_OPEN, _Sn_SR_, _Sn_MR2_
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR(), getSn_MR2(), setSn_MR2()
S */
S#define _Sn_MR_(N)           (_W6100_IO_BASE_ + (0x0000 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKET n Prefer Source IPv6 Address Register Address [R=W][0x00]
S * @details @ref _Sn_PSR_ select the Source IPv6 Address to transmit a packet by @ref _Sn_CR_.
S * This function is same as @ref _SLPSR_.
S *   - @ref PSR_AUTO 
S *   - @ref PSR_LLA 
S *   - @ref PSR_GUA 
S * @sa _Sn_CR_, _Sn_PSR_, _SLPSR_
S * @sa getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSLPSR(), setSLPSR(), 
S */
S #define _Sn_PSR_(N)         (_W6100_IO_BASE_ + (0x0004 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief Socket Command Register Address [RW,AC][0x00]
S * @details @ref _Sn_CR_ is used to set the command for SOCKET n such as OPEN, CLOSE, CONNECT, LISTEN, SEND, and RECEIVE.\n
S *          It is automatically cleared to 0x00 after the command is recognized by @ref _WIZCHIP_.\n
S *          Even though @ref _Sn_CR_ is cleared to 0x00, the command is still being processed.\n
S *          To check whether the command is completed or not, please check the @ref _Sn_IR_ or @ref _Sn_SR_.
S *   - @ref Sn_CR_OPEN            : Initialize or open socket.
S *   - @ref Sn_CR_LISTEN       : Wait connection request on TCP4/TCP6/TCPD mode(<b>Server mode</b>)
S *   - @ref Sn_CR_CONNECT      : Send connection request on TCP4/TCPD mode(<b>Client mode</b>)
S *   - @ref Sn_CR_CONNECT6  : Send connection request on TCP6/TCPD mode(<b>Client mode</b>):nohl
S *   - @ref Sn_CR_DISCON       : Send closing request on TCP/TCP6/TCPD mode.
S *   - @ref Sn_CR_CLOSE        : Close socket.
S *   - @ref Sn_CR_SEND            : Update TX buffer pointer and send data in IPv4 socket.
S *   - @ref Sn_CR_SEND6        : Update TX buffer pointer and send data in IPv6 socket.
S *   - @ref Sn_CR_SEND_KEEP : Send keep alive message.
S *   - @ref Sn_CR_RECV            : Update RX buffer pointer and receive data.
S *
S * @note These commands should be exclusive executed.\n That is, the other command can not executed when one command is not cleared yet.
S * @sa _Sn_IR_, _Sn_IRCLR_, Sn_IMR_, _SIR_, _Sn_SR_
S * @sa getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), getSIR(), getSn_SR()
S */
S#define _Sn_CR_(N)           (_W6100_IO_BASE_ + (0x0010 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Interrupt Register Address [RO][0x00]
S * @details @ref _Sn_IR_ gets the status of SOCKETn interrupt such as establishment, termination, receiving data, timeout.\n
S *          If SOCKETn interrupt occurs and the n-th bit of @ref _SIMR_ is set, then @ref SIR_INT(n) is set.\n
S *          In order to clear the @ref _Sn_IR_ bit, Set the corresponding bit of _Sn_IRCLR_ to 1.\n
S *          If all @ref _Sn_IR_ bits are cleared, the @ref SIR_INT(n) is automatically cleared.
S * <table>
S *     <tr> <td>7 ~ 5   </td> <td>4     </td> <td>3      </td> <td>2   </td> <td>1     </td> <td>0  </td> </tr>
S *     <tr> <td>Reserved</td> <td>SENDOK</td> <td>TIMEOUT</td> <td>RECV</td> <td>DISCON</td> <td>CON</td> </tr>
S * </table>
S *   - @ref Sn_IR_SENDOK 
S *   - @ref Sn_IR_TIMEOUT 
S *   - @ref Sn_IR_RECV 
S *   - @ref Sn_IR_DISCON 
S *   - @ref Sn_IR_CON 
S *  
S * @sa _Sn_IRCLR_, _Sn_IMR_, _SIR_, _SIMR_
S * @sa getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), getSIR(), getSIMR(), setSIMR()
S */
S#define _Sn_IR_(N)           (_W6100_IO_BASE_ + (0x0020 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Interrupt Mask Register Address [R=W][0xFF]
S * @details @ref _Sn_IMR_ is used to mask interrupts of @ref _Sn_IR_.
S * @sa _Sn_IR_, _Sn_IRCR_, _SIR_, _SIMR_
S * @sa getSn_IMR(), setSn_IMR(), getSn_IR(), setSn_IRCLR(), getSIR(), getSIMR(), setSIMR()
S */
S#define _Sn_IMR_(N)          (_W6100_IO_BASE_ + (0x0024 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Interrupt Clear Register Address [WO][0x00]
S * @details @ref _Sn_IRCLR_ clears @ref _Sn_IR_
S * @sa _Sn_IR_, _SIR_, _SIMR_
S * @sa setSn_IRCLR(), getSn_IR(), getSIR(), getSIMR(), setSIMR()
S */
S#define _Sn_IRCLR_(N)        (_W6100_IO_BASE_ + (0x0028 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S
S
S/**
S * @brief SOCKETn Status Register Address [RO][0x00]
S * @details @ref _Sn_SR_ indicates the status of SOCKETn.\n
S *          The status of SOCKETn can be changed by @ref _Sn_CR_, some TCP packets such as SYN, FIN, RST packet, or @ref Sn_IR_TIMEOUT.
S *  - Normal status
S *    - @ref SOCK_CLOSED      : Closed
S *    - @ref SOCK_INIT        : Initiate state
S *    - @ref SOCK_LISTEN      : Listen state
S *    - @ref SOCK_ESTABLISHED : Success to connect
S *    - @ref SOCK_CLOSE_WAIT  : Closing state
S *    - @ref SOCK_UDP         : UDP socket
S *    - @ref SOCK_IPRAW       : IPRAW socket
S *    - @ref SOCK_IPRAW6      : IPv6 IPRAW socket
S *    - @ref SOCK_MACRAW      : MAC raw mode socket
S *  - Temporary status during changing the status of SOCKETn .
S *    - @ref SOCK_SYNSENT     : This indicates SOCKETn  sent the connect-request packet (SYN packet) to a peer.
S *    - @ref SOCK_SYNRECV     : It indicates SOCKETn  successfully received the connect-request packet (SYN packet) from a peer.
S *    - @ref SOCK_FIN_WAIT    : Connection state
S *    - @ref SOCK_TIME_WAIT   : Closing state
S *    - @ref SOCK_LAST_ACK    : Closing state
S *
S * @sa _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT 
S * @sa getSn_SR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR()
S * 
S *  <table width=0 >
S *     <tr> <td>@image html SocketStatus.png "<SOCKETn Status Transition>"</td> </tr>
S *  </table>
S *
S */
S#define _Sn_SR_(N)           (_W6100_IO_BASE_ + (0x0030 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Extension Status Register Address [RO][0x00]
S * @details @ref _Sn_ESR_ indicates the connected client IP address information such as IP version, IPv6 address type(LLA or GUA), \n
S *          and TCP operation mode such as <b>TCP SERVER</b> and <b>TCP CLIENT</b>
S * <table>
S *    <tr> <td> 7 ~ 3   </td> <td>2   </td> <td>1    </td> <td>0   </td> </tr> 
S *    <tr> <td> Reserved</td> <td>TCPM</td> <td>TCPOP</td> <td>IP6T</td> </tr> 
S * </table>
S * - @ref Sn_ESR_TCPM  : @ref Sn_ESR_TCPM_IPV4, @ref Sn_ESR_TCPM_IPV6
S * - @ref Sn_ESR_TCPOP : @ref Sn_ESR_TCPOP_SVR, @ref Sn_ESR_TCPOP_CLT
S * - @ref Sn_ESR_IP6T  : @ref Sn_ESR_IP6T_LLA,  @ref Sn_ESR_IP6T_GUA
S * 
S * @note It is valid only on TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_MR_, _Sn_PSR_
S * @sa getSn_ESR(), getSn_MR(), setSn_MR(), getSn_PSR(), setSn_PSR()
S */
S#define _Sn_ESR_(N)          (_W6100_IO_BASE_ + (0x0031 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn IP Protocol Number(PN) Register Address [R/W][0x0000]
S * @details \ref _Sn_PNR_ that sets the protocol number/next header field of the IPv4/IPv6 header at the IP layer.
S * @note It is valid only in IPRAW mode such as @ref Sn_MR_IPRAW4 and @ref Sn_MR_IPRAW6.
S * @note It is set before @ref Sn_CR_OPEN is performed.
S * @sa _Sn_NHR_, _Sn_MR_, Sn_CR_OPEN
S * @sa getSn_PNR(), setSn_PNR(), getSn_NHR(), setSn_NHR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
S */
S#define _Sn_PNR_(N)          (_W6100_IO_BASE_ + (0x0100 << 8) + WIZCHIP_SREG_BLOCK(N))
S#define _Sn_NHR_(N)          (_Sn_PNR_(N))      ///< Refer to @ref _Sn_PNR_.
S
S/**
S * @brief SOCKETn IPv4 Type of Service(TOS) Register Address [R=W][0x00]
S * @details @ref _Sn_TOSR_ sets the TOS(Type Of Service) field in IPv4 Header.
S * @sa getSn_TOSR(), setSn_TOSR()
S */
S#define _Sn_TOSR_(N)         (_W6100_IO_BASE_ + (0x0104 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn IP Time to live(TTL) Register Address [R=W][0x80]
S * @details @ref _Sn_TTLR_ sets the TTL(Time To Live)/HOP(Hop Limit) field in IPv4/IPv6 header at the IP layer.
S * @sa _Sn_HOPR_
S * @sa getSn_TTLR(), setSn_TTLR(), getSn_HOPR(), setSn_HOPR()
S */
S#define _Sn_TTLR_(N)         (_W6100_IO_BASE_ + (0x0108 << 8) + WIZCHIP_SREG_BLOCK(N))
S#define _Sn_HOPR_(N)         (_Sn_TTLR_(N))   ///< Refer to @ref _Sn_TTLR_.
S
S/**
S * @brief SOCKETn Fragment Register Address [R=W][0x4000]
S * @details @ref _Sn_FRGR_ sets the fragment flag & offset in IPv4 header.
S * @note @ref _WIZCHIP_ can not support IP fragment & re-assembly.\n So It is not recommended to set @ref _Sn_FRGR_ to any other value.
S * @sa getSn_FRGR(), setSn_FRGR()
S */
S#define _Sn_FRGR_(N)         (_W6100_IO_BASE_ + (0x010C << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Maximum Segment Size(MSS) Register Address [RW][0x0000]
S * @details @ref _Sn_MSSR_ sets or gets the MTU(Maximum Transfer Unit) of SOCKETn. \n
S *          The MTU of each protocol is as following.
S * <table>
S *    <tr> <td> @ref _Sn_MR_[3:0] </td> <td>@ref NETMR2_PPPoE = 0 </td> <td>@ref NETMR2_PPPoE = '1'</td> </tr>
S *    <tr> <td> @ref Sn_MR_TCP4   </td> <td> 1 ~ 1460             </td> <td> 1 ~ 1452              </td> </tr>
S *    <tr> <td> @ref Sn_MR_TCP6   </td> <td> 1 ~ 1440             </td> <td> 1 ~ 1432              </td> </tr>
S *    <tr> <td> @ref Sn_MR_UDP4   </td> <td> 1 ~ 1472             </td> <td> 1 ~ 1464              </td> </tr>
S *    <tr> <td> @ref Sn_MR_UDP6   </td> <td> 1 ~ 1452             </td> <td> 1 ~ 1444              </td> </tr>
S *    <tr> <td> @ref Sn_MR_IPRAW4 </td> <td> 1 ~ 1480             </td> <td> 1 ~ 1472              </td> </tr>
S *    <tr> <td> @ref Sn_MR_IPRAW6 </td> <td> 1 ~ 1460             </td> <td> 1 ~ 1452              </td> </tr>
S *    <tr> <td> @ref Sn_MR_MACRAW </td> <td colspan = "2">      1 ~ 1514                                              </td> </tr>
S * </table>
S *
S * @note It is not set exceeding the MTU for each protocol of SOCKETn even if _Sn_MSSR_ is set over the MTU.
S * @sa _Sn_MR_, NETMR2_PPPoE
S * @sa getSn_MSSR(), setSn_MSSR(), getSn_MR(), setSn_MR(), getNETMR2(), setNETMR2()
S */
S#define _Sn_MSSR_(N)         (_W6100_IO_BASE_ + (0x0110 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Source Port Register Address [R=W][0x0000]
S * @details @ref _Sn_PORTR_ sets the source port number of SOCKETn .
S * @note It is valid in TCP(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6, @ref Sn_MR_TCPD) and UDP(@ref Sn_MR_UDP4, @ref Sn_MR_UDP6, @ref Sn_MR_UDPD) mode.
S * @note It should be set before @ref Sn_CR_OPEN is performed.
S * @sa _Sn_MR_, Sn_CR_OPEN
S * @sa getSn_PORTR(), getSn_PORTR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
S*/
S#define _Sn_PORTR_(N)        (_W6100_IO_BASE_ + (0x0114 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Destination Hardware Address Register Address [RW][00:00:00:00:00:00]
S * @details @ref _Sn_DHAR_ sets or gets the destination hardware address of SOCKETn.\n
S *   - When @ref Sn_MR2_DHAM = 1 and @ref _Sn_MR_[3:0] != @ref Sn_MR_MACRAW
S *     The destination hardware address is set by @ref _Sn_DHAR_ without ARP processed by @ref Sn_CR_CONNECT, @ref Sn_CR_CONNECT6, @ref Sn_CR_SEND, and @ref Sn_CR_SEND6.\n
S *     Also, when SOCKETn is opened with @ref Sn_MR_UDP4 or @ref Sn_MR_UDP6 and @ref Sn_MR_MULTI is set, @ref _Sn_DHAR_ sets the Multicast Group Hardware address.
S *   - Others
S *     In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD, \n
S *     @ref _Sn_DHAR_ gets the destination hardware address when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
S * @sa _Sn_MR_, _Sn_MR2_, _Sn_CR_, _Sn_SR_
S * @sa getSn_DHAR(), setSn_DHAR(), getSn_MR(), setSn_MR(), getSn_MR2(), setSn_MR2(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define _Sn_DHAR_(N)         (_W6100_IO_BASE_ + (0x0118 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Destination IPv4 Address Register Address [RW][0.0.0.0]
S * @details @ref _Sn_DIPR_(= @ref _Sn_DIP4R_) sets or gets the destination IPv4 address of SOCKETn. \n
S *   - In TCP mode such as @ref Sn_MR_TCP4, and @ref Sn_MR_TCPD
S *      - <b>TCP CLIENT</b> mode : It sets the IPv4 address of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT is performed. 
S *      - <b>TCP SERVER</b> mode : It gets the IPv4 address of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
S *   - In UDP(@ref Sn_MR_UDP4, @ref Sn_MR_UDPD) mode & IPRAW4(@ref Sn_MR_IPRAW4) mode
S *     It sets the destination IPv4 address before @ref Sn_CR_SEND is performed. \n
S *     When Sn_MR_MULTI = 1, It sets the multicast group IPv4 address.
S * @sa _Sn_DIP4R_, _Sn_MR_, _Sn_CR_, _Sn_SR_ 
S * @sa getSn_DIPR(), getSn_DIPR(), getSn_DIP4R(), getSn_DIP4R(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define _Sn_DIPR_(N)         (_W6100_IO_BASE_ + (0x0120 << 8) + WIZCHIP_SREG_BLOCK(N))
S#define _Sn_DIP4R_(N)        (_Sn_DIPR_(N))            ///< Refer to @ref _Sn_DIPR_.
S
S/**
S * @brief SOCKETn Destination IPv6 Address Register Address [RW][::]
S * @details @ref _Sn_DIP6R_ sets or gets the destination IPv6 address of SOCKETn.
S *   - In TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
S *      - <b>TCP CLIENT</b> mode : It sets the IPv6 address of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT6 is performed. 
S *      - <b>TCP SERVER</b> mode : It gets the IPv6 address of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
S *   - In UDP(@ref Sn_MR_UDP6, @ref Sn_MR_UDPD) mode & IPRAW4(@ref Sn_MR_IPRAW6) mode
S *     It sets the destination IPv6 address before @ref Sn_CR_SEND6 is performed.\n
S *     When Sn_MR_MULTI = 1, It sets the multicast group IPv6 address.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
S * @sa getSn_DIP6R(), setSn_DIP6R(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define _Sn_DIP6R_(N)        (_W6100_IO_BASE_ + (0x0130 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Destination Port Register Address [RW][0x0000]
S * @details @ref _Sn_DPORTR_ sets or gets the destination port number of SOCKETn.
S *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
S *      - <b>TCP CLIENT</b> mode : It sets the port number of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT is performed.
S *      - <b>TCP SERVER</b> mode : It gets the port number of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
S *   - In UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD
S *     It sets the destination port number before @ref Sn_CR_SEND is performed. \n
S *     When Sn_MR_MULTI = 1, It sets the multicast group group port number.
S *
S * @note It is valid SOCKETn is opened with @ref Sn_MR_TCP4,  @ref Sn_MR_TCP6, @ref Sn_MR_TCPD, @ref Sn_MR_UDP4, @ref Sn_MR_UDP4, and @ref Sn_MR_UDPD.
S * @note It should be set before OPEN command is ordered.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_ 
S * @sa getSn_DPORTR(), getSn_DPORTR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define _Sn_DPORTR_(N)       (_W6100_IO_BASE_ + (0x0140 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Mode Register 2 Address [R=W][0x00]
S * @details @ref _Sn_MR2_ sets the option of SOCKETn with @ref _Sn_MR_, before @ref Sn_CR_OPEN is performed.\n
S *          Each bit of @ref _Sn_MR2_ is defined as the following.
S * <table>
S *    <tr> <td>7 ~ 2   </td> <td>1   </td> <td>0   </td> </tr>
S *    <tr> <td>Reserved</td> <td>DHAM</td> <td>FARP</td> </tr>
S * </table>
S *   - @ref Sn_MR2_DHAM : @ref Sn_MR2_DHAM_AUTO, @ref Sn_MR2_DHAM_MANUAL
S *   - @ref Sn_MR2_FARP
S * @sa _Sn_MR_, _Sn_CR_
S * @sa getSn_MR2(), setSn_MR2(), getSn_MR(), getSn_MR(), getSn_CR()
S */
S#define _Sn_MR2_(N)          (_W6100_IO_BASE_ + (0x0144 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S
S/**
S * @brief SOCKETn Retransmission Time Register Address [R=W][0x0000]
S * @details @ref _Sn_RTR_ sets the timeout value of packet to be retransmitted by @ref _SLCR_.\n
S * @note It should be set before @ref Sn_CR_OPEN is performed.\n
S *       It is initialized as @ref _RTR_ if you do not set it to none-zero value.
S * @sa _RTR_, _Sn_CR_
S * @sa getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
S */
S#define _Sn_RTR_(N)          (_W6100_IO_BASE_ + (0x0180 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Retransmission Count Register Address [R=W][0x00]
S * @details @ref _Sn_RCR_ sets the retry count value of packet to be retransmitted by @ref _SLCR_.\n
S * @note It should be set before @ref Sn_CR_OPEN is performed.\n
S *       It is initialized as @ref _RTR_ if you do not set it to any none-zero value.
S * @sa _RTR_, _Sn_CR_
S * @sa getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
S */
S#define _Sn_RCR_(N)          (_W6100_IO_BASE_ + (0x0184 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Keep Alive Time Register Address [R=W][0x00]
S * @details @ref _Sn_KPALVTR_ sets the auto-retransmission time of KA(Keep Alive) packet. \n
S *          If the destination can not respond to the KA packet during the time set by @ref _Sn_KPALVTR_,\n
S *          the connection is terminated, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed @ref SOCK_CLOSED.\n
S *          Before the time is expierd, if the destination sends a KA/ACK packet or any packet, the connection is still valid,\n
S *          @ref _Sn_SR_ remained at @ref SOCK_ESTABLISHED.
S * @note It is valid only after sending data over 1 byte in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @note If it is set to 0, KA packet can be sent by @ref Sn_CR_SEND_KEEP.
S * @sa Sn_CR_SEND_KEEP, Sn_IR_TIMEOUT, Sn_IRCLR, Sn_SR, Sn_MR
S * @sa getSn_KPALVTR(), setSn_KPALVTR(), getSn_IR(), setSn_IRCLR(), getSn_SR(), getSn_MR(), setSn_MR()
S */
S#define _Sn_KPALVTR_(N)      (_W6100_IO_BASE_ + (0x0188 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn TX Buffer Size Register Address [R=W][0x02]
S * @details @ref _Sn_TX_BSR_ sets the TX buffer size of SOCKETn in the 16KB TX memory.\n
S *          It can be set only with 0,1,2,4,8, and 16K bytes.
S * @note The 16KB TX memory is allocated as many as @ref _Sn_TX_BSR_ sequentially from SOCKET0 to SOCKETn(Here, 0 <= n <= @ref _WIZCHIP_SOCK_NUM_ - 1).\n
S *       The total sum of Sn_TX_BSR can not be exceed 16KB of TX memory. \n
S *       If the total size is exceeded, SOCKETn can't be normally sent data to a destination.
S * @sa _Sn_RX_BSR_
S * @sa getSn_TX_BSR(), setSn_TX_BSR(), getSn_TXBUF_SIZE(), setSn_TXBUF_SIZE(), getSn_TxMAX(), setSn_TX_BSR(), getSn_RX_BSR(), setSn_RX_BSR()
S */
S#define _Sn_TX_BSR_(N)       (_W6100_IO_BASE_ + (0x0200 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn TX Free Buffer Size Register Address [RO][0x0800]
S * @details @ref _Sn_TX_FSR_ gets the transmittable free size of SOCKETn TX buffer.
S * @note Data should not be saved bigger than it because the data overwrites the previous saved data not to be sent yet.\n
S *       Therefore, Check it before saving the data to the SOCKETn TX buffer. \n
S *       If the data size is equal or smaller than it, transmit the data with @ref Sn_CR_SEND / @ref Sn_CR_SEND6 after saving the data in SOCKETn TX buffer.\n
S *       If the data size is greater than it, transmit the data after dividing into it and saving in the SOCKETn TX buffer.
S * @note \n
S *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD, \n
S *     It is automatically increased by the absolute difference between @ref _Sn_TX_WR_ and interanl TX ACK pointer.
S *   - In other mode \n
S *     It is automatically increased by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_.
S * @sa _Sn_RX_RSR_, _Sn_TX_WR_, _Sn_TX_RD_, _Sn_CR_
S * @sa getSn_TX_FSR(), getSn_TX_WR(), getSn_TX_WR(), getSn_TX_RD(), getSn_CR(), setSn_CR()
S */
S#define _Sn_TX_FSR_(N)       (_W6100_IO_BASE_ + (0x0204 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKET TX Memory Read Pointer Register Address[R][0x0000]
S * @details @ref _Sn_TX_RD_ gets the start pointer of data to be sent by @ref Sn_CR_SEND. \n
S *          @ref Sn_CR_SEND / @ref Sn_CR_SEND6 starts to transmit the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX Buffer,\n
S *          and when @ref Sn_IR_SENDOK is set, It is automatically increased to equal @ref _Sn_TX_WR_.
S * @note It is initialized by @ref Sn_CR_OPEN, But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
S *       it is re-initialized when the TCP connection is completed.
S * @note If it exceeds the maximum value 0xFFFF, (that is, it is greater than 0x10000 and the carry bit occurs),\n
S *       then the carry bit is ignored and it automatically is updated with its the lower 16bits value.
S * @sa _Sn_TX_WR_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
S * @sa getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
S */
S#define _Sn_TX_RD_(N)        (_W6100_IO_BASE_ + (0x0208 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S
S/**
S * @brief SOCKETn TX Memory Write Pointer Register Address [RW][0x0000]
S * @details @ref _Sn_TX_WR_ gets the start pointer of data to be saved in the SOCKETn TX buffer, \n
S *          or sets the end pointer of data to be sent by @ref Sn_CR_SEND. \n
S *          If you have completed to save the data to be sent in the SOCKETn TX buffer,
S *          increase it as many as the saved size of data before @ref Sn_CR_SEND is performed.\n
S *          @ref Sn_CR_SEND starts to transmit the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX Buffer, \n
S *          and when @ref Sn_IR_SENDOK is set, @ref _Sn_TX_RD_ is automatically increased to equal it.
S * @note It is initialized by @ref Sn_CR_OPEN.\n
S *       But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
S *       it is re-initialized when the TCP connection is completed.
S * @note The size of data to be saved can't exceed @ref _Sn_TX_FSR_.
S * @note If it exceeds the maximum value 0xFFFF(that is, it is greater than 0x10000 and the carry bit occurs),\n
S *       then ignore the carry bit and update it with its lower 16bits value.
S * @sa _Sn_TX_RD_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
S * @sa getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
S */
S#define _Sn_TX_WR_(N)        (_W6100_IO_BASE_ + (0x020C << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn RX Buffer Size Register Address [R=W][0x02]
S * @details @ref _Sn_RX_BSR_ sets the RX buffer size of SOCKETn in the 16KB RX memory.\n
S *          It can be set only with 0,1,2,4,8, and 16K bytes.
S * @note The 16KB RX memory is allocated as many as @ref _Sn_RX_BSR_ sequentially from SOCKET0 to SOCKETn(Here, 0 <= n <= @ref _WIZCHIP_SOCK_NUM_ - 1).\n
S *       The total sum of @ref _Sn_RX_BSR_ can not be exceed 16KB of RX memory. \n
S *       If the total size is exceeded, SOCKETn can't be normally received data from a destination.
S * @sa _Sn_RX_BSR_
S * @sa getSn_TX_BSR(), setSn_TX_BSR(), getSn_RXBUF_SIZE(), setSn_RXBUF_SIZE(), getSn_RxMAX(), getSn_RX_BSR(), setSn_RX_BSR()
S */
S#define _Sn_RX_BSR_(N)       (_W6100_IO_BASE_ + (0x0220 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn RX Received Size Register Address [RO][0x0000]
S * @details @ref _Sn_RX_RSR_ gets the received data size of SOCKETn RX buffer.
S * @note The real received data size maybe smaller than it, \n
S *       because it maybe included the size of 'PACKET NFO' such like as \n
S *       the destination IP address, destination port number and data size of the received DATA PACKET.
S * @note Do not read bigger data than @ref _Sn_RX_RSR_.
S * @note It is automatically increased by the absolute difference between @ref _Sn_RX_WR_ and @ref _Sn_RX_RD_ \n
S *       after @ref Sn_CR_RECV is performed.
S * @sa _Sn_RX_RSR_, _Sn_TX_WR_, _Sn_TX_RD_, _Sn_CR_, _Sn_TX_FSR_
S * @sa getSn_RX_RSR(), getSn_TX_WR(), getSn_TX_WR(), getSn_CR(), setSn_CR(), getSn_TX_FSR()
S */
S#define _Sn_RX_RSR_(N)       (_W6100_IO_BASE_ + (0x0224 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKET RX Memory Read Pointer Register Address[R][0x0000]
S * @details @ref _Sn_RX_RD_ gets the start pointer of the received data in the SOCKETn RX buffer,\n
S *          or sets the end data pointer of the read completed data by @ref Sn_CR_RECV. \n
S *          You can read the received data from it to @ref _Sn_RX_WR_ in the SOCKET RX buffer.\n
S *          After completing to read data, you should increase it as many as the read size before @ref Sn_CR_RECV is performed.
S * @note It is initialized by @ref Sn_CR_OPEN, But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
S *       it is re-initialized when the TCP connection is completed.
S * @note If it exceeds the maximum value 0xFFFF, (that is, it is greater than 0x10000 and the carry bit occurs),\n
S *       Ignore the carry bit and update with its the lower 16bits value.
S * @sa _Sn_RX_WR_, _Sn_RX_RSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
S * @sa getSn_RX_WR(), setSn_RX_RD(), getSn_RX_WR(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
S */
S#define _Sn_RX_RD_(N)        (_W6100_IO_BASE_ + (0x0228 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn TX Memory Write Pointer Register Address [RW][0x0000]
S * @details @ref _Sn_TX_WR_ gets the end pointer of the data that has been completely received in the SOCKETn RX buffer. \n
S *          Whenever a data has been completely received from a destination, \n
S *          It is automatically increased as many as the sum size of the received data and the 'PACKET INFO'. \n
S *          You can read the recevied data from @ref _Sn_RX_RD_ to it in the SOCKET RX buffer.
S * @note It is initialized by @ref Sn_CR_OPEN. But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
S *       it is re-initialized when the TCP connection is completed.
S * @note If it exceeds the maximum value 0xFFFF(that is, it is greater than 0x10000 and the carry bit occurs),\n
S *       then ignore the carry bit and update it with its lower 16bits value.
S * @sa _Sn_TX_RD_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, Sn_IRCLR_, _Sn_MR_
S * @sa getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
S */
S#define _Sn_RX_WR_(N)        (_W6100_IO_BASE_ + (0x022C << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @}
S */
S
S/*----------------------------- W6100 Register values  -----------------------------*/
S
S/* System Status Register Bit Definition */
S/**
S * @brief CHIP Lock staus bit of @ref _SYSR_.
S * @details @ref SYSR_CHPL indicates the lock status of @ref _SYCR0_ and @ref _SYCR1_.\n
S *          1 : Lock \n
S *          0 : unlock 
S * @note It is set by only @ref _CHPLCKR_.
S * @sa _SYSR_, _CHPLCKR_, _SYCR0_, _SYCR1_
S * @sa getSYSR(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), setSYCR0(), setSYCR1()
S */
S#define SYSR_CHPL            (1 << 7)
S
S/**
S * @brief NET Lock status bit of @ref _SYSR_.
S * @details @ref SYSR_NETL indicates the lock of network information registers such as 
S *          @ref _SHAR_, @ref _GAR_, @ref _SUBR_, @ref _SIPR_, @ref _LLAR_, @ref _GUAR_, and @ref _SUB6R_. \n
S *          1 : Lock \n
S *          0 : unlock 
S * @note It is set by only @ref _NETLCKR_.
S * @note @ref _GA6R_ can be accessed regardless of @ref SYSR_NETL.
S * @sa _SYSR_, _NETLCKR_, _SHAR_, _GAR_, _SUBR_, _SIPR_, _LLAR_, _GUAR_, _SUB6R_
S * @sa getSYSR(), getNETLCKR(), setNETLCKR(), NETLOCK(), NETUNLOCK(),\n
S *     getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), getSIR(), setSIPR(), \n
S *     getLLAR(), setLLAR(), getGUAR(),setGUAR(), getSUB6R(), setSUB6R()
S */
S#define SYSR_NETL            (1 << 6)
S
S/**
S * @brief PHY Lock status bit of @ref _SYSR_. Refer to @ref _PHYLCKR_.
S * @details @ref SYSR_PHYL indicates the lock status of @ref _PHYCR0_ and _PHYCR1_.\n
S *          1 : Lock \n
S *          0 : unlock
S * @note It is set by only @ref _PHYLCKR_.
S * @sa _SYSR_, _PHYCLKR_, _PHYCR0_, _PHYCR1_
S * @sa getSYSR(), getPHYLCKR(), setPHYLCKR(), setPHYCR0(), getPHYCR1(), setPHYCR1()
S */
S#define SYSR_PHYL            (1 << 5)
S
S/**
S * @brief Parallel Bus Mode bit of @ref _SYSR_
S * @details @ref SYSR_IND is set when @ref _WIZCHIP_ PIN MODE[3:0] == "010X".
S *          It indicates to use the parallel BUS mode. 
S * @sa _SYSR_, _WIZCHIP_IO_MODE_BUS_
S * @sa getSYSR()
S */
S#define SYSR_IND             (1 << 5)
S
S/**
S * @brief SPI I/F Mode bit of @ref _SYSR_.
S * @details @ref SYSR_SPI is set when @ref _WIZCHIP_ PIN MODE[3:0] == "000X".
S *          It indicates to use the SPI mode.
S * @sa _SYSR_, _WIZCHIP_IO_MODE_SPI_
S * @sa getSYSR()
S */
S#define SYSR_SPI             (1 << 0)
S
S
S/* System Config Register Bit Definition */
S/**
S * @brief RST bit of @ref _SYCR0_
S * @details @ref SYCR0_RST resets to @ref _WIZCHIP_ softly. \n
S *          0 : Soft reset \n
S *          1 : Normal operation
S * @note It can be set only when @ref SYSR_CHPL = 1.
S * @sa _SYSR0_, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa setSYCR0(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define SYCR0_RST            (0x00)
S
S/**
S * @brief IEN bit of @ref _SYCR1_.
S * @details @ref SYCR1_IEN is globally enable or disable the interrupt of @ref _WIZCHIP_,\n
S *          regardless of the related interrupt mask registers such as @ref _IMR_, @ref _SIMR_, @ref _SLIMR_, and @ref _Sn_IMR_.\n
S *          1 : Enable  \n
S *          0 : Disable
S * @sa _SYCR1_, _IR_, _SIR_, _SLIR_, _Sn_IR_, _IRCLR_,  _SLIRCLR_, _Sn_IRCLR_
S * @sa getSYCR1(), setSYCR1(), getIR(), getSIR(), getSLIR(), getSn_IR(), setIRCLR(), setSLIRCLR(), setSn_IRCLR()
S */
S#define SYCR1_IEN            (1 << 7)
S
S/**
S * @brief System Clock select mask bit of @ref _SYCR1_.
S * @details @ref SYCR1_CLKSEL selects a system clock to 100MHz or 25MHz. \n
S *          The masked bit values are as following.
S *            - @ref SYCR1_CLKSEL_25M
S *            - @ref SYCR1_CLKSEL_100M
S * @note It can be set only when @ref SYSR_CHPL = 1.
S * @note The system clock is automatically changed to 25MHz while the reset of @ref _WIZCHIP_ H/W reset, the Ethernet PHY H/W reset and power down. \n
S *       On the other hand, the system clock is set by @ref SYCR1_CLKSEL during normal operating.
S * @sa _SYCR1_, _SYSR_, _CHPLCKR_, SYSL_CHPL, PHYCR1_RST, PHYCR1_PWDN
S * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getPHYCR1(), setPHYCR1()
S */
S#define SYCR1_CLKSEL         (1 << 0)
S
S/**
S * @brief System Clock - 25MHz
S * @details @ref SYCR1_CLKSEL_25M selects a system clock to 25MHz.
S * @note It can be set only when @ref SYSR_CHPL = 1.
S * @sa _SYCR1_, SYCR1_CLKSEL, SYCR1_CLKSEL_100M
S * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK()
S */
S#define SYCR1_CLKSEL_25M     1
S
S/**
S * @brief System Clock - 100MHz
S * @details @ref SYCR1_CLKSEL_100M selects a system clock to 100MHz.
S * @note It can be set only when @ref SYSR_CHPL = 1.
S * @sa _SYCR1_, SYCR1_CLKSEL, SYCR1_CLKSEL_25M
S * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK()
S */
S#define SYCR1_CLKSEL_100M    0
S
S
S/* Interrupt Register Bit Definition */
S/**
S * @brief WOL bit of @ref _IR_
S * @details @ref IR_WOL is set when @ref _WIZCHIP_ receives a magic packet of WOL.
S * @sa _IR_, _IRCLR_, _IMR_ 
S * @sa getIR(), setIRCLR(), getIMR(), setIMR()
S */
S#define IR_WOL               (1<<7) 
S
S/**
S * @brief UNR6 bit of @ref _IR_
S * @details @ref IR_UNR6 is set when @ref _WIZCHIP_ receives the unreachable message of ICMPv6.
S * @sa _IR_, _IRCLR_, _IMR_
S * @sa getIR(), setIRCLR(), getIMR(), setIMR()
S */
S#define IR_UNR6              (1<<4)
S
S/**
S * @brief IPCONF bit of @ref _IR_
S * @details @ref IR_IPCONF is set when @ref _WIZCHIP_ receives a ARP reply with the same IPv4 address as @ref _SIPR_.
S * @sa _IR_, _IRCLR_, _IMR_
S * @sa getIR(), setIRCLR(), getIMR(), setIMR()
S */
S#define IR_IPCONF            (1<<2)
S
S/**
S * @brief UNR4 bit of @ref _IR_
S * @details @ref IR_UNR4 is set when @ref _WIZCHIP_ receives the unreachable message of ICMPv4.
S * @sa _IR_, _IRCLR_, _IMR_
S * @sa getIR(), setIRCLR(), getIMR(), setIMR()
S */
S#define IR_UNR4              (1<<1)
S
S/**
S * @brief PTERM bit of @ref _IR_
S * @details @ref IR_PTERM is set when @ref _WIZCHIP_ receives the PPP termination packet
S * @sa _IR_, _IRCLR_, _IMR_
S * @sa getIR(), setIRCLR(), getIMR(), setIMR()
S */
S#define IR_PTERM             (1<<0) 
S
S
S/* SOCKET Interrupt Register Bit Definition */
S/**
S * @brief N-th INT bit of @@ref _SIR_
S * @details @ref SIR_INT(N) is set when @ref _Sn_IR_(N) is not equal to zero.
S * @sa _SIR_, _Sn_IRCLR_, _SIMR_
S * @sa getSIR(), setSn_IRCLR(), getSIMR()
S */
S#define SIR_INT(N)           (1<<N)
S
S
S/* SOCKET-less Interrupt Register Bit Definition */
S/**
S * @brief TOUT bit of @ref _SLIR_
S * @details @ref SLIR_TOUT is set when the timeout is occurred after @ref _SLCR_ is performed.
S * @sa _SLIR_, _SLIRCLR_, _SLCR_
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR()
S */
S#define SLIR_TOUT            (1<<7)
S
S/**
S * @brief ARP4 bit of @ref _SLIR_
S * @details @ref SLIR_ARP4 is set when the ARP-relay is received successfully after @ref SLCR_ARP4 is performed \n
S *          and the destination hardware address can be checked by @ref _SLDHAR_. \n
S *          Otherwise, @ref SLIR_TOUT is set.
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, SLIR_TOUT
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR() 
S */
S#define SLIR_ARP4            (1<<6)
S
S/**
S * @brief PING4 bit of @ref _SLIR_
S * @details @ref SLIR_PING4 is set when the PING-relay is received successfully after @ref SLCR_PING4 is performed \n
S *          and the destination hardware address can be checked by @ref _SLDHAR_ like as @ref SLIR_ARP4.\n
S *          Otherwise, @ref SLIR_TOUT is set. 
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, SLIR_TOUT
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR() 
S */
S#define SLIR_PING4           (1<<5)
S
S/**
S * @brief ARP6 bit of @ref _SLIR_
S * @details @ref SLIR_ARP6 is set when the ARP6-relay is received successfully after @ref SLCR_ARP6 is performed \n
S *          and the destination hardware address can be checked by @ref _SLDHAR_. \n
S *          Otherwise, @ref SLIR_TOUT is set.
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, _SLDHAR_, SLIR_TOUT
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR() 
S */
S#define SLIR_ARP6            (1<<4)
S
S/**
S * @brief PING6 bit of @ref _SLIR_
S * @details @ref SLIR_PING6 is set when the PING-relay is received successfully after @ref SLCR_PING6 is performed \n
S *          and the destination hardware address can be checked by @ref _SLDHAR_ like as @ref SLIR_ARP6. \n
S *          Otherwise, @ref SLIR_TOUT is set.
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, _SLDHAR_, SLIR_TOUT
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR() 
S */
S#define SLIR_PING6           (1<<3)
S
S/**
S * @brief NS bit of @ref _SLIR_
S * @details @ref SLIR_NS is set when the ICMPv6 NA is received after @ref SLCR_NS is performed. \n
S *          Its set means IPv6 address such like as @ref _LLAR_ or @ref _GUAR_ is conflict. \n
S *          If @ref SLIR_TOUT is set, You can use @ref _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_.
S * @note It is used for IPv6 state-less address auto-configuration(SLAAC).
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, SLIR_TOUT, _LLAR_, _GUAR_
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getLLAR(), setLLAR(), getGAUR(), setGUAR()
S */
S#define SLIR_NS              (1<<2) 
S
S/**
S * @brief RS bit of @ref _SLIR_
S * @details @ref SLIR_RS is set when the ICMPv6 RA is received successfully after @ref SLCR_RS is performed \n
S *          and the prefix length, the prefix flag, the valid life time, the preferred life time and the prefix address of RA option message \n
S *          can be checked by @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_, respectively.\n
S *          Otherwise, @ref SLIR_TOUT is set.
S * @bug Only when the first received RA option is the source link-layer address(0x01) and the second is prefix information(0x03),\n
S *      and the prefix information is in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address,\n
S *      @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_ is correctly set.\n
S *      Other case, these registers are not valid.\n\n
S *      To solve this errata,\n
S *      You should use a IPRAW6 mode SOCKETn opened with Sn_MR_IPRAW6 and set the @ref _Sn_PNR_ to ICMPv6 number 58.\n
S *      This SOCKETn can be received a RA message or other ICMPv6 message, and a ICMPv6 message can be selectively filtered out by @ref _ICMP6BLKR_.\n
S *      For more details, Refer to "IPv6 Auto-configuration" document.
S *
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, SLIR_TOUT
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR()
S */
S#define SLIR_RS              (1<<1)
S
S/**
S * @brief ICMPv6 RA Received Interrupt
S * @details @ref SLIR_RA is set when a RA is received from a router without @ref SLCR_RS.\n
S *          Like as @ref SLIR_RS, a RA option message can be checked by @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_.\n
S * @bug Only when RA options are received in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address,\n
S *      @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_ is correctly set. \n
S *      Other case, these registers are not valid.\n\n
S *      To solve this errata, You should use a IPRAW6 mode SOCKETn opened with @ref Sn_MR_IPRAW6 and set the @ref _Sn_PNR_ to ICMPv6 number 58.\n
S *      This SOCKETn can be received a RA message or other ICMPv6 message, and a ICMPv6 message can be selectively filtered out by @ref _ICMP6BLKR_.\n
S *      For more details, Refer to "IPv6 Auto-configuration" document.
S *
S * @sa _SLIR_, _SLIRCLR_ 
S * @sa getSLIR(), setSLIRCLR(), 
S  */
S#define SLIR_RA              (1<<0)
S
S
S/* SOCKET-less & SOCKETn  Prefer Source IPv6 Address Register Bit Definition */
S/**
S * @brief Select the source IPv6 address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to AUTO
S * @details The source IPv6 address depends on IPv6 address type of @ref _SLDIP6R_ or @ref _Sn_DIP6R_.\n
S *          If @ref _Sn_DIP6R_ is a link-local, the source IPv6 address is selected to @ref _LLAR_.\n
S *          Otherwise, the source IPv6 address is selected to @ref _GUAR_.
S * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDI6PR_, _Sn_DIP6R_, _LLAR_, _GUAR_
S * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
S *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
S */
S#define PSR_AUTO             (0x00)
S
S/**
S * @brief Select the source IP address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to @ref _LLAR_
S * @details Regardless of the destination IPv6 address type of @ref _SLDIP6R_ or @ref _Sn_DIP6R_, the source IP is selected to @ref _LLAR_.
S * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDIP6R_, _Sn_DIP6R_, _LLAR_, _GUAR_
S * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
S *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
S */
S#define PSR_LLA              (0x02)
S
S/**
S * @brief Select the source IP address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to @ref _GUAR_
S * @details Regardless of the destination IPv6 address type of @ref _SLDIP6R_, or @ref _Sn_DIP6R_, the source IP is selected to @ref _GUAR_.
S * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDIP6R_, _Sn_DIP6R_, _LLAR_, _GUAR_
S * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
S *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
S */
S#define PSR_GUA              (0x03)
S
S
S/* SOCKET-less Command Register Bit Definition */
S/**
S * @brief IPv4 ARP Command
S * @details It sends a IPv4 ARP request message to @ref _SLDIP4R_ without SOCKETn. \n
S *          The results can be ether @ref SLIR_TOUT or @ref SLIR_ARP4.\n
S *          If the result is @ref SLIR_ARP4, It is success to receive the reply from @ref _SLDIP4R_. \n
S *          You can check the destination hardware address thru @ref _SLDHAR_. \n
S *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP4R_ \n
S *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
S * @sa _SLCR_, _SLDIPR_, _SLDIP4R_ _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
S * @sa getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
S */
S#define SLCR_ARP4            (1<<6)
S
S/**
S * @brief IPv4 PING Command
S * @details It sends a IPv4 PING request message to @ref _SLDIP4R_ without SOCKETn.\n
S *          The results can be ether @ref SLIR_TOUT or @ref SLIR_PING4.\n
S *          If the result is @ref SLIR_PING4, It is success to receive the reply from @ref _SLDIP4R_. \n
S *          Also such like as @ref SLCR_ARP4, You can check the destination hardware address thru @ref _SLDHAR_.\n
S *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP4R_ \n
S *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
S * @sa _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
S * @sa getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
S */
S#define SLCR_PING4           (1<<5)
S
S/**
S * @brief IPv6 ARP Command
S * @details It sends a IPv6 ARP request message to @ref _SLDIP6R_ without SOCKETn. \n
S *          The results can be either @ref SLIR_TOUT or @ref SLIR_ARP6.
S *          If the result is @ref SLIR_ARP6, It is success to receive the reply from @ref _SLDIP6R_. \n
S *          You can check the destination hardware address thru @ref _SLDHAR_.\n
S *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP6R_
S *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
S * @sa _SLCR_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
S * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
S */
S#define SLCR_ARP6            (1<<4)
S
S/**
S * @brief IPv6 PING Command
S * @details It sends a IPv6 PING request message to @ref _SLDIP6R_ without SOCKET. \n
S *          The results can be either @ref SLIR_TOUT or @ref SLIR_PING6.\n
S *          If the result is @ref SLIR_PING6, It is success to receive the reply from @ref _SLDIP6R_.\n
S *          Also such like as @ref SLCR_ARP6, You can check the destination hardware address thru @ref _SLDHAR_.\n
S *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP6R_ \n
S *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
S * @sa _SLCR_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
S * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
S */
S#define SLCR_PING6           (1<<3)
S
S/**
S * @brief IPv6 DAD(Duplicate Address Detection) NS Command
S * @details It sends NS message for DAD to @ref _SLDIP6R_ that is set the address to be used as as @ref _LLAR_ or @ref _GUAR_, without SOCKET.\n
S *          The result can be ether @ref SLIR_TOUT and @ref SLIR_NS.\n
S *          If @ref SLIR_TOUT is set then you can use @ref _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_,\n
S *          else if @ref SLIR_NS is set then you can not use _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_.\n
S *          That means the IPv6 Address are Conflict.
S * @sa _SLCR_, _SLDIP6R_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_, _LLAR_, _GUAR_
S * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR(), \n
S *        getLLAR(), setLLAR(), getGUAR(), setGUAR()
S */
S#define SLCR_NS              (1<<2) 
S
S/**
S * @brief IPv6 Auto-configuration RS Command
S * @details It sends RS message to All-router for IPv6 Auto-configuration without SOCKET.\n
S *         The result can be ether @ref SLIR_RS or @ref SLIR_TOUT. \n
S *         If the result is @ref SLIR_RS, You can some information of router such as a prefix length, a Prefix flag, a valid life time, \n
S *         a preferred life time, and a prefix address respectively thru @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_, and @ref _PAR_.\n
S *         @ref SLIR_TOUT is set when it is no reply from a IPv6 router \n
S *         while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
S * @sa _SLCR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_, _PLR_, _PFR_, _VLTR_, _PLTR_, _PAR_.
S * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR(), \n
S *        getPLR(), getPFR(), getVLTR(), getPLTR(), getPAR().
S */
S#define SLCR_RS              (1<<1)
S
S/**
S * @brief IPv6 Unsolicited NA Command
S * @details It sends the IPv6 unsolicited NA message for updating the network information such as @ref _LLAR_, @ref _GUAR_, and @ref _SHAR_.\n
S *          The result is none.\n
S *          When @ref _SLPSR_ = @ref PSR_GUA, It can send the GUA unsolicited NA message.\n
S *          When @ref _SLPSR_ = Others, It can send the LLA unsolicited NA message.
S * @sa _SLCR_, _SLIR_, _SLIRCLR_, _SLPSR_
S * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCR(), getSLPFR(), setSLPFR()
S */
S#define SLCR_UNA             (1<<0)
S
S
S
S/* PHY Status Register Bit Definition */
S/**
S * @brief CAB mask bit
S * @details @ref PHYSR_CAB masks the CAB bit of @ref _PHYSR_.\n
S *          The masked bit values are as following. \n
S * - @ref PHYSR_CAB_OFF
S * - @ref PHYSR_CAB_ON
S * @sa getPHYSR()
S */
S#define PHYSR_CAB            (1<<7)
S
S/* PHY Status Register Bit Definition */
S/**
S * @brief Ethernet Cable Off
S * @details @ref PHYSR_CAB_OFF indicates the cable is off the Ethernet PHY.
S * @sa _PHYSR_, PHYSR_CAB, PHYSR_CAB_ON
S * @sa getPHYSR()
S */
S#define PHYSR_CAB_OFF        (1<<7)
S
S/**
S * @brief Ethernet PHY Cable On
S * @details @ref PHYSR_CAB_OFF indicates the cable is on the Ethernet PHY.
S * @sa _PHYSR_, PHYSR_CAB, PHYSR_CAB_OFF
S * @sa getPHYSR()
S */
S#define PHYSR_CAB_ON         (0<<7)
S
S/**
S * @brief Mask bits of @ref _PHYSR_
S * @details @ref PHYSR_MODE masks the MODE bits of @ref _PHYSR_.\n
S *          The masked bits values are as following. \n
S *            - @ref PHYSR_MODE_AUTO
S *            - @ref PHYSR_MODE_100F
S *            - @ref PHYSR_MODE_100H
S *            - @ref PHYSR_MODE_10F
S *            - @ref PHYSR_MODE_10H
S * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
S * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
S */
S#define PHYSR_MODE           (7<<3)
S
S/**
S * @brief PHY Mode - AUTO
S * @details @ref PHYSR_MODE_AUTO indicates the Ethernet PHY is operated as auto-negotiation mode.
S * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10F, PHYSR_MODE_10H
S * @sa getPHYSR()
S */
S#define PHYSR_MODE_AUTO      (0<<3)
S
S/**
S * @brief PHY Mode - 100F
S * @details @ref PHYSR_MODE_100F indicates the Ethernet PHY is operated as 100M full-duplex mode.
S * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100H, PHYSR_MODE_10F, PHYSR_MODE_10H
S * @sa getPHYSR()
S */
S#define PHYSR_MODE_100F      (4<<3)
S
S/**
S * @brief PHY Mode - 100H
S * @details @ref PHYSR_MODE_100H indicates the Ethernet PHY is operated as 100M half-duplex mode.
S * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_10F, PHYSR_MODE_10H
S * @sa getPHYSR()
S */
S#define PHYSR_MODE_100H      (5<<3)
S
S/**
S * @brief PHY Mode - 10F
S * @details @ref PHYSR_MODE_10F indicates the Ethernet PHY is operated as 10M full-duplex mode.
S * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10H
S * @sa getPHYSR()
S */
S#define PHYSR_MODE_10F       (6<<3)
S
S/**
S * @brief PHY Mode - 10H
S * @details @ref PHYSR_MODE_10H indicates the Ethernet PHY is operated as 10M half-duplex mode.
S * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10F
S * @sa getPHYSR() 
S */
S#define PHYSR_MODE_10H       (7<<3)
S
S/**
S * @brief DPX mask bit of @ref _PHYSR_
S * @details @ref PHYSR_DPX masks the DPX bit of @ref _PHYSR_. \n
S *          The masked bit values are as following. \n
S *            - @ref PHYSR_DPX_HALF
S *            - @ref PHYSR_DPX_FULL
S * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
S * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
S */
S#define PHYSR_DPX            (1<<2)
S
S/**
S * @brief PHY Duplex - HALF
S * @details @ref PHYSR_DPX_HALF indicates the Ethernet PHY is operated as half-duplex mode.
S * @sa _PHYSR_, PHYSR_DPX_FULL
S * @sa getPHYSR()
S */
S#define PHYSR_DPX_HALF       (1<<2)
S
S/**
S * @brief PHY Duplex - FULL
S * @details @ref PHYSR_DPX_FULL indicates the Ethernet PHY is operated as full-duplex mode.
S * @sa _PHYSR_, PHYSR_DPX_HALF
S * @sa getPHYSR()
S */
S#define PHYSR_DPX_FULL       (0<<2)
S
S/**
S * @brief SPD mask bit of @ref _PHYSR_
S * @details @ref PHYSR_SPD masks the SPD bit of @ref _PHYSR_. The masked bit values are as following. \n
S *   - @ref PHYSR_SPD_10M
S *   - @ref PHYSR_SPD_100M
S * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
S * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
S */
S#define PHYSR_SPD            (1<<1)
S
S /**
S * @brief PHY Speed - 10M
S * @details @ref PHYSR_SPD_10M indicates the Ethernet PHY is operated as 10Mbps speed.
S * @sa _PHYSR_, PHYSR_SPD_100M
S * @sa getPHYSR()
S */
S#define PHYSR_SPD_10M        (1<<1)
S
S /**
S * @brief PHY Speed - 100M
S * @details @ref PHYSR_SPD_100M indicates the Ethernet PHY is operated as 100Mbps speed.
S * @sa _PHYSR_, PHYSR_SPD_10M
S * @sa getPHYSR()
S */
S#define PHYSR_SPD_100M       (0<<1)
S
S/**
S * @brief LNK mask bit of @ref _PHYSR_
S * @details @ref PHYSR_LNK masks the LNK bit of @ref _PHYSR_. The masked bit values are as following. \n
S *   - @ref PHYSR_LNK_DOWN
S *   - @ref PHYSR_LNK_UP
S * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
S * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
S */
S#define PHYSR_LNK            (1<<0)
S
S/**
S * @brief PHY Link - Up
S * @details @ref PHYSR_LNK_UP indicates the link of Ethernet PHY is successfully established .\n
S * @sa _PHYSR_, PHYSR_LNK_DOWN
S * @sa getPHYSR()
S */
S#define PHYSR_LNK_UP         (1<<0)
S
S/**
S * @brief PHY Link - Down
S * @details @ref PHYSR_LNK_DOWN indicates the link of Ethernet PHY is not established yet.\n
S * @sa _PHYSR_, PHYSR_LNK_UP
S * @sa getPHYSR()
S */
S#define PHYSR_LNK_DOWN       (0<<0)
S
S/**
S * @brief Read a value  from the Ethernet PHY register specified by @ref _PHYRAR_.\n
S *        The read value can be checked by _PHYDOR_.
S * @sa _PHYACR_, _PHYDOR_, _PHYRAR_, _PHYDIR_, PHYACR_WRITE
S * @sa getPHYACR(), setPHYACR(), getPHYDOR(), getPHYRAR(), setPHYRAR(), setPHYDIR()
S */
S#define PHYACR_READ          (0x02)
S
S/**
S * @brief Write @ref _PHYDIR_ to the Ethernet PHY register specified by @ref _PHYRAR_.
S * @sa _PHYACR_, _PHYDIR_, _PHYRAR_, _PHYDOR_, PHYACR_READ
S * @sa getPHYACR(), setPHYACR(), setPHYDIR(), getPHYRAR(), setPHYRAR(), getPHYDOR()
S */
S#define PHYACR_WRITE         (0x01)
S
S/**
S * @brief PHY's MDC clock is the divided the system clock by 32
S * @sa _PHYDIVR_
S * @sa getPHYDIVR(), setPHYDIVR()
S */
S#define PHYDIVR_32           (0x00)
S
S/**
S * @brief PHY's MDC clock is the divided system clock by 64
S * @sa _PHYDIVR_
S * @sa getPHYDIVR(), setPHYDIVR()
S */
S#define PHYDIVR_64           (0x01)
S
S/**
S * @brief PHY's MDC clock is the divided system clock by 128
S * @sa _PHYDIVR_
S * @sa getPHYDIVR(), setPHYDIVR()
S */
S#define PHYDIVR_128          (0xFF)
S
S
S/* PHY Command Register Bit Definition */
S/**
S * @brief PHY Operation Mode - Auto Negotiation
S * @details @ref PHYCR0_AUTO sets the Ethernet PHY to operate on auto-negotiation mode.\n
S *          The Ethernet PHY can operate on auto-negotiation after @ref PHYCR1_RST is performed, \n
S *          and the result of @ref PHYCR0_AUTO can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H, BMCR_ANE 
S * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()  
S */
S#define PHYCR0_AUTO          (0x00)
S
S/**
S * @brief PHY Operation Mode - 100F 
S * @details @ref PHYCR0_100F sets the Ethernet PHY to operate on 100F\n
S *          The Ethernet PHY can operate on 100F after @ref PHYCR1_RST is performed,\n
S *          and the result of @ref PHYCR0_100F can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, BMCR_SPD, BMCR_DPX
S * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR0_100F          (0x04)
S
S/**
S * @brief PHY Operation Mode - 100H 
S * @details @ref PHYCR0_100H sets the Ethernet PHY to operate on 100H \n
S *          The Ethernet PHY can operate 100H after @ref PHYCR1_RST is performed, \n
S *          and the result of @ref PHYCR0_100H can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H, BMCR_SPD, BMCR_DPX
S * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR0_100H          (0x05)
S
S/**
S * @brief PHY Operation Mode - 10F 
S * @details @ref PHYCR0_10F sets the Ethernet PHY to operate on 10F \n
S *          The Ethernet PHY can operate 10H after @ref PHYCR1_RST is performed, \n
S *          and the result of @ref PHYCR0_10F can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100F, PHYCR0_100H, PHYCR0_10H, BMCR_SPD, BMCR_DPX
S * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR0_10F           (0x06)
S
S/**
S * @brief PHY Operation Mode - 10H 
S * @details @ref PHYCR0_10H sets the Ethernet PHY to operate on 10H \n
S *          The Ethernet PHY can operate 10H after @ref PHYCR1_RST is performed,  \n
S *          and the result of @ref PHYCR0_10H can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100F, PHYCR0_100H, PHYCR0_10H, BMCR_SPD, BMCR_DPX
S * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR0_10H           (0x07)
S
S
S/**
S * @brief PHY function - Power Down
S * @details @ref PHYCR1_PWDN enters the Ethernet PHY in power down mode. \n
S *          0 : Normal mode \n
S *          1 : Power down mode
S * @note The system clock changes to 25MHz in power down mode, and depends on @ref SYCR1_CLKSEL in normal mode.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR1_, SYCR1_CLKSEL, BMCR_PWDN
S * @sa getPHYCR1(), setPHYCR1(), getSYCR1(), setSYCR1(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR1_PWDN          (1<<5)
S
S/**
S * @brief PHY function - 10Base-TE Mode
S * @details @ref PHYCR1_TE sets the operation of Ethernet PHY to 10base-Te.
S * @note It is valid only when @ref PHYSR_MODE = @ref PHYSR_MODE_AUTO.
S * @note It can be set only when @ref SYSR_PHYL = 1. 
S * @sa _PHYCR1_
S * @sa getPHYCR1(), setPHYCR1()
S */
S#define PHYCR1_TE            (1<<3)
S
S/**
S * @brief PHY function - HW Reset
S * @details @ref PHYCR1_RST resets the Ethernet PHY in hardware, \n
S *          and it is automatically cleared after the H/W reset and it takes 60.3ms to stabilize.\n
S *          0 : Normal mode \n  
S *          1 : H/W Reset \n
S * @note The system clock changes to 25MHz in H/W reset time, and depends on @ref SYCR1_CLKSEL in normal mode.
S * @note It can be set only when @ref SYSR_PHYL = 1. 
S * @sa _PHYCR1_, BMCR_RST
S * @sa getPHYCR1(), setPHYCR1(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR1_RST           (1<<0)
S
S
S
S/* IPv4 Network Mode Register Bit Definition */
S/**
S * @brief UDP Unreachable Packet Block
S * @details @ref NETxMR_UNRB can block sending a ICMPv or ICMPv6 unreachable message to a peer.
S * @sa _NET4MR_, _NET6MR_
S * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
S */
S#define NETxMR_UNRB          (1<<3) 
S
S/**
S * @brief PING ARP Request
S * @details @ref NETxMR_PARP can send a ARP request before sending a ICMPv4 or ICMPv6 PING reply.
S * @sa _NET4MR_, _NET6MR_
S * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
S */
S#define NETxMR_PARP          (1<<2)
S
S/**
S * @brief TCP Reset Packet Block
S * @details @ref NETxMR_RSTB can block sending a TCP RST packet based on IPv4 or IPv6 \n
S *          when there is no SOCKET n opened with a listen port.
S * @sa _NET4MR_, _NET6MR_
S * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
S */
S#define NETxMR_RSTB          (1<<1)
S
S/**
S * @brief PING Reply Block
S * @details @ref NETxMR_PB can block sending a ICMPv4 or ICMPv6 PING reply to a peer.
S * @sa _NET4MR_, _NET6MR_
S * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
S */
S#define NETxMR_PB            (1<<0)
S
S
S/* Network Mode Register Bit Definition */
S/**
S * @brief All-node Multicating PING Reply Block
S * @details @ref NETMR_ANB can block sending a IPv6 PING reply to the peer ping requested to all-node multicast address.
S * @sa _NETMR_
S * @sa getNETMR(), setNETMR()
S */
S#define NETMR_ANB            (1<<5)
S
S/**
S * @brief Solicited Multicasting PING Reply Block
S * @details @ref NETMR_M6B can block sending a IPv6 PING reply to the peer ping requested to the own solicited multicast address.
S * @sa _NETMR_
S * @sa getNETMR(), setNETMR()
S */
S#define NETMR_M6B            (1<<4)
S
S/**
S * @brief Wake On LAN mode
S * @details @ref NETMR_WOL can receive a magic packet of WOL.
S * @sa _NETMR_
S * @sa getNETMR(), setNETMR()
S */
S#define NETMR_WOL            (1<<2)
S
S/**
S * @brief IPv6 Packet Block
S * @details @ref NETMR_IP6B can block receiving all IPv6 packets.
S * @sa _NETMR_
S * @sa getNETMR(), setNETMR()
S */
S#define NETMR_IP6B           (1<<1)
S
S/**
S * @brief IPv4 Packet Block
S * @details @ref NETMR_IP4B can block receiving all IPv4 packets.
S * @sa _NETMR_
S * @sa getNETMR(), setNETMR()
S */
S#define NETMR_IP4B           (1<<0)
S
S
S/**
S * @brief Destination Hardware Address Select
S * @details @ref NETMR2_DHAS masks the DHAS bit of @ref _NETMR2_. \n
S *          The masked bit values are as following.
S *            - @ref NETMR2_DHAS_ARP
S *            - @ref NETMR2_DHAS_ETH
S *
S * @note It is useful when the destination hardware address of Ethernet frame is different from the target address of ARP.
S * @sa _NETMR2_
S * @sa getNETMR2(), setNETMR2()
S */
S#define NETMR2_DHAS          (1<<7)
S
S/**
S * @brief Destination Hardware Address Select - ARP
S * @details @ref NETMR2_DHAS_ARP select the target address of ARP-replay packet to the destination hardware address.
S * @sa _NETMR2_, NETMR2_DHAS_ETH
S * @sa getNETMR2(), setNETMR2()
S */
S#define NETMR2_DHAS_ARP      (1<<7)
S
S/**
S * @brief Destination Hardware Address Select - Ethernet Frame
S * @details @ref NETMR2_DHAS_ETH select the destination address of Ethernet frame to the destination hardware address.
S * @sa _NETMR2_, NETMR2_DHAS_ARP
S * @sa getNETMR2(), setNETMR2()
S */
S#define NETMR2_DHAS_ETH      (0<<7)
S
S/**
S * @brief PPPoE Mode
S * @details @ref NETMR2_PPPoE enables PPPoE mode \n
S *          0 : Disable \n
S *          1 : Enable
S * @note For enabling a PPPoE mode, some information such like as _PTMR_, _PHAR_, _PSIDR_, and _PMRUR_ are needed. \n
S *       To get these information, You can use a SOCKET0 opened with @ref Sn_MR_MACRAW. 
S * @sa _NETMR2_, _PTMR_, _PHAR_, _PSIDR_, _PMRUR_, Sn_MR_MACRAW
S * @sa getNETMR2(), setNETMR2()
S */
S#define NETMR2_PPPoE         (1<<0)
S
S/* ICMPv6 Block Register Bit Definition */
S/**
S * @brief ICMPv6 PING Block
S * @details @ref ICMP6BLKR_PING6 can block a ping request from a peer
S * @sa _IMCP6BLKR_, NETxMR_PB
S * @sa getICMP6BLKR(), setICMP6BLKR(), getNET6MR(), setNET6MR()
S */
S#define ICMP6BLKR_PING6      (1<<4)
S
S/**
S * @brief ICMPv6 MLD Block
S * @details @ref ICMP6BLKR_MLD can block a multicast listener discovery(MLD) query.
S * @sa _ICMP6BLKR_
S * @sa getICMP6BLKR(), setICMP6BLKR()
S */
S#define ICMP6BLKR_MLD        (1<<3)
S
S/**
S * @brief ICMPv6 RA Block
S * @details @ref ICMP6BLKR_RA can block a RA packet from a router
S * @sa _ICMP6BLKR_
S * @sa getICMP6BLKR(), setICMP6BLKR()
S */
S#define ICMP6BLKR_RA         (1<<2)
S
S/**
S * @brief ICMPv6 NA Block
S * @details @ref ICMP6BLKR_NA can block a Neighbor Advertisement(NA) from a peer
S * @sa _ICMP6BLKR_
S * @sa getICMP6BLKR(), setICMP6BLKR()
S */
S#define ICMP6BLKR_NA         (1<<1)
S
S/**
S * @brief ICMPv6 NS Block
S * @details @ref ICMP6BLKR_NS can block a Neighbor Solicitation(NS) from a peer
S * @sa _ICMP6BLKR_
S * @sa getICMP6BLKR(), setICMP6BLKR()
S */
S#define ICMP6BLKR_NS         (1<<0)
S
S
S/* Sn_MR values */
S/**
S * @brief UDP Multicasting 
S * @details  @ref Sn_MR_MULTI enables to a multicast packet from a multicast group in UDP mode SOCKETn. \n
S *            To use multicasting, @ref _Sn_DIPR_, @ref _Sn_DIP6R_, & @ref _Sn_DPORTR_ should be respectively set with \n
S *            the multicast group IPv4, IPv6 address & port number before @ref Sn_CR_OPEN. \n
S *            0 : Disable Multicasting \n
S *            1 : Enable Multicasting \n
S * @note It is valid only in UDP mode such like as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
S * @sa _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_
S * @sa getSn_MR(), setSn_MR(), getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR().
S */
S#define Sn_MR_MULTI          (1<<7)
S
S/**
S * @brief MAC Filter 
S * @details @ref Sn_MR_MF filters other packets except broadcasting, multicasting, and packets sent to your own.\n
S *          0 : Disable MAC Filtering \n
S *          1 : Enable MAC Filtering \n
S * @note It is valid only in MACRAW SOCKET0 opened with @ref Sn_MR_MACRAW \n
S * @note If you want to implement a hybrid TCP/IP stack, \n
S *       It is recommended that @ref Sn_MR_MF enable for reducing host overhead to process the all received packets.
S * @sa _Sn_MR_, Sn_MR_MULTI
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_MF             (1<<7)
S
S/**
S * @brief Broadcasting packet block
S * @details @ref Sn_MR_BRDB can block a broadcasting packet in MACRAW SOCKET0 or UDP mode SOCKETn. \n
S *          0 : Disable Broadcast Blocking \n
S *          1 : Enable Broadcast Blocking \n
S * @note It is valid only in MACRAW mode such as @ref Sn_MR_MACRAW, or in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
S * @sa _Sn_MR_, Sn_MR_FPSH 
S * @sa getSn_MR(), setSn_MR()
S */
S #define Sn_MR_BRDB          (1<<6)
S
S/**
S * @brief Force PUSH flag
S * @details When @ref Sn_MR_FPSH is set, all TCP DATA packets with PSH flag set can be transmitted by @ref Sn_CR_SEND. \n
S *          When @ref Sn_MR_FPSH is not set, the PSH flag is set only in the last DATA packet among the DATA packets transmitted by @ref Sn_CR_SEND. \n
S *          0 : No Force PSH flag \n
S *          1 : Force PSH flag \n
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_MR_, Sn_CR_SEND, Sn_MR_BRDB
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
S */
S#define Sn_MR_FPSH           (1<<6)
S
S/**
S * @brief No Delayed Ack
S * @details When @ref Sn_MR_FPSH is set, It sends the ACK packet without delay as soon as a DATA packet is received from a peer.\n
S *          Otherwise, It sends the ACK packet after waiting the time set by @ref _Sn_RTR_. \n
S *          0 : Delayed ACK \n
S *          1 : No Delayed ACK \n
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.
S * @note Regardless of @ref Sn_MR_ND, It sends the ACK packet when SOCKETn window size is less than MSS after @ref Sn_CR_RECV.
S * @sa _Sn_MR_, _Sn_RTR_, Sn_CR_RECV, Sn_MR_MC, Sn_MR_SMB, Sn_MR_MMB
S * @sa getSn_MR(), setSn_MR(), getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
S */
S #define Sn_MR_ND            (1<<5)
S
S/**
S * @brief IGMP version for IPv4 Multicasting
S * @details @ref Sn_MR_MC decides IGMP version. \n
S *          0 : IGMPv2 \n
S *          1 : IGMPv1 \n
S * @note It is valid only when @ref Sn_MR_MULTI = '1' and UDP mode is @ref Sn_MR_UDP4.
S * @note IGMP packet can be automatically sent to the multicast group by @ref Sn_CR_OPEN.
S * @note @ref _WIZCHIP_ doesn't not support IGMP version 3.
S * @sa _Sn_MR_, Sn_MR_MULTI, Sn_MR_ND, Sn_MR_SMB, Sn_MR_MMB
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_MC             (1<<5)
S
S/**
S * @brief Solicited Mulitcast Block
S * @details @ref Sn_MR_SMB can block a received packet that have your own solicited multicast address. \n
S *          0 : Unblock a solicited multicast packet \n
S *          1 : Block a solicited multicast packet \n
S * @note It is valid only when UDP mode is @ref Sn_MR_UDP6 or @ref Sn_MR_UDPD.
S * @sa _Sn_MR_,  Sn_MR_ND, Sn_MR_MC, Sn_MR_MMB
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_SMB            (1<<5)
S
S/**
S * @brief UDP4 Multicast Block
S * @details @ref Sn_MR_MMB can block the UDP4 multicast packet when SOCKET0 is opend with @ref Sn_MR_MACRAW and @ref Sn_MR_MF is set.\n
S *          0 : Unblock a UDP multicast packet with IPv4 address \n
S *          1 : Block a UDP multicast packet with IPv4 address \n
S * @note It is valid only in MACRAW SOCKET0 with Sn_MR_MF = '1'.
S * @sa _Sn_MR_, Sn_MR_MMB6, Sn_MR_ND, Sn_MR_MC, Sn_MR_SMB
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_MMB            (1<<5)
S#define Sn_MR_MMB4           (Sn_MR_MMB)  /// Refer to @ref Sn_MR_MMB.
S
S/**
S * @brief Unicast Block
S * @details @ref Sn_MR_UNIB can block a unicast packet. \n
S *          0 : Unblock a UDP unicast packet \n
S *          1 : Block a UDP unicast packet \n
S * @note It is valid only when SOCKETn is opened with UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6 and @ref Sn_MR_UDPD, and @ref Sn_MR_MULTI is set.
S * @sa _Sn_MR_, Sn_MR_MULTIL, Sn_MR_MMB6
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_UNIB           (1<<4)
S
S/**
S * @brief UDP6 Multicast Block
S * @details @ref Sn_MR_MMB6 can block the UDP6 multicast packet. \n
S *          0 : Unblock a UDP multicast packet with IPv6 address \n
S *          1 : Block a UDP multicast packet with IPv6 address \n
S * @note  It is valid only when SOCKET0 is opend with @ref Sn_MR_MACRAW and @ref Sn_MR_MF is set.
S * @sa _Sn_MR_, Sn_MR_MMB
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_MMB6           (1<<4)
S
S/**
S * @brief SOCKETn Closed
S * @details @ref Sn_MR_CLOSE is not opened yet.\n
S *          It is the default mode when @ref _WIZCHIP_ is reset.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_CLOSE          (0x00)
S
S/**
S * @brief IPv4 TCP mode 
S * @details @ref Sn_MR_TCP(= @ref Sn_MR_TCP4) sets SOCKETn to TCP4 mode. \n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opend as TCP4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.
S * @note In oder to connect a peer, You should use @ref Sn_CR_CONNECT as command and @ref _Sn_DIPR_ as destination.
S * @note In order to send data, You should use @ref Sn_CR_SEND.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_TCP6, Sn_MR_TCPD
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_TCP            (0x01)
S#define Sn_MR_TCP4           (Sn_MR_TCP)   ///< Refer to @ref Sn_MR_TCP.
S
S/**
S * @brief IPv4 UDP mode
S * @details @ref Sn_MR_UDP(= @ref Sn_MR_UDP4) sets SOCKETn to UDP4 mode.\n
S *          It should be set before @ref Sn_CR_OPEN is performed. \n
S *          After @ref Sn_CR_OPEN, SOCKETn is opend as UDP4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
S * @note In order to send data, You should use @ref Sn_CR_SEND as command and @ref _Sn_DIPR_ as destination.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP6, Sn_MR_UDPD
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_UDP            (0x02)
S#define Sn_MR_UDP4           (Sn_MR_UDP)   ///< Refer to @ref Sn_MR_UDP
S
S/**
S * @brief IPv4 RAW mode
S * @details @ref Sn_MR_IPRAW(= @ref Sn_MR_IPRAW4) sets SOCKETn to IPRAW4 mode. \n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opend as IPRAW4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW(= @ref SOCK_IPRAW4).
S * @note In order to send data, You should use @ref Sn_CR_SEND as command and @ref _Sn_DIPR_ as destination.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_IPRAW6
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_IPRAW          (0x03)
S#define Sn_MR_IPRAW4         (Sn_MR_IPRAW)   ///< Refer to @ref Sn_MR_IPRAW.   
S
S/**
S * @brief MACRAW mode
S * @details @ref Sn_MR_MACRAW sets only SOCKET0 to MACRAW mode.\n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKET0 is opend as MACRAW mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_MACRAW.
S * @note In order to send data, You should use @ref Sn_CR_SEND.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_MACRAW         (0x07)
S
S/**
S * @brief IPv6 TCP mode 
S * @details @ref Sn_MR_TCP6 sets SOCKETn to TCP6 mode. \n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opend as TCP6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.
S * @note In oder to connect a peer, You should use @ref Sn_CR_CONNECT6 as command and @ref _Sn_DIP6R_ as destination.
S * @note In order to send data, You should use @ref Sn_CR_SEND, not @ref Sn_CR_SEND6.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_TCP4, Sn_MR_TCPD
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_TCP6           (0x09)
S
S/**
S * @brief IPv6 UDP mode
S * @details @ref Sn_MR_UDP6 sets SOCKETn to UDP6 mode.\n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opend as UDP6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
S * @note In order to send data, You should use @ref Sn_CR_SEND6 as command and @ref _Sn_DIP6R_ as destination.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP4, Sn_MR_UDPD
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_UDP6           (0x0A)
S
S/**
S * @brief IPv6 RAW mode
S * @details @ref Sn_MR_IPRAW6 sets SOCKETn to IPRAW6 mode.\n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opened as IPRAW6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW6.
S * @note In order to send data, You should use @ref Sn_CR_SEND6 as command and @ref _Sn_DIP6R_ as destination.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_IPRAW4
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_IPRAW6         (0x0B)
S
S/**
S * @brief Both IPv4 & IPv6 TCP mode (TCP dual mode)
S * @details @ref Sn_MR_TCPD sets SOCKETn to both TCP4 & TCP6 mode. \n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opened as TCP Dual mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.\n
S *          The real mode of TCP dual SOCKETn is decided when the connection with a peer is established.\n
S *   - In SOCKETn is operated as <b>TCP SERVER</b> mode 
S *     If the connection request client have a IPv4 address, \n
S *     TCP dual SOCKETn is changed to TCP4 mode and a destination IP address can be checked thru @ref _Sn_DIPR_, \n
S *     else if the client have a IPv6 address, \n
S *     TCP dual SOCKETn is changed to IPv6 mode and destination IP address can be checked by thru @ref _Sn_DIP6R_.
S *   - In SOCKETn is operated as <b>TCP CLIENT</b> mode, 
S *     If the IP address type of destination to connect is IPv4, \n
S *     the destination IP address should be set to @ref _Sn_DIPR_ and try to connect by @ref Sn_CR_CONNECT, \n
S *     else if the type is IPv6, \n
S *     the destination IP address should be set to @ref _Sn_DIP6R_ and try to connect by @ref Sn_CR_CONNECT6. \n
S *           
S * @note In <b>TCP SERVER</b> mode, You can check the IP type of the client with @ref Sn_ESR_TCPM.
S * @note If the connected client have a IPv6 address, You can check whether the address is LLA or GAU, thru @ref Sn_ESR_IP6T
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, _Sn_ESR_TCPM_, Sn_MR_TCP4, Sn_MR_TCP6
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR(), getSn_ESR()
S */
S#define Sn_MR_TCPD           (0x0D)
S
S/**
S * @brief UDP Dual mode
S * @details @ref Sn_MR_UDPD sets SOCKETn to both UDP4 & UDP6 mode. \n
S *          It should be set before @ref Sn_CR_OPEN is performed. \n
S *          After @ref Sn_CR_OPEN, SOCKETn is opened as UDP dual mode \n
S *          and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
S * @note In order to send data, \n
S *       You can use both @ref Sn_CR_SEND and @ref Sn_CR_SEND6 as command and both @ref _Sn_DIPR_ and @ref _Sn_DIP6R_ as destination.
S * @note You can know the destination IP address type is whether IPv6 or IPv4 thru @ref getsockopt() with @ref SO_PACKINFO.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP6, Sn_MR_UDP4
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_UDPD           (0x0E)
S
S/* SOCKETn  Command Register BIt Definition */
S/**
S * @brief Initialize or Open SOCKETn.
S * @details SOCKETn is initialized and opened according to the protocol mode selected by @ref _Sn_MR_ and with a source port set by @ref _Sn_PORTR_. \n
S *                   The table shows @ref _Sn_SR_ is changed according to @ref _Sn_MR_.\n
S * <table>
S *    <tr> <td> <b>@ref _Sn_MR_</b> (P[3:0])                      </td> <td><b>@ref _Sn_SR_</b> </td> </tr>
S *    <tr> <td> @ref Sn_MR_CLOSE                                  </td> <td> @ref SOCK_CLOSED   </td> </tr>
S *    <tr> <td> @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, @ref Sn_MR_TCPD </td> <td> @ref SOCK_INIT     </td> </tr>
S *    <tr> <td> @ref Sn_MR_UDP, @ref Sn_MR_UDP6, @ref Sn_MR_UDPD  </td> <td> @ref SOCK_UDP      </td> </tr>
S *    <tr> <td> @ref Sn_MR_IPRAW4                                 </td> <td> @ref SOCK_IPRAW4   </td> </tr>
S *    <tr> <td> @ref Sn_MR_IPRAW6                                 </td> <td> @ref SOCK_IPRAW6   </td> </tr>
S *    <tr> <td> @ref Sn_MR_MACRAW                                 </td> <td> @ref SOCK_MACRAW   </td> </tr>
S * </table>
S *
S * @note If you want to use a SOCKETn option such as Sn_MR_MF, Sn_MR_ND, Sn_MR_MUTIL and etc, \n
S *       these options should be set before @ref Sn_CR_OPEN is performed.
S * @note If you want to open a multicast UDP mode SOCKETn, \n
S *       You should set the multicast group with @ref _Sn_DIPR_ or @ref _Sn_DIP6R_ and @ref _Sn_DPORTR_ before @ref Sn_CR_OPEN is performed.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_PORTR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_,
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_PORTR(), setSn_PORTR(), getSn_DIPR(), setSn_DIPR(),
S *     getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR()
S */
S#define Sn_CR_OPEN           (0x01)
S
S/**
S * @brief Wait a connection request in <b>TCP SERVER</b> mode
S * @details SOCKETn operates as a <b>TCP SERVER</b> and waits for a connection-request (SYN packet) \n
S *          with corresponding @ref _Sn_PORTR_ port number from any <b>TCP CLIENT</b> \n
S *          The @ref _Sn_SR_ is changed from @ref SOCK_INIT to @ref SOCK_LISTEN. \n
S *          When a <b>TCP CLIENT</b> connection request is successfully accepted,\n
S *          the @ref _Sn_SR_ is changed from @ref SOCK_LISTEN to @ref SOCK_ESTABLISHED \n
S *          and the @ref Sn_IR_CON is set.\n
S *          But when a <b>TCP CLIENT</b> connection request is failed, \n
S *          @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to SOCK_CLOSED.
S * @note This is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_PORTR_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_PORTR(), setSn_PORTR()
S */
S#define Sn_CR_LISTEN         (0x02)
S
S/**
S * @brief Send a connection request in <b>TCP CLIENT</b> mode
S * @details To establish a connection, a connect-request (SYN packet) is sent to <b>TCP SERVER</b> set by @ref _Sn_DIPR_ & @ref _Sn_DPORTR_.\n
S *          If the connect-request is successful accepted by a <b>TCP SERVER</b>, \n
S *          the @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and the @ref Sn_IR_CON is set. \n
S *          The connect-request fails in the following three cases, \n
S *          and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n\n
S *  1. Until a ARP timeout is occurred (@ref Sn_IR_TIMEOUT = 1), a destination hardware address can not be acquired through the ARP-process.\n
S *  2. Until a TCP tmeout occurred (@ref Sn_IR_TIMEOUT = 1), a SYN/ACK packet is not received from the server\n
S *  3. When a RST packet is received instead of a SYN/ACK packet \n
S *
S * @note This is valid only in TCP mode such as @ref Sn_MR_TCP4 and @ref Sn_MR_TCPD. 
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_DIPR_, _Sn_DPORTR_, Sn_CR_CONNECT6, _Sn_IR_, _Sn_IRCLR_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIPR(), setSn_DIPR(), getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR()
S */
S#define Sn_CR_CONNECT        (0x04)
S
S/**
S * @brief Send connection request in <b>TCP CLIENT</b> mode
S * @details To establish a connection, a connect-request (SYN packet) is sent to <b>TCP SERVER</b> set by @ref _Sn_DIP6R_ & @ref _Sn_DPORTR_.\n
S *          If the connect-request is successful accepted by a <b>TCP SERVER</b>, \n
S *          the @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and the @ref Sn_IR_CON is set. \n
S *          The connect-request fails in the following three cases, and @ref _Sn_SR_ is changed @ref SOCK_CLOSED.\n
S *   1. Until a ARP timeout is occurred (@ref Sn_IR_TIMEOUT = 1), a destination hardware address can not be acquired through the ARP-process.\n
S *   2. Until a TCP tmeout occurred (@ref Sn_IR_TIMEOUT = 1), a @b SYN/ACK packet is not received from the server\n
S *   3. When a RST packet is received instead of a @b SYN/ACK packet \n
S *
S * @note This is valid only in TCP mode such as @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD. 
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_DIP6R_, _Sn_DPORTR_, Sn_CR_CONNECT, _Sn_IR_, _Sn_IRCLR_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR()
S */
S#define Sn_CR_CONNECT6       (0x84)
S
S/**
S * @brief Send a disconnect request in TCP mode
S * @details Regardless of <b>TCP SERVER</b> or <b>TCP CLIENT</b>, \n
S *          @ref Sn_CR_DISCON processes the disconnect-process (Active or Passive close).\n
S *          When the disconnect-process is successful (that is, FIN/ACK packet is received successfully from/to each other),\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n
S *          Otherwise, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S *   - Active close 
S *     It transmits first a disconnect-request(FIN packet) to the connected peer, and waits to receive two FIN/ACK and FIN packet from the peer. \n
S *     If two FIN/ACK and FIN packet is received successfully, @ref Sn_IR_DISCON is set and @ref _Sn_SR_ is changed @ref SOCK_CLOSED.
S *   - Passive close
S *     When a FIN packet is first received from the peer, the FIN/ACK packet is replied back to the peer and @ref Sn_IR_DISCON is set.\n
S *     And then, a FIN packet is sent by @ref Sn_CR_DISCON to the peer, and waits to receive the FIN/ACK packet from the peer. \n
S *     If the FIN/ACK packet is received successfully from the peer, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S *
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_DISCON, Sn_IR_TIMEOUT
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_IR(), setSn_IRCLR()
S */
S#define Sn_CR_DISCON         (0x08)
S
S/**
S * @brief Release or Close SOCKETn
S * @details In TCP mode, @ref Sn_CR_CLOSE force to close a SOCKETn without the disconnect-process.\n
S *          In other SOCKETn mode, @ref Sn_CR_CLOSE just closes a SOCKET.\n
S * @note @ref _Sn_SR_ can be changed from any status to @ref SOCK_CLOSED by @ref Sn_CR_CLOSE.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, Sn_CR_DISCON
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR()
S */
S#define Sn_CR_CLOSE          (0x10)
S
S/**
S * @brief Send Data  
S * @details @ref Sn_CR_SEND send the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX buffer \n
S *          to the destination specified by @ref _Sn_DIPR_ or @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_.\n
S *   - TCP mode(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6,  @ref Sn_MR_TCPD)
S *     If it starts to be sent the data by @ref Sn_CR_SEND, @ref Sn_IR_SENDOK is set. \n 
S *     And after sending the data, if the ACK to the sent data can not be received during @ref _Sn_RTR_, \n
S *     the sent data can be retransmitted as many as @ref _Sn_RCR_. \n
S *     During the retransmission, \n
S *     If the ACK is received, @ref _Sn_TX_FSR_ is increased as many as the sent data size, \n
S *     Otherwise, @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S *   - UDP mode(@ref Sn_MR_UDP4, @ref Sn_MR_UDPD) & IPRAW mode(@ref Sn_MR_IPRAW4)
S *     It first sends a ARP-request to a destination specified with @ref _Sn_DIPR_ before it starts to be sent data by @ref Sn_CR_SEND. \n
S *     If the ARP-reply can not be received during @ref _Sn_RTR_, the ARP-request can be retransmitted as many as @ref _Sn_RCR_. \n
S *     During the retransmission, \n
S *     If the ARP-reply is received and @ref Sn_IR_SENDOK is set, it starts to send data and then @ref _Sn_TX_FSR_ is increased as many as the sent data size. \n
S *     Otherwise, @ref Sn_IR_TIMEOUT is set but @ref _Sn_SR_ is not changed.
S *   - MACRAW mode(@ref Sn_MR_MACRAW)
S *     It just start to send data and @ref Sn_IR_SENDOK is set.
S *
S * @note Data size to be sent is calculated by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_. \n
S *       In TCP or UDP mode, It can not be sent bigger data than @ref _Sn_TX_FSR_.\n
S *       In IPRAW or Macraw case, it can not be sent bigger data than MTU(Maximum Transmit Unit).
S * @note In TCP or MACRAW mode, It can send data to a destination address whether IPv4 or IPv6. \n
S *       In UDP or IPRAW mode, It can send data only to a destination IPv4 address. \n
S *       For Sending to IPv6 address, It can be used with @ref Sn_CR_SEND6.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_, _Sn_IR_, _Sn_IRCLR_, _Sn_TX_FSR_, _Sn_TX_WR_, _Sn_TX_RD_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), \n
S *     getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR(), getSn_TX_FSR(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD()
S */
S#define Sn_CR_SEND           (0x20)
S
S/**
S * @brief Send Data       
S * @details @ref Sn_CR_SEND6 sends the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX buffer \n
S *          to the destination specified by @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_.\n
S *   - TCP mode(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6,  @ref Sn_MR_TCPD) & MACRAW mode(@ref Sn_MR_MACRAW)
S *     @ref Sn_CR_SEND6 is not recommended. In this case, Use @ref Sn_CR_SEND.
S *   - UDP mode(@ref Sn_MR_UDP6, @ref Sn_MR_UDPD) & IPRAW mode(@ref Sn_MR_IPRAW6)
S *     It first send a neighbor solicitation NS) of ICMPv6 to a destination specified with @ref _Sn_DIP6R_ \n
S *     before it starts to be sent data by @ref Sn_CR_SEND. \n
S *     If the neighbor advertisement(NA) of ICMPv6 can not be received during @ref _Sn_RTR_, \n
S *     the NS can be retransmitted as many as @ref _Sn_RCR_. \n
S *     During the retransmission, \n
S *     If the NA is received and @ref Sn_IR_SENDOK is set, \n
S *     it starts to send data and then @ref _Sn_TX_FSR_ is increased as many as the sent data size. \n
S *     Otherwise, @ref Sn_IR_TIMEOUT is set but @ref _Sn_SR_ is not changed.
S *
S * @note Data size to be sent is calculated by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_. \n
S *       In TCP or UDP mode, It can not be sent bigger data than @ref _Sn_TX_FSR_.\n
S *       In IPRAW or Macraw case, it can not be sent bigger data than MTU(Maximum Transmit Unit).
S * @note In UDP or IPRAW mode, It can send data only to a destination IPv6 address. \n
S *       For Sending to IPv4 address, It can be sent by @ref Sn_CR_SEND.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_DIP6R_, _Sn_DPORTR_, _Sn_IR_, _Sn_IRCLR_, _Sn_TX_FSR_, _Sn_TX_WR_, _Sn_TX_RD_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR(), \n
S *     getSn_IR(), setSn_IRCLR(), getSn_TX_FSR(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD()
S */
S #define Sn_CR_SEND6         (0xA0)
S
S/**
S * @brief Send keep alive message
S * @details @ref Sn_CR_SEND_KEEP checks whether the connection is established or not by sending 1 byte KA(Keep Alive) packet.\n
S *          If the destination can not respond to the KA packet during the time set by @ref _Sn_RTR_ and @ref _Sn_RCR_, \n
S *          the connection is terminated, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed @ref SOCK_CLOSED.
S * @note It is valid only after sending data over 1 byte in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_IR_, _Sn_IRCLR_, _Sn_RTR_, _Sn_RCR_, _Sn_KPALVTR_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_IR(), setSn_IRCLR(), \n
S *        getSn_RTR(), setSn_RTR(), getSn_RCR(), setSn_RCR(), getSn_KPALVTR(), getSn_KPALVTR()
S */
S#define Sn_CR_SEND_KEEP      (0x22)
S
S/**
S * @brief Receive data
S * @details @ref Sn_CR_RECV reads the saved from @ref _Sn_RX_RD_ to @ref _Sn_RX_WR_ data in SOCKETn RX buffer.\n
S *          When a data is saved in the SOCKETn RX buffer, \n
S *          @ref Sn_IR_RECV is set and @ref _Sn_RX_RSR_ is increased as many as the saved data size.\n
S *          The total size of saved data is calculated by the absolute difference between @ref _Sn_RX_WR_ and @ref _Sn_RX_RD_,\n
S *          and it can be checked thru @ref _Sn_RX_RSR_.\n
S *          After reading data, @ref _Sn_RX_RD_ should be increased as many as the read size before @ref Sn_CR_RECV is performed.\n
S *          After @ref Sn_CR_RECV, @ref _Sn_RX_RSR_ is decreased as many as the read size.\n
S *          If @ref _Sn_RX_RSR_ is remained still at none-zero, @ref Sn_IR_RECV is set again.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_IR_, _Sn_IRCLR_, _Sn_RX_RD_, _Sn_RX_WR_, _Sn_RX_RSR_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_IR(), getSn_IRCLR(), \n
S *     getSn_RX_RD(), setSn_RX_RD(), getSn_RX_TX(), getSn_RX_RSR()
S */
S#define Sn_CR_RECV           (0x40)
S
S
S/* Sn_IR values */
S/**
S * @brief SEND OK Interrupt
S * @details @ref Sn_IR_SENDOK is set when it is started to be sent data by @ref Sn_CR_SEND. 
S * @note Even though @ref Sn_IR_SENDOK is set, it does not means that the destination receives data successfully.\n
S *         - In TCP mode, The sent data maybe still transmitting or retransmitting. \n
S *         - In other modes, The sent data maybe lost by media collision or an other reason such as network traffic.
S * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_SEND
S * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
S */
S#define Sn_IR_SENDOK         (0x10)
S
S/**
S * @brief TIMEOUT Interrupt
S * @details @ref Sn_IR_TIMEOUT is set when a timeout occurs in ARP and ND process or TCP retransmission.
S * @note In TCP mode, If it is set, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED. \n
S *       In other modes, _Sn_SR_ is still remained at the previous status.
S * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_CONNECT, Sn_CR_CONNECT6, Sn_CR_SEND
S * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
S */
S#define Sn_IR_TIMEOUT        (0x08)
S
S/**
S * @brief RECV Interrupt
S * @details @ref Sn_IR_RECV is set whenever data is received from a peer, \n
S *          or if @ref _Sn_RX_RSR_ is still at none-zero whenever @ref Sn_CR_RECV is performed.
S * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_RECV
S * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
S */
S#define Sn_IR_RECV           (0x04)
S
S/**
S * @brief DISCON Interrupt
S * @details @ref Sn_IR_DISCON is set when a FIN or FIN/ACK packet is received from the connected peer.
S * @note When first a FIN packet is received from the connected peer and @ref _Sn_SR_ is changed to SOCK_CLOSE_WAIT, \n
S *       you should perform @ref Sn_CR_DISCON for a successful disconnect. \n
S *       If the disconnect-process is completed or failed, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valild only in TCP mode such as @ref Sn_MR_TCP4, @ ref Sn_MR_TCP6 and @ref Sn_MR_TCPD.
S * @sa _Sn_IR_, _Sn_IRCLR_, Sn_IR_DISCON, _Sn_SR_
S * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_IR_DISCON         (0x02)
S
S/**
S * @brief CONNECT Interrupt
S * @details @ref Sn_IR_CON is set once the connection with a peer is established and @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ ref Sn_MR_TCP6 adn @ref Sn_MR_TCPD.
S * @sa _Sn_IR_, _Sn_IRCLR_, _Sn_SR_
S * @sa getSn_IR(), setSn_IRCLR(), getSn_SR()
S */
S#define Sn_IR_CON            (0x01)
S
S/* Sn_SR values */
S/**
S * @brief SOCKETn Closed status
S * @details @ref SOCK_CLOSED indicates that SOCKETn is closed and released.\n
S *          It is set when @ref Sn_CR_DISCON , @ref Sn_CR_CLOSE is performed, or when @ref Sn_IR_TIMEOUT is set.\n
S *          It can be changed to @ref SOCK_CLOSED regardless of previous status.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
S * @sa getSn_SR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR()
S */
S#define SOCK_CLOSED          (0x00)
S
S/**
S * @brief TCP SOCKETn initialized status
S * @details @ref SOCK_INIT indicates SOCKETn is opened with TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.\n
S *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT when @ref Sn_CR_OPEN is performed in TCP mode.\n
S *          In @ref SOCK_INIT status, @ref Sn_CR_LISTEN for operating a <b>TCP SERVER</b> \n
S *          or @ref Sn_CR_CONNECT / @ref Sn_CR_CONNECT6 for operating a <b>TCP CLIENT</b> can be performed.
S * @note It is valid only in TCP mode.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_MR_
S * @sa getSn_SR, getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_INIT            (0x13)
S
S/**
S * @brief TCP SOCKETn Listen status
S * @details @ref SOCK_LISTEN indicates SOCKETn is operating as <b>TCP SERVER</b> mode \n
S *          and waiting for connection-request (SYN packet) from a peer (<b>TCP CLIENT</b>).\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_SYNRECV when the connection-request(SYN packet) is successfully accepted \n
S *          and It is changed from @ref SOCK_SYNRECV to @ref SOCK_ESTABLISHED \n
S *          when the SYN/ACK packet is sent successfully to the peer and then the ACK packet of SYN/ACK is received successfully.\n
S *          Otherwise, it is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_ 
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_LISTEN          (0x14)
S
S/**
S * @brief TCP Connection Request status
S * @details @ref SOCK_SYNSENT indicates TCP SOCKETn sent the connect-request packet(SYN packet)\n
S *          to the peer specified by @ref _Sn_DIPR_ / @ref _Sn_DIP6R_ and @ref _Sn_DPORTR_.\n
S *          It is temporarily shown when @ref _Sn_SR_ is changing from @ref SOCK_INIT to @ref SOCK_ESTABLISHED by @ref Sn_CR_CONNECT or @ref Sn_CR_CONNECT6.\n
S *          When the connect-accept packet (SYN/ACK packet) is received from the peer at @ref SOCK_SYNSENT and the ACK packet of SYN/ACK is sent successfully, \n
S *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED.\n
S *          Otherwise, it is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_  
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_SYNSENT         (0x15)
S
S/**
S * @brief TCP Connection Accept status
S * @details @ref SOCK_SYNRECV indicates TCP SOCKETn is successfully received the connect-request packet (SYN packet) from a peer.\n
S *          It is temporarily shown when @ref _Sn_SR_ is changing from @ref SOCK_LISTEN to @ref SOCK_ESTABLISHED by the SYN packet\n
S *          If SOCKETn sends the response (SYN/ACK  packet) to the peer successfully and the ACK packet of SYS/ACK is received successfully,\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED. \n
S *          Otherwise, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_SYNRECV         (0x16)
S
S/**
S * @brief TCP SOCKETn Established status
S * @details @ref SOCK_ESTABLISHED indicates TCP SOCKETn is connected successfully with a peer.\n
S *          when the <b>TCP SERVER</b> processes the SYN packet from the <b>TCP CLIENT</b> during @ref SOCK_LISTEN or \n
S *          when the <b>TCP CLIENT</b> performs successfully @ref Sn_CR_CONNECT or @ref Sn_CR_CONNECT6,\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and @ref Sn_IR_CON is set. \n
S *          During @ref SOCK_ESTABLISHED, a DATA packet can be sent to or received from the peer by @ref Sn_CR_SEND or @ref Sn_CR_RECV.  \n
S *          If the DATA/ACK packet is not received from the peer during data re-transmission, @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n
S *          Otherwise, @ref _Sn_SR_ is still at @ref SOCK_ESTABLISHED.
S * @note In <b>TCP SERVER</b>, \n
S *       You can check the IPv4/IPv6 address and port number of connected peer thru @ref _Sn_DIPR_, @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_ respectively.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
S *     getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR().
S */
S#define SOCK_ESTABLISHED     (0x17)
S
S/**
S * @brief TCP SOCKETn Closing status
S * @details @ref SOCK_FIN_WAIT indicates TCP mode SOCKETn waits until the disconnect-process is completed. \n
S *          It is temporarily shown in disconnect-process such as active-close. \n
S *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_TIME_WAIT, SOCK_LAST_ACK
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S *
S */
S#define SOCK_FIN_WAIT        (0x18)
S
S/**
S * @brief TCP SOCKETn Closing status
S * @details @ref SOCK_TIME_WAIT indicates TCP SOCKETn waits until the disconnect-process is completed.\n
S *          It is temporarily shown in disconnect-process such as active-close. \n
S *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_FIN_WAIT, SOCK_LAST_ACK 
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_TIME_WAIT       (0x1B)
S
S/**
S * @brief TCP SOCKETn Half Closing staus
S * @details @ref SOCK_CLOSE_WAIT indicates TCP SOCKETn receives the disconnect-request (FIN packet) from the connected peer.\n
S *          It is a half-closing status, and a DATA packet can be still sent or received by @ref Sn_CR_SEND or @ref Sn_CR_RECV.\n
S *          If you do not have any more need to send or received a DATA packet, You can perform @ref Sn_CR_DISCON for a full-closing.
S * @note If you have no need the successful closing, You maybe perform @ref Sn_CR_CLOSE.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_ 
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_CLOSE_WAIT      (0x1C)
S
S/**
S * @brief TCP SOCKETn Closing status
S * @details @ref SOCK_LAST_ACK indicates TCP SOCKETn waits until the disconnect-process is completed.\n
S *          It is temporarily shown in disconnect-process such as active-close and passive-close.\n
S *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_FIN_WAIT, SOCK_TIME_WAIT 
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_LAST_ACK        (0x1D)
S
S/**
S * @brief UDP SOCKETn status
S * @details @ref SOCK_UDP indicates SOCKETn is opened in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.\n
S *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT when @ref Sn_CR_OPEN is performed in UDP mode.\n
S *          Unlike TCP mode, during @ref SOCK_UDP, \n
S *          a DATA packet can be sent to or received from a peer by @ref Sn_CR_SEND / @ref Sn_CR_SEND6 or @ref Sn_CR_RECV without a connect-process.\n
S *          Before a DATA packet is sent by @ref Sn_CR_SEND / @ref Sn_CR_SEND6,\n
S *          the ARP is requested to the peer specified by @ref _Sn_DIPR_ / @ref _Sn_DIP6R_.\n
S *          In ARP processing, @ref _Sn_SR_ is stll at @ref SOCK_UDP even if @ref Sn_IR_TIMEOUT is set.\n
S *          If you do not have any more need to send or received a DATA packet, \n
S *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
S *     getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R()
S */
S#define SOCK_UDP             (0x22)
S
S/**
S * @brief IPRAW4 SOCKETn mode
S * @details @ref SOCK_IPRAW4(= @ref SOCK_IPRAW) SOCKETn indicates SOCKETn is opened as IPv4 RAW mode.\n
S *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW4 when @ref Sn_CR_OPEN is performed with @ref Sn_MR_IPRAW4. \n
S *          A DATA packet can be send to or received from a peer without a connection like as @ref SOCK_UDP. \n
S *          Before a DATA packet is sent by @ref Sn_CR_SEND, \n
S *          the ARP is requested to the peer specified by @ref _Sn_DIPR_.\n
S *          In ARP processing, @ref _Sn_SR_ is still at @ref SOCK_IPRAW4 even if @ref Sn_IR_TIMEOUT is set.\n
S *          IPRAW4 SOCKETn can receive only the packet specified by @ref _Sn_PNR_, and it discards the others packets.\n
S *          If you do not have any more need to send or received a DATA packet, \n
S *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in IPRAW4 mode such as @ref Sn_MR_IPRAW4.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_PNR_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
S *     getSn_DIPR(), setSn_DIPR(), getSn_PNR(), setSn_PNR() 
S */
S#define SOCK_IPRAW4          (0x32)
S#define SOCK_IPRAW           (SOCK_IPRAW4)   ///< Refer to @ref SOCK_IPRAW4.
S
S/**
S * @brief IPRAW6 SOCKETn mode
S * @details @ref SOCK_IPRAW6 SOCKETn indicates SOCKETn is opened as IPv6 RAW mode.\n
S *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW6 when @ref Sn_CR_OPEN is performed with @ref Sn_MR_IPRAW6. \n
S *          A DATA packet can be send to or received from a peer without a connection like as @ref SOCK_UDP.\n
S *          Before a DATA packet is sent by @ref Sn_CR_SEND6, \n
S *          the ICMPv6 NS is requested to the peer specified by @ref _Sn_DIPR_ or @ref _Sn_DIP6R_.\n
S *          In ND(Neighbor Discovery) is processing,\n
S *          @ref _Sn_SR_ is still at @ref SOCK_IPRAW6 even if @ref Sn_IR_TIMEOUT is set.\n
S *          IPRAW6 SOCKETn can receive only the packet specified by @ref _Sn_PNR_, and it discards the others packets.\n
S *          If you do not have any more need to send or received a DATA packet, \n
S *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in IPRAW6 mode such as @ref Sn_MR_IPRAW6.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIP6R_, _Sn_PNR_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
S *     getSn_DIP6R(), setSn_DIP6R(), getSn_PNR(), setSn_PNR() 
S */
S#define SOCK_IPRAW6          (0x33)
S
S/**
S * @brief MACRAW SOCKETn mode
S * @details @ref SOCK_MACRAW indicates SOCKET0 is opened as MACRAW mode.\n
S *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_MACRAW when @ref Sn_CR_OPEN command is ordered with @ref Sn_MR_MACRAW.\n
S *          MACRAW SOCKET0 can be sent or received a pure Ethernet frame packet to/from any peer.
S * @note  It is valid only in SOCKET0.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
S */
S#define SOCK_MACRAW          (0x42)
S
S/* Sn_ESR values */
S/**
S * @brief SOCKETn Extended Status : TCP Mode
S * @details @ref Sn_ESR_TCPM masks the TCPM bit of @ref _Sn_ESR_. \n
S *          The masked bit values are as following. \n
S *          - @ref Sn_ESR_TCPM_IPV4
S *          - @ref Sn_ESR_TCPM_IPV6
S * @note It is useful to know the destination IP version when TCPD(@ref Sn_MR_TCPD) mode SOCKETn is operated as <b>TCP SERVER</b>.
S * @sa _Sn_ESR_
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPM          (1<<2)
S
S/**
S * @brief TCP SOCKETn IP version - IPv4
S * @details @ref Sn_ESR_TCPM_IPV4 indicates TCP SOCKETn is operated on IPv4 .
S * @sa _Sn_ESR_, Sn_ESR_TCPM_IPV6
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPM_IPV4     (0<<2)
S
S/**
S * @brief TCP SOCKETn IP version - IPv6
S * @details @ref Sn_ESR_TCPM_IPV6 indicates TCP SOCKETn is operated on IPv6 .
S * @sa _Sn_ESR_, Sn_ESR_TCPM_IPV4
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPM_IPV6     (1<<2)
S
S/**
S * @brief SOCKETn Extended Status : TCP Operation Mode
S * @details @ref Sn_ESR_TCPOP masks the TCPOP bit of @ref _Sn_ESR_. The masked bit values are as following. \n
S *            - @ref Sn_ESR_TCPOP_SVR
S *            - @ref Sn_ESR_TCPOP_CLT
S * @note It is useful to check TCP mode SOCKETn is operated as whether <b>TCP SERVER</b> or <b>TCP CLIENT</b>.
S * @sa _Sn_ESR_
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPOP         (1<<1)
S
S/**
S * @brief TCP SOCKETn Operation Mode - <b>TCP SERVER</b>
S * @details @ref Sn_ESR_TCPOP_SVR indicates TCP mode SOCKET n is operated as <b>TCP SERVER</b>
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_ESR_, Sn_ESR_TCPOP_CLT
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPOP_SVR     (0<<1)
S
S/**
S * @brief TCP SOCKETn Operation Mode - <b>TCP CLIENT</b>
S * @details @ref Sn_ESR_TCPOP_SVR indicates TCP mode SOCKET n is operated as <b>TCP CLIENT</b>
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_ESR_, Sn_ESR_TCPOP_SVR
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPOP_CLT     (1<<1)
S
S/**
S * @brief SOCKETn Extended Status : Source IPv6 Address Type
S * @details @ref Sn_ESR_IP6T masks the IP6T bit of @ref _Sn_ESR_. \n
S *          The masked bit values are as following. \n
S *            - @ref Sn_ESR_IP6T_LLA
S *            - @ref Sn_ESR_IP6T_GUA
S * @note It is useful to check whether the connected peer IP address is LLA or GUA.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD.
S * @sa _Sn_ESR_
S * @sa getSn_ESR()
S */
S#define Sn_ESR_IP6T          (1<<0)
S
S/**
S * @brief Source IPv6 Address Type - LLA
S * @details @ref Sn_ESR_IP6T_LLA indicates the source IPv6 Address is used as @ref _LLAR_
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_ESR_, Sn_ESR_IP6T_GUA, _LLAR_
S * @sa getSn_ESR(), getLLAR(), setLLAR()
S */
S#define Sn_ESR_IP6T_LLA      (0<<0)
S
S/**
S * @brief Source IPv6 Address Type - LLA
S * @details @ref Sn_ESR_IP6T_GUA indicates the source IPv6 Address is used as @ref _GUAR_
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_ESR_, Sn_ESR_IP6T_LLA, _GUAR_
S * @sa getSn_ESR(), getGUAR(), setGUAR()
S */
S#define Sn_ESR_IP6T_GUA      (1<<0)
S
S/* Sn_MR2 values */
S/**
S * @brief Destination Hardware Address Mode 
S * @details @ref Sn_MR2_DHAM masks the DHAM bit of @ref _Sn_MR2_.\n
S *          The masked bit values are as following.
S *            - @ref Sn_MR2_DHAM_AUTO
S *            - @ref Sn_MR2_DHAM_MANUAL
S * @sa _Sn_MR2_
S * @sa getSn_MR2(), setSn_MR2()
S */
S#define Sn_MR2_DHAM          (1<<1)
S
S/**
S * @brief Destination Hardware Address Mode - AUTO
S * @details @ref Sn_MR2_DHAM_AUTO sets the destination hardware address as the address acquired by ARP-process.
S * @sa _Sn_MR2_, Sn_MR_DHAM_MANUAL, NETMR_DHAS
S * @sa getSn_MR2(), setSn_MR2(), getNETMR(), setNETMR()
S */
S#define Sn_MR2_DHAM_AUTO     (0<<1)
S
S/**
S * @brief Destination Hardware Address Mode - MANUAL
S * @details @ref Sn_MR2_DHAM_MANUAL sets the destination hardware address as @ref _Sn_DHAR_.
S * @sa _Sn_MR2_, Sn_MR_DHAM_MANUAL, NETMR_DHAS
S * @sa getSn_MR2(), setSn_MR2(), getNETMR(), setNETMR()
S */
S#define Sn_MR2_DHAM_MANUAL   (1<<1)
S
S/**
S * @brief Force ARP
S * @details @ref Sn_MR2_FARP force to perform the ARP-process for acquiring the destination hardware address, before data communication\n
S *          0 : Normal \n
S *          1 : Force ARP
S *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
S *     If SOCKETn is operated as <b>TCP SERVER</b>, It sets the destination hardware address as the address 
S *     acquired by the forced ARP-process before sending SYN/ACK packet.
S *   - In UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD 
S *     It sets the destination hardware address as the address acquired by the forced ARP-process whenever @ref Sn_CR_SEND or @ref Sn_CR_SEND6.
S * @note When @ref Sn_MR2_DHAM_MANUAL and @ref Sn_MR2_FARP = '1', It sets the destination hardware address as @ref _Sn_DHAR_ even if the ARP-process is forced.
S */
S#define Sn_MR2_FARP          (1<<0)
S
S
S/*----------------------------For PHY Control-------------------------------*/
S
S/**
S * @ingroup Common_register_group_W6100
S * @brief Basic Mode Control Register of Ethernet PHY [RW][0x3100]
S * @details @ref PHYRAR_BMCR can be controlled by MDC/MDIO controller of @ref _WIZCHIP_. \n
S *          Each bit of @ref PHYRAR_BMCR is defined as the following.
S * <table>
S *    <tr> <td>15</td>  <td>14</td> <td>13</td>  <td>12 </td>  <td>11</td>  <td>10  </td> <td>9  </td> <td>8  </td> <td>7   </td>  <td>6 ~ 0  </td> </tr>
S *    <tr> <td>RST</td> <td>LB</td> <td>SPD</td> <td>ANE</td> <td>PWDN</td> <td>ISOL</td> <td>RAN</td> <td>DPX</td> <td>COLT</td> <td>Reserved</td> </tr>
S * </table>
S *   - @ref BMCR_RST
S *   - @ref BMCR_LB
S *   - @ref BMCR_SPD
S *   - @ref BMCR_ANE
S *   - @ref BMCR_PWDN
S *   - @ref BMCR_ISOL : Not supported.
S *   - @ref BMCR_REAN
S *   - @ref BMCR_DPX
S *   - @ref BMCR_COLT
S *
S * @note Its some bits have the same function as @ref _PHYCR0_ and @ref _PHYCR1_.\n
S *       It can control the Ethernet PHY with software, while @ref _PHYCR0_ \n
S *       and @ref _PHYCR1_ can control the Ethernet PHY with hardware.
S *       
S * @sa PHYRAR_BMSR, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYCR0_, _PHYCR1_
S * @sa getPHYRAR(), setPHYRAR(), wiz_mdio_read(), wiz_mdio_write()
S */
S#define PHYRAR_BMCR          (0x00)
S
S//Basic mode status register, basic register
S/**
S * @ingroup Common_register_group_W6100
S * @brief Basic Mode Status Register of Ethernet PHY [RO][0x7809]
S * @details @ref PHYRAR_BMSR gets the status of Ethernet PHY through MDC/MDIO controller of @ref _WIZCHIP_. \n
S *          Each bit of @ref PHYRAR_BMSR is defined as the following.
S * <table>
S *    <tr> <td>15</td> <td>14</td> <td>13</td> <td>12</td> <td>11</td> <td>10~7</td> 
S *         <td>6 </td> <td>5 </td> <td>4 </td> <td>3 </td> <td>2 </td> <td>1   </td> <td>0</td> </tr>
S *    <tr> <td>100_T4  </td> <td>100_FDX     </td> <td>100_HDX    </td> <td>10_FDX     </td> <td>10_HDX       </td> <td>Reserved</td> <td>MF_SUP</td> 
S *         <td>ANG_COMP</td> <td>REMOTE_FAULT</td> <td>ANG_ABILITY</td> <td>LINK_STATUS</td> <td>JABBER_DETECT</td> <td>EXT_CAPA</td> </tr>
S * </table>
S *   - @ref BMSR_100_T4        : Not supported. Always 0
S *   - @ref BMSR_100_FDX
S *   - @ref BMSR_100_HDX
S *   - @ref BMSR_10_FDX
S *   - @ref BMSR_10_HDX
S *   - @ref BMSR_MF_SUP        : Not supported. Always 0.
S *   - @ref BMSR_AN_COMP
S *   - @ref BMSR_REMOTE_FAULT  : Not supported. Always 0.
S *   - @ref BMSR_AN_ABILITY
S *   - @ref BMSR_LINK_STATUS
S *   - @ref BMSR_JABBER_DETECT
S *   - @ref BMSR_EXT_CAPA      : Always 1. If you need a extended register information, send e-mail to support@wiznet.io
S *
S * @note Its some bits have the same function as @ref _PHYSR_.
S * @sa PHYRAR_BMCR, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYCR0_, _PHYCR1_
S * @sa getPHYRAR(), setPHYRAR(), wiz_mdio_read(), wiz_mdio_write()
S */
S#define PHYRAR_BMSR          (0x01)
S
S
S/********************/
S/* BMCR & BMSR Bit definitions  */
S/********************/
S
S/*For BMCR register*/
S/**
S * @brief Ethernet PHY S/W Reset.
S * @details 0 - Normal operation \n
S *          1 - Software reset
S * @sa PHYRAR_BMCR, PHYCR1_RST
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define BMCR_RST             (1<<15)
S
S/**
S * @brief Ethernet PHY Loopback.
S * @details 0 - Normal Operation \n
S *          1 - Loopback Enable
S * @sa PHYRAR_BMCR
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define BMCR_LB              (1<<14)  ///< Loopback. 0 - Noraml operation, 1 - Loopback enabled
S
S/**
S * @brief Ethernet PHY Speed 
S * @details 0 - 10  Mbps \n
S *          1 - 100 Mbps
S * @sa PHYCR_BMCR, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
S */
S#define BMCR_SPD             (1<<13)
S
S/**
S * @brief Ethernet PHY Auto-Negotiation
S * @details 0 - Disable \n
S *          1 - Enable
S * @note When it is set, @ref BMCR_SPD and @ref BMCR_DPX is ignored
S * @sa PHYCR_BMCR, PHYCR0_AUTO
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
S */
S#define BMCR_ANE             (1<<12)
S
S/**
S * @brief Ethernet PHY Power Down Mode
S * @details 0 - Normal Operation \n
S *          1 - Power Down mode
S * @sa PHYCR_BMCR, PHYCR0_PWDN
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
S */
S#define BMCR_PWDN            (1<<11)  ///< Power-down mode
S
S/**
S * @brief Ethernet PHY Isolation Mode
S * @details 0 - Normal Operation \n
S *          1 - Isolation Mode
S * @ Don't set it to '1'. It is not supported.
S * @sa PHYCR_BMCR
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define BMCR_ISOL            (1<<10)
S
S/**
S * @brief Ethernet PHY Restart Auto-Negotiation
S * @details 0 - Normal Operation \n
S *          1 - Restart Auto-Negotiation
S * @sa PHYCR_BMCR
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define BMCR_REAN            (1<<9)
S
S/**
S * @brief Ethernet PHY Duplex 
S * @details 0 - Half-Duplex \n
S *          1 - Full-Duplex
S * @sa PHYCR_BMCR, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
S */
S#define BMCR_DPX             (1<<8)
S
S/**
S * @brief Ethernet PHY Collision Test
S * @details 0 - Normal Operation \n
S *          1 - Collision Test
S * @sa PHYCR_BMCR
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define BMCR_COLT            (1<<7)
S
S/*For BMSR register*/
S
S/**
S * @brief Ethernet PHY 100 Base-T4 capable
S * @details @ref BMSR_100_T4 is always 0.
S * @note It is not supported. 
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_100_T4          (1<<15)
S
S/**
S * @brief Ethernet PHY 100 Base-TX Full-Duplex capable
S * @details @ref BMSR_100_FDX is always 1.
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_100_FDX         (1<<14)
S
S/**
S * @brief Ethernet PHY 100 Base-TX Half-Duplex capable
S * @details @ref BMSR_100_HDX is always 1.
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_100_HDX         (1<<13)
S
S/**
S * @brief Ethernet PHY 10 Base-T Full-Duplex capable
S * @details @ref BMSR_10_FDX is always 1.
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_10_FDX          (1<<12)
S
S/**
S * @brief Ethernet PHY 10 Base-T Half-Duplex capable
S * @details @ref BMSR_10_HDX is always 1.
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_10_HDX          (1<<11)
S
S/**
S * @brief Ethernet PHY Management Frame preamble suppression
S * @details @ref BMSR_MF_SUP is always 0.
S * @note It is not supported 
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_MF_SUP          (1<<6)
S
S/**
S * @brief Ethernet PHY Auto-Negotiation Complete
S * @details @ref BMSR_MF_SUP indicates the status of auto-negotiation. \n
S *          0 - Auto-negotiation process is not completed \n
S *          1 - Auto-negotiation process is completed
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_AN_COMP         (1<<5)
S
S/**
S * @brief Ethernet PHY Remote Fault
S * @details @ref BMSR_REMOTE_FAULT is always 0.
S * @note It is not supported 
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_REMOTE_FAULT    (1<<4)
S
S/**
S * @brief Ethernet PHY Auto-Negotiation Ability
S * @details @ref BMSR_AN_ABILITY is always 1.
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_AN_ABILITY      (1<<3)
S
S/**
S * @brief Ethernet PHY Link Status
S * @details @ref BMSR_LINK_STATUS indicates the status of link. \n
S *          0 - Link is not established
S *          1 - Valid link is established
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_LINK_STATUS     (1<<2)
S
S/**
S * @brief Ethernet PHY Jabber Detect
S * @details @ref BMSR_JABBER_DETECT indicates the status of auto-negotiation. \n
S *          0 - Jabber condition is not detected\n
S *          1 - Jabber condition is detected
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_JABBER_DETECT   (1<<1)
S
S/**
S * @brief Ethernet PHY Extended capability
S * @details @ref BMSR_EXT_CAPA indicates the extended register capability. \n
S *          0 - Only basic registers are capable\n
S *          1 - Extended registers are capable
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_EXT_CAPA        (1<<0)
S
S
S/**
S * @brief Enter a critical section
S * @details It is provided to protect your shared code and hardware resources against interference. \n
S *   - Non-OS environment
S *     It can be just implemented by disabling whole interrupt.
S *   - OS environment
S *     You can replace it to critical section API supported by OS.
S *
S * @note It is callback function that can be replaced it with your code, by calling @ref reg_wizchip_cris_cbfunc(). 
S * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
S * @sa WIZCHIP_CRITICAL_EXIT(), reg_wizchip_cris_cbfunc()
S */
S#define WIZCHIP_CRITICAL_ENTER()       WIZCHIP.CRIS._e_n_t_e_r_()
S
S
S/**
S * @brief Enter a critical section
S * @details It exits the protected code and hardware resources against interference. \n
S *   - Non-OS environment
S *     It can be just implemented by enabling whole interrupt.\n
S *   - OS environment
S *     You can replace it to critical section API supported by OS.
S *
S * @note It is callback function that can be replaced it with your code, by calling @ref reg_wizchip_cris_cbfunc(). 
S * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
S * @sa WIZCHIP_CRITICAL_EXIT(), reg_wizchip_cris_cbfunc()
S */
S#define WIZCHIP_CRITICAL_EXIT()        WIZCHIP.CRIS._e_x_i_t_()
S
S
S
S////////////////////////
S// Basic I/O Function //
S////////////////////////
S//
S//
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It reads 1 byte value from a register.
S * @param AddrSel Register address
S * @return The value of register
S * @sa WIZCHIP_READ_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_WRITE()
S */
Suint8_t WIZCHIP_READ(uint32_t AddrSel);
S
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It writes 1 byte value to a register.
S * @param AddrSel Register address
S * @param wb Write data
S * @return void
S * @sa WIZCHIP_WRITE_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_READ()
S */
Svoid WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb );
S
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It reads sequentail data from registers.
S * @param AddrSel Register address
S * @param pBuf Pointer buffer to read data
S * @param len Data length
S * @return void
S * @sa WIZCHIP_WRITE_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_READ()
S */
Svoid WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, datasize_t len);
S
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It writes sequential data to registers.
S * @param AddrSel Register address
S * @param pBuf Pointer buffer to write data
S * @param len Data length
S * @return void
S * @sa WIZCHIP_READ_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_WRITE()
S */
Svoid WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, datasize_t len);
S
S
S
S/////////////////////////////////
S// Common Register IO function //
S/////////////////////////////////
S/**
S * @addtogroup Common_register_access_function_W6100
S * @{
S */
S#define getCIDR() \
S        ((((uint16_t)WIZCHIP_READ(_CIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_CIDR_,1)))
X#define getCIDR()         ((((uint16_t)WIZCHIP_READ(_CIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_CIDR_,1)))
S
S#define getVER() \
S        ((((uint16_t)WIZCHIP_READ(_VER_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VER_,1)))
X#define getVER()         ((((uint16_t)WIZCHIP_READ(_VER_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VER_,1)))
S
S#define getSYSR() \
S        WIZCHIP_READ(_SYSR_)
X#define getSYSR()         WIZCHIP_READ(_SYSR_)
S
S#define getSYCR0() \
S        WIZCHIP_READ(_SYCR0_)
X#define getSYCR0()         WIZCHIP_READ(_SYCR0_)
S
S#define setSYCR0(sycr0) \
S        WIZCHIP_WRITE(_SYCR0_, (sycr0))
X#define setSYCR0(sycr0)         WIZCHIP_WRITE(_SYCR0_, (sycr0))
S
S#define getSYCR1() \
S        WIZCHIP_READ(_SYCR1_)
X#define getSYCR1()         WIZCHIP_READ(_SYCR1_)
S                  
S#define setSYCR1(sycr1) \
S        WIZCHIP_WRITE(_SYCR1_, (sycr1))
X#define setSYCR1(sycr1)         WIZCHIP_WRITE(_SYCR1_, (sycr1))
S
S#define getTCNTR() \
S        ((((uint16_t)WIZCHIP_READ(_TCNTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_TCNTR_,1)))
X#define getTCNTR()         ((((uint16_t)WIZCHIP_READ(_TCNTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_TCNTR_,1)))
S
S#define setTCNTRCLR(tcntrclr) \
S        WIZCHIP_WRITE(_TCNTRCLR_,(tcntrclr))
X#define setTCNTRCLR(tcntrclr)         WIZCHIP_WRITE(_TCNTRCLR_,(tcntrclr))
S
S#define getIR() \
S        WIZCHIP_READ(_IR_)
X#define getIR()         WIZCHIP_READ(_IR_)
S
S#define getSIR() \
S        WIZCHIP_READ(_SIR_)
X#define getSIR()         WIZCHIP_READ(_SIR_)
S
S#define getSLIR() \
S        WIZCHIP_READ(_SLIR_)
X#define getSLIR()         WIZCHIP_READ(_SLIR_)
S
S#define setIMR(imr) \
S        WIZCHIP_WRITE(_IMR_,(imr))
X#define setIMR(imr)         WIZCHIP_WRITE(_IMR_,(imr))
S
S#define getIMR() \
S        WIZCHIP_READ(_IMR_)
X#define getIMR()         WIZCHIP_READ(_IMR_)
S
S#define setIRCLR(irclr) \
S        WIZCHIP_WRITE(_IRCLR_,(irclr))
X#define setIRCLR(irclr)         WIZCHIP_WRITE(_IRCLR_,(irclr))
S#define setIR(ir)                setIRCLR(ir)
S
S#define setSIMR(simr) \
S        WIZCHIP_WRITE(_SIMR_,(simr))
X#define setSIMR(simr)         WIZCHIP_WRITE(_SIMR_,(simr))
S
S#define getSIMR() \
S        WIZCHIP_READ(_SIMR_)
X#define getSIMR()         WIZCHIP_READ(_SIMR_)
S
S#define setSLIMR(slimr) \
S        WIZCHIP_WRITE(_SLIMR_,(slimr))
X#define setSLIMR(slimr)         WIZCHIP_WRITE(_SLIMR_,(slimr))
S
S#define getSLIMR() \
S        WIZCHIP_READ(_SLIMR_)
X#define getSLIMR()         WIZCHIP_READ(_SLIMR_)
S
S#define setSLIRCLR(slirclr) \
S        WIZCHIP_WRITE(_SLIRCLR_,(slirclr))
X#define setSLIRCLR(slirclr)         WIZCHIP_WRITE(_SLIRCLR_,(slirclr))
S#define setSLIR(slir)            setSLIRCLR(slir)
S
S#define setSLPSR(slpsr) \
S        WIZCHIP_WRITE(_SLPSR_,(slpsr))
X#define setSLPSR(slpsr)         WIZCHIP_WRITE(_SLPSR_,(slpsr))
S
S#define getSLPSR() \
S        WIZCHIP_READ(_SLPSR_)
X#define getSLPSR()         WIZCHIP_READ(_SLPSR_)
S
S#define setSLCR(slcr) \
S        WIZCHIP_WRITE(_SLCR_,(slcr))
X#define setSLCR(slcr)         WIZCHIP_WRITE(_SLCR_,(slcr))
S                  
S#define getSLCR()      \
S        WIZCHIP_READ(_SLCR_)
X#define getSLCR()              WIZCHIP_READ(_SLCR_)
S
S#define getPHYSR() \
S        WIZCHIP_READ(_PHYSR_)
X#define getPHYSR()         WIZCHIP_READ(_PHYSR_)
S
S#define setPHYRAR(phyrar) \
S        WIZCHIP_WRITE(_PHYRAR_,(phyrar))
X#define setPHYRAR(phyrar)         WIZCHIP_WRITE(_PHYRAR_,(phyrar))
S
S#define getPHYRAR() \
S        WIZCHIP_READ(_PHYRAR_)
X#define getPHYRAR()         WIZCHIP_READ(_PHYRAR_)
S
S#define setPHYDIR(phydir)  \
S        do{                                                                       \
S           WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PHYDIR_,1), (uint8_t)((phydir)>>8)); \
S           WIZCHIP_WRITE(_PHYDIR_, (uint8_t)(phydir));                            \
S        }while(0);
X#define setPHYDIR(phydir)          do{                                                                                  WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PHYDIR_,1), (uint8_t)((phydir)>>8));            WIZCHIP_WRITE(_PHYDIR_, (uint8_t)(phydir));                                    }while(0);
S
S#define getPHYDOR() \
S        ((((uint16_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PHYDOR_,1))) << 8) + WIZCHIP_READ(_PHYDOR_))
X#define getPHYDOR()         ((((uint16_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PHYDOR_,1))) << 8) + WIZCHIP_READ(_PHYDOR_))
S
S#define setPHYACR(phyacr) \
S        WIZCHIP_WRITE(_PHYACR_,(phyacr))
X#define setPHYACR(phyacr)         WIZCHIP_WRITE(_PHYACR_,(phyacr))
S
S#define getPHYACR() \
S        WIZCHIP_READ(_PHYACR_)
X#define getPHYACR()         WIZCHIP_READ(_PHYACR_)
S
S#define setPHYDIVR(phydivr) \
S        WIZCHIP_WRITE(_PHYDIVR_,(phydivr))
X#define setPHYDIVR(phydivr)         WIZCHIP_WRITE(_PHYDIVR_,(phydivr))
S
S#define getPHYDIVR() \
S        WIZCHIP_READ(_PHYDIVR_)
X#define getPHYDIVR()         WIZCHIP_READ(_PHYDIVR_)
S
S#define setPHYCR0(phycr0) \
S        WIZCHIP_WRITE(_PHYCR0_,(phycr0))
X#define setPHYCR0(phycr0)         WIZCHIP_WRITE(_PHYCR0_,(phycr0))
S
S#define setPHYCR1(phycr1) \
S        WIZCHIP_WRITE(_PHYCR1_,(phycr1))
X#define setPHYCR1(phycr1)         WIZCHIP_WRITE(_PHYCR1_,(phycr1))
S
S#define getPHYCR1() \
S        WIZCHIP_READ(_PHYCR1_)
X#define getPHYCR1()         WIZCHIP_READ(_PHYCR1_)
S
S#define setNET4MR(net4mr) \
S        WIZCHIP_WRITE(_NET4MR_,(net4mr))
X#define setNET4MR(net4mr)         WIZCHIP_WRITE(_NET4MR_,(net4mr))
S
S#define setNET6MR(net6mr) \
S        WIZCHIP_WRITE(_NET6MR_,(net6mr))
X#define setNET6MR(net6mr)         WIZCHIP_WRITE(_NET6MR_,(net6mr))
S
S#define setNETMR(netmr) \
S        WIZCHIP_WRITE(_NETMR_,(netmr))
X#define setNETMR(netmr)         WIZCHIP_WRITE(_NETMR_,(netmr))
S
S#define setNETMR2(netmr2) \
S        WIZCHIP_WRITE(_NETMR2_,(netmr2))
X#define setNETMR2(netmr2)         WIZCHIP_WRITE(_NETMR2_,(netmr2))
S
S#define getNET4MR() \
S        WIZCHIP_READ(_NET4MR_)
X#define getNET4MR()         WIZCHIP_READ(_NET4MR_)
S
S#define getNET6MR() \
S        WIZCHIP_READ(_NET6MR_)
X#define getNET6MR()         WIZCHIP_READ(_NET6MR_)
S
S#define getNETMR() \
S        WIZCHIP_READ(_NETMR_)
X#define getNETMR()         WIZCHIP_READ(_NETMR_)
S
S#define getNETMR2() \
S        WIZCHIP_READ(_NETMR2_)
X#define getNETMR2()         WIZCHIP_READ(_NETMR2_)
S
S#define setPTMR(ptmr) \
S        WIZCHIP_WRITE(_PTMR_, (ptmr))
X#define setPTMR(ptmr)         WIZCHIP_WRITE(_PTMR_, (ptmr))
S
S#define getPTMR() \
S        WIZCHIP_READ(_PTMR_)
X#define getPTMR()         WIZCHIP_READ(_PTMR_)
S
S#define setPMNR(pmnr) \
S        WIZCHIP_WRITE(_PMNR_, (pmnr))
X#define setPMNR(pmnr)         WIZCHIP_WRITE(_PMNR_, (pmnr))
S
S#define getPMNR() \
S        WIZCHIP_READ(_PMNR_)
X#define getPMNR()         WIZCHIP_READ(_PMNR_)
S
S#define setPHAR(phar) \
S        WIZCHIP_WRITE_BUF(_PHAR_,(phar),6)
X#define setPHAR(phar)         WIZCHIP_WRITE_BUF(_PHAR_,(phar),6)
S
S#define getPHAR(phar) \
S        WIZCHIP_READ_BUF(_PHAR_,(phar),6)
X#define getPHAR(phar)         WIZCHIP_READ_BUF(_PHAR_,(phar),6)
S
S#define setPSIDR(psidr) \
S        do{                                                                \
S            WIZCHIP_WRITE(_PSIDR_,(uint8_t)((psidr) >> 8));                \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PSIDR_,1),(uint8_t)(psidr)); \
S        }while(0);
X#define setPSIDR(psidr)         do{                                                                            WIZCHIP_WRITE(_PSIDR_,(uint8_t)((psidr) >> 8));                            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PSIDR_,1),(uint8_t)(psidr));         }while(0);
S
S#define getPSIDR() \
S        ((((uint16_t)WIZCHIP_READ(_PSIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PSIDR_,1)))
X#define getPSIDR()         ((((uint16_t)WIZCHIP_READ(_PSIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PSIDR_,1)))
S
S#define setPMRUR(pmrur) \
S        do{                                                                \
S            WIZCHIP_WRITE(_PMRUR_,(uint8_t)((pmrur) >> 8));                \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PMRUR_,1),(uint8_t)(pmrur)); \
S        }while(0);
X#define setPMRUR(pmrur)         do{                                                                            WIZCHIP_WRITE(_PMRUR_,(uint8_t)((pmrur) >> 8));                            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PMRUR_,1),(uint8_t)(pmrur));         }while(0);
S
S#define getPMRUR() \
S        ((((uint16_t)WIZCHIP_READ(_PMRUR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PMRUR_,1)))
X#define getPMRUR()         ((((uint16_t)WIZCHIP_READ(_PMRUR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PMRUR_,1)))
S
S#define setSHAR(shar) \
S        WIZCHIP_WRITE_BUF(_SHAR_,(shar),6)
X#define setSHAR(shar)         WIZCHIP_WRITE_BUF(_SHAR_,(shar),6)
S
S#define getSHAR(shar) \
S        WIZCHIP_READ_BUF(_SHAR_,(shar),6)
X#define getSHAR(shar)         WIZCHIP_READ_BUF(_SHAR_,(shar),6)
S
S#define setGAR(gar) \
S        WIZCHIP_WRITE_BUF(_GAR_,(gar),4)
X#define setGAR(gar)         WIZCHIP_WRITE_BUF(_GAR_,(gar),4)
S
S#define getGAR(gar) \
S        WIZCHIP_READ_BUF(_GAR_,(gar),4)
X#define getGAR(gar)         WIZCHIP_READ_BUF(_GAR_,(gar),4)
S
S#define setGA4R(ga4r)            setGAR(ga4r)
S#define getGA4R(ga4r)            getGAR(ga4r)
S
S#define setSUBR(subr) \
S        WIZCHIP_WRITE_BUF(_SUBR_,(subr),4)
X#define setSUBR(subr)         WIZCHIP_WRITE_BUF(_SUBR_,(subr),4)
S
S#define getSUBR(subr) \
S        WIZCHIP_READ_BUF(_SUBR_,(subr),4)
X#define getSUBR(subr)         WIZCHIP_READ_BUF(_SUBR_,(subr),4)
S
S#define setSUB4R(sub4r)          setSUBR(sub4r)
S#define getSUB4R(sub4r)          getSUBR(sub4r)
S
S#define setSIPR(sipr) \
S        WIZCHIP_WRITE_BUF(_SIPR_,(sipr),4)
X#define setSIPR(sipr)         WIZCHIP_WRITE_BUF(_SIPR_,(sipr),4)
S
S#define getSIPR(sipr) \
S        WIZCHIP_READ_BUF(_SIPR_,(sipr),4)
X#define getSIPR(sipr)         WIZCHIP_READ_BUF(_SIPR_,(sipr),4)
S
S#define setLLAR(llar) \
S        WIZCHIP_WRITE_BUF(_LLAR_,(llar),16)
X#define setLLAR(llar)         WIZCHIP_WRITE_BUF(_LLAR_,(llar),16)
S
S#define getLLAR(llar) \
S        WIZCHIP_READ_BUF(_LLAR_,(llar),16)
X#define getLLAR(llar)         WIZCHIP_READ_BUF(_LLAR_,(llar),16)
S
S#define setGUAR(guar) \
S        WIZCHIP_WRITE_BUF(_GUAR_,(guar),16)
X#define setGUAR(guar)         WIZCHIP_WRITE_BUF(_GUAR_,(guar),16)
S
S#define getGUAR(guar) \
S        WIZCHIP_READ_BUF(_GUAR_,(guar),16)
X#define getGUAR(guar)         WIZCHIP_READ_BUF(_GUAR_,(guar),16)
S
S#define setSUB6R(sub6r) \
S        WIZCHIP_WRITE_BUF(_SUB6R_,(sub6r),16)
X#define setSUB6R(sub6r)         WIZCHIP_WRITE_BUF(_SUB6R_,(sub6r),16)
S
S#define getSUB6R(sub6r) \
S        WIZCHIP_READ_BUF(_SUB6R_,(sub6r),16)
X#define getSUB6R(sub6r)         WIZCHIP_READ_BUF(_SUB6R_,(sub6r),16)
S
S#define setGA6R(ga6r) \
S        WIZCHIP_WRITE_BUF(_GA6R_,(ga6r),16)
X#define setGA6R(ga6r)         WIZCHIP_WRITE_BUF(_GA6R_,(ga6r),16)
S
S#define getGA6R(ga6r) \
S        WIZCHIP_READ_BUF(_GA6R_,(ga6r),16)
X#define getGA6R(ga6r)         WIZCHIP_READ_BUF(_GA6R_,(ga6r),16)
S
S#define setSLDIPR(sldipr) \
S        WIZCHIP_WRITE_BUF(_SLDIPR_,(sldipr),4)
X#define setSLDIPR(sldipr)         WIZCHIP_WRITE_BUF(_SLDIPR_,(sldipr),4)
S#define setSLDIP4R(sldip4r)      setSLDIPR((sldip4r))
S
S#define getSLDIPR(sldipr) \
S        WIZCHIP_READ_BUF(_SLDIPR_,(sldipr),4)
X#define getSLDIPR(sldipr)         WIZCHIP_READ_BUF(_SLDIPR_,(sldipr),4)
S#define getSLDIP4R(sldip4r)      getSLDIPR((sldip4r))
S
S#define setSLDIP6R(sldip6r) \
S        WIZCHIP_WRITE_BUF(_SLDIP6R_, (sldip6r),16)
X#define setSLDIP6R(sldip6r)         WIZCHIP_WRITE_BUF(_SLDIP6R_, (sldip6r),16)
S
S#define getSLDIP6R(sldip6r) \
S        WIZCHIP_READ_BUF(_SLDIP6R_,(sldip6r),16)
X#define getSLDIP6R(sldip6r)         WIZCHIP_READ_BUF(_SLDIP6R_,(sldip6r),16)
S
S#define getSLDHAR(sldhar) \
S        WIZCHIP_READ_BUF(_SLDHAR_,(sldhar),6)
X#define getSLDHAR(sldhar)         WIZCHIP_READ_BUF(_SLDHAR_,(sldhar),6)
S
S#define setPINGIDR(pingidr) \
S        do{                                                                    \
S            WIZCHIP_WRITE(_PINGIDR_,(uint8_t)((pingidr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGIDR_,1),(uint8_t)(pingidr)); \
S        }while(0);
X#define setPINGIDR(pingidr)         do{                                                                                WIZCHIP_WRITE(_PINGIDR_,(uint8_t)((pingidr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGIDR_,1),(uint8_t)(pingidr));         }while(0);
S
S#define getPINGIDR() \
S        (((int16_t)(WIZCHIP_READ(_PINGIDR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGIDR_,1)))
X#define getPINGIDR()         (((int16_t)(WIZCHIP_READ(_PINGIDR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGIDR_,1)))
S
S#define setPINGSEQR(pingseqr) \
S        do{                                                                      \
S            WIZCHIP_WRITE(_PINGSEQR_,(uint8_t)((pingseqr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGSEQR_,1),(uint8_t)(pingseqr)); \
S        }while(0);
X#define setPINGSEQR(pingseqr)         do{                                                                                  WIZCHIP_WRITE(_PINGSEQR_,(uint8_t)((pingseqr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGSEQR_,1),(uint8_t)(pingseqr));         }while(0);
S
S#define getPINGSEQR() \
S        (((int16_t)(WIZCHIP_READ(_PINGSEQR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGSEQR_,1)))
X#define getPINGSEQR()         (((int16_t)(WIZCHIP_READ(_PINGSEQR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGSEQR_,1)))
S
S#define getUIPR(uipr) \
S        WIZCHIP_READ_BUF(_UIPR_, (uipr), 4)
X#define getUIPR(uipr)         WIZCHIP_READ_BUF(_UIPR_, (uipr), 4)
S
S#define getUIP4R(uip4r)          getUIPR(uip4r)
S
S#define getUPORTR() \
S        ((((uint16_t)WIZCHIP_READ(_UPORTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORTR_,1)))
X#define getUPORTR()         ((((uint16_t)WIZCHIP_READ(_UPORTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORTR_,1)))
S
S#define getUPORT4R()             getUPORTR()
S
S#define getUIP6R(uip6r) \
S        WIZCHIP_READ_BUF(_UIP6R_,(uip6r),16)
X#define getUIP6R(uip6r)         WIZCHIP_READ_BUF(_UIP6R_,(uip6r),16)
S
S#define getUPORT6R(uport6r) \
S        ((((uint16_t)WIZCHIP_READ(_UPORT6R_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORT6R_,1)))
X#define getUPORT6R(uport6r)         ((((uint16_t)WIZCHIP_READ(_UPORT6R_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORT6R_,1)))
S
S#define setINTPTMR(intptmr) \
S        do{                                                                     \
S            WIZCHIP_WRITE(_INTPTMR_,(uint8_t)((intptmr) >> 8));                 \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_INTPTMR_,1),(uint8_t)(intptmr));  \
S       }while(0);
X#define setINTPTMR(intptmr)         do{                                                                                 WIZCHIP_WRITE(_INTPTMR_,(uint8_t)((intptmr) >> 8));                             WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_INTPTMR_,1),(uint8_t)(intptmr));         }while(0);
S
S#define getINTPTMR() \
S        ((((uint16_t)WIZCHIP_READ(_INTPTMR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_INTPTMR_,1)))
X#define getINTPTMR()         ((((uint16_t)WIZCHIP_READ(_INTPTMR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_INTPTMR_,1)))
S
S#define getPLR() \
S        WIZCHIP_READ(_PLR_)
X#define getPLR()         WIZCHIP_READ(_PLR_)
S
S#define getPFR() \
S        WIZCHIP_READ(_PFR_)
X#define getPFR()         WIZCHIP_READ(_PFR_)
S
S#define getVLTR() \
S        ( (((uint32_t)WIZCHIP_READ(_VLTR_)) << 24) +                       \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,1))) << 16) + \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,2))) << 16) + \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,3))) << 16) )
X#define getVLTR()         ( (((uint32_t)WIZCHIP_READ(_VLTR_)) << 24) +                                 (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,1))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,2))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,3))) << 16) )
S
S#define getPLTR() \
S        ( (((uint32_t)WIZCHIP_READ(_PLTR_)) << 24) +                       \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,1))) << 16) + \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,2))) << 16) + \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,3))) << 16) )
X#define getPLTR()         ( (((uint32_t)WIZCHIP_READ(_PLTR_)) << 24) +                                 (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,1))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,2))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,3))) << 16) )
S
S#define getPAR(par) \
S        WIZCHIP_READ_BUF(_PAR_, (par), 16)
X#define getPAR(par)         WIZCHIP_READ_BUF(_PAR_, (par), 16)
S
S#define setICMP6BLKR(icmp6blkr) \
S        WIZCHIP_WRITE(_ICMP6BLKR_,(icmp6blkr))
X#define setICMP6BLKR(icmp6blkr)         WIZCHIP_WRITE(_ICMP6BLKR_,(icmp6blkr))
S
S#define getICMP6BLKR() \
S        WIZCHIP_READ(_ICMP6BLKR_)
X#define getICMP6BLKR()         WIZCHIP_READ(_ICMP6BLKR_)
S
S#define setCHPLCKR(chplckr) \
S        WIZCHIP_WRITE(_CHPLCKR_, (chplckr))
X#define setCHPLCKR(chplckr)         WIZCHIP_WRITE(_CHPLCKR_, (chplckr))
S
S#define getCHPLCKR() \
S        ((getSYSR() & SYSR_CHPL) >> 7)
X#define getCHPLCKR()         ((getSYSR() & SYSR_CHPL) >> 7)
S
S#define CHIPLOCK()      setCHPLCKR(0xFF)
S#define CHIPUNLOCK()    setCHPLCKR(0xCE)
S
S#define setNETLCKR(netlckr) \
S        WIZCHIP_WRITE(_NETLCKR_, (netlckr))
X#define setNETLCKR(netlckr)         WIZCHIP_WRITE(_NETLCKR_, (netlckr))
S
S#define getNETLCKR() \
S        ((getSYSR() & SYSR_NETL) >> 6)
X#define getNETLCKR()         ((getSYSR() & SYSR_NETL) >> 6)
S
S#define NETLOCK()      setNETLCKR(0xC5)
S#define NETUNLOCK()    setNETLCKR(0x3A)
S
S#define setPHYLCKR(phylckr) \
S        WIZCHIP_WRITE(_PHYLCKR_,(phylckr))
X#define setPHYLCKR(phylckr)         WIZCHIP_WRITE(_PHYLCKR_,(phylckr))
S
S#define getPHYLCKR() \
S        ((getSYSR() & SYSR_PHYL) >> 5)
X#define getPHYLCKR()         ((getSYSR() & SYSR_PHYL) >> 5)
S
S#define PHYLOCK()      setPHYLCKR(0xFF)
S#define PHYUNLOCK()    setPHYLCKR(0x53)
S
S#define setRTR(rtr) \
S        do{                                                            \
S            WIZCHIP_WRITE(_RTR_,(uint8_t)((rtr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_RTR_,1),(uint8_t)(rtr)); \
S        }while(0);
X#define setRTR(rtr)         do{                                                                        WIZCHIP_WRITE(_RTR_,(uint8_t)((rtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_RTR_,1),(uint8_t)(rtr));         }while(0);
S
S#define getRTR() \
S        ((((uint16_t)WIZCHIP_READ(_RTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_RTR_,1)))
X#define getRTR()         ((((uint16_t)WIZCHIP_READ(_RTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_RTR_,1)))
S
S#define setRCR(rcr) \
S        WIZCHIP_WRITE(_RCR_,(rcr))
X#define setRCR(rcr)         WIZCHIP_WRITE(_RCR_,(rcr))
S
S#define getRCR() \
S        WIZCHIP_READ(_RCR_)
X#define getRCR()         WIZCHIP_READ(_RCR_)
S
S#define setSLRTR(slrtr) \
S        do{                                                                \
S            WIZCHIP_WRITE(_SLRTR_,(uint8_t)((slrtr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_SLRTR_,1),(uint8_t)(slrtr)); \
S        }while(0);
X#define setSLRTR(slrtr)         do{                                                                            WIZCHIP_WRITE(_SLRTR_,(uint8_t)((slrtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_SLRTR_,1),(uint8_t)(slrtr));         }while(0);
S
S#define getSLRTR() \
S        ((((uint16_t)WIZCHIP_READ(_SLRTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_SLRTR_,1)))
X#define getSLRTR()         ((((uint16_t)WIZCHIP_READ(_SLRTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_SLRTR_,1)))
S
S#define setSLRCR(slrcr) \
S        WIZCHIP_WRITE(_SLRCR_,(slrcr))
X#define setSLRCR(slrcr)         WIZCHIP_WRITE(_SLRCR_,(slrcr))
S
S#define getSLRCR() \
S        WIZCHIP_READ(_SLRCR_)
X#define getSLRCR()         WIZCHIP_READ(_SLRCR_)
S
S#define setSLHOPR(slhopr) \
S        WIZCHIP_WRITE(_SLHOPR_,(slhopr))
X#define setSLHOPR(slhopr)         WIZCHIP_WRITE(_SLHOPR_,(slhopr))
S
S#define getSLHOPR() \
S        WIZCHIP_READ(_SLHOPR_)
X#define getSLHOPR()         WIZCHIP_READ(_SLHOPR_)
S/**
S * @}
S */
S
S
S////////////////////////////////////
S// SOCKETn  register I/O function //
S////////////////////////////////////
S/**
S * @addtogroup Socket_register_access_function_W6100
S * @{
S */
S#define setSn_MR(sn,mr) \
S        WIZCHIP_WRITE(_Sn_MR_(sn),(mr))
X#define setSn_MR(sn,mr)         WIZCHIP_WRITE(_Sn_MR_(sn),(mr))
S#define getSn_MR(sn) \
S        WIZCHIP_READ(_Sn_MR_(sn))
X#define getSn_MR(sn)         WIZCHIP_READ(_Sn_MR_(sn))
S
S#define setSn_PSR(sn,psr) \
S        WIZCHIP_WRITE(_Sn_PSR_(sn),(psr))
X#define setSn_PSR(sn,psr)         WIZCHIP_WRITE(_Sn_PSR_(sn),(psr))
S#define getSn_PSR(sn) \
S        WIZCHIP_READ(_Sn_PSR_(sn))
X#define getSn_PSR(sn)         WIZCHIP_READ(_Sn_PSR_(sn))
S
S#define setSn_CR(sn,cr) \
S        WIZCHIP_WRITE(_Sn_CR_(sn),(cr))
X#define setSn_CR(sn,cr)         WIZCHIP_WRITE(_Sn_CR_(sn),(cr))
S#define getSn_CR(sn) \
S        WIZCHIP_READ(_Sn_CR_(sn))
X#define getSn_CR(sn)         WIZCHIP_READ(_Sn_CR_(sn))
S
S#define getSn_IR(sn) \
S        WIZCHIP_READ(_Sn_IR_(sn))
X#define getSn_IR(sn)         WIZCHIP_READ(_Sn_IR_(sn))
S
S#define setSn_IMR(sn,imr) \
S        WIZCHIP_WRITE(_Sn_IMR_(sn),(imr))
X#define setSn_IMR(sn,imr)         WIZCHIP_WRITE(_Sn_IMR_(sn),(imr))
S#define getSn_IMR(sn) \
S        WIZCHIP_READ(_Sn_IMR_(sn))
X#define getSn_IMR(sn)         WIZCHIP_READ(_Sn_IMR_(sn))
S
S#define setSn_IRCLR(sn,irclr) \
S        WIZCHIP_WRITE(_Sn_IRCLR_(sn),(irclr))
X#define setSn_IRCLR(sn,irclr)         WIZCHIP_WRITE(_Sn_IRCLR_(sn),(irclr))
S#define setSn_IR(sn,ir)          setSn_IRCLR(sn,(ir))
S
S#define getSn_SR(sn) \
S        WIZCHIP_READ(_Sn_SR_(sn))
X#define getSn_SR(sn)         WIZCHIP_READ(_Sn_SR_(sn))
S
S#define getSn_ESR(sn) \
S        WIZCHIP_READ(_Sn_ESR_(sn))
X#define getSn_ESR(sn)         WIZCHIP_READ(_Sn_ESR_(sn))
S
S#define setSn_PNR(sn,pnr) \
S        WIZCHIP_WRITE(_Sn_PNR_(sn),(pnr))
X#define setSn_PNR(sn,pnr)         WIZCHIP_WRITE(_Sn_PNR_(sn),(pnr))
S#define setSn_NHR(sn,nhr)        setSn_PNR(_Sn_PNR_(sn),(nhr))
S
S#define getSn_PNR(sn) \
S        WIZCHIP_READ(_Sn_PNR_(sn))
X#define getSn_PNR(sn)         WIZCHIP_READ(_Sn_PNR_(sn))
S#define getSn_NHR(sn)            getSn_PNR(sn)
S
S#define setSn_TOSR(sn,tosr) \
S        WIZCHIP_WRITE(_Sn_TOSR_(sn),(tosr))
X#define setSn_TOSR(sn,tosr)         WIZCHIP_WRITE(_Sn_TOSR_(sn),(tosr))
S#define getSn_TOSR(sn) \
S        WIZCHIP_READ(_Sn_TOSR_(sn))
X#define getSn_TOSR(sn)         WIZCHIP_READ(_Sn_TOSR_(sn))
S
S#define setSn_TTLR(sn,ttlr) \
S        WIZCHIP_WRITE(_Sn_TTLR_(sn),(ttlr))
X#define setSn_TTLR(sn,ttlr)         WIZCHIP_WRITE(_Sn_TTLR_(sn),(ttlr))
S#define getSn_TTLR(sn) \
S        WIZCHIP_READ(_Sn_TTLR_(sn))
X#define getSn_TTLR(sn)         WIZCHIP_READ(_Sn_TTLR_(sn))
S
S#define setSn_HOPR(sn,hopr)      setSn_TTLR(sn),(ttlr))
S#define getSn_HOPR(sn)           getSn_TTLR(sn)
S
S#define setSn_FRGR(sn,frgr) \
S        do{                                                                      \
S            WIZCHIP_WRITE(_Sn_FRGR_(sn),(uint8_t)((frgr)>>8));                   \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1),(uint8_t)(frgr));  \
S        }while(0);
X#define setSn_FRGR(sn,frgr)         do{                                                                                  WIZCHIP_WRITE(_Sn_FRGR_(sn),(uint8_t)((frgr)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1),(uint8_t)(frgr));          }while(0);
S#define getSn_FRGR(sn,frgr) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_FRGR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1)))
X#define getSn_FRGR(sn,frgr)         ((((uint16_t)WIZCHIP_READ(_Sn_FRGR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1)))
S
S#define setSn_MSSR(sn,mssr) \
S        do{                                                                      \
S            WIZCHIP_WRITE(_Sn_MSSR_(sn),(uint8_t)((mssr)>>8));                   \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1),(uint8_t)(mssr));  \
S        }while(0);
X#define setSn_MSSR(sn,mssr)         do{                                                                                  WIZCHIP_WRITE(_Sn_MSSR_(sn),(uint8_t)((mssr)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1),(uint8_t)(mssr));          }while(0);
S#define getSn_MSSR(sn) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_MSSR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1)))
X#define getSn_MSSR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_MSSR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1)))
S
S#define setSn_PORTR(sn,portr) \
S        do{                                                                       \
S            WIZCHIP_WRITE(_Sn_PORTR_(sn),(uint8_t)((portr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1),(uint8_t)(portr)); \
S        }while(0);
X#define setSn_PORTR(sn,portr)         do{                                                                                   WIZCHIP_WRITE(_Sn_PORTR_(sn),(uint8_t)((portr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1),(uint8_t)(portr));         }while(0);
S#define getSn_PORTR(sn) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_PORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1)))
X#define getSn_PORTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_PORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1)))
S
S#define setSn_DHAR(sn,dhar) \
S        WIZCHIP_WRITE_BUF(_Sn_DHAR_(sn),(dhar),6)
X#define setSn_DHAR(sn,dhar)         WIZCHIP_WRITE_BUF(_Sn_DHAR_(sn),(dhar),6)
S#define getSn_DHAR(sn,dhar) \
S        WIZCHIP_READ_BUF(_Sn_DHAR_(sn),(dhar),6)
X#define getSn_DHAR(sn,dhar)         WIZCHIP_READ_BUF(_Sn_DHAR_(sn),(dhar),6)
S
S#define setSn_DIPR(sn,dipr) \
S        WIZCHIP_WRITE_BUF(_Sn_DIPR_(sn),(dipr),4)
X#define setSn_DIPR(sn,dipr)         WIZCHIP_WRITE_BUF(_Sn_DIPR_(sn),(dipr),4)
S#define getSn_DIPR(sn,dipr) \
S        WIZCHIP_READ_BUF(_Sn_DIPR_(sn),(dipr),4)
X#define getSn_DIPR(sn,dipr)         WIZCHIP_READ_BUF(_Sn_DIPR_(sn),(dipr),4)
S
S#define setSn_DIP4R(sn,dipr)      setSn_DIPR(sn,(dipr))
S#define getSn_DIP4R(sn,dipr)      getSn_DIPR(sn,(dipr))
S
S#define setSn_DIP6R(sn,dip6r) \
S        WIZCHIP_WRITE_BUF(_Sn_DIP6R_(sn),(dip6r),16)
X#define setSn_DIP6R(sn,dip6r)         WIZCHIP_WRITE_BUF(_Sn_DIP6R_(sn),(dip6r),16)
S#define getSn_DIP6R(sn,dip6r) \
S        WIZCHIP_READ_BUF(_Sn_DIP6R_(sn),(dip6r),16)
X#define getSn_DIP6R(sn,dip6r)         WIZCHIP_READ_BUF(_Sn_DIP6R_(sn),(dip6r),16)
S
S#define setSn_DPORTR(sn,dportr) \
S        do{                                                                         \
S            WIZCHIP_WRITE(_Sn_DPORTR_(sn),(uint8_t)((dportr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1),(uint8_t)(dportr)); \
S        }while(0);
X#define setSn_DPORTR(sn,dportr)         do{                                                                                     WIZCHIP_WRITE(_Sn_DPORTR_(sn),(uint8_t)((dportr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1),(uint8_t)(dportr));         }while(0);
S#define getSn_DPORTR(sn) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_DPORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1)))
X#define getSn_DPORTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_DPORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1)))
S
S#define setSn_MR2(sn,mr2) \
S        WIZCHIP_WRITE(_Sn_MR2_(sn),(mr2))
X#define setSn_MR2(sn,mr2)         WIZCHIP_WRITE(_Sn_MR2_(sn),(mr2))
S#define getSn_MR2(sn) \
S        WIZCHIP_READ(_Sn_MR2_(sn))
X#define getSn_MR2(sn)         WIZCHIP_READ(_Sn_MR2_(sn))
S
S#define setSn_RTR(sn,rtr) \
S        do{                                                                   \
S            WIZCHIP_WRITE(_Sn_RTR_(sn),(uint8_t)((rtr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1),(uint8_t)(rtr)); \
S        }while(0);
X#define setSn_RTR(sn,rtr)         do{                                                                               WIZCHIP_WRITE(_Sn_RTR_(sn),(uint8_t)((rtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1),(uint8_t)(rtr));         }while(0);
S#define getSn_RTR(sn) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_RTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1)))
X#define getSn_RTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_RTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1)))
S
S#define setSn_RCR(sn,rcr) \
S        WIZCHIP_WRITE(_Sn_RCR_(sn),(rcr))
X#define setSn_RCR(sn,rcr)         WIZCHIP_WRITE(_Sn_RCR_(sn),(rcr))
S#define getSn_RCR(sn) \
S        WIZCHIP_READ(_Sn_RCR_(sn))
X#define getSn_RCR(sn)         WIZCHIP_READ(_Sn_RCR_(sn))
S
S#define setSn_KPALVTR(sn,kpalvtr) \
S        WIZCHIP_WRITE(_Sn_KPALVTR_(sn),(kpalvtr))
X#define setSn_KPALVTR(sn,kpalvtr)         WIZCHIP_WRITE(_Sn_KPALVTR_(sn),(kpalvtr))
S#define getSn_KPALVTR(sn) \
S        WIZCHIP_READ(_Sn_KPALVTR_(sn))
X#define getSn_KPALVTR(sn)         WIZCHIP_READ(_Sn_KPALVTR_(sn))
S
S#define setSn_TX_BSR(sn, tmsr) \
S        WIZCHIP_WRITE(_Sn_TX_BSR_(sn),(tmsr))
X#define setSn_TX_BSR(sn, tmsr)         WIZCHIP_WRITE(_Sn_TX_BSR_(sn),(tmsr))
S#define setSn_TXBUF_SIZE(sn, tmsr)      setSn_TX_BSR(sn,(tmsr))
S
S#define getSn_TX_BSR(sn) \
S        WIZCHIP_READ(_Sn_TX_BSR_(sn))
X#define getSn_TX_BSR(sn)         WIZCHIP_READ(_Sn_TX_BSR_(sn))
S#define getSn_TXBUF_SIZE(sn)            getSn_TX_BSR(sn)
S              
S#define getSn_TxMAX(sn) \
S	  (getSn_TX_BSR(sn) << 10)
X#define getSn_TxMAX(sn) 	  (getSn_TX_BSR(sn) << 10)
S
Sdatasize_t getSn_TX_FSR(uint8_t sn);
S
S#define getSn_TX_RD(sn) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_TX_RD_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_RD_(sn),1)))
X#define getSn_TX_RD(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_TX_RD_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_RD_(sn),1)))
S
S#define setSn_TX_WR(sn,txwr) \
S        do{                                                                       \
S            WIZCHIP_WRITE(_Sn_TX_WR_(sn), (uint8_t)((txwr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1), (uint8_t)(txwr)); \
S        }while(0);
X#define setSn_TX_WR(sn,txwr)         do{                                                                                   WIZCHIP_WRITE(_Sn_TX_WR_(sn), (uint8_t)((txwr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1), (uint8_t)(txwr));         }while(0);
S#define getSn_TX_WR(sn) \
S        (((uint16_t)WIZCHIP_READ(_Sn_TX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1)))
X#define getSn_TX_WR(sn)         (((uint16_t)WIZCHIP_READ(_Sn_TX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1)))
S
S#define setSn_RX_BSR(sn,rmsr) \
S        WIZCHIP_WRITE(_Sn_RX_BSR_(sn),(rmsr))
X#define setSn_RX_BSR(sn,rmsr)         WIZCHIP_WRITE(_Sn_RX_BSR_(sn),(rmsr))
S#define setSn_RXBUF_SIZE(sn,rmsr)      setSn_RX_BSR(sn,(rmsr))
S
S#define getSn_RX_BSR(sn) \
S        WIZCHIP_READ(_Sn_RX_BSR_(sn))
X#define getSn_RX_BSR(sn)         WIZCHIP_READ(_Sn_RX_BSR_(sn))
S#define getSn_RXBUF_SIZE(sn)           getSn_RX_BSR(sn)
S
S#define getSn_RxMAX(sn) \
S        (getSn_RX_BSR(sn) <<10)
X#define getSn_RxMAX(sn)         (getSn_RX_BSR(sn) <<10)
S
Sdatasize_t getSn_RX_RSR(uint8_t s);
S
S#define setSn_RX_RD(sn,rxrd) \
S        do{                                                                        \
S            WIZCHIP_WRITE(_Sn_RX_RD_(sn), (uint8_t)((rxrd)>>8));                   \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1), (uint8_t)(rxrd)) ; \
S        }while(0);
X#define setSn_RX_RD(sn,rxrd)         do{                                                                                    WIZCHIP_WRITE(_Sn_RX_RD_(sn), (uint8_t)((rxrd)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1), (uint8_t)(rxrd)) ;         }while(0);
S
S#define getSn_RX_RD(sn) \
S        (((uint16_t)WIZCHIP_READ(_Sn_RX_RD_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1)))
X#define getSn_RX_RD(sn)         (((uint16_t)WIZCHIP_READ(_Sn_RX_RD_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1)))
S
S#define getSn_RX_WR(sn) \
S        (((uint16_t)WIZCHIP_READ(_Sn_RX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_WR_(sn),1)))
X#define getSn_RX_WR(sn)         (((uint16_t)WIZCHIP_READ(_Sn_RX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_WR_(sn),1)))
S/**
S * @}
S */
S                  
S
S/////////////////////////////////////
S// Sn_TXBUF & Sn_RXBUF IO function //
S/////////////////////////////////////
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It saves data to be sent in the SOCKETn TX buffer.
S * @details This function reads first @ref _Sn_TX_WR_ \n
S *          and starts to copy <i>wizdata</i> from @ref _Sn_TX_WR_ address of SOCKETn TX buffer as many as <i>len</i>.\n
S *          After it is completed to copy <i><wizdata</i>, \n
S *          It increases @ref _Sn_TX_WR_ as many as <i>len</i>.
S * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
S * @param wizdata Pointer buffer to write data
S * @param len Data length
S * @sa wiz_recv_data()
S */
Svoid wiz_send_data(uint8_t sn, uint8_t *wizdata, datasize_t len);
S
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It reads the received data from the SOCKETn RX buffer and copies the data to your system memory specified by <i>wizdata</i>.
S * @details This function reads first @ref _Sn_RX_RD_ \n
S *          and starts to copy the received data to <i>wizdata</i> as many as <i>len</i>.\n
S *          After it is completed to copy the received data, \n
S *          It increases @ref _Sn_RX_RD_ as many as <i>len</i>.
S * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
S * @param wizdata Pointer buffer to read data
S * @param len Data length
S * @sa wiz_send_data()
S */
Svoid wiz_recv_data(uint8_t sn, uint8_t *wizdata, datasize_t len);
S
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It discards the received data in the SOCKETn RX buffer.
S * @details This function discards the received data by increasing @ref _Sn_RX_RD_ as manay as <i>len</i> without coping the data.
S * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
S * @param len Data length
S */
Svoid wiz_recv_ignore(uint8_t sn, datasize_t len);
S
S/// @cond DOXY_APPLY_CODE
S#if (_PHY_IO_MODE_ == _PHY_IO_MODE_MII_)
S/// @endcond
S/**
S * @ingroup Special_function_W6100
S * @brief Write data to the PHY via MDC/MDIO interface.
S * @details Write command data to the PHY via MDC/MDIO interface.
S * @param phyregaddr Address of the PHY register. It should be @ref PHYRAR_BMCR, @ref PHYRAR_BMSR, and etc.
S * @param var Data to write to the PHY register. Please refer to the bit definitions of the BMCR and BMSR register.
S * @note In order to use it, You should define @ref _PHY_IO_MODE_ to @ref _PHY_IO_MODE_MII_.
S */
Svoid wiz_mdio_write(uint8_t phyregaddr, uint16_t var);
S
S/**
S * @ingroup Special_function_W6100
S * @brief Read data from the PHY via MDC/MDIO interface.
S * @details Read command or status data from the PHY via MDC/MDIO interface.
S * @param phyregaddr Address of the PHY register. It should be @ref PHYRAR_BMCR, @ref PHYRAR_BMSR, and etc.
S * @return The value of the PHY register
S * @note In order to use it, You should define @ref _PHY_IO_MODE_ to @ref _PHY_IO_MODE_MII_.
S */
Suint16_t wiz_mdio_read(uint8_t phyregaddr);
S/// @cond DOXY_APPLY_CODE
S#endif
S/// @endcond
S
S/// @cond DOXY_APPLY_CODE
S#endif  // _WIZCHIP_ == 6100
S/// @endcond
S
S
S#ifdef __cplusplus
S}
S#endif
S
S
N#endif //_W6100_H_
L 130 "..\..\Libraries\io6Library\Ethernet\wizchip_conf.h" 2
N   #include "../Application/Application.h"
L 1 "..\..\Libraries\io6Library\Ethernet\../Application/Application.h" 1
N#ifndef _APPLICATION_H_
N#define _APPLICATION_H_
N
N#include <stdint.h>
N
N
N#define SOCK_TCP4			 (Sn_MR_TCP)
N#define SOCK_TCP6			 (Sn_MR_TCP6)
N#define SOCK_TCPD			 (Sn_MR_TCPD)
N
N#define SOCK_UDP4			 (Sn_MR_UDP4)
N#define SOCK_UDP6			 (Sn_MR_UDP6)
N#define SOCK_UDPD			 (Sn_MR_UDPD)
N
N#define AS_IPV4 2
N#define AS_IPV6 23
N#define AS_IPDUAL 11
N#endif
L 131 "..\..\Libraries\io6Library\Ethernet\wizchip_conf.h" 2
N#else
S   #error "Unknown defined _WIZCHIP_. You should define 6100"
N#endif
N
N#ifndef _WIZCHIP_IO_MODE_
S   #error "Undefined _WIZCHIP_IO_MODE_. You should define it !!!"
N#endif
N
N/**
N * @brief Define I/O base address of @ref _WIZCHIP_.
N * @todo If you want to use @ref _WIZCHIP_IO_MODE_BUS_ such as @ref _WIZCHIP_IO_MODE_BUS_DIR_ and @ref _WIZCHIP_IO_MODE_BUS_INDIR_,\n
N *       You should redefine @ref _WIZCHIP_IO_BASE_ to a free address space of your system.\n
N *       ex> <code> #define _WIZCHIP_IO_BASE_      0x00008000 </code> \n\n
N *       Otherwise, No need to redefine it.
N */
N#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_
X#if (0x0100 + 2) & 0x0100
N   #define _WIZCHIP_IO_BASE_            0x60000000   // for W6100 BUS
N#elif _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_
S   #define _WIZCHIP_IO_BASE_            0x00000000   // for W6100 SPI
S#else
S   #error "You should define _WIZCHIP_IO_BASE_ to fit your system memory map."
N#endif
N
N
N#define _WIZCHIP_SOCK_NUM_   8   ///< The count of independent SOCKET of @ref _WIZCHIP_
N
N
N/********************************************************
N* WIZCHIP BASIC IF functions for SPI, SDIO, I2C , ETC.
N*********************************************************/
N/**
N * @ingroup DATA_TYPE
N * @brief Callback function set for @ref _WIZCHIP_
N * @details @ref __WIZCHIP_T__ is a structure type to provide the callback function set \n
N * *        which is called instead of the default functions \n
N *          in order to your HOST dependent functions can access to @ref _WIZCHIP_.
N * @note If it is not registered, the default function is called.
N * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * @sa reg_wizchip_cris_cbfunc(), reg_wizchip_cs_cbfunc(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc()
N */
Ntypedef struct __WIZCHIP_T__
N{
N
N   uint16_t  if_mode;                     ///< HOST Interface Mode
N   uint8_t   id[6];                       ///< ID of CHIP such as W6100, and so on.
N
N   ///< The set of critical section callback function.
N   struct _CRIS
N   {
N      void (*_e_n_t_e_r_)  (void);        ///< critical section enter
N      void (*_e_x_i_t_) (void);           ///< critical section exit
N   }CRIS;  
N
N   ///< The set of @ref _WIZCHIP_ select control callback function.
N   struct _CS
N   {
N      void (*_s_e_l_e_c_t_)  (void);      ///< @ref _WIZCHIP_ selected
N      void (*_d_e_s_e_l_e_c_t_)(void);    ///< @ref _WIZCHIP_ deselected
N   }CS;  
N
N   ///< The set of interface IO callback function.
N   union _IF
N   {
N      ///< The callback function of @ref _WIZCHIP_IO_MODE_BUS_ such as @ref _WIZCHIP_IO_MODE_BUS_DIR_ and @ref _WIZCHIP_IO_MODE_BUS_INDIR_
N      struct _BUS
N      {
N         iodata_t  (*_read_data)      (uint32_t AddrSel);               ///< Read 1 @ref iodata_t from @ref _WIZCHIP_ through BUS
N         void      (*_write_data)     (uint32_t AddrSel, iodata_t wb);  ///< Write 1 @ref iodata_t to @ref _WIZCHIP_ through BUS
N         void      (*_read_data_buf)  (uint32_t AddrSel, iodata_t* pBuf, datasize_t len, uint8_t addrinc);  ///< Read @ref iodata_t as many as <i>len</i> from @ref _WIZCHIP_ through BUS
N         void      (*_write_data_buf) (uint32_t AddrSel, iodata_t* pBuf, datasize_t len, uint8_t addrinc);  ///< Write @ref iodata_t data as many as <i>len</i> to @ref _WIZCHIP_ through BUS
N      }BUS;
N
N      ///< The callback function of @ref _WIZCHIP_IO_MODE_SPI_ such as @ref _WIZCHIP_IO_MODE_SPI_VDM_ and @ref _WIZCHIP_IO_MODE_SPI_FDM_
N      struct _SPI
N      {
N         uint8_t   (*_read_byte)      (void);                           ///< Read 1 byte data from @ref _WIZCHIP_ through SPI
N         void      (*_write_byte)     (uint8_t wb);                     ///< Write 1 byte data to @ref _WIZCHIP_ through SPI
N         void      (*_read_byte_buf)  (uint8_t* pBuf, datasize_t len);  ///< Read byte data as many as <i>len</i> from @ref _WIZCHIP_ through SPI
N         void      (*_write_byte_buf) (uint8_t* pBuf, datasize_t len);  ///< Write byte data as many as <i>len</i> to @ref _WIZCHIP_ through SPI
N      }SPI;
N   }IF;    
N
N}_WIZCHIP_T_;
N
N
Nextern _WIZCHIP_T_  WIZCHIP;  ///< @ref WIZCHIP is instance of @ref _WIZCHIP_T_ to access @ref _WIZCHIP_.
N
N
N/**
N * @ingroup DATA_TYPE
N * @brief @ref _WIZCHIP_ Control Type Enumeration.
N * @details @ref ctlwizchip_type includes a general control function for @ref _WIZCHIP_ and the integrated Ethernet PHY.
N * @note If @ref _PHY_IO_MODE_ is @ref _PHY_IO_MODE_PHYCR_,\n
N *       the PHY control types such as following can configure the integrate PHY thru @ref _PHYCR0_ & @ref _PHYCR1_, or indicate thru or @ref _PHYSR_.\n
N *       - @ref CW_RESET_PHY      : It can configure the PHY only when @ref SYS_PHY_LOCK is unlock.
N *       - @ref CW_SET_PHYCONF    : It can configure the PHY only when @ref SYS_PHY_LOCK is unlock.
N *       - @ref CW_GET_PHYCONF    
N *       - @ref CW_GET_PHYSTATUS
N *       - @ref CW_SET_PHYPOWMODE : It can configure the PHY only when @ref SYS_PHY_LOCK is unlock.
N *       - @ref CW_GET_PHYPOWMODE
N *       - @ref CW_GET_PHYLINK
N *       Else if @ref _PHY_IO_MODE_ is @ref _PHY_IO_MODE_MII_, \n
N *       the PHY control types configure or indicate through two MDC/MDIO signal of MII \n
N *       regardless of @ref SYS_PHY_LOCK.
N * @sa ctlwizchip()
N */
Ntypedef enum
N{
N   CW_SYS_LOCK,           ///< Lock or Unlock @ref _WIZCHIP_ with @ref SYS_CHIP_LOCK, @ref SYS_PHY_LOCK, and @ref SYS_NET_LOCK
N   CW_SYS_UNLOCK,         ///< Lock or Unlock @ref _WIZCHIP_ with @ref SYS_CHIP_LOCK, @ref SYS_PHY_LOCK, and @ref SYS_NET_LOCK
N   CW_GET_SYSLOCK,        ///< Get the lock status of @ref _WIZCHIP_ with @ref SYS_CHIP_LOCK, @ref SYS_PHY_LOCK, and @ref SYS_NET_LOCK
N
N   CW_RESET_WIZCHIP,      ///< Reset @ref _WIZCHIP_ by software
N   CW_INIT_WIZCHIP,       ///< Initialize to SOCKETn buffer size with n byte array typed uint8_t
N   CW_GET_INTERRUPT,      ///< Get the interrupt status with @ref intr_kind 
N   CW_CLR_INTERRUPT,      ///< Clear the interrupt with @ref intr_kind
N   CW_SET_INTRMASK,       ///< Set the interrupt mask with @ref intr_kind
N   CW_GET_INTRMASK,       ///< Get the interrupt mask with @ref intr_kind
N   CW_SET_INTRTIME,       ///< Set the interrupt pending time 
N   CW_GET_INTRTIME,       ///< Get the interrupt pending time
N   CW_SET_IEN,            ///< Set the global interrupt enable only when @ref SYS_CHIP_LOCK is not set
N   CW_GET_IEN,            ///< Get the global interrupt enable 
N
N   CW_GET_ID,             ///< Get @ref _WIZCHIP_ name.
N   CW_GET_VER,            ///< Get the version of TCP/IP TOE engine
N
N   CW_SET_SYSCLK,         ///< Set the system clock with @ref SYSCLK_100MHZ or SYSCLK_10MHZ only when @ref SYS_CHIP_LOCK is unlock
N   CW_GET_SYSCLK,         ///< Get the system clock with @ref SYSCLK_100MHZ or SYSCLK_10MHZ 
N
N   CW_RESET_PHY,          ///< Reset PHY 
N   CW_SET_PHYCONF,        ///< Set PHY operation mode (Manual/Auto, 10/100, Half/Full) with @ref wiz_PhyConf
N   CW_GET_PHYCONF,        ///< Get PHY operation mode (Manual/Auto, 10/100, Half/Full) with @ref wiz_PhyConf
N   CW_GET_PHYSTATUS,      ///< Get real operation mode with @ref wiz_PhyConf when PHY is linked up.  
N   CW_SET_PHYPOWMODE,     ///< Set PHY power mode with @ref PHY_POWER_NORM or PHY_POWER_DOWN
N   CW_GET_PHYPOWMODE,     ///< Get PHY Power mode with @ref PHY_POWER_NORM or PHY_POWER_DOWN
N   CW_GET_PHYLINK         ///< Get PHY Link status with @ref PHY_LINK_ON or @ref PHY_LINK_OFF
N}ctlwizchip_type;
N
N
N/**
N * @ingroup DATA_TYPE
N * @brief  Network control type enumeration
N * @details @ref ctlnetwork_type includes a general network configuration function for @ref _WIZCHIP_.
N * @sa ctlnetwork().
N */
Ntypedef enum
N{
N   CN_SET_NETINFO,  ///< Set Network with @ref wiz_NetInfo
N   CN_GET_NETINFO,  ///< Get Network with @ref wiz_NetInfo
N   CN_SET_NETMODE,  ///< Set network mode with @ref netmode_type
N   CN_GET_NETMODE,  ///< Get network mode with @ref netmode_type
N   CN_SET_TIMEOUT,  ///< Set network timeout with @ref wiz_NetTimeout
N   CN_GET_TIMEOUT,  ///< Get network timeout with @ref wiz_NetTimeout
N   CN_SET_PREFER,   ///< Set the preferred source IPv6 address of @ref _SLCR_.\n Refer to @ref IPV6_ADDR_AUTO, @ref IPV6_ADDR_LLA, @ref IPV6_ADDR_GUA
N   CN_GET_PREFER,   ///< Get the preferred source IPv6 address of @ref _SLCR_.\n Refer to @ref IPV6_ADDR_AUTO, @ref IPV6_ADDR_LLA, @ref IPV6_ADDR_GUA
N}ctlnetwork_type;
N
N/**
N * @ingroup DATA_TYPE
N * @brief  Network Service Control Type enumeration
N * @details @ref ctlnetservice_type includes network management or monitor functions for @ref _WIZCHIP_.
N * @sa ctlnetservice(), wiz_IPAddress, wiz_Prefix
N */
Ntypedef enum
N{
N   CNS_ARP,            ///< ARP process with @ref wiz_IPAddress
N   CNS_PING,           ///< PING process with @ref wiz_IPAddress
N   CNS_DAD,            ///< Duplicated IPv6 Address Detection
N   /**
N    * @brief Stateless Address Auto-configuration(SLAAC) with @ref wiz_Prefix. 
N    * @details @ref CNS_SLAAC sends first RS message to all-router and then receives RA message from a router.
N    * @note It is valid only when the first received RA option is the source link-layer address(0x01) and the second is prefix information(0x03).\n
N    *       Refer to @ref SLIR_RS.
N    * @sa ctlnetservice()
N    * @sa CNS_GET_PREFIX
N    */
N   CNS_SLAAC,          
N   CNS_UNSOL_NA,       ///< Unsolicited Neighbor Advertisement for update @ref _WIZCHIP_ network information to neighbors
N   /**
N    * @brief Get prefix information with @ref wiz_Prefix.  
N    * @details @ref CNS_GET_PREFIX can get prefix information of RA message to be sent by a router without RS message.
N    * @note It is valid only when @ref IK_SOCKL_RA is set and the prefix information(0x03) of RA option is first received. 
N    * @sa ctlnetservice()
N    * @sa CNS_SLAAC
N    */
N   CNS_GET_PREFIX      
N}ctlnetservice_type;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Interrupt Kind
N * @details @ref intr_kind can be used as the interrupt bits of @ref _IR_, @ref _SIR_, and @ref _SLIR_,\n
N *          It can be used as the interrupt mask bits of @ref _IMR_, @ref _SIMR_, and @ref _SLIMR_,\n
N *          and also, It can be used as the interrupt clear bits of @ref _IRCLR_, @ref _Sn_IRCLR_, and @ref _SLIRCLR_.
N * @note It can be used with @b OR operation.
N * @sa ctlwizchip(), CW_GET_INTERRUPT, CW_CLR_INTERRUPT, CW_GET_INTRMASK, CW_SET_INTRMASK
N * @sa ctlnetservice(), ctlnetservice_type
N * @sa wizchip_getinterrupt(), wizchip_clrinterrupt(), wizchip_getinterruptmask(), wizchip_setinterruptmask()
N */
Ntypedef enum
N{
N   IK_PPPOE_TERMINATED = (1 << 0),     ///< PPPoE Termination Interrupt
N   IK_DEST_UNREACH     = (1 << 1),     ///< ICMPv4 Destination Unreachable Interrupt
N   IK_IP_CONFLICT      = (1 << 2),     ///< IPv4 Address Conflict Interrupt
N   IK_DEST_UNREACH6    = (1 << 4),     ///< ICMPv6 Destination Unreachable Interrupt
N   IK_WOL              = (1 << 7),     ///< WOL magic packet Interrupt
N   IK_NET_ALL          = (0x97),       ///< All Network Interrupt
N   
N   IK_SOCK_0           = (1 << 8),     ///< Socket 0 Interrupt
N   IK_SOCK_1           = (1 << 9),     ///< Socket 1 Interrupt
N   IK_SOCK_2           = (1 << 10),    ///< Socket 2 Interrupt
N   IK_SOCK_3           = (1 << 11),    ///< Socket 3 Interrupt
N   IK_SOCK_4           = (1 << 12),    ///< Socket 4 Interrupt
N   IK_SOCK_5           = (1 << 13),    ///< Socket 5 Interrupt
N   IK_SOCK_6           = (1 << 14),    ///< Socket 6 Interrupt
N   IK_SOCK_7           = (1 << 15),    ///< Socket 7 Interrupt
N   IK_SOCK_ALL         = (0xFF << 8),  ///< All Socket Interrupt
N
N   IK_SOCKL_TOUT       = (1 << 16),    ///< @ref _SLCR_ Timeout Interrupt.\n Refer to @ref ctlnetservice_type.
N   IK_SOCKL_ARP4       = (1 << 17),    ///< @ref _SLCR_ APR4 Interrupt.\n Refer to @ref CNS_ARP.
N   IK_SOCKL_PING4      = (1 << 18),    ///< @ref _SLCR_ PING4 Interrupt.\n Refer to @ref CNS_PING.
N   IK_SOCKL_ARP6       = (1 << 19),    ///< @ref _SLCR_ ARP6 Interrupt.\n Refer to @ref CNS_ARP.
N   IK_SOCKL_PING6      = (1 << 20),    ///< @ref _SLCR_ PING6 Interrupt.\n Refer to @ref CNS_PING.
N   IK_SOCKL_NS         = (1 << 21),    ///< @ref _SLCR_ NS Interrupt.\n Refer to @ref CNS_DAD.
N   IK_SOCKL_RS         = (1 << 22),    ///< @ref _SLCR_ RS Interrupt.\n Refer to @ref CNS_SLAAC.
N   IK_SOCKL_RA         = (1 << 23),    ///< @ref _SLCR_ RA Interrupt.\n Refer to @ref CNS_GET_PREFIX.
N   IK_SOCKL_ALL        = (0xFF << 16), ///< @ref _SLCR_ All Interrupt
N
N   IK_INT_ALL          = (0x00FFFF97)   ///< All Interrupt
N}intr_kind;
N
N
N
N#define SYS_CHIP_LOCK           (1<<2)   ///< CHIP LOCK. \n Refer to @ref CW_SYS_LOCK, @ref CW_SYS_UNLOCK, and @ref CW_GET_SYSLOCK.
N#define SYS_NET_LOCK            (1<<1)   ///< NETWORK Information LOCK. \n Refer to @ref CW_SYS_LOCK, @ref CW_SYS_UNLOCK, and @ref CW_GET_SYSLOCK.
N#define SYS_PHY_LOCK            (1<<0)   ///< PHY LOCK.\n Refer to @ref CW_SYS_LOCK, @ref CW_SYS_UNLOCK, and @ref CW_GET_SYSLOCK.
N
N#define SYSCLK_100MHZ            0       ///< System Clock 100MHz.\n Refer to Refer to @ref CW_SET_SYSCLK and  @ref CW_GET_SYSCLK.
N#define SYSCLK_25MHZ             1       ///< System Clock 25MHz.\n Refer to Refer to @ref CW_SET_SYSCLK and  @ref CW_GET_SYSCLK.
N
N#define PHY_MODE_MANUAL          0       ///< Configured PHY operation mode with user setting.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N#define PHY_MODE_AUTONEGO        1       ///< Configured PHY operation mode with auto-negotiation.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N/**
N * @brief Configured PHY operation mode with 10Base-Te.
N * @details It can be set or get through @ref ctlwizchip() with @ref CW_SET_PHYCONF or @ref CW_GET_PHYCONF.
N * @note It is controlled by @ref _PHYCR1_ regardless of @ref _PHY_IO_MODE_.
N * @note After 10Base-Te mode is set, Ethernet PHY should be reset by calling @ref ctlwizchip() with @ref CW_RESET_PHY
N */
N#define PHY_MODE_TE              2
N#define PHY_SPEED_10             0       ///< PHY Link Speed 10.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N#define PHY_SPEED_100            1       ///< PHY Link Speed 100.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N#define PHY_DUPLEX_HALF          0       ///< PHY Link Half-Duplex.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N#define PHY_DUPLEX_FULL          1       ///< PHY Link Full-Duplex.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N#define PHY_LINK_OFF             0       ///< PHY Link Off.\n Refer to @ref CW_GET_PHYLINK.
N#define PHY_LINK_ON              1       ///< PHY Link On.\n Refer to @ref CW_GET_PHYLINK.
N#define PHY_POWER_NORM           0       ///< PHY power normal mode.\n Refer to @ref CW_SET_PHYPOWMODE and @ref CW_GET_PHYPOWMODE
N#define PHY_POWER_DOWN           1       ///< PHY power down mode.\n Refer to @ref CW_SET_PHYPOWMODE and @ref CW_GET_PHYPOWMODE
N
N#define IPV6_ADDR_AUTO           0x00    ///< IPv6 Address Type : Auto.\n Refer to @ref CN_SET_PREFER, @ref CN_GET_PREFER.
N#define IPV6_ADDR_LLA            0x02    ///< IPv6 Address Type : LLA. \n Refer to @ref CN_SET_PREFER, @ref CN_GET_PREFER, @ref CNS_DAD.
N#define IPV6_ADDR_GUA            0x03    ///< IPv6 Address Type : GUA. \n Refer to @ref CN_SET_PREFER, @ref CN_GET_PREFER, @ref CNS_DAD.
N
N
N/**
N * @ingroup DATA_TYPE
N * @brief Ethernet PHY operation mode configuration
N * @details @ref wiz_PhyConf is a structure type to configure or \n
N *          indicate the PHY operation mode such as auto-negotiation, speed, and duplex.\n
N * @note If @ref _PHY_IO_MODE_ is defined with @ref _PHY_IO_MODE_PHYCR_,\n
N *       the PHY operation mode is configured by @ref _PHYCR0_ and is indicated by @ref _PHYSR_.\n
N *       Otherwise, the PHY operation mode is configured or indicated by two MDC/MDIO signal of MII.
N * @note In order to apply @ref wiz_PhyConf to the integrated Ethernet PHY, \n
N *       It needs to reset the PHY by calling @ref ctlwizchip(@ref CW_RESET_PHY)
N * @sa ctlwizchip(), CW_SET_PHYCONF, CW_GET_PHYCONF, CW_RESET_PHY
N * @sa wizphy_setphyconf(), wizphy_getphyconf(), wizphy_reset()
N */
Ntypedef struct wiz_PhyConf_t
N{
N      uint8_t mode;     ///< set by @ref PHY_MODE_MANUAL ,@ref PHY_MODE_AUTONEGO, or @ref PHY_MODE_TE
N      uint8_t speed;    ///< set by @ref PHY_SPEED_10 or @ref PHY_SPEED_100
N      uint8_t duplex;   ///< set by @ref PHY_DUPLEX_HALF @ref PHY_DUPLEX_FULL 
N}wiz_PhyConf;
N
N/**
N * @ingroup DATA_TYPE
N * @brief IP Address Configuration Mode
N * @details @ref ipconf_mode can be used to save the DHCP mode running on your system.
N * @sa ctlnetwork(), CN_SET_NETINFO, CN_GET_NETINFO
N * @sa wizchip_setnetinfo(), wizchip_getnetinfo(), wiz_NetInfo
N */
Ntypedef enum
N{
N   NETINFO_NONE       = 0x00,    ///< No use DHCP
N   NETINFO_STATIC_V4  = 0x01,    ///< Static IPv4 configuration by manually.
N   NETINFO_STATIC_V6  = 0x02,    ///< Static IPv6 configuration by manually.
N   NETINFO_STATIC_ALL = 0x03,    ///< Static IPv4 and IPv6 configuration by manually.
N   NETINFO_SLAAC_V6   = 0x04,    ///< Stateless Adders Auto Configuration for IPv6
N   NETINFO_DHCP_V4    = 0x10,    ///< Dynamic IPv4 configuration from a DHCP sever
N   NETINFO_DHCP_V6    = 0x20,    ///< Dynamic IPv6 configuration from a DHCP sever
N   NETINFO_DHCP_ALL   = 0x30     ///< Dynamic IPv4 and IPv6 configuration from a DHCP sever
N}ipconf_mode;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Network Information for @ref _WIZCHIP_
N * @details @ref wiz_NetInfo is a structure type to configure or indicate the network information of @ref _WIZCHIP_.
N * @sa ctlnetwork(), CN_SET_NETINFO, CN_GET_NETINFO
N * @sa wizchip_setnetinfo(), wizchip_getnetinfo()
N */
Ntypedef struct wiz_NetInfo_t
N{
N   uint8_t     mac[6];    ///< Source Hardware Address
N   uint8_t     ip[4];     ///< Source IPv4 Address
N   uint8_t     sn[4];     ///< Subnet Mask value
N   uint8_t     gw[4];     ///< Gateway IPv4 Address
N   uint8_t     lla[16];   ///< Source Link Local Address
N   uint8_t     gua[16];   ///< Source Global Unicast Address
N   uint8_t     sn6[16];   ///< IPv6 Prefix
N   uint8_t     gw6[16];   ///< Gateway IPv6 Address
N   uint8_t     dns[4];    ///< DNS server IPv4 Address
N   uint8_t     dns6[16];  ///< DNS server IPv6 Address
N   ipconf_mode ipmode;    ///< IP Configuration Mode
N}wiz_NetInfo;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Network mode Configuration
N * @details @ref netmode_type includes the network mode control function such as ping, TCP/RST block and etc.
N * @sa ctlnetwork(), CN_SET_NETMODE, CN_GET_NETMODE
N */
Ntypedef enum
N{
N   // NETMR Bit Values
N   NM_IPB_V4            = (1 << 0),      ///< IPv4 Packet Block
N   NM_IPB_V6            = (1 << 1),      ///< IPv6 Packet Block
N   NM_WOL               = (1 << 2),      ///< Wake On Lan(WOL) Mode
N   NM_PB6_MULTI         = (1 << 4),      ///< PING6 request from multicasting group address Block
N   NM_PB6_ALLNODE       = (1 << 5),      ///< PING6 request from all-node multicasting address Block
N   NM_MR_MASK           = (0x37),        ///< @ref _NETMR_ Mask value
N
N   // NETMR2 Bit Values
N   NM_PPPoE             = (1 << 8),      ///< PPPoE Mode
N   NM_DHA_SELECT        = (1 << 15),     ///< Destination Hardware Address Select
N   NM_MR2_MASK          = (0x09<<8),     ///< @ref _NETMR2_ Mask value
N
N  //NET4MR Bit Values
N   NM_PB4_ALL           = (1 << 16),     ///< All PING4 request Block
N   NM_TRSTB_V4          = (1 << 17),     ///< TCP RST packet for IPv4 Send Block
N   NM_PARP_V4           = (1 << 18),     ///< ARP request for IPv4 before PINGv4 Replay
N   NM_UNRB_V4           = (1 << 19),     ///< Unreachable Destination for IPv4 Block
N   NM_NET4_MASK         = (0x0F << 16),  ///< @ref _NET4MR_ Mask value
N
N  //NET4MR Bit Values
N   NM_PB6_ALL           = (1 << 24),     ///< All PING6 request Block
N   NM_TRSTB_V6          = (1 << 25),     ///< TCP RST packet for IPv6 Send Block
N   NM_PARP_V6           = (1 << 26),     ///< ARP request for IPv6 before PINGv4 Replay
N   NM_UNRB_V6           = (1 << 27),     ///< Unreachable Destination for IPv6 Block
N   NM_NET6_MASK         = (0x0F << 24),  ///< @ref _NET6MR_ Mask value
N
N   NM_MASK_ALL          = (0x0F0F0937)   ///< @ref netmode_type all mask value
N}netmode_type;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Network Timeout for @ref _WIZCHIP_
N * @details @ref wiz_NetInfo is a structure type to configure or indicate the network timeout of @ref _WIZCHIP_.
N * @sa ctlnetwork(), CN_SET_TIMEOUT, CN_GET_TIMEOUT
N * @sa wizchip_settimeout(), wizchip_gettimeout()
N */
Ntypedef struct wiz_NetTimeout_t
N{
N   uint8_t  s_retry_cnt;         ///< The default retry count of SOCKETn
N   uint16_t s_time_100us;        ///< The retransmission time of SOCKETn (unit 100us)
N   uint8_t  sl_retry_cnt;        ///< The retry count of SOCKET-less
N   uint16_t sl_time_100us;       ///< The retransmission time of SOCKET-less (unit 100us)
N}wiz_NetTimeout;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Destination Information for Network Service of @ref _WIZCHIP_
N * @details @ref wiz_NetInfo is a structure type to configure or indicate a destination information of network service.
N * @sa ctlnetservice(), CNS_ARP, CNS_PING
N * @sa IK_SOCKL_TOUT, IK_SOCKL_ARP4, IK_SOCKL_ARP6, IK_SOCKL_PING4, IK_SOCKL_PING6
N */
Ntypedef struct wiz_IPAddress_t
N{
N   uint8_t ip[16];               ///< Destination IP Address. \n IPv4 index : 0 to 3, IPv6 index : 0 to 15
N   uint8_t len;                  ///< Destination IP Address Length.\n IPv4 : 4, IPv6 : 16.
N}wiz_IPAddress;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Prefix Information
N * @details @ref wiz_Prefix is a structure type to indicate a prefix information(0x03) of received RA message from a router.
N * @sa ctlnetservice(), CNS_SLAAC, IK_SOCKL_RS
N * @sa IK_SOCKL_TOUT, IK_SOCKL_RA, CNS_GET_PREFIX
N */
Ntypedef struct wiz_Prefix_t
N{
N   uint8_t  len;                 ///< Prefix Length. \n It is used to set @ref _SUB6R_ to 1 as many as <i>len</i> from LSB bit.
N   uint8_t  flag;                ///< Prefix Flag
N   uint32_t valid_lifetime;      ///< Valid Lifetime
N   uint32_t preferred_lifetime;  ///< Preferred Lifetime
N   uint8_t  prefix[16];          ///< Prefix
N}wiz_Prefix;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Destination Information & Destination Hardware Address for @ref CNS_ARP
N * @details @ref wiz_ARP is a structure type to set a destination IP address for ARP-request or \n
N *          indicate a destination hardware address in APR-reply.
N * @sa ctlnetservice(), CNS_ARP
N * @sa IK_SOCKL_TOUT, IK_SOCKL_ARP4, IK_SOCKL_ARP6
N */
Ntypedef struct wiz_ARP_t
N{
N   wiz_IPAddress destinfo;       ///< Destination IP address for ARP-request
N   uint8_t dha[6];               ///< Destination Hardware Address when ARP-reply is received from the destination.
N}wiz_ARP;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Destination Information & Destination Hardware Address for @ref CNS_ARP
N * @details @ref wiz_PING is a structure type to set a ID, sequence number, destination IP address for PING-request.
N * @sa ctlnetservice(), CNS_PING
N * @sa IK_SOCKL_TOUT, IK_SOCKL_PING4, IK_SOCKL_PING6
N */
Ntypedef struct wiz_PING_t
N{
N   uint16_t id;
N   uint16_t seq;
N   wiz_IPAddress destinfo;
N}wiz_PING;
N
N/**
N * @brief Registers call back functions for critical section.
N * @details @ref reg_wizchip_cris_cbfunc() is for basic I/O functions \n
N *           such as @ref WIZCHIP_READ(), @ref WIZCHIP_WRITE(), @ref WIZCHIP_READ_BUF() and @ref WIZCHIP_WRITE_BUF().
N * @param cris_en : callback function for critical section enter.
N * @param cris_ex : callback function for critical section exit.
N * @todo Register your functions for critical session.
N * @note If you do not register it, the @b empty default functions are called.\n
N *       @ref wizchip_cris_enter(), @ref wizchip_cris_exit()
N */
Nvoid reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void));
N
N
N/**
N * @brief Registers call back functions for @ref _WIZCHIP_ select & deselect.
N * @details @ref reg_wizchip_cs_cbfunc() registers your functions to select & deselect @ref _WIZCHIP_
N * @param cs_sel : callback function to select @ref _WIZCHIP_
N * @param cs_desel : callback function to deselect @ref _WIZCHIP_
N * @todo Register your functions to select or deselect @ref _WIZCHIP_.
N * @note If you do not register it, the @b empty default functions are called. \n
N *       @ref wizchip_cs_select(), @ref wizchip_cs_deselect()
N */
Nvoid reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void));
N
N/// @cond DOXY_APPLY_CODE
N#if (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_)
X#if ((0x0100 + 2) & 0x0100)
N/// @endcond
N/**
N * @brief Registers call back functions for BUS interface.
N * @details @ref reg_wizchip_bus_cbfunc() is for basic I/O functions \n
N *          such as @ref WIZCHIP_READ(), @ref WIZCHIP_WRITE(), @ref WIZCHIP_READ_BUF() and @ref WIZCHIP_WRITE_BUF().
N * @param bus_rd   : callback function to read 1 @ref iodata_t data 
N * @param bus_wd   : callback function to write 1 @ref iodata_t data
N * @param bus_rbuf : callback function to read @ref iodata_t data buf as many as <i>len</i>
N * @param bus_wbuf : callback function to write @ref iodata_t data buf as many as <i>len</i>
N * @todo Register your functions for data read & write through BUS interface.
N * @note If you do not register it,the default functions are called. \n
N *       @ref wizchip_bus_read(), @ref wizchip_bus_write(), @ref wizchip_bus_read_buf(), @ref wizchip_bus_write_buf().
N */
Nvoid reg_wizchip_bus_cbfunc(iodata_t (*bus_rd)(uint32_t addr), 
N                            void (*bus_wd)(uint32_t addr, iodata_t wb),
N                            void (*bus_rbuf)(uint32_t addr, iodata_t* buf, datasize_t len, uint8_t inc),
N                            void (*bus_wbuf)(uint32_t addr, iodata_t* buf, datasize_t len, uint8_t inc) );
N/// @cond DOXY_APPLY_CODE
N#endif
N/// @endcond
N
N/// @cond DOXY_APPLY_CODE
N#if (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
X#if ((0x0100 + 2) & 0x0200)
S/// @endcond
S/**
S * @brief Registers call back functions for SPI interface.
S * @details @ref reg_wizchip_spi_cbfunc() is for for basic I/O functions \n
S * *        such as @ref WIZCHIP_READ(), @ref WIZCHIP_WRITE(), @ref WIZCHIP_READ_BUF() and @ref WIZCHIP_WRITE_BUF().
S * @param spi_rb : callback function to read 1 byte data using SPI
S * @param spi_wb : callback function to write 1 byte data using SPI
S * @param spi_rbuf : callback function to read byte data buf as many as <i>len</i>
S * @param spi_rbuf : callback function to write byte data buf as many as <i>len</i>
S * @todo Should register your functions for data read/write through SPI interface.
S * @note If you do not register it, the empty default function are called but these function are all null function.\n
S *        So, You should overwrite them or register your functions for replacing them.\n\n
S *        The empty default functions are @ref wizchip_spi_read(), @ref wizchip_spi_write(),@ref wizchip_spi_read_buf(), and @ref wizchip_spi_write_buf().
S */
Svoid reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), 
S                            void (*spi_wb)(uint8_t wb),
S                            void (*spi_rbuf)(uint8_t* buf, datasize_t len),
S                            void (*spi_wbuf)(uint8_t* buf, datasize_t len) );
S/// @cond DOXY_APPLY_CODE
N#endif
N/// @endcond
N
N
N/**
N * @ingroup extra_functions
N * @brief Control @ref _WIZCHIP_.
N * @details @ref ctlwizchip() resets @ref _WIZCHIP_ & integrated Ethernet PHY,\n
N *          configures PHY mode, monitors PHY(Link,Speed,Half/Full/Auto), controls interrupt & mask and so on.
N * @param cwtype : Decides to the control type
N * @param arg : arg type is dependent on cwtype.
N * @return  0 : Success \n
N *         -1 : Fail because of invalid @ref ctlwizchip_type or unsupported @ref ctlwizchip_type
N * @note When you define @ref _PHY_IO_MODE_ to @ref _PHY_IO_MODE_PHYCR_,\n
N *       If you call @ref ctlwizchip(@ref CW_RESET_PHY), you should wait for stable reset time.\n\n
N *       ex> W6100 case \n
N *          <code>
N *            ctlwizchip(CW_RESET_PHY); \n
N *            // Need to wait stable reset time 60.3ms\n
N *            your_delay_function(60300);
N *          </code>
N */          
Nint8_t ctlwizchip(ctlwizchip_type cwtype, void* arg);
N
N/**
N * @ingroup extra_functions
N * @brief Controls to network.
N * @details @ref ctlnetwork() controls to network environment, mode, timeout and so on.
N * @param cntype : Decides to the control type
N * @param arg : arg type is dependent on cntype.
N * @return -1 : Fail because of invalid @ref ctlnetwork_type or unsupported @ref ctlnetwork_type \n
N *          0 : Success      
N */          
Nint8_t ctlnetwork(ctlnetwork_type cntype, void* arg);
N
N
N/**
N * @ingroup extra_functions
N * @brief Controls to network service.
N * @details Controls to network environment, mode, timeout and so on.
N * @param cnstype : Decides to the control type
N * @param arg : arg type is dependent on cnstype.
N * @return -1 : Fail because of invalid @ref ctlnetwork_type or unsupported @ref ctlnetwork_type \n
N *          0 : Success      
N */          
Nint8_t ctlnetservice(ctlnetservice_type cnstype, void* arg);
N
N
N/* 
N * The following functions are implemented for internal use. 
N * but You can call these functions for code size reduction instead of ctlwizchip() and ctlnetwork().
N */
N 
N/**
N * @ingroup extra_functions
N * @brief Soft Reset @ref _WIZCHIP_.
N * @note It backs up the network information before reset, and restores after reset.
N * @sa ctlwizchip(), CW_RESET_WIZCHIP
N * @sa SYCR0_RST
N */ 
Nvoid   wizchip_sw_reset(void);
N
N/**
N * @ingroup extra_functions
N * @brief Initializes SOCKETn TX/RX buffer size
N * @param txsize SOCKETn TX buffer sizes.\n If it is null, SOCKETn TX buffer is initialized as the default size 2KB.
N * @param rxsize SOCKETn RX buffer sizes.\n If it is null, SOCKETn RX buffer is initialized as the default size 2KB.
N * @return 0 : Success \n
N *        -1 : Fail. Invalid buffer size
N * @sa ctlwizchip(), CW_INIT_WIZCHIP
N * @sa _Sn_TX_BSR_, _Sn_RX_BSR_
N */
Nint8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize);
N
N/**  
N * @ingroup extra_functions
N * @brief Clear Interrupt of @ref _WIZCHIP_.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint32_t.
N * @sa ctlwizchip(), CW_CLR_INTERRUPT, CW_GET_INTERRUPT, CW_SET_INTRMASK, CW_GET_INTRMASK
N * @sa wizchip_getintrerupt(), wizchip_setinterruptmask(), wizchip_getinterruptmask()
N */
Nvoid wizchip_clrinterrupt(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt of @ref _WIZCHIP_.
N * @return @ref intr_kind value operated OR. It can type-cast to uint32_t.
N * @sa ctlwizchip(), CW_GET_INTERRUPT, CW_CLR_INTERRUPT, CW_SET_INTRMASK, CW_GET_INTRMASK
N * @sa wizchip_clrinterrupt(), wizchip_setinterruptmask(), wizchip_getinterruptmask()
N */
Nintr_kind wizchip_getinterrupt(void);
N
N/** 
N * @ingroup extra_functions
N * @brief Mask or Unmask Interrupt of @ref _WIZCHIP_.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint32_t.
N * @sa ctlwizchip(), CW_SET_INTRMASK, CW_GET_INTRMASK, CW_CLR_INTERRUPT, CW_GET_INTERRUPT
N * @sa wizchip_getinterruptmask(), wizchip_clrinterrupt(), wizchip_getinterrupt()
N */
Nvoid wizchip_setinterruptmask(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt mask of @ref _WIZCHIP_.
N * @return The operated OR value of @ref intr_kind. It can type-cast to uint32_t.
N * @sa ctlwizchip(), CW_GET_INTRMASK, CW_SET_INTRMASK, CW_CLR_INTERRUPT, CW_GET_INTERRUPT
N * @sa wizchip_setinterruptmask(), wizchip_clrinterrupt(), wizchip_getinterrupt()
N */
Nintr_kind wizchip_getinterruptmask(void);
N
N/** 
N * @ingroup extra_functions
N * @brief Get the Link status of integrated PHY.
N * @details @ref wizphy_getphylink() gets the link status of the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_. \n
N * @return : @ref PHY_LINK_ON or @ref PHY_LINK_OFF.
N * @sa ctlwizchip(), CW_GET_PHYLINK
N * @sa _PHY_IO_MODE_
N */
Nint8_t wizphy_getphylink(void);            ///< get the link status of phy in WIZCHIP. No use in W5100
N
N/** 
N * @ingroup extra_functions
N * @brief Reset the integrated PHY.
N * @details @ref wizphy_reset() resets the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_. \n
N * @note In @ref _PHY_IO_MODE_PHYCR_, It needs a stable reset time. \n
N *       So you need to wait for the stable reset time.\n
N *       The stable reset time for each @ref _WIZCHIP_ maybe different.
N * @sa ctlwizchip(), CW_RESET_PHY
N * @sa _PHY_IO_MODE_
N */
Nvoid wizphy_reset(void);                   ///< Reset phy. Vailid only in W5500
N
N/**
N * @ingroup extra_functions
N * @details @ref wizphy_setphyconf() set a operation mode of the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_.\n
N * @param phyconf : @ref wiz_PhyConf
N * @note The operation mode can be applied to Ethernet PHY after the Ethernet PHY is reset by @ref wizphy_reset().
N * @sa ctlwizchip(), CW_SET_PHYCONF, CW_GET_PHYCONF, CW_GET_PHYSTATUS, CW_RESET_PHY
N * @sa _PHY_IO_MODE_, wizphy_getphyconf(), wizphy_getphystatus(), wizphy_reset()
N */
Nvoid wizphy_setphyconf(wiz_PhyConf* phyconf);  
N
N/**
N * @ingroup extra_functions
N * @brief Get the integrated Ethernet PHY operation mode.
N * @details @ref wizphy_getphyconf() gets a operation mode of the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_.\n
N * @param phyconf : @ref wiz_PhyConf
N * @note It gets just the configured value for PHY operation, not real PHY operation.\n
N *       To get real PHY operation, you can call @ref wizphy_getphystatus()
N * @sa ctlwizchip(), CW_GET_PHYCONF, CW_SET_PHYCONF, CW_GET_PHYSTATUS
N * @sa _PHY_IO_MODE_, wizphy_setphyconf(), wizphy_getphystatus()
N */
Nvoid wizphy_getphyconf(wiz_PhyConf* phyconf); 
N
N/**
N * @ingroup extra_functions
N * @brief Get the real PHY operation status when link is established.
N * @details @ref wizphy_getphystatus() gets a operation mode of the integrated Ethernet PHY. \n
N * @param phyconf : @ref wiz_PhyConf
N * @sa ctlwizchip(), CW_GET_PHYSTATUS, CW_GET_PHYCONF, CW_SET_PHYCONF 
N * @sa wizphy_setphyconf(), wizphy_getphyconf() 
N */ 
Nvoid wizphy_getphystatus(wiz_PhyConf* phyconf);
N 
N/**
N * @ingroup extra_functions
N * @brief Set the power mode of integrated Ethernet PHY.
N * @details @ref wizphy_setphypmode() sets a power mode of the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_.\n
N * @param pmode @ref PHY_POWER_NORM or @ref PHY_POWER_DOWN
N * @note When the integrated Ethernet PHY enters in power down mode, \n
N *       the system clock of @ref _WIZCHIP_ is changed to the lowest speed. \n
N *       So, you should adjust the access time of @ref _WIZCHIP_ to the changed system clock.
N * @sa ctlwizchip(), CW_SET_PHYPOWMODE, CW_GET_PHYPOWMODE
N * @sa _PHY_IO_MODE_, wizphy_setphypmode(), wizphy_getphypmode()
N */   
Nvoid wizphy_setphypmode(uint8_t pmode);    
N
N/**
N * @ingroup extra_functions
N * @brief get the power mode of integrated Ethernet PHY.
N * @details @ref wizphy_getphypmode() gets a power mode of the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_.\n
N * @return @ref PHY_POWER_NORM or @ref PHY_POWER_DOWN
N * @note When the integrated Ethernet PHY enters in power down mode,\n
N *       the system clock of @ref _WIZCHIP_ is changed to the lowest speed. \n
N *       So, you should adjust the access time of @ref _WIZCHIP_ to the changed system clock.
N * @sa ctlwizchip(), CW_SET_PHYPOWMODE, CW_GET_PHYPOWMODE
N * @sa _PHY_IO_MODE_, wizphy_setphypmode(), wizphy_getphypmode()
N */   
Nint8_t wizphy_getphypmode(void);
N
N/**
N * @ingroup extra_functions
N * @brief Set the network information for @ref _WIZCHIP_
N * @param pnetinfo : @ref wiz_NetInfo
N * @sa ctlnetwork(), CN_SET_NETINFO, CN_GET_NETINFO
N * @sa wizchip_getnetinfo()
N */
Nvoid wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network information of @ref _WIZCHIP_
N * @param pnetinfo : @ref wiz_NetInfo
N * @sa ctlnetwork(), CN_GET_NETINFO, CN_SET_NETINFO
N * @sa wizchip_setnetinfo()
N */
Nvoid wizchip_getnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Set the network mode such as WOL, PPPoE, PING Block, and etc. 
N * @param netmode : @ref netmode_type.
N * @sa ctlnetwork(), CN_SET_NETMODE, CN_GET_NETMODE
N * @sa wizchip_getnetmode()
N */
Nvoid wizchip_setnetmode(netmode_type netmode);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network mode such as WOL, PPPoE, PING Block, and etc. 
N * @return @ref netmode_type.
N * @sa ctlnetwork(), CN_GET_NETMODE, CN_SET_NETMODE
N * @sa wizchip_setnetmode()
N */
Nnetmode_type wizchip_getnetmode(void);
N
N/**
N * @ingroup extra_functions
N * @brief Set retransmission time values and retry counts.
N * @param nettime : @ref wiz_NetTimeout. 
N * @sa ctlnetwork(), CN_SET_TIMEOUT, CN_GET_TIMEOUT
N * @sa wizchip_gettimeout()
N */
Nvoid wizchip_settimeout(wiz_NetTimeout* nettime);
N
N/**
N * @ingroup extra_functions
N * @brief Get retransmission time values and retry counts.
N * @param nettime : @ref wiz_NetTimeout. 
N * @sa ctlnetwork(), CN_GET_TIMEOUT, CN_SET_TIMEOUT
N * @sa wizchip_settimeout()
N */
Nvoid wizchip_gettimeout(wiz_NetTimeout* nettime);
N
N/**
N * @ingroup extra_functions
N * @brief ARP process.
N * @details @ref wizchip_arp() processes ARP. \n
N *          It sends the APR-request to destination and waits to receive the ARP-reply.
N * @param arp @ref wiz_ARP.\n
N *            It sets a destination IP address and indicates the destination hardware address.
N * @return 0 : success, destination hardware address is valid.\n
N *         -1 : fail. destination hardware address is invalid because timeout is occurred.\n
N * @sa ctlnetservice(), CNS_ARP
N */
Nint8_t wizchip_arp(wiz_ARP* arp);
N
N/**
N * @ingroup extra_functions
N * @brief PING process.
N * @details @ref wizchip_ping() processes PING. \n
N *          It sends the PING-request to destination and waits to receive the PING-reply.
N * @param ping @ref wiz_PING, It sets a destination IP address, ID, SEQ of PING-request message
N * @return 0 : success, PING-reply is successfully received.\n
N *         -1 : fail. Timeout is occurred.\n
N * @sa ctlnetservice(), CNS_PING
N */
Nint8_t wizchip_ping(wiz_PING* ping);
N
N/**
N * @ingroup extra_functions
N * @brief DAD(Duplcated Address Detection) process.
N * @details @ref wizchip_dad() detects the duplication of source IPv6 address.\n
N *          It sends a NA message for DAD to all-node multicasting address(FF02::01).
N * @param ipv6 : IPv6 address to be detected the duplication.
N * @return 0 : success, There is no duplicated address. \n
N *         -1 : fail. @ref _WIZCHIP_ source IP address to use is duplicated with a neighbor's one.
N * @sa ctlnetservice(), CNS_DAD
N */
Nint8_t wizchip_dad(uint8_t* ipv6);
N
N/**
N * @ingroup extra_functions
N * @brief Stateless Address Auto Configuration(SLAAC) process.
N * @details @ref wizchip_slaac() get a prefix information from a router for SLAAC.\n
N *          It sends first a RS message to all-router and waits to receive a RS message with prefix information option from a router.
N * @param prefix @ref wiz_Prefix
N * @return 0 : success, RA message is successfully received, and <i>prefix</i> is valid.  \n
N *         -1 : fail. Timeout is occurred.
N * @note It is valid only when the prefix information type(0x03) of RA option received first.\n
N *       The prefix option should be in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address. \n
N *       For more detail, Refer to @ref SLIR_RS.
N * @sa ctlnetservice(), CNS_SLAAC
N */
Nint8_t wizchip_slaac(wiz_Prefix* prefix);
N
N/**
N * @ingroup extra_functions
N * @brief Unsolicited NA process.
N * @details @ref wizchip_unsolicited() updates the network information of @ref _WIZCHIP_ to neighbors.\n
N *          It sends a unsolicited NA message with @ref _LLAR_ or @ref _GUAR_ to neighbors \n
N *          in order to update the network information of @ref _WIZCHIP_.\n
N *          Because the unsolicited NA message have no reply, timeout is always occurred.
N * @return always 0. Timeout is occurred.
N * @sa ctlnetservice(), CNS_UNSOL
N */
Nint8_t wizchip_unsolicited(void);
N
N/**
N * @ingroup extra_functions
N * @brief Get a prefix information of RA message from a router.
N * @details @ref wizchip_getprefix() get a prefix information of RA is periodically sent by a router. \n
N * @return 0 : success, a RS message is successfully received from a router.
N *         -1 : fail, a RS message is not received from a router yet.
N * @note It is valid only when the prefix information type(0x03) of RA option received first.\n
N *       The prefix option should be in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address. \n
N *       For more detail, Refer to @ref SLIR_RS.
N * @sa ctlnetservice(), CNS_GET_PREFIX
N */
Nint8_t wizchip_getprefix(wiz_Prefix * prefix);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif   // _WIZCHIP_CONF_H_
L 39 "..\..\Libraries\io6Library\Ethernet\W6100\w6100.h" 2
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/// @cond DOXY_APPLY_CODE
N#if      (_WIZCHIP_ == W6100)
X#if      (6100 == 6100)
N/// @endcond
N
N#define _W6100_SPI_READ_                  (0x00 << 2)        ///< SPI interface Read operation in Control Phase
N#define _W6100_SPI_WRITE_                 (0x01 << 2)        ///< SPI interface Write operation in Control Phase
N
N#define WIZCHIP_CREG_BLOCK                (0x00   <<3)       ///< Common register block
N#define WIZCHIP_SREG_BLOCK(N)             ((1+4*N)<<3)       ///< SOCKETn register block
N#define WIZCHIP_TXBUF_BLOCK(N)            ((2+4*N)<<3)       ///< SOCKETn Tx buffer address block
N#define WIZCHIP_RXBUF_BLOCK(N)            ((3+4*N)<<3)       ///< SOCKETn Rx buffer address block
N
N#define WIZCHIP_OFFSET_INC(ADDR, N) (ADDR + (N<<8)) ///< Increase offset address
N
N#if (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)      
X#if ((0x0100 + 2) == (0x0100 + 2))      
N   #define IDM_AR0                        ((_WIZCHIP_IO_BASE_ + 0x0000))      ///< Indirect High Address Register
N   #define IDM_AR1                        ((_WIZCHIP_IO_BASE_ + 0x0001))      ///< Indirect Low Address Register
N   #define IDM_BSR                        ((_WIZCHIP_IO_BASE_ + 0x0002))      ///< Block Select Register
N   #define IDM_DR                         ((_WIZCHIP_IO_BASE_ + 0x0003))      ///< Indirect Data Register
N   #define _W6100_IO_BASE_       _WIZCHIP_IO_BASE_
N#elif (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
S   #define _W6100_IO_BASE_       0x00000000
N#endif
N
N
N//-----------       defgroup --------------------------------
N
N/**
N * @defgroup W6100 W6100
N * @brief @ref _WIZCHIP_ register defines and I/O functions
N * @details
N *   - @ref WIZCHIP_register_W6100 : @ref Common_register_group_W6100, @ref Socket_register_group_W6100
N *   - @ref WIZCHIP_IO_Functions_W6100 : @ref Basic_IO_function_W6100, @ref Common_register_access_function_W6100, @ref Socket_register_access_function_W6100
N */
N
N /**
N * @defgroup WIZCHIP_register_W6100 WIZCHIP register
N * @ingroup W6100
N * @brief @ref WIZCHIP_register_W6100 defines register group of @b W6100.
N * @details
N *   - @ref Common_register_group_W6100 : Common register group W6100
N *   - @ref Socket_register_group_W6100 : SOCKET n register group W6100
N */
N
N/**
N * @defgroup Basic_IO_function_W6100 Basic I/O function
N * @ingroup WIZCHIP_IO_Functions_W6100
N * @brief These are basic input/output functions to read values from register or write values to register.
N */
N
N/**
N * @defgroup Common_register_access_function_W6100 Common register access functions
N * @ingroup WIZCHIP_IO_Functions_W6100
N * @brief These are functions to access @ref Common_register_group_W6100.
N */
N
N/**
N * @defgroup Socket_register_access_function_W6100 Socket register access functions
N * @ingroup WIZCHIP_IO_Functions_W6100
N * @brief These are functions to access @ref Socket_register_group_W6100.
N */
N
N/**
N * @defgroup WIZCHIP_IO_Functions_W6100 WIZCHIP I/O functions
N * @ingroup W6100
N * @brief @ref WIZCHIP_IO_Functions_W6100 supports the basic I/O functions for @ref WIZCHIP_register_W6100.
N * @details
N *   - @ref WIZCHIP_IO_Functions_W6100 \n
N *     WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N *   - @ref Common_register_access_function_W6100 \n
N *     - @ref _WIZCHIP_ Mode \n
N *       getCIDR(), getVER() \n
N *       getSYSR()  \n
N *       setCHPLCKR(), setNETLCKR(), setPHYLCKR() \n
N *       setSYCR0(), getSYCR1(), setSYCR1()
N *     - Network Mode \n
N *       getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR(), getNETMR(), setNETMR(), getNETMR2(), setNETMR2()
N *     - Interrupt \n
N *       getIR(), setIRCLR(), getIMR(), setIMR() \n
N *       getSIR(), getSIMR(), setSIMR() \n
N *       getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR() \n
N *       getINTPTMR(), setINTPTMR()
N *     - Network Information \n
N *       NETLOCK(), NETUNLOCK() \n
N *       getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), setSUBR(), getSIPR(), setSIPR() \n
N *       getLLAR(), setLLAR(), getGUAR(), setGUAR(), getGA6R(), setGA6R(), getSUB6R(), setSUB6R() \n
N *       getPLR(), getPFR(), getVLTR(), getPLTR(), getPAR() \n
N *     - SOCKET-less Commands for PING, ARP and IPv6 Auto-Configuration \n
N *       getSLCR(), setSLCR() \n
N *       getPINGIDR(), setPINGIDR(), getPINGSEQR(), setPINGSEQR() \n
N *       getSLDHAR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLHOPR(), setSLHOPR() \n
N *     - Retransmission  \n
N *       getRCR(), setRCR() \n
N *       getSLRCR(), setSLRCR(), getSLRTR(), setSLRTR() \n
N *     - ICMP \n
N *       getUIPR(), getUIP6R(), getUPORTR(), getUPORT6R() \n
N *       getICMP6BLKR(), setICMP6BLKR() \n
N *     - PPPoE \n
N *       getPTMR(), setPTMR(), getPMNR(), getPMNR() \n
N *       getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR()
N *     - PHY Configuration \n
N *       getPHYSR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK() \n
N *       setPHYCR0(), getPHYCR1(), setPHYCR1() \n
N *       getPHYRAR(), setPHYRAR(), setPHYDIR(), getPHYDOR(), getPHYACR(), setPHYACR(), getPHYDIVR(), setPHYDIVR()
N *     - etc \n
N *       getTCNTR(), setTCNTRCLR()
N *   - @ref Socket_register_access_function_W6100 \n
N *     - SOCKET control \n
N *       getSn_MR(), setSn_MR(), getSn_MR2(), setSn_MR2(), getSn_PSR(), setSn_PSR(), getSn_CR(), setSn_CR() \n
N *       getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR()  \n
N *       getSn_RTR(), setSn_RTR(), getSn_RCR(), setSn_RCR(), getSn_KPALVTR(), setSn_KPALVTR()
N *     - SOCKET information \n
N *       getSn_SR(), getSn_ESR() \n
N *       getSn_DHAR(), setSn_DHAR(),  getSn_PORTR(), setSn_PORTR(), getSn_DPORTR(), setSn_DPORTR() \n
N *       getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R() \n
N *       getSn_MSSR(), setSn_MSSR()
N *     - SOCKET communication \n
N *       getSn_RX_BSR(), setSn_RX_BSR(), getSn_TX_BSR(), setSn_TX_BSR() \n
N *       getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR() \n
N *       getSn_RX_RD(), setSn_RX_RD(), getSn_RX_WR() \n
N *       getSn_TX_FSR(), getSn_RX_RSR()
N *     - IP header field \n
N *       getSn_FRGR(), setSn_FRGR(),  getSn_TOSR(), setSn_TOSR() \n
N *       getSn_TTLR(), setSn_TTLR()
N */
N
N/**
N * @defgroup Common_register_group_W6100 Common register
N * @ingroup WIZCHIP_register_W6100
N * @brief Common register group \n
N * @details It set the general configuration such as interrupt, network information, ICMP, and etc.
N * @sa
N * <table width=0>
N *    <tr><td> @ref _WIZCHIP_ Information   </td><td>: _CIDR_, _VER_                                                                   </td></tr>
N *    <tr><td> @ref _WIZCHIP_ Mode          </td><td>: _SYSR_, _SYCR0_, _SYCR1_, _CHPLCKR_, _NETLCKR_, _PHYLCKR_                       </td></tr>
N *    <tr><td> Network Mode                 </td><td>: _NET4MR_, _NET6MR_, _NETMR_, _NETMR2_                                           </td></tr>
N *    <tr><td> Network Information          </td><td>: _GAR_, _SUBR_, _SHAR_, _SIPR_, _GA6R_, _LLAR_, _GUAR_, _SUB6R_                  </td></tr>
N *    <tr><td> Interrupt                    </td><td>: _IR_, _IRCLR_, _IMR_, _SIR_, _SIMR_, _SLIR_, _SLIMR_, _SLIRCLR_, _INTPTMR_      </td></tr>
N *    <tr><td> Data retransmission          </td><td>: _RTR_, _RCR_, _SLRTR_, _SLRCR_, _SLHOPR_                                        </td></tr>
N *    <tr><td> PPPoE                        </td><td>: _PHAR_, _PSIDR_, _PMRUR_, _PTMR_, _PMNR_                                        </td></tr>
N *    <tr><td> SOCKET-less command          </td><td>: _SLCR_, _SLIR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _PINGIDR_, _PINGSEQR_ </td></tr>
N *    <tr><td> ICMP v4 & v6                 </td><td>: _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_, _ICMP6BLKR_                               </td></tr>
N *    <tr><td> IPv6 Auto-configuration      </td><td>: _PLR_, _PFR_, _VLTR_, _PAR_                                                     </td></tr>
N *    <tr><td> PHY Configuration            </td><td>: _PHYSR_, _PHYCR0_, _PHYCR1_, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYDIVR_  </td></tr>
N * </table>
N */
N 
N
N/**
N * @defgroup Socket_register_group_W6100 Socket register
N * @ingroup WIZCHIP_register_W6100
N * @brief Socket register group\n
N * @details
N * SOCKETn registers configure and control SOCKETn which is necessary to data communication.
N * @sa
N * <table width=0>
N *    <tr><td> SOCKETn Control       </td><td>: _Sn_MR_, _Sn_MR2_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, _Sn_PSR_                                </td></tr>
N *    <tr><td> SOCKETn Information   </td><td>: _Sn_SR_, _Sn_ESR_, _Sn_PORTR_, _Sn_DHAR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_                       </td></tr>
N *    <tr><td> SOCKETn Retransmission </td><td>: _Sn_RTR_, _Sn_RCR_                                                                                 </td></tr>
N *    <tr><td> Internet protocol     </td><td>: _Sn_MSSR_, _Sn_TOSR_, _Sn_TTLR_, _Sn_FRGR_                                                         </td></tr>
N *    <tr><td> Data communication    </td><td>: _Sn_RX_BSR_, _Sn_TX_BSR_, _Sn_TX_FSR_, _Sn_TX_RD_, _Sn_TX_WR_, _Sn_RX_RSR_, _Sn_RX_RD_, _Sn_RX_WR_ </td></tr>
N * </table>
N */
N
N//-----------------------------------------------------------------------------------
N
N//----------------------------- W6100 Common Registers IOMAP -----------------------------
N
N/**
N * @addtogroup Common_register_group_W6100
N * @{
N */
N
N/**
N * @brief Chip Identification Register address [RO] [0x6100]
N * @sa getCIDR()
N */
N#define _CIDR_               (_W6100_IO_BASE_ + (0x0000 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Chip Version Register address [RO] [0x4661]
N * @sa getVER()
N */
N#define _VER_                (_W6100_IO_BASE_ + (0x0002 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief System Status Register address [RO] [0xEU]
N * @details @ref _SYSR_ shows the information such as CHIP, NET, PHY Locking and Host I/F
N * <table>
N *    <tr> <td>7   </td> <td>6   </td> <td>5   </td> <td>4 ~ 2   </td> <td>1  </td> <td>0  </td> </tr>
N *    <tr> <td>CHPL</td> <td>NETL</td> <td>PHYL</td> <td>Reserved</td> <td>IND</td> <td>SPI</td> </tr>
N * </table>
N *  - @ref SYSR_CHPL 
N *  - @ref SYSR_NETL 
N *  - @ref SYSR_PHYL 
N *  - @ref SYSR_IND  : HOST use Parallel BUS Interface(Indirect Bus Mode)
N *  - @ref SYSR_SPI  : HOST use SPI Interface
N *
N * @sa _CHPLCKR_, _NETLCKR_, _PHYLCKR_, 
N * @sa getSYSR(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK() \n
N *        setPHYLCKR(), getPHYLCKR(), PHYLOCK(), PHYUNLOCK()
N */
N#define _SYSR_               (_W6100_IO_BASE_ + (0x2000 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief System Config Register 0 address [WO][0x80] 
N * @details @ref _SYCR0_ softly reset to _WIZCHIP_.
N * <table>
N *    <tr> <td>7  </td> <td>6 ~ 0   </td> </tr>
N *    <tr> <td>RST</td> <td>Reserved</td> </tr>
N * </table>
N *   - @ref SYCR0_RST : Software Reset.
N *
N * @note It can be accessed only when @ref SYSR_CHPL = 1.
N * @sa _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa setSYCR0(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SYCR0_              (_W6100_IO_BASE_ + (0x2004 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief System Config Register 1 address [R=W][0x80] 
N * @details @ref _SYCR1_ controls the global interrupt enable, and selects the system clock.
N * <table>
N *    <tr> <td>7  </td> <td>6 ~ 1   </td> <td>0     </td> </tr>
N *    <tr> <td>IEN</td> <td>Reserved</td> <td>CLKSEL</td> </tr>
N * </table>
N *   - @ref SYCR1_IEN
N *   - @ref SYCR1_CLKSEL
N *
N * @note SYCR1_CLKSEL bit can be accessed only when @ref SYSR_CHPL = 1.
N * @sa _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSYCR1(), setSYCR1(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SYCR1_              (WIZCHIP_OFFSET_INC(_SYCR0_,1))
N
N/**
N * @brief Ticker Counter Register address [RO][0x0000]
N * @details @ref _TCNTR_ increase by 1 every 100us after _WIZCHIP_ reset.
N * @sa _TCNTRCLR_
N * @sa getTCNTR(), setTCNTRCLR() 
N */
N#define _TCNTR_              (_W6100_IO_BASE_ + (0x2016 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Ticker Counter Clear Register address [RO][0x00]
N * @details @ref _TCNTRCLR_ clear @ref _TCNTR_.
N * @sa setTCNTRCLR(), getTCNTR()
N */
N#define _TCNTRCLR_           (_W6100_IO_BASE_ + (0x2020 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Interrupt Register address [RO][0x00]
N * @details @ref _IR_ indicates the interrupt status.
N *          If @ref _IR_ is not equal to x00 INTn PIN is asserted to low until it is x00.
N * 
N * <table>
N *    <tr> <td>7  </td> <td>6 ~ 5   </td> <td>4   </td> <td>3       </td> <td>2     </td> <td>1   </td> <td>0    </td> </tr>
N *    <tr> <td>WOL</td> <td>Reserved</td> <td>UNR6</td> <td>Reserved</td> <td>IPCONF</td> <td>UNR4</td> <td>PTERM</td> </tr>
N * </table>
N *  - @ref IR_WOL    : Wake On LAN
N *  - @ref IR_UNR6   : Destination Port Unreachable for IPv6
N *  - @ref IR_IPCONF : @ref _SIPR_ is Conflict
N *  - @ref IR_UNR4   : Destination Port Unreachable for IPv4
N *  - @ref IR_PTERM  : PPPoE Terminated
N *
N * @sa _IMR_, _IRCLR_, SYCR1_IEN, _CHIPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getIR(), setIRCLR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR() 
N */
N#define _IR_                 (_W6100_IO_BASE_ + (0x2100 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET Interrupt Register address [RO][0x00]
N * @details @ref _SIR_ indicates whether a socket interrupt is occurred or not.\n
N *          Each bit of @ref _SIR_ be still until @ref _Sn_IR_ is cleared by @ref _Sn_IRCLR_
N * @sa _SIMR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, SYCR1_IEN , _CHIPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSIR(), getSn_IR(), setSn_IRCLR(), getSIMR(), setSIMR(), getSn_IMR(), setSn_IMR(), getSYCR1(), setSYCR1(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SIR_                (_W6100_IO_BASE_ + (0x2101 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Interrupt Register address [RO][0x00]
N * @details @ref _SLIR_ indicates the completion of @ref _SLCR_ or timeout.
N * <table>
N *    <tr> <td>7   </td> <td>6   </td> <td>5    </td> <td>4   </td> <td>3    </td> <td>2 </td> <td>1 </td> <td>0 </td> </tr>
N *    <tr> <td>TOUT</td> <td>ARP4</td> <td>PING4</td> <td>ARP6</td> <td>PING6</td> <td>NS</td> <td>RS</td> <td>RA</td> </tr>
N * </table>
N *  - @ref SLIR_TOUT  : The timeout occurrence after @ref _SLCR_ is performed
N *  - @ref SLIR_ARP4  : The completion of @ref SLCR_ARP4
N *  - @ref SLIR_PING4 : The completion of @ref SLCR_PING4
N *  - @ref SLIR_ARP6  : The completion f @ref SLCR_ARP6
N *  - @ref SLIR_PING6 : The completion of @ref SLCR_PING6
N *  - @ref SLIR_NS    : The completion of @ref SLCR_NS
N *  - @ref SLIR_RS    : The completion of @ref SLIR_RS
N *  - @ref SLIR_RA    : The reception from Router Advertisement
N *
N * @sa _SLIRCLR_, _SLIMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSLIR(), setSLIRCLR(),  getSLIR(), getSLIMR(), setSLIMR(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SLIR_               (_W6100_IO_BASE_ + (0x2102 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Interrupt Mask Register address [R=W][0x00]
N * @details @ref _IMR_ is used to mask interrupts of @ref _IR_.\n
N *          When a bit of @ref _IMR_ and the corresponding bit of @ref _IR_ is set, an interrupt will be issued.
N * @sa _IR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getIMR(), setIMR(),  getIR(), setIRCLR(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _IMR_                (_W6100_IO_BASE_ + (0x2104 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief @ref _IR_  Clear Register address [WO][0x00]
N * @details @ref _IRCLR_ clears @ref _IR_
N * @sa _IR_, _IMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa setIRCLR(), getIR(), getIMR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _IRCLR_              (_W6100_IO_BASE_ + (0x2108 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET Interrupt Mask Register address [R=W]][0x00]
N * @details @ref _SIMR_ is used to mask interrupts of @ref _SIR_.\n
N *          When a bit of @ref _SIMR_ and the corresponding bit of @ref _SIR_ is set, an interrupt will be issued.\n
N *          when @ref _Sn_IR_ is not 0,  The N-th bit of @ref _SIR_ is set. Otherwise, this bit is automatically clear.\n
N * @sa _SIR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSIMR(), setSIMR(), getSIR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SIMR_               (_W6100_IO_BASE_ + (0x2114 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Interrupt Mask Register address [R=W][0x00]
N * @details @ref _SLIMR_ is used to mask interrupts of @ref _SLIR_\n
N *          When a bit of @ref _SLIMR_ and the corresponding bit of @ref _SLIR_ is set, an interrupt will be issued.
N * @sa _SLIR_, _SLIRCLR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSLIMR(), setSLIMR(), getSLIR(), setSLIRCLR(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SLIMR_              (_W6100_IO_BASE_ + (0x2124 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Interrupt Clear Register address [WO][0x00]
N * @details @ref _SLIRCLR_ clears @ref _SLIR_
N * @sa _SLIR_, _SLIRCLR_, _SLIMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SLIRCLR_            (_W6100_IO_BASE_ + (0x2128 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Prefer Source IPv6 Address Register address [R=W][0x00]
N * @details @ref _SLPSR_ select the Source IPv6 Address to transmit a packet by @ref _SLCR_.
N *   - @ref PSR_AUTO 
N *   - @ref PSR_LLA 
N *   - @ref PSR_GUA 
N * @sa _SLCR_, _Sn_PSR_
N * @sa getSLPSR(), setSLPSR(), getSLCR(), setSLCR(), getSn_PSR(), setSn_PSR()
N */
N#define _SLPSR_              (_W6100_IO_BASE_ + (0x212C << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Command Register address [RW,AC][0x00]
N * @details @ref _SLCR_ can be request a message such like as ARP, PING, and ICMPv6 without SOCKET.
N * <table>
N *    <tr> <td>7       </td> <td>6   </td> <td>5    </td> <td>4   </td> <td>3    </td> <td>2 </td> <td>1 </td> <td>0  </td> </tr>
N *    <tr> <td>Reserved</td> <td>ARP4</td> <td>PING4</td> <td>ARP6</td> <td>PING6</td> <td>NS</td> <td>RS</td> <td>UNA</td> </tr>
N * </table>
N *   - @ref SLCR_ARP4
N *   - @ref SLCR_PING4
N *   - @ref SLCR_ARP6
N *   - @ref SLCR_PING6
N *   - @ref SLCR_NS
N *   - @ref SLCR_RS
N *   - @ref SLCR_UNA
N *
N * @sa _SLIR_, _SLIMR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDIPR(),setSLDIPR(), getSLDIP4R(),setSLDIP4R(), 
N *     getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SLCR_               (_W6100_IO_BASE_ + (0x2130 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Status Register address [RO][0x00]
N * @details @ref _PHYSR_ shows the operation mode of PHY, the link status and etc.
N *   - @ref PHYSR_CAB  : @ref PHYSR_CAB_OFF, @ref PHYSR_CAB_ON
N *   - @ref PHYSR_MODE : @ref PHYSR_MODE_AUTO, @ref PHYSR_MODE_100F, @ref PHYSR_MODE_100H, @ref PHYSR_MODE_10F, @ref PHYSR_MODE_10H
N *   - @ref PHYSR_DPX  : @ref PHYSR_DPX_FULL, @ref PHYSR_DPX_HALF
N *   - @ref PHYSR_SPD  : @ref PHYSR_SPD_100M, @ref PHYSR_SPD_10M
N *   - @ref PHYSR_LNK  : @ref PHYSR_LNK_UP, @ref PHYSR_LNK_DOWN
N *
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL
N * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), getPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
N */
N#define _PHYSR_              (_W6100_IO_BASE_ + (0x3000 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Internal Register Address Register address(R/W)
N * @details @ref _PHYRAR_ specifies the address of register in the Ethernet PHY.
N *   - @ref PHYRAR_BMCR
N *   - @ref PHYRAR_BMSR
N * @sa _PHYACR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
N * @sa getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
N */
N#define _PHYRAR_             (_W6100_IO_BASE_ + (0x3008 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Data Input Register address [R=W][0x00]
N * @details @ref _PHYDIR_ specifies the value to write to the register in PHY
N * @sa _PHYRAR_, _PHYACR_, _PHYDOR_, _PHYDIVR_
N * @sa setPHYDIR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
N */
N#define _PHYDIR_             (_W6100_IO_BASE_ + (0x300C << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Data Output Register address [WO][0x00]
N * @details @ref _PHYDOR_ read the value from the register in PHY
N * @sa _PHYRAR_, _PHYACR_, _PHYDIR_, _PHYDIVR_
N * @sa getPHYDOR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
N */
N#define _PHYDOR_             (_W6100_IO_BASE_ + (0x3010 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Access Register address [RW,AC][0x00]
N * @details @ref _PHYACR_ write(read)  to(from) the value of register in the Ethernet PHY
N *   - @ref PHYACR_READ
N *   - @ref PHYACR_WRITE
N * @sa _PHYRAR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
N * @sa getPHYACR(), setPHYACR(), getPHYDOR(), getPHYRAR(), setPHYRAR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
N */
N#define _PHYACR_             (_W6100_IO_BASE_ + (0x3014 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY's MDC Clock Division Register address [R=W][0x01]
N * @details @ref _PHYDIVR_ divides the system clock for the MDC clock of Ethernet PHY'
N *   - @ref PHYDIVR_32
N *   - @ref PHYDIVR_64
N *   - @ref PHYDIVR_128
N * @sa _PHYRAR_, _PHYACR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
N * @sa getPHYDIVR(), setPHYDIVR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR()
N */
N#define _PHYDIVR_            (_W6100_IO_BASE_ + (0x3018 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Control Register address [WO][0x00]
N * @details @ref _PHYCR0_ controls the operation mode of PHY.
N *          The result will be checked by @ref _PHYSR_ after PHY HW reset by @ref PHYCR1_RST.
N *   - @ref PHYCR0_AUTO
N *   - @ref PHYCR0_100F
N *   - @ref PHYCR0_100H
N *   - @ref PHYCR0_10F
N *   - @ref PHYCR0_10H
N *
N * @note It can be only accessed when @ref SYSR_PHYL is unlock.  
N * @sa _SYSR_, _PHYCR1_
N * @sa setPHYCR0(), getSYSR(), getPHYCR1(), setPHYCR1() 
N */
N#define _PHYCR0_             (_W6100_IO_BASE_ + (0x301C << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Control Register address [R=W][0x40]
N * @details @ref _PHYCR1_ controls the Ethernet PHY function such as HW reset, Power down and etc.
N * <table>
N *    <tr> <td>7       </td> <td>6       </td> <td>5   </td> <td>4      </td> <td>3 </td> <td>2 ~ 1   </td> <td>0  </td> </tr>
N *    <tr> <td>Reserved</td> <td>Always 1</td> <td>PWDN</td> <td>Reseved</td> <td>TE</td> <td>Reserved</td> <td>RST</td> </tr>
N * </table>
N *   - @ref PHYCR1_PWDN
N *   - @ref PHYCR1_TE
N *   - @ref PHYCR1_RST
N *
N * @note It can be only accessed when @ref SYSR_PHYL is unlock.  
N * @sa _SYSR_, _PHYCR0_
N * @sa getPHYCR1(), setPHYCR1(), setPHYCR0(), getSYSR() 
N */
N#define _PHYCR1_             WIZCHIP_OFFSET_INC(_PHYCR0_,1)
N
N/**
N * @brief Network IPv4 Mode Register address [R=W][0x00]
N * @details @ref _NET4MR_ can block the transmission such like as unreachable message, TCP reset, and ping relay.\n
N *          It can ARP request before ping relpy.
N *
N * <table>
N *    <tr> <td>7 ~ 4   </td> <td>3   </td> <td>2   </td> <td>1   </td> <td>0 </td> </tr>
N *    <tr> <td>Reserved</td> <td>UNRB</td> <td>PARP</td> <td>RSTB</td> <td>PB</td> </tr>
N * </table>
N *   - @ref NETxMR_UNRB
N *   - @ref NETxMR_PARP
N *   - @ref NETxMR_RSTB
N *   - @ref NETxMR_PB
N * @sa _NET6MR_
N * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
N */
N#define _NET4MR_             (_W6100_IO_BASE_ + (0x4000 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Network IPv6 Mode Register address [R=W][0x00]
N * @details @ref _NET6MR_ can block the transmission such like as unreachable message, TCP reset, and ping relay.\n
N *          It can ARP request before ping reply.
N *
N * <table>
N *    <tr> <td>7 ~ 4   </td> <td>3   </td> <td>2   </td> <td>1   </td> <td>0 </td> </tr>
N *    <tr> <td>Reserved</td> <td>UNRB</td> <td>PARP</td> <td>RSTB</td> <td>PB</td> </tr>
N * </table>
N *   - @ref NETxMR_UNRB
N *   - @ref NETxMR_PARP
N *   - @ref NETxMR_RSTB
N *   - @ref NETxMR_PB
N * @sa _NET4MR_
N * @sa getNET6MR(), setNET6MR(), getNET4MR(), setNET4MR() 
N */
N#define _NET6MR_             (_W6100_IO_BASE_ + (0x4004 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Network Mode Register address [R=W][0x00]
N * @details @ref _NETMR_ set WOL(Wake On Lan) mode.\n
N *          It also can block a packet such as \n
N *          IPv6 PING request from an all-node broadcasting, \n
N *          IPv6 PING request from a solicited mulitcasting address,\n
N *          IPv4 packets, \n
N *          and IPv6 packets.
N * 
N * <table>
N *    <tr> <td>7 ~ 6   </td> <td>5  </td> <td>4  </td> <td>3       </td> <td>2  </td> <td>1   </td> <td>0  </td> </tr>
N *    <tr> <td>Reserved</td> <td>ANB</td> <td>M6B</td> <td>Always 0</td> <td>WOL</td> <td>IP6B</td> <td>IP4B</td> </tr> 
N * </table>
N * - @ref NETMR_ANB
N * - @ref NETMR_M6B
N * - @ref NETMR_WOL
N * - @ref NETMR_IP6B
N * - @ref NETMR_IP4B
N * @sa getNETMR(), setNETMR()
N *
N */
N#define _NETMR_              (_W6100_IO_BASE_ + (0x4008 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Network Mode Register 2 address [R=W][0x00]
N * @details @ref _NETMR2_ set PPPoE mode.\n
N *          It also can select the destination hardware address to either Ethernet frame MAC or target MAC in the ARP-reply message
N * <table>
N *    <tr> <td>7   </td> <td>6 ~ 1</td> <td>0    </td> </tr>
N *    <tr> <td>DHAS</td> <td>6 ~ 1</td> <td>PPPoE</td> </tr>
N * </table>
N *   - @ref NETMR2_DHAS : @ref NETMR2_DHAS_ARP, @ref NETMR2_DHAS_ETH
N *   - @ref NETMR2_PPPoE
N * @sa getNETMR2(), setNETMR2()
N */
N#define _NETMR2_             (_W6100_IO_BASE_ + (0x4009 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PPP LCP request Timer Register address [R=W][0x28]
N * @details @ref _PTMR_ sets the time for sending LCP echo request.\n
N *          The unit of time is 25ms.
N * @sa _PMNR_, _PHAR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
N * @sa getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
N */
N#define _PTMR_               (_W6100_IO_BASE_ + (0x4100 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PPP LCP Magic Number Register address [R=W][0x00]
N * @details @ref _PMNR_ sets the 4bytes magic number to be used in LCP negotiation.
N * @sa _PTMR_, _PHAR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
N * @sa getPMNR(), setPMNR(), getPTMR(), setPTMR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
N */
N#define _PMNR_               (_W6100_IO_BASE_ + (0x4104 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PPPoE Hardware Address Register address [R=W][0x00]
N * @details @ref _PHAR_ sets the PPPoE server hardware address that is acquired during PPPoE connection process.
N * @sa _PTMR_, _PMNR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
N * @sa getPHAR(), setPHAR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
N */
N#define _PHAR_               (_W6100_IO_BASE_ + (0x4108 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PPP Session ID Register address [R=W][0X0000]
N * @details @ref  _PSIDR_ sets the PPPoE sever session ID acquired during PPPoE connection process.
N * @sa _PTMR_, _PMNR_, _PHAR_, _PMRUR_, NETMR2_PPPoE
N * @sa getPSIDR(), setPSIDR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
N */
N#define _PSIDR_              (_W6100_IO_BASE_ + (0x4110 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PPP Maximum Receive Unit Register address [R=W][0xFFFF]
N * @details @ref _PMRUR_ sets the maximum receive unit of PPPoE.
N * @sa _PTMR_, _PMNR_, _PHAR_, _PSIDR_, NETMR2_PPPoE
N * @sa  getPMRUR(), setPMRUR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getNETMR2(), setNETMR2()
N */
N#define _PMRUR_              (_W6100_IO_BASE_ + (0x4114 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Source Hardware Address Register address [R=W][00:00:00:00:00:00]
N * @details @ref _SHAR_ sets the source hardware address.
N * @note It can be accessed only when @ref SYSR_NETL is unlock.
N * @sa SYSR_NETL, _NETLCKR_
N * @sa getSHAR(), setSHAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK()
N */
N#define _SHAR_               (_W6100_IO_BASE_ + (0x4120 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv4 Gateway Address Register address [R=W][0.0.0.0]
N * @details @ref _GAR_ sets the default gateway IPv4 address.
N * @note It can be accessed only when @ref SYSR_NETL is unlock.
N * @sa SYSR_NETL, _NETLCKR_, _GA6R_
N * @sa getGAR(), setGAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getGA6R(), setGA6R()
N */
N#define _GAR_                (_W6100_IO_BASE_ + (0x4130 << 8) + WIZCHIP_CREG_BLOCK)
N#define _GA4R_               (_GAR_)      ///< Refer to @ref _GAR_
N/**
N * @brief IPv4 Subnet Mask Register address [R=W][0.0.0.0]
N * @details @ref _SUBR_ sets the default subnet mask address of IPv4.
N * @note It can be accessed only when @ref SYSR_NETL is unlock. 
N * @sa SYSR_NETL, _NETLCKR_, _SUB6R_
N * @sa getSUBR(), setSUBR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getSUB6R(), setSUB6R()
N */
N#define _SUBR_               (_W6100_IO_BASE_ + (0x4134 << 8) + WIZCHIP_CREG_BLOCK)
N#define _SUB4R_              (_SUBR_)      ///< Refer to @ref _SUBR_
N
N/**
N * @brief IPv4 Source IP Register address [R=W][0.0.0.0]
N * @details @ref _SIPR_ sets the source IPv4 address.
N * @note It can be accessed only when @ref SYSR_NETL is unlock. 
N * @sa SYSR_NETL, _NETLCKR_, _LLAR_, _GUAR_
N * @sa getSIPR(), setSIPR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getLLAR(), setLLAR(), getGUAR(),setGUAR()
N */
N#define _SIPR_               (_W6100_IO_BASE_ + (0x4138 << 8) + WIZCHIP_CREG_BLOCK)
N#define _SIP4R_              (_SIPR_)   ///< Refer to @ref _SIPR_.
N
N/**
N * @brief IPv6 LLA(Link Local Address) Register address [R=W][::]
N * @details @ref _LLAR_ sets the LLA address of IPv6.
N * @note It can be accessed only when @ref SYSR_NETL is unlock. 
N * @sa SYSR_NETL, _NETLCKR_, _GUAR_, _SIPR_
N * @sa getLLAR(), setLLAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getGUAR(),setGUAR(), getSIPR(), setSIPR()
N */
N#define _LLAR_               (_W6100_IO_BASE_ + (0x4140 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv6 GUA(Global Unicast Address) Register address [R=W][::]
N * @details @ref _GUAR_ sets the GUA address of IPv6.
N * @note It can be accessed only when @ref SYSR_NETL is unlock.  
N * @sa SYSR_NETL, _NETLCKR_, _LLAR_, _SIPR_
N * @sa getGUAR(), setGUAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getLLAR(),setLLAR(), getSIPR(), setSIPR()
N */
N#define _GUAR_               (_W6100_IO_BASE_ + (0x4150 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv6 Subnet Mask Register address [R=W][]
N * @details @ref _SUB6R_ sets the default subnet mask address of IPv6.
N * @note It can be accessed only when @ref SYSR_NETL is unlock. 
N * @sa SYSR_NETL, _NETLCKR_, _SUBR_
N * @sa getSUB6R(), setSUB6R(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getSUBR(), setSUBR()
N */
N#define _SUB6R_              (_W6100_IO_BASE_ + (0x4160 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv6 Gateway Address Register address [R/W][::]
N * @details @ref _GA6R_ sets the default gateway IPv6 address.
N * @sa _GAR_
N * @sa getGA6R(), setGA6R(), getGAR(), setGAR()
N */
N#define _GA6R_               (_W6100_IO_BASE_ + (0x4170 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Peer IPv6 Register address [R=W][::]
N * @details @ref _SLDIP6R_ sets the destination IP address of @ref _SLCR_.
N * @sa _SLDIP6R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_, _SLDHAR_, _SLDIPR_, _SLDIP4R_
N * @sa getSLDIP6R(), setSLDIP6R(), getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDHAR(),
N *     getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R()
N */
N#define _SLDIP6R_            (_W6100_IO_BASE_ + (0x4180 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Peer IPv6 Register address [R=W][0.0.0.0]
N * @details @ref _SLDIPR_(= @ref _SLDIP4R_) sets the destination IPv4 address of @ref _SLCR_.
N * @sa _SLDIP4R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_, _SLDHAR_, _SLDIP6R_
N * @sa getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDHAR(),
N *     getSLDIP6R(), setSLDIP6R()
N */
N#define _SLDIPR_             (_W6100_IO_BASE_ + (0x418C << 8) + WIZCHIP_CREG_BLOCK)
N#define _SLDIP4R_            (_SLDIPR_)            ///< Refer to @ref _SLDIPR_.
N
N
N/**
N * @brief SOCKET-less Peer Hardware Address Register address [RO][00:00:00:00:00:00]
N * @details @ref _SLDHAR_ gets the destination hardware address acquired by of @ref SLCR_ARP4, SLCR_ARP6, SLCR_PING4, and SLCR_PING6.
N * @sa _SLDIP4R_, _SLDIP6R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_
N * @sa getSLDHAR(), getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLCR(), setSLCR(), \n
N *     getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR() 
N */
N#define _SLDHAR_             (_W6100_IO_BASE_ + (0x4190 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Ping ID Register address [R=W][0x00]
N * @details @ref _PINGIDR_ sets the PING-request ID to be sent by @ref SLCR_PING4 or @ref SLCR_PING6.
N * @sa _SLCR_, _PINGSEQR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLIMR_
N * @sa getPINGIDR(), setPINGIDR(), getSLCR(), setSLCR(), getPINGSEQR(), setPINGSEQR(), getSLDIPR(), setSLDIPR(), 
N *     getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR()
N */
N#define _PINGIDR_            (_W6100_IO_BASE_ + (0x4198 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less ping Sequence number Register address [R=W][0x0000]
N * @details @ref _PINGIDR_ sets the PING-request sequence number to be sent by @ref SLCR_PING4 or @ref SLCR_PING6.
N * @sa _SLCR_, _PINGIDR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLIMR_
N * @sa getPINGSEQR(), setPINGSEQR(), getSLCR(), setSLCR(), getPINGIDR(), setPINGIDR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(),
N *     getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR()
N */
N#define _PINGSEQR_           (_W6100_IO_BASE_ + (0x419C << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv4 Unreachable Address Register address [RO][0.0.0.0]
N * @details @ref _UIPR_ is set when a unreachable ICMPv4 message is received.
N * @sa _UPORTR_, _UIP6R_, _UPORT6R_
N * @sa getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUIPR6(), setUIPR6(), getUPORT6R(), setUPORT6R()
N */
N#define _UIPR_               (_W6100_IO_BASE_ + (0x41A0 << 8) + WIZCHIP_CREG_BLOCK)
N#define _UIP4R_              (_UIPR_)   ///< Refer to @ref _UPORTR_
N
N/**
N * @brief IPv4 Unreachable Port number Register address [RO][0x0000]
N * @details @ref _UPORTR_ is set when a unreachable ICMPv4 message is received.
N * @sa _UIPR_, _UIP6R_, _UPORT6R_
N * @sa getUPORTR(), setUPORTR(), getUIPR(), setUIPR(), getUIPR6(), setUIPR6(), getUPORT6R(), setUPORT6R()
N */
N#define _UPORTR_             (_W6100_IO_BASE_ + (0x41A4 << 8) + WIZCHIP_CREG_BLOCK)
N#define _UPORT4R_            (_UPORTR_)   ///< Refer to @ref _UPORTR_
N/**
N * @brief IPv6 Unreachable IP Address Register address [RO][::]
N * @details @ref _UIP6R_ is set when a unreachable ICMPv6 message is received.
N * @sa _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_
N * @sa getUIPR6(), setUIPR6(), getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUPORT6R(), setUPORT6R()
N */
N#define _UIP6R_              (_W6100_IO_BASE_ + (0x41B0 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv6 Unreachable Port number Register address [RO][0x0000]
N * @details @ref _UIP6R_ is set when a unreachable ICMPv6 message is received.
N * @sa _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_
N * @sa getUIPR6(), setUIPR6(), getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUPORT6R(), setUPORT6R()
N */
N#define _UPORT6R_            (_W6100_IO_BASE_ + (0x41C0 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Interrupt Pending Time Register address [R=w][0x0000]
N * @details @ref _INTPTMR_ pends the next interrupt issued by the INTn pin of @ref _WIZCHIP_.\n
N *          It is decreased 1 every 4 SYS_CLK. \n
N *          If it is zero and some interrupt is still remained, the INTn pin is issued.
N * @sa _IR_, _IRCLR_, _IMR_, _SIR_, _Sn_IRCLR_, _SIMR_, _SLIR_, _SLIRCLR_, _SLIMR_, SYCR_IEN
N * @sa getINTPTMR(), setINTPTMR(), getIR(), setIRCLR(), getIMR(), setIMR(), getSIR(), setSn_IRCLR(), getSIMR(), setSIMR(), \n
N *     getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSYCR1(), setSYCR1()
N */
N#define _INTPTMR_            (_W6100_IO_BASE_ + (0x41C5 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief RA Prefix Length Register address [RO][0x00]
N * @details @ref _PLR_ is set when RA packet is received from a router.
N * @sa SLIR_RA, _SLIRCLR_, _PFR_, _VLTR_, _PLTR_, _PAR_
N * @sa getPLR(), getSLIR(), setSLIRCLR(), getPFR(), getVLTR(), getPLTR(), getPAR()
N */
N#define _PLR_                (_W6100_IO_BASE_ + (0x41D0 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief RA Prefix Flag Register address [RO][0x00]
N * @details @ref _PFR_ is set when RA packet is received from a router.
N * @sa SLIR_RA, _SLIRCLR_, _PLR_, _VLTR_, _PLTR_, _PAR_
N * @sa getPFR(), getSLIR(), setSLIRCLR(), getPLR(), getVLTR(), getPLTR(), getPAR()
N */
N#define _PFR_                (_W6100_IO_BASE_ + (0x41D4 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief RA Valid Life Time Register address [RO][0x00000000]
N * @details @ref _VLTR_ is set when RA packet is received from a router.
N * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _PLTR_, _PAR_
N * @sa getVLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(),  getPLTR(), getPAR()
N */
N#define _VLTR_               (_W6100_IO_BASE_ + (0x41D8 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief RA Prefered Life Time Register address [RO][0x00000000]
N * @details @ref _PLTR_ is set when RA packet is received from a router.
N * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _PLTR_, _PAR_
N * @sa getPLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(), getVLTR(), getPAR()
N */
N#define _PLTR_               (_W6100_IO_BASE_ + (0x41DC << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief RA Prefix Address Register address[RO][::]
N * @details @ref _PAR_ is set when RA packet is received from a router.
N * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _VLTR_, _PLTR_, _PAR_
N * @sa getPAR(), getPLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(), getVLTR() 
N */
N#define _PAR_                (_W6100_IO_BASE_ + (0x41E0 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief ICMPv6 Block Register address [R=W][0x00]
N * @details @ref _ICMP6BLKR_ can block ICMPv6 message such like as PING, MLD, RA, NS and NA.\n
N *          In this blocked case, @ref Sn_MR_IPRAW6 SOCKET can receive it.
N * <table>
N *    <tr> <td>7 ~ 5</td> <td>4    </td> <td>3  </td> <td>2 </td> <td>1 </td> <td>0 </td> </tr>
N *    <tr> <td>7 ~ 5</td> <td>PING6</td> <td>MLD</td> <td>RA</td> <td>NA</td> <td>NS</td> </tr>
N * </table>
N *   - @ref ICMP6BLKR_PING6 : The same as @ref NETxMR_PB
N *   - @ref ICMP6BLKR_MLD
N *   - @ref ICMP6BLKR_RA
N *   - @ref ICMP6BLKR_NA
N *   - @ref ICMP6BLKR_NS
N *
N * @note The blocked message can be accepted by SOCKETn opened with @ref Sn_MR_IPRAW6.
N * @sa NETxMR_PB
N * @sa getICMP6BLKR(), setICMP6BLKR(), getNET6MR(), setNET6MR()
N */
N#define _ICMP6BLKR_          (_W6100_IO_BASE_ + (0x41F0 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Chip configuration Lock Register address [WO][0x00]
N * @details @ref _CHPLCKR_ can lock or unlock to access @ref _SYCR0_ and @ref _SYCR1_.\n
N *          The lock state can be checked from @ref SYSR_CHPL.
N * @sa _SYCR0_, _SYCR1_, _SYSR_, SYSR_CHPL
N * @sa getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _CHPLCKR_            (_W6100_IO_BASE_ + (0x41F4 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Network configuration Lock Register address [WO][0x00]
N * @details @ref _NETLCKR_ can lock or unlock to access the network information register such as @ref _SIPR_, @ref _LLAR_, and etc.\n
N *          The lock state can be checked from @ SYSR_NETL.
N * @sa _SHAR_, _SIPR_, _SUBR_, _GAR_, _LLAR_, _GUAR_, _SUB6R_, _SYSR_, SYSR_NETL
N * @sa getNETLCKR(), setNETLCKR(), NETLOCK(), NETUNLOCK(), getSHAR(), setSHAR(), getSIPR(), getSIPR(), getSUBR(), setSUBR(), \n
N *     getGAR(), setGAR(), getLLAR(), setLLAR(), getGUAR(), setGUAR(), getSUB6R(), setSUB6R(), getSYSR()
N */
N#define _NETLCKR_            (_W6100_IO_BASE_ + (0x41F5 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY configuration Lock Register address [WO][0x00]
N * @details @ref _PHYLCKR_ can lock or unlock to access @ref _PHYCR0_ and @ref _PHYCR1_.\n
N *          The lock state can be checked from @ref SYSR_PHYL.
N * @sa _PHYCR0_, _PHYCR1_, _SYSR_, SYSR_PHYL.
N * @sa getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), setPHYCR0(), getPHYCR1(), setPHYCR1(), getSYSR()
N */
N#define _PHYLCKR_            (_W6100_IO_BASE_ + (0x41F6 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Retransmission Time Register address [R=W][0x07D0]
N * @details @ref _RTR_ sets the default timeout value of @ref _Sn_RTR_.\n
N *          When @ref _Sn_RTR_ is 0, @ref _Sn_RTR_ is reset to @ref _RTR_ after @ref Sn_CR_OPEN.
N * @sa _Sn_RTR_, _RCR_, _Sn_RCR_, _Sn_CR_, Sn_CR_OPEN, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
N * @sa getRTR(), setRTR(), getSn_RTR(), setSn_RTR(), getRCR(), setRCR(), getSn_RCR(), setSn_RCR(),  \n
N *     getSn_CR(), getSn_CR(), getSn_IR(), setSn_IRCLR()
N */
N#define _RTR_                (_W6100_IO_BASE_ + (0x4200 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Retransmission Counter Register address [R=W][0x08]
N * @details @ref _RCR_ sets the default retransmission count of @ref _Sn_RCR_.\n
N *          When @ref _Sn_RCR_ is 0, @ref _Sn_RCR_ is initialized as @ref _Sn_RTR_ after @ref Sn_CR_OPEN.
N * @sa _Sn_RCR_, _RTR_, _Sn_RTR_, _Sn_CR_, Sn_CR_OPEN, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
N * @sa getRCR(), setRCR(), getSn_RCR(), setSn_RCR(), getRTR(), setRTR(), getSn_RTR(), setSn_RTR(), \n 
N *     getSn_CR(), getSn_CR(), getSn_IR(), setSn_IRCLR()
N */
N#define _RCR_                (_W6100_IO_BASE_ + (0x4204 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Retransmission Time Register address [R=W][0x07D0]
N * @details @ref _SLRTR_ sets the timeout value of packet to be retransmitted by @ref _SLCR_.
N * @sa _SLRCR_, _SLIR_, _SLIRCLR_, SLIR_TOUT
N * @sa getSLRTR(), setSLRTR(), getSLRCR(), setSLRCR(), getSLIR(), setSLIRCLR() 
N */
N#define _SLRTR_              (_W6100_IO_BASE_ + (0x4208 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Retransmission Count Register address [R=W][0x00]
N * @details @ref _SLRCR_ sets the retry counter of packet to be retransmitted by @ref _SLCR_.
N * @sa _SLRTR_, _SLIR_, _SLIRCLR_, SLIR_TOUT
N * @sa getSLRCR(), setSLRCR(), getSLRTR(), setSLRTR(), setSLIRCLR(), getSLIR(), setSLIRCLR(),
N */
N#define _SLRCR_              (_W6100_IO_BASE_ + (0x420C << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Hop Limit Register address [R=W][0x80]
N * @details @ref _SLHOPR_ sets the hop limit value of packet to be transmitted by @ref _SLCR_.
N * @sa _SLCR_
N * @sa getSLHOPR(), setSLHOPR(), getSLCR(), setSLCR()
N */
N#define _SLHOPR_             (_W6100_IO_BASE_ + (0x420F << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @}
N */
N
N//----------------------------- W6100 Socket Registers -----------------------------
N/**
N * @addtogroup Socket_register_group_W6100
N * @{
N */
N/**
N * @brief Socket Mode Register Address [R=W][0x00]
N * @details @ref _Sn_MR_ sets the option or protocol type of SOCKETn before @ref Sn_CR_OPEN is performed.\n\n
N *          Each bit of @ref _Sn_MR_ is defined as the following.
N * <table>
N *    <tr> <td>7       </td> <td>6        </td> <td>5            </td> <td>4        </td> <td>3 ~ 0 </td> </tr>
N *    <tr> <td>MULTI/MF</td> <td>BRDB/FPSH</td> <td>ND/MC/SMB/MMB</td> <td>UNIB/MMB6</td> <td>P[3:0]</td> </tr>
N * </table>
N *   - @ref Sn_MR_MULTI : Support UDP Multicasting
N *   - @ref Sn_MR_MF    : Support MAC Filter Enable
N *   - @ref Sn_MR_BRDB  : Broadcast Block
N *   - @ref Sn_MR_FPSH  : Force PSH flag
N *   - @ref Sn_MR_ND    : No Delay ACK flag
N *   - @ref Sn_MR_MC    : IGMP ver2, ver1
N *   - @ref Sn_MR_SMB   : Solicited Multicast Block
N *   - @ref Sn_MR_MMB   : IPv4 Multicast block
N *   - @ref Sn_MR_UNIB  : Unicast Block
N *   - @ref Sn_MR_MMB6  : IPv6 UDP Multicast Block
N *   - <b>P[3:0]</b>
N * <table>
N *    <tr> <td> P[3:0] </td> <td> Protocol Mode  </td> </tr>
N *    <tr> <td> 0000   </td> <td> SOCKET Closed  </td> </tr>
N *    <tr> <td> 0001   </td> <td> TCP4           </td> </tr>
N *    <tr> <td> 0010   </td> <td> UDP4           </td> </tr>
N *    <tr> <td> 0011   </td> <td> IPRAW4         </td> </tr>
N *    <tr> <td> 0100   </tr> <td> MACRAW         </td> </tr>
N *    <tr> <td> 1001   </td> <td> TCP6           </td> </tr>
N *    <tr> <td> 1010   </td> <td> UDP6           </td> </tr>
N *    <tr> <td> 1100   </td> <td> IPRAW6         </td> </tr>
N *    <tr> <td> 1101   </td> <td> TCP Dual(TCPD) </td> </tr>
N *    <tr> <td> 1110   </td> <td> UDP Dual (UDPD)</td> </tr>
N * </table>
N *   - @ref Sn_MR_CLOSE                      : SOCKET Closed
N *   - @ref Sn_MR_TCP4(= @ref Sn_MR_TCP)     : TCP4 mode
N *   - @ref Sn_MR_UDP4(= @ref Sn_MR_UDP)     : UDP4 mode
N *   - @ref Sn_MR_IPRAW4(= @ref Sn_MR_IPRAW) : IPRAW4 mode
N *   - @ref Sn_MR_MACRAW                     : MACRAW mode
N *   - @ref Sn_MR_TCP6                       : TCP6 mode
N *   - @ref Sn_MR_UDP6                       : UDP6 mode
N *   - @ref Sn_MR_IPRAW6                     : IPRAW6 mode
N *   - @ref Sn_MR_TCPD                       : TCP Dual (TCPD) mode
N *   - @ref Sn_MR_UDPD                       : UDP Dual (UDPD) mode
N *
N * @note MACRAW mode should be only used in Socket 0.
N * @sa _Sn_CR_, Sn_CR_OPEN, _Sn_SR_, _Sn_MR2_
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR(), getSn_MR2(), setSn_MR2()
N */
N#define _Sn_MR_(N)           (_W6100_IO_BASE_ + (0x0000 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKET n Prefer Source IPv6 Address Register Address [R=W][0x00]
N * @details @ref _Sn_PSR_ select the Source IPv6 Address to transmit a packet by @ref _Sn_CR_.
N * This function is same as @ref _SLPSR_.
N *   - @ref PSR_AUTO 
N *   - @ref PSR_LLA 
N *   - @ref PSR_GUA 
N * @sa _Sn_CR_, _Sn_PSR_, _SLPSR_
N * @sa getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSLPSR(), setSLPSR(), 
N */
N #define _Sn_PSR_(N)         (_W6100_IO_BASE_ + (0x0004 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief Socket Command Register Address [RW,AC][0x00]
N * @details @ref _Sn_CR_ is used to set the command for SOCKET n such as OPEN, CLOSE, CONNECT, LISTEN, SEND, and RECEIVE.\n
N *          It is automatically cleared to 0x00 after the command is recognized by @ref _WIZCHIP_.\n
N *          Even though @ref _Sn_CR_ is cleared to 0x00, the command is still being processed.\n
N *          To check whether the command is completed or not, please check the @ref _Sn_IR_ or @ref _Sn_SR_.
N *   - @ref Sn_CR_OPEN            : Initialize or open socket.
N *   - @ref Sn_CR_LISTEN       : Wait connection request on TCP4/TCP6/TCPD mode(<b>Server mode</b>)
N *   - @ref Sn_CR_CONNECT      : Send connection request on TCP4/TCPD mode(<b>Client mode</b>)
N *   - @ref Sn_CR_CONNECT6  : Send connection request on TCP6/TCPD mode(<b>Client mode</b>):nohl
N *   - @ref Sn_CR_DISCON       : Send closing request on TCP/TCP6/TCPD mode.
N *   - @ref Sn_CR_CLOSE        : Close socket.
N *   - @ref Sn_CR_SEND            : Update TX buffer pointer and send data in IPv4 socket.
N *   - @ref Sn_CR_SEND6        : Update TX buffer pointer and send data in IPv6 socket.
N *   - @ref Sn_CR_SEND_KEEP : Send keep alive message.
N *   - @ref Sn_CR_RECV            : Update RX buffer pointer and receive data.
N *
N * @note These commands should be exclusive executed.\n That is, the other command can not executed when one command is not cleared yet.
N * @sa _Sn_IR_, _Sn_IRCLR_, Sn_IMR_, _SIR_, _Sn_SR_
N * @sa getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), getSIR(), getSn_SR()
N */
N#define _Sn_CR_(N)           (_W6100_IO_BASE_ + (0x0010 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Interrupt Register Address [RO][0x00]
N * @details @ref _Sn_IR_ gets the status of SOCKETn interrupt such as establishment, termination, receiving data, timeout.\n
N *          If SOCKETn interrupt occurs and the n-th bit of @ref _SIMR_ is set, then @ref SIR_INT(n) is set.\n
N *          In order to clear the @ref _Sn_IR_ bit, Set the corresponding bit of _Sn_IRCLR_ to 1.\n
N *          If all @ref _Sn_IR_ bits are cleared, the @ref SIR_INT(n) is automatically cleared.
N * <table>
N *     <tr> <td>7 ~ 5   </td> <td>4     </td> <td>3      </td> <td>2   </td> <td>1     </td> <td>0  </td> </tr>
N *     <tr> <td>Reserved</td> <td>SENDOK</td> <td>TIMEOUT</td> <td>RECV</td> <td>DISCON</td> <td>CON</td> </tr>
N * </table>
N *   - @ref Sn_IR_SENDOK 
N *   - @ref Sn_IR_TIMEOUT 
N *   - @ref Sn_IR_RECV 
N *   - @ref Sn_IR_DISCON 
N *   - @ref Sn_IR_CON 
N *  
N * @sa _Sn_IRCLR_, _Sn_IMR_, _SIR_, _SIMR_
N * @sa getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), getSIR(), getSIMR(), setSIMR()
N */
N#define _Sn_IR_(N)           (_W6100_IO_BASE_ + (0x0020 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Interrupt Mask Register Address [R=W][0xFF]
N * @details @ref _Sn_IMR_ is used to mask interrupts of @ref _Sn_IR_.
N * @sa _Sn_IR_, _Sn_IRCR_, _SIR_, _SIMR_
N * @sa getSn_IMR(), setSn_IMR(), getSn_IR(), setSn_IRCLR(), getSIR(), getSIMR(), setSIMR()
N */
N#define _Sn_IMR_(N)          (_W6100_IO_BASE_ + (0x0024 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Interrupt Clear Register Address [WO][0x00]
N * @details @ref _Sn_IRCLR_ clears @ref _Sn_IR_
N * @sa _Sn_IR_, _SIR_, _SIMR_
N * @sa setSn_IRCLR(), getSn_IR(), getSIR(), getSIMR(), setSIMR()
N */
N#define _Sn_IRCLR_(N)        (_W6100_IO_BASE_ + (0x0028 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N
N
N/**
N * @brief SOCKETn Status Register Address [RO][0x00]
N * @details @ref _Sn_SR_ indicates the status of SOCKETn.\n
N *          The status of SOCKETn can be changed by @ref _Sn_CR_, some TCP packets such as SYN, FIN, RST packet, or @ref Sn_IR_TIMEOUT.
N *  - Normal status
N *    - @ref SOCK_CLOSED      : Closed
N *    - @ref SOCK_INIT        : Initiate state
N *    - @ref SOCK_LISTEN      : Listen state
N *    - @ref SOCK_ESTABLISHED : Success to connect
N *    - @ref SOCK_CLOSE_WAIT  : Closing state
N *    - @ref SOCK_UDP         : UDP socket
N *    - @ref SOCK_IPRAW       : IPRAW socket
N *    - @ref SOCK_IPRAW6      : IPv6 IPRAW socket
N *    - @ref SOCK_MACRAW      : MAC raw mode socket
N *  - Temporary status during changing the status of SOCKETn .
N *    - @ref SOCK_SYNSENT     : This indicates SOCKETn  sent the connect-request packet (SYN packet) to a peer.
N *    - @ref SOCK_SYNRECV     : It indicates SOCKETn  successfully received the connect-request packet (SYN packet) from a peer.
N *    - @ref SOCK_FIN_WAIT    : Connection state
N *    - @ref SOCK_TIME_WAIT   : Closing state
N *    - @ref SOCK_LAST_ACK    : Closing state
N *
N * @sa _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT 
N * @sa getSn_SR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR()
N * 
N *  <table width=0 >
N *     <tr> <td>@image html SocketStatus.png "<SOCKETn Status Transition>"</td> </tr>
N *  </table>
N *
N */
N#define _Sn_SR_(N)           (_W6100_IO_BASE_ + (0x0030 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Extension Status Register Address [RO][0x00]
N * @details @ref _Sn_ESR_ indicates the connected client IP address information such as IP version, IPv6 address type(LLA or GUA), \n
N *          and TCP operation mode such as <b>TCP SERVER</b> and <b>TCP CLIENT</b>
N * <table>
N *    <tr> <td> 7 ~ 3   </td> <td>2   </td> <td>1    </td> <td>0   </td> </tr> 
N *    <tr> <td> Reserved</td> <td>TCPM</td> <td>TCPOP</td> <td>IP6T</td> </tr> 
N * </table>
N * - @ref Sn_ESR_TCPM  : @ref Sn_ESR_TCPM_IPV4, @ref Sn_ESR_TCPM_IPV6
N * - @ref Sn_ESR_TCPOP : @ref Sn_ESR_TCPOP_SVR, @ref Sn_ESR_TCPOP_CLT
N * - @ref Sn_ESR_IP6T  : @ref Sn_ESR_IP6T_LLA,  @ref Sn_ESR_IP6T_GUA
N * 
N * @note It is valid only on TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_MR_, _Sn_PSR_
N * @sa getSn_ESR(), getSn_MR(), setSn_MR(), getSn_PSR(), setSn_PSR()
N */
N#define _Sn_ESR_(N)          (_W6100_IO_BASE_ + (0x0031 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn IP Protocol Number(PN) Register Address [R/W][0x0000]
N * @details \ref _Sn_PNR_ that sets the protocol number/next header field of the IPv4/IPv6 header at the IP layer.
N * @note It is valid only in IPRAW mode such as @ref Sn_MR_IPRAW4 and @ref Sn_MR_IPRAW6.
N * @note It is set before @ref Sn_CR_OPEN is performed.
N * @sa _Sn_NHR_, _Sn_MR_, Sn_CR_OPEN
N * @sa getSn_PNR(), setSn_PNR(), getSn_NHR(), setSn_NHR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
N */
N#define _Sn_PNR_(N)          (_W6100_IO_BASE_ + (0x0100 << 8) + WIZCHIP_SREG_BLOCK(N))
N#define _Sn_NHR_(N)          (_Sn_PNR_(N))      ///< Refer to @ref _Sn_PNR_.
N
N/**
N * @brief SOCKETn IPv4 Type of Service(TOS) Register Address [R=W][0x00]
N * @details @ref _Sn_TOSR_ sets the TOS(Type Of Service) field in IPv4 Header.
N * @sa getSn_TOSR(), setSn_TOSR()
N */
N#define _Sn_TOSR_(N)         (_W6100_IO_BASE_ + (0x0104 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn IP Time to live(TTL) Register Address [R=W][0x80]
N * @details @ref _Sn_TTLR_ sets the TTL(Time To Live)/HOP(Hop Limit) field in IPv4/IPv6 header at the IP layer.
N * @sa _Sn_HOPR_
N * @sa getSn_TTLR(), setSn_TTLR(), getSn_HOPR(), setSn_HOPR()
N */
N#define _Sn_TTLR_(N)         (_W6100_IO_BASE_ + (0x0108 << 8) + WIZCHIP_SREG_BLOCK(N))
N#define _Sn_HOPR_(N)         (_Sn_TTLR_(N))   ///< Refer to @ref _Sn_TTLR_.
N
N/**
N * @brief SOCKETn Fragment Register Address [R=W][0x4000]
N * @details @ref _Sn_FRGR_ sets the fragment flag & offset in IPv4 header.
N * @note @ref _WIZCHIP_ can not support IP fragment & re-assembly.\n So It is not recommended to set @ref _Sn_FRGR_ to any other value.
N * @sa getSn_FRGR(), setSn_FRGR()
N */
N#define _Sn_FRGR_(N)         (_W6100_IO_BASE_ + (0x010C << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Maximum Segment Size(MSS) Register Address [RW][0x0000]
N * @details @ref _Sn_MSSR_ sets or gets the MTU(Maximum Transfer Unit) of SOCKETn. \n
N *          The MTU of each protocol is as following.
N * <table>
N *    <tr> <td> @ref _Sn_MR_[3:0] </td> <td>@ref NETMR2_PPPoE = 0 </td> <td>@ref NETMR2_PPPoE = '1'</td> </tr>
N *    <tr> <td> @ref Sn_MR_TCP4   </td> <td> 1 ~ 1460             </td> <td> 1 ~ 1452              </td> </tr>
N *    <tr> <td> @ref Sn_MR_TCP6   </td> <td> 1 ~ 1440             </td> <td> 1 ~ 1432              </td> </tr>
N *    <tr> <td> @ref Sn_MR_UDP4   </td> <td> 1 ~ 1472             </td> <td> 1 ~ 1464              </td> </tr>
N *    <tr> <td> @ref Sn_MR_UDP6   </td> <td> 1 ~ 1452             </td> <td> 1 ~ 1444              </td> </tr>
N *    <tr> <td> @ref Sn_MR_IPRAW4 </td> <td> 1 ~ 1480             </td> <td> 1 ~ 1472              </td> </tr>
N *    <tr> <td> @ref Sn_MR_IPRAW6 </td> <td> 1 ~ 1460             </td> <td> 1 ~ 1452              </td> </tr>
N *    <tr> <td> @ref Sn_MR_MACRAW </td> <td colspan = "2">      1 ~ 1514                                              </td> </tr>
N * </table>
N *
N * @note It is not set exceeding the MTU for each protocol of SOCKETn even if _Sn_MSSR_ is set over the MTU.
N * @sa _Sn_MR_, NETMR2_PPPoE
N * @sa getSn_MSSR(), setSn_MSSR(), getSn_MR(), setSn_MR(), getNETMR2(), setNETMR2()
N */
N#define _Sn_MSSR_(N)         (_W6100_IO_BASE_ + (0x0110 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Source Port Register Address [R=W][0x0000]
N * @details @ref _Sn_PORTR_ sets the source port number of SOCKETn .
N * @note It is valid in TCP(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6, @ref Sn_MR_TCPD) and UDP(@ref Sn_MR_UDP4, @ref Sn_MR_UDP6, @ref Sn_MR_UDPD) mode.
N * @note It should be set before @ref Sn_CR_OPEN is performed.
N * @sa _Sn_MR_, Sn_CR_OPEN
N * @sa getSn_PORTR(), getSn_PORTR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
N*/
N#define _Sn_PORTR_(N)        (_W6100_IO_BASE_ + (0x0114 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Destination Hardware Address Register Address [RW][00:00:00:00:00:00]
N * @details @ref _Sn_DHAR_ sets or gets the destination hardware address of SOCKETn.\n
N *   - When @ref Sn_MR2_DHAM = 1 and @ref _Sn_MR_[3:0] != @ref Sn_MR_MACRAW
N *     The destination hardware address is set by @ref _Sn_DHAR_ without ARP processed by @ref Sn_CR_CONNECT, @ref Sn_CR_CONNECT6, @ref Sn_CR_SEND, and @ref Sn_CR_SEND6.\n
N *     Also, when SOCKETn is opened with @ref Sn_MR_UDP4 or @ref Sn_MR_UDP6 and @ref Sn_MR_MULTI is set, @ref _Sn_DHAR_ sets the Multicast Group Hardware address.
N *   - Others
N *     In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD, \n
N *     @ref _Sn_DHAR_ gets the destination hardware address when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
N * @sa _Sn_MR_, _Sn_MR2_, _Sn_CR_, _Sn_SR_
N * @sa getSn_DHAR(), setSn_DHAR(), getSn_MR(), setSn_MR(), getSn_MR2(), setSn_MR2(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define _Sn_DHAR_(N)         (_W6100_IO_BASE_ + (0x0118 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Destination IPv4 Address Register Address [RW][0.0.0.0]
N * @details @ref _Sn_DIPR_(= @ref _Sn_DIP4R_) sets or gets the destination IPv4 address of SOCKETn. \n
N *   - In TCP mode such as @ref Sn_MR_TCP4, and @ref Sn_MR_TCPD
N *      - <b>TCP CLIENT</b> mode : It sets the IPv4 address of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT is performed. 
N *      - <b>TCP SERVER</b> mode : It gets the IPv4 address of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
N *   - In UDP(@ref Sn_MR_UDP4, @ref Sn_MR_UDPD) mode & IPRAW4(@ref Sn_MR_IPRAW4) mode
N *     It sets the destination IPv4 address before @ref Sn_CR_SEND is performed. \n
N *     When Sn_MR_MULTI = 1, It sets the multicast group IPv4 address.
N * @sa _Sn_DIP4R_, _Sn_MR_, _Sn_CR_, _Sn_SR_ 
N * @sa getSn_DIPR(), getSn_DIPR(), getSn_DIP4R(), getSn_DIP4R(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define _Sn_DIPR_(N)         (_W6100_IO_BASE_ + (0x0120 << 8) + WIZCHIP_SREG_BLOCK(N))
N#define _Sn_DIP4R_(N)        (_Sn_DIPR_(N))            ///< Refer to @ref _Sn_DIPR_.
N
N/**
N * @brief SOCKETn Destination IPv6 Address Register Address [RW][::]
N * @details @ref _Sn_DIP6R_ sets or gets the destination IPv6 address of SOCKETn.
N *   - In TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
N *      - <b>TCP CLIENT</b> mode : It sets the IPv6 address of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT6 is performed. 
N *      - <b>TCP SERVER</b> mode : It gets the IPv6 address of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
N *   - In UDP(@ref Sn_MR_UDP6, @ref Sn_MR_UDPD) mode & IPRAW4(@ref Sn_MR_IPRAW6) mode
N *     It sets the destination IPv6 address before @ref Sn_CR_SEND6 is performed.\n
N *     When Sn_MR_MULTI = 1, It sets the multicast group IPv6 address.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
N * @sa getSn_DIP6R(), setSn_DIP6R(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define _Sn_DIP6R_(N)        (_W6100_IO_BASE_ + (0x0130 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Destination Port Register Address [RW][0x0000]
N * @details @ref _Sn_DPORTR_ sets or gets the destination port number of SOCKETn.
N *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
N *      - <b>TCP CLIENT</b> mode : It sets the port number of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT is performed.
N *      - <b>TCP SERVER</b> mode : It gets the port number of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
N *   - In UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD
N *     It sets the destination port number before @ref Sn_CR_SEND is performed. \n
N *     When Sn_MR_MULTI = 1, It sets the multicast group group port number.
N *
N * @note It is valid SOCKETn is opened with @ref Sn_MR_TCP4,  @ref Sn_MR_TCP6, @ref Sn_MR_TCPD, @ref Sn_MR_UDP4, @ref Sn_MR_UDP4, and @ref Sn_MR_UDPD.
N * @note It should be set before OPEN command is ordered.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_ 
N * @sa getSn_DPORTR(), getSn_DPORTR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define _Sn_DPORTR_(N)       (_W6100_IO_BASE_ + (0x0140 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Mode Register 2 Address [R=W][0x00]
N * @details @ref _Sn_MR2_ sets the option of SOCKETn with @ref _Sn_MR_, before @ref Sn_CR_OPEN is performed.\n
N *          Each bit of @ref _Sn_MR2_ is defined as the following.
N * <table>
N *    <tr> <td>7 ~ 2   </td> <td>1   </td> <td>0   </td> </tr>
N *    <tr> <td>Reserved</td> <td>DHAM</td> <td>FARP</td> </tr>
N * </table>
N *   - @ref Sn_MR2_DHAM : @ref Sn_MR2_DHAM_AUTO, @ref Sn_MR2_DHAM_MANUAL
N *   - @ref Sn_MR2_FARP
N * @sa _Sn_MR_, _Sn_CR_
N * @sa getSn_MR2(), setSn_MR2(), getSn_MR(), getSn_MR(), getSn_CR()
N */
N#define _Sn_MR2_(N)          (_W6100_IO_BASE_ + (0x0144 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N
N/**
N * @brief SOCKETn Retransmission Time Register Address [R=W][0x0000]
N * @details @ref _Sn_RTR_ sets the timeout value of packet to be retransmitted by @ref _SLCR_.\n
N * @note It should be set before @ref Sn_CR_OPEN is performed.\n
N *       It is initialized as @ref _RTR_ if you do not set it to none-zero value.
N * @sa _RTR_, _Sn_CR_
N * @sa getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
N */
N#define _Sn_RTR_(N)          (_W6100_IO_BASE_ + (0x0180 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Retransmission Count Register Address [R=W][0x00]
N * @details @ref _Sn_RCR_ sets the retry count value of packet to be retransmitted by @ref _SLCR_.\n
N * @note It should be set before @ref Sn_CR_OPEN is performed.\n
N *       It is initialized as @ref _RTR_ if you do not set it to any none-zero value.
N * @sa _RTR_, _Sn_CR_
N * @sa getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
N */
N#define _Sn_RCR_(N)          (_W6100_IO_BASE_ + (0x0184 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Keep Alive Time Register Address [R=W][0x00]
N * @details @ref _Sn_KPALVTR_ sets the auto-retransmission time of KA(Keep Alive) packet. \n
N *          If the destination can not respond to the KA packet during the time set by @ref _Sn_KPALVTR_,\n
N *          the connection is terminated, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed @ref SOCK_CLOSED.\n
N *          Before the time is expierd, if the destination sends a KA/ACK packet or any packet, the connection is still valid,\n
N *          @ref _Sn_SR_ remained at @ref SOCK_ESTABLISHED.
N * @note It is valid only after sending data over 1 byte in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @note If it is set to 0, KA packet can be sent by @ref Sn_CR_SEND_KEEP.
N * @sa Sn_CR_SEND_KEEP, Sn_IR_TIMEOUT, Sn_IRCLR, Sn_SR, Sn_MR
N * @sa getSn_KPALVTR(), setSn_KPALVTR(), getSn_IR(), setSn_IRCLR(), getSn_SR(), getSn_MR(), setSn_MR()
N */
N#define _Sn_KPALVTR_(N)      (_W6100_IO_BASE_ + (0x0188 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn TX Buffer Size Register Address [R=W][0x02]
N * @details @ref _Sn_TX_BSR_ sets the TX buffer size of SOCKETn in the 16KB TX memory.\n
N *          It can be set only with 0,1,2,4,8, and 16K bytes.
N * @note The 16KB TX memory is allocated as many as @ref _Sn_TX_BSR_ sequentially from SOCKET0 to SOCKETn(Here, 0 <= n <= @ref _WIZCHIP_SOCK_NUM_ - 1).\n
N *       The total sum of Sn_TX_BSR can not be exceed 16KB of TX memory. \n
N *       If the total size is exceeded, SOCKETn can't be normally sent data to a destination.
N * @sa _Sn_RX_BSR_
N * @sa getSn_TX_BSR(), setSn_TX_BSR(), getSn_TXBUF_SIZE(), setSn_TXBUF_SIZE(), getSn_TxMAX(), setSn_TX_BSR(), getSn_RX_BSR(), setSn_RX_BSR()
N */
N#define _Sn_TX_BSR_(N)       (_W6100_IO_BASE_ + (0x0200 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn TX Free Buffer Size Register Address [RO][0x0800]
N * @details @ref _Sn_TX_FSR_ gets the transmittable free size of SOCKETn TX buffer.
N * @note Data should not be saved bigger than it because the data overwrites the previous saved data not to be sent yet.\n
N *       Therefore, Check it before saving the data to the SOCKETn TX buffer. \n
N *       If the data size is equal or smaller than it, transmit the data with @ref Sn_CR_SEND / @ref Sn_CR_SEND6 after saving the data in SOCKETn TX buffer.\n
N *       If the data size is greater than it, transmit the data after dividing into it and saving in the SOCKETn TX buffer.
N * @note \n
N *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD, \n
N *     It is automatically increased by the absolute difference between @ref _Sn_TX_WR_ and interanl TX ACK pointer.
N *   - In other mode \n
N *     It is automatically increased by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_.
N * @sa _Sn_RX_RSR_, _Sn_TX_WR_, _Sn_TX_RD_, _Sn_CR_
N * @sa getSn_TX_FSR(), getSn_TX_WR(), getSn_TX_WR(), getSn_TX_RD(), getSn_CR(), setSn_CR()
N */
N#define _Sn_TX_FSR_(N)       (_W6100_IO_BASE_ + (0x0204 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKET TX Memory Read Pointer Register Address[R][0x0000]
N * @details @ref _Sn_TX_RD_ gets the start pointer of data to be sent by @ref Sn_CR_SEND. \n
N *          @ref Sn_CR_SEND / @ref Sn_CR_SEND6 starts to transmit the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX Buffer,\n
N *          and when @ref Sn_IR_SENDOK is set, It is automatically increased to equal @ref _Sn_TX_WR_.
N * @note It is initialized by @ref Sn_CR_OPEN, But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
N *       it is re-initialized when the TCP connection is completed.
N * @note If it exceeds the maximum value 0xFFFF, (that is, it is greater than 0x10000 and the carry bit occurs),\n
N *       then the carry bit is ignored and it automatically is updated with its the lower 16bits value.
N * @sa _Sn_TX_WR_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
N * @sa getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
N */
N#define _Sn_TX_RD_(N)        (_W6100_IO_BASE_ + (0x0208 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N
N/**
N * @brief SOCKETn TX Memory Write Pointer Register Address [RW][0x0000]
N * @details @ref _Sn_TX_WR_ gets the start pointer of data to be saved in the SOCKETn TX buffer, \n
N *          or sets the end pointer of data to be sent by @ref Sn_CR_SEND. \n
N *          If you have completed to save the data to be sent in the SOCKETn TX buffer,
N *          increase it as many as the saved size of data before @ref Sn_CR_SEND is performed.\n
N *          @ref Sn_CR_SEND starts to transmit the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX Buffer, \n
N *          and when @ref Sn_IR_SENDOK is set, @ref _Sn_TX_RD_ is automatically increased to equal it.
N * @note It is initialized by @ref Sn_CR_OPEN.\n
N *       But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
N *       it is re-initialized when the TCP connection is completed.
N * @note The size of data to be saved can't exceed @ref _Sn_TX_FSR_.
N * @note If it exceeds the maximum value 0xFFFF(that is, it is greater than 0x10000 and the carry bit occurs),\n
N *       then ignore the carry bit and update it with its lower 16bits value.
N * @sa _Sn_TX_RD_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
N * @sa getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
N */
N#define _Sn_TX_WR_(N)        (_W6100_IO_BASE_ + (0x020C << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn RX Buffer Size Register Address [R=W][0x02]
N * @details @ref _Sn_RX_BSR_ sets the RX buffer size of SOCKETn in the 16KB RX memory.\n
N *          It can be set only with 0,1,2,4,8, and 16K bytes.
N * @note The 16KB RX memory is allocated as many as @ref _Sn_RX_BSR_ sequentially from SOCKET0 to SOCKETn(Here, 0 <= n <= @ref _WIZCHIP_SOCK_NUM_ - 1).\n
N *       The total sum of @ref _Sn_RX_BSR_ can not be exceed 16KB of RX memory. \n
N *       If the total size is exceeded, SOCKETn can't be normally received data from a destination.
N * @sa _Sn_RX_BSR_
N * @sa getSn_TX_BSR(), setSn_TX_BSR(), getSn_RXBUF_SIZE(), setSn_RXBUF_SIZE(), getSn_RxMAX(), getSn_RX_BSR(), setSn_RX_BSR()
N */
N#define _Sn_RX_BSR_(N)       (_W6100_IO_BASE_ + (0x0220 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn RX Received Size Register Address [RO][0x0000]
N * @details @ref _Sn_RX_RSR_ gets the received data size of SOCKETn RX buffer.
N * @note The real received data size maybe smaller than it, \n
N *       because it maybe included the size of 'PACKET NFO' such like as \n
N *       the destination IP address, destination port number and data size of the received DATA PACKET.
N * @note Do not read bigger data than @ref _Sn_RX_RSR_.
N * @note It is automatically increased by the absolute difference between @ref _Sn_RX_WR_ and @ref _Sn_RX_RD_ \n
N *       after @ref Sn_CR_RECV is performed.
N * @sa _Sn_RX_RSR_, _Sn_TX_WR_, _Sn_TX_RD_, _Sn_CR_, _Sn_TX_FSR_
N * @sa getSn_RX_RSR(), getSn_TX_WR(), getSn_TX_WR(), getSn_CR(), setSn_CR(), getSn_TX_FSR()
N */
N#define _Sn_RX_RSR_(N)       (_W6100_IO_BASE_ + (0x0224 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKET RX Memory Read Pointer Register Address[R][0x0000]
N * @details @ref _Sn_RX_RD_ gets the start pointer of the received data in the SOCKETn RX buffer,\n
N *          or sets the end data pointer of the read completed data by @ref Sn_CR_RECV. \n
N *          You can read the received data from it to @ref _Sn_RX_WR_ in the SOCKET RX buffer.\n
N *          After completing to read data, you should increase it as many as the read size before @ref Sn_CR_RECV is performed.
N * @note It is initialized by @ref Sn_CR_OPEN, But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
N *       it is re-initialized when the TCP connection is completed.
N * @note If it exceeds the maximum value 0xFFFF, (that is, it is greater than 0x10000 and the carry bit occurs),\n
N *       Ignore the carry bit and update with its the lower 16bits value.
N * @sa _Sn_RX_WR_, _Sn_RX_RSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
N * @sa getSn_RX_WR(), setSn_RX_RD(), getSn_RX_WR(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
N */
N#define _Sn_RX_RD_(N)        (_W6100_IO_BASE_ + (0x0228 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn TX Memory Write Pointer Register Address [RW][0x0000]
N * @details @ref _Sn_TX_WR_ gets the end pointer of the data that has been completely received in the SOCKETn RX buffer. \n
N *          Whenever a data has been completely received from a destination, \n
N *          It is automatically increased as many as the sum size of the received data and the 'PACKET INFO'. \n
N *          You can read the recevied data from @ref _Sn_RX_RD_ to it in the SOCKET RX buffer.
N * @note It is initialized by @ref Sn_CR_OPEN. But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
N *       it is re-initialized when the TCP connection is completed.
N * @note If it exceeds the maximum value 0xFFFF(that is, it is greater than 0x10000 and the carry bit occurs),\n
N *       then ignore the carry bit and update it with its lower 16bits value.
N * @sa _Sn_TX_RD_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, Sn_IRCLR_, _Sn_MR_
N * @sa getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
N */
N#define _Sn_RX_WR_(N)        (_W6100_IO_BASE_ + (0x022C << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @}
N */
N
N/*----------------------------- W6100 Register values  -----------------------------*/
N
N/* System Status Register Bit Definition */
N/**
N * @brief CHIP Lock staus bit of @ref _SYSR_.
N * @details @ref SYSR_CHPL indicates the lock status of @ref _SYCR0_ and @ref _SYCR1_.\n
N *          1 : Lock \n
N *          0 : unlock 
N * @note It is set by only @ref _CHPLCKR_.
N * @sa _SYSR_, _CHPLCKR_, _SYCR0_, _SYCR1_
N * @sa getSYSR(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), setSYCR0(), setSYCR1()
N */
N#define SYSR_CHPL            (1 << 7)
N
N/**
N * @brief NET Lock status bit of @ref _SYSR_.
N * @details @ref SYSR_NETL indicates the lock of network information registers such as 
N *          @ref _SHAR_, @ref _GAR_, @ref _SUBR_, @ref _SIPR_, @ref _LLAR_, @ref _GUAR_, and @ref _SUB6R_. \n
N *          1 : Lock \n
N *          0 : unlock 
N * @note It is set by only @ref _NETLCKR_.
N * @note @ref _GA6R_ can be accessed regardless of @ref SYSR_NETL.
N * @sa _SYSR_, _NETLCKR_, _SHAR_, _GAR_, _SUBR_, _SIPR_, _LLAR_, _GUAR_, _SUB6R_
N * @sa getSYSR(), getNETLCKR(), setNETLCKR(), NETLOCK(), NETUNLOCK(),\n
N *     getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), getSIR(), setSIPR(), \n
N *     getLLAR(), setLLAR(), getGUAR(),setGUAR(), getSUB6R(), setSUB6R()
N */
N#define SYSR_NETL            (1 << 6)
N
N/**
N * @brief PHY Lock status bit of @ref _SYSR_. Refer to @ref _PHYLCKR_.
N * @details @ref SYSR_PHYL indicates the lock status of @ref _PHYCR0_ and _PHYCR1_.\n
N *          1 : Lock \n
N *          0 : unlock
N * @note It is set by only @ref _PHYLCKR_.
N * @sa _SYSR_, _PHYCLKR_, _PHYCR0_, _PHYCR1_
N * @sa getSYSR(), getPHYLCKR(), setPHYLCKR(), setPHYCR0(), getPHYCR1(), setPHYCR1()
N */
N#define SYSR_PHYL            (1 << 5)
N
N/**
N * @brief Parallel Bus Mode bit of @ref _SYSR_
N * @details @ref SYSR_IND is set when @ref _WIZCHIP_ PIN MODE[3:0] == "010X".
N *          It indicates to use the parallel BUS mode. 
N * @sa _SYSR_, _WIZCHIP_IO_MODE_BUS_
N * @sa getSYSR()
N */
N#define SYSR_IND             (1 << 5)
N
N/**
N * @brief SPI I/F Mode bit of @ref _SYSR_.
N * @details @ref SYSR_SPI is set when @ref _WIZCHIP_ PIN MODE[3:0] == "000X".
N *          It indicates to use the SPI mode.
N * @sa _SYSR_, _WIZCHIP_IO_MODE_SPI_
N * @sa getSYSR()
N */
N#define SYSR_SPI             (1 << 0)
N
N
N/* System Config Register Bit Definition */
N/**
N * @brief RST bit of @ref _SYCR0_
N * @details @ref SYCR0_RST resets to @ref _WIZCHIP_ softly. \n
N *          0 : Soft reset \n
N *          1 : Normal operation
N * @note It can be set only when @ref SYSR_CHPL = 1.
N * @sa _SYSR0_, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa setSYCR0(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define SYCR0_RST            (0x00)
N
N/**
N * @brief IEN bit of @ref _SYCR1_.
N * @details @ref SYCR1_IEN is globally enable or disable the interrupt of @ref _WIZCHIP_,\n
N *          regardless of the related interrupt mask registers such as @ref _IMR_, @ref _SIMR_, @ref _SLIMR_, and @ref _Sn_IMR_.\n
N *          1 : Enable  \n
N *          0 : Disable
N * @sa _SYCR1_, _IR_, _SIR_, _SLIR_, _Sn_IR_, _IRCLR_,  _SLIRCLR_, _Sn_IRCLR_
N * @sa getSYCR1(), setSYCR1(), getIR(), getSIR(), getSLIR(), getSn_IR(), setIRCLR(), setSLIRCLR(), setSn_IRCLR()
N */
N#define SYCR1_IEN            (1 << 7)
N
N/**
N * @brief System Clock select mask bit of @ref _SYCR1_.
N * @details @ref SYCR1_CLKSEL selects a system clock to 100MHz or 25MHz. \n
N *          The masked bit values are as following.
N *            - @ref SYCR1_CLKSEL_25M
N *            - @ref SYCR1_CLKSEL_100M
N * @note It can be set only when @ref SYSR_CHPL = 1.
N * @note The system clock is automatically changed to 25MHz while the reset of @ref _WIZCHIP_ H/W reset, the Ethernet PHY H/W reset and power down. \n
N *       On the other hand, the system clock is set by @ref SYCR1_CLKSEL during normal operating.
N * @sa _SYCR1_, _SYSR_, _CHPLCKR_, SYSL_CHPL, PHYCR1_RST, PHYCR1_PWDN
N * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getPHYCR1(), setPHYCR1()
N */
N#define SYCR1_CLKSEL         (1 << 0)
N
N/**
N * @brief System Clock - 25MHz
N * @details @ref SYCR1_CLKSEL_25M selects a system clock to 25MHz.
N * @note It can be set only when @ref SYSR_CHPL = 1.
N * @sa _SYCR1_, SYCR1_CLKSEL, SYCR1_CLKSEL_100M
N * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK()
N */
N#define SYCR1_CLKSEL_25M     1
N
N/**
N * @brief System Clock - 100MHz
N * @details @ref SYCR1_CLKSEL_100M selects a system clock to 100MHz.
N * @note It can be set only when @ref SYSR_CHPL = 1.
N * @sa _SYCR1_, SYCR1_CLKSEL, SYCR1_CLKSEL_25M
N * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK()
N */
N#define SYCR1_CLKSEL_100M    0
N
N
N/* Interrupt Register Bit Definition */
N/**
N * @brief WOL bit of @ref _IR_
N * @details @ref IR_WOL is set when @ref _WIZCHIP_ receives a magic packet of WOL.
N * @sa _IR_, _IRCLR_, _IMR_ 
N * @sa getIR(), setIRCLR(), getIMR(), setIMR()
N */
N#define IR_WOL               (1<<7) 
N
N/**
N * @brief UNR6 bit of @ref _IR_
N * @details @ref IR_UNR6 is set when @ref _WIZCHIP_ receives the unreachable message of ICMPv6.
N * @sa _IR_, _IRCLR_, _IMR_
N * @sa getIR(), setIRCLR(), getIMR(), setIMR()
N */
N#define IR_UNR6              (1<<4)
N
N/**
N * @brief IPCONF bit of @ref _IR_
N * @details @ref IR_IPCONF is set when @ref _WIZCHIP_ receives a ARP reply with the same IPv4 address as @ref _SIPR_.
N * @sa _IR_, _IRCLR_, _IMR_
N * @sa getIR(), setIRCLR(), getIMR(), setIMR()
N */
N#define IR_IPCONF            (1<<2)
N
N/**
N * @brief UNR4 bit of @ref _IR_
N * @details @ref IR_UNR4 is set when @ref _WIZCHIP_ receives the unreachable message of ICMPv4.
N * @sa _IR_, _IRCLR_, _IMR_
N * @sa getIR(), setIRCLR(), getIMR(), setIMR()
N */
N#define IR_UNR4              (1<<1)
N
N/**
N * @brief PTERM bit of @ref _IR_
N * @details @ref IR_PTERM is set when @ref _WIZCHIP_ receives the PPP termination packet
N * @sa _IR_, _IRCLR_, _IMR_
N * @sa getIR(), setIRCLR(), getIMR(), setIMR()
N */
N#define IR_PTERM             (1<<0) 
N
N
N/* SOCKET Interrupt Register Bit Definition */
N/**
N * @brief N-th INT bit of @@ref _SIR_
N * @details @ref SIR_INT(N) is set when @ref _Sn_IR_(N) is not equal to zero.
N * @sa _SIR_, _Sn_IRCLR_, _SIMR_
N * @sa getSIR(), setSn_IRCLR(), getSIMR()
N */
N#define SIR_INT(N)           (1<<N)
N
N
N/* SOCKET-less Interrupt Register Bit Definition */
N/**
N * @brief TOUT bit of @ref _SLIR_
N * @details @ref SLIR_TOUT is set when the timeout is occurred after @ref _SLCR_ is performed.
N * @sa _SLIR_, _SLIRCLR_, _SLCR_
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR()
N */
N#define SLIR_TOUT            (1<<7)
N
N/**
N * @brief ARP4 bit of @ref _SLIR_
N * @details @ref SLIR_ARP4 is set when the ARP-relay is received successfully after @ref SLCR_ARP4 is performed \n
N *          and the destination hardware address can be checked by @ref _SLDHAR_. \n
N *          Otherwise, @ref SLIR_TOUT is set.
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, SLIR_TOUT
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR() 
N */
N#define SLIR_ARP4            (1<<6)
N
N/**
N * @brief PING4 bit of @ref _SLIR_
N * @details @ref SLIR_PING4 is set when the PING-relay is received successfully after @ref SLCR_PING4 is performed \n
N *          and the destination hardware address can be checked by @ref _SLDHAR_ like as @ref SLIR_ARP4.\n
N *          Otherwise, @ref SLIR_TOUT is set. 
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, SLIR_TOUT
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR() 
N */
N#define SLIR_PING4           (1<<5)
N
N/**
N * @brief ARP6 bit of @ref _SLIR_
N * @details @ref SLIR_ARP6 is set when the ARP6-relay is received successfully after @ref SLCR_ARP6 is performed \n
N *          and the destination hardware address can be checked by @ref _SLDHAR_. \n
N *          Otherwise, @ref SLIR_TOUT is set.
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, _SLDHAR_, SLIR_TOUT
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR() 
N */
N#define SLIR_ARP6            (1<<4)
N
N/**
N * @brief PING6 bit of @ref _SLIR_
N * @details @ref SLIR_PING6 is set when the PING-relay is received successfully after @ref SLCR_PING6 is performed \n
N *          and the destination hardware address can be checked by @ref _SLDHAR_ like as @ref SLIR_ARP6. \n
N *          Otherwise, @ref SLIR_TOUT is set.
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, _SLDHAR_, SLIR_TOUT
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR() 
N */
N#define SLIR_PING6           (1<<3)
N
N/**
N * @brief NS bit of @ref _SLIR_
N * @details @ref SLIR_NS is set when the ICMPv6 NA is received after @ref SLCR_NS is performed. \n
N *          Its set means IPv6 address such like as @ref _LLAR_ or @ref _GUAR_ is conflict. \n
N *          If @ref SLIR_TOUT is set, You can use @ref _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_.
N * @note It is used for IPv6 state-less address auto-configuration(SLAAC).
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, SLIR_TOUT, _LLAR_, _GUAR_
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getLLAR(), setLLAR(), getGAUR(), setGUAR()
N */
N#define SLIR_NS              (1<<2) 
N
N/**
N * @brief RS bit of @ref _SLIR_
N * @details @ref SLIR_RS is set when the ICMPv6 RA is received successfully after @ref SLCR_RS is performed \n
N *          and the prefix length, the prefix flag, the valid life time, the preferred life time and the prefix address of RA option message \n
N *          can be checked by @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_, respectively.\n
N *          Otherwise, @ref SLIR_TOUT is set.
N * @bug Only when the first received RA option is the source link-layer address(0x01) and the second is prefix information(0x03),\n
N *      and the prefix information is in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address,\n
N *      @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_ is correctly set.\n
N *      Other case, these registers are not valid.\n\n
N *      To solve this errata,\n
N *      You should use a IPRAW6 mode SOCKETn opened with Sn_MR_IPRAW6 and set the @ref _Sn_PNR_ to ICMPv6 number 58.\n
N *      This SOCKETn can be received a RA message or other ICMPv6 message, and a ICMPv6 message can be selectively filtered out by @ref _ICMP6BLKR_.\n
N *      For more details, Refer to "IPv6 Auto-configuration" document.
N *
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, SLIR_TOUT
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR()
N */
N#define SLIR_RS              (1<<1)
N
N/**
N * @brief ICMPv6 RA Received Interrupt
N * @details @ref SLIR_RA is set when a RA is received from a router without @ref SLCR_RS.\n
N *          Like as @ref SLIR_RS, a RA option message can be checked by @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_.\n
N * @bug Only when RA options are received in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address,\n
N *      @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_ is correctly set. \n
N *      Other case, these registers are not valid.\n\n
N *      To solve this errata, You should use a IPRAW6 mode SOCKETn opened with @ref Sn_MR_IPRAW6 and set the @ref _Sn_PNR_ to ICMPv6 number 58.\n
N *      This SOCKETn can be received a RA message or other ICMPv6 message, and a ICMPv6 message can be selectively filtered out by @ref _ICMP6BLKR_.\n
N *      For more details, Refer to "IPv6 Auto-configuration" document.
N *
N * @sa _SLIR_, _SLIRCLR_ 
N * @sa getSLIR(), setSLIRCLR(), 
N  */
N#define SLIR_RA              (1<<0)
N
N
N/* SOCKET-less & SOCKETn  Prefer Source IPv6 Address Register Bit Definition */
N/**
N * @brief Select the source IPv6 address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to AUTO
N * @details The source IPv6 address depends on IPv6 address type of @ref _SLDIP6R_ or @ref _Sn_DIP6R_.\n
N *          If @ref _Sn_DIP6R_ is a link-local, the source IPv6 address is selected to @ref _LLAR_.\n
N *          Otherwise, the source IPv6 address is selected to @ref _GUAR_.
N * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDI6PR_, _Sn_DIP6R_, _LLAR_, _GUAR_
N * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
N *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
N */
N#define PSR_AUTO             (0x00)
N
N/**
N * @brief Select the source IP address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to @ref _LLAR_
N * @details Regardless of the destination IPv6 address type of @ref _SLDIP6R_ or @ref _Sn_DIP6R_, the source IP is selected to @ref _LLAR_.
N * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDIP6R_, _Sn_DIP6R_, _LLAR_, _GUAR_
N * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
N *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
N */
N#define PSR_LLA              (0x02)
N
N/**
N * @brief Select the source IP address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to @ref _GUAR_
N * @details Regardless of the destination IPv6 address type of @ref _SLDIP6R_, or @ref _Sn_DIP6R_, the source IP is selected to @ref _GUAR_.
N * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDIP6R_, _Sn_DIP6R_, _LLAR_, _GUAR_
N * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
N *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
N */
N#define PSR_GUA              (0x03)
N
N
N/* SOCKET-less Command Register Bit Definition */
N/**
N * @brief IPv4 ARP Command
N * @details It sends a IPv4 ARP request message to @ref _SLDIP4R_ without SOCKETn. \n
N *          The results can be ether @ref SLIR_TOUT or @ref SLIR_ARP4.\n
N *          If the result is @ref SLIR_ARP4, It is success to receive the reply from @ref _SLDIP4R_. \n
N *          You can check the destination hardware address thru @ref _SLDHAR_. \n
N *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP4R_ \n
N *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
N * @sa _SLCR_, _SLDIPR_, _SLDIP4R_ _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
N * @sa getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
N */
N#define SLCR_ARP4            (1<<6)
N
N/**
N * @brief IPv4 PING Command
N * @details It sends a IPv4 PING request message to @ref _SLDIP4R_ without SOCKETn.\n
N *          The results can be ether @ref SLIR_TOUT or @ref SLIR_PING4.\n
N *          If the result is @ref SLIR_PING4, It is success to receive the reply from @ref _SLDIP4R_. \n
N *          Also such like as @ref SLCR_ARP4, You can check the destination hardware address thru @ref _SLDHAR_.\n
N *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP4R_ \n
N *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
N * @sa _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
N * @sa getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
N */
N#define SLCR_PING4           (1<<5)
N
N/**
N * @brief IPv6 ARP Command
N * @details It sends a IPv6 ARP request message to @ref _SLDIP6R_ without SOCKETn. \n
N *          The results can be either @ref SLIR_TOUT or @ref SLIR_ARP6.
N *          If the result is @ref SLIR_ARP6, It is success to receive the reply from @ref _SLDIP6R_. \n
N *          You can check the destination hardware address thru @ref _SLDHAR_.\n
N *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP6R_
N *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
N * @sa _SLCR_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
N * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
N */
N#define SLCR_ARP6            (1<<4)
N
N/**
N * @brief IPv6 PING Command
N * @details It sends a IPv6 PING request message to @ref _SLDIP6R_ without SOCKET. \n
N *          The results can be either @ref SLIR_TOUT or @ref SLIR_PING6.\n
N *          If the result is @ref SLIR_PING6, It is success to receive the reply from @ref _SLDIP6R_.\n
N *          Also such like as @ref SLCR_ARP6, You can check the destination hardware address thru @ref _SLDHAR_.\n
N *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP6R_ \n
N *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
N * @sa _SLCR_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
N * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
N */
N#define SLCR_PING6           (1<<3)
N
N/**
N * @brief IPv6 DAD(Duplicate Address Detection) NS Command
N * @details It sends NS message for DAD to @ref _SLDIP6R_ that is set the address to be used as as @ref _LLAR_ or @ref _GUAR_, without SOCKET.\n
N *          The result can be ether @ref SLIR_TOUT and @ref SLIR_NS.\n
N *          If @ref SLIR_TOUT is set then you can use @ref _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_,\n
N *          else if @ref SLIR_NS is set then you can not use _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_.\n
N *          That means the IPv6 Address are Conflict.
N * @sa _SLCR_, _SLDIP6R_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_, _LLAR_, _GUAR_
N * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR(), \n
N *        getLLAR(), setLLAR(), getGUAR(), setGUAR()
N */
N#define SLCR_NS              (1<<2) 
N
N/**
N * @brief IPv6 Auto-configuration RS Command
N * @details It sends RS message to All-router for IPv6 Auto-configuration without SOCKET.\n
N *         The result can be ether @ref SLIR_RS or @ref SLIR_TOUT. \n
N *         If the result is @ref SLIR_RS, You can some information of router such as a prefix length, a Prefix flag, a valid life time, \n
N *         a preferred life time, and a prefix address respectively thru @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_, and @ref _PAR_.\n
N *         @ref SLIR_TOUT is set when it is no reply from a IPv6 router \n
N *         while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
N * @sa _SLCR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_, _PLR_, _PFR_, _VLTR_, _PLTR_, _PAR_.
N * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR(), \n
N *        getPLR(), getPFR(), getVLTR(), getPLTR(), getPAR().
N */
N#define SLCR_RS              (1<<1)
N
N/**
N * @brief IPv6 Unsolicited NA Command
N * @details It sends the IPv6 unsolicited NA message for updating the network information such as @ref _LLAR_, @ref _GUAR_, and @ref _SHAR_.\n
N *          The result is none.\n
N *          When @ref _SLPSR_ = @ref PSR_GUA, It can send the GUA unsolicited NA message.\n
N *          When @ref _SLPSR_ = Others, It can send the LLA unsolicited NA message.
N * @sa _SLCR_, _SLIR_, _SLIRCLR_, _SLPSR_
N * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCR(), getSLPFR(), setSLPFR()
N */
N#define SLCR_UNA             (1<<0)
N
N
N
N/* PHY Status Register Bit Definition */
N/**
N * @brief CAB mask bit
N * @details @ref PHYSR_CAB masks the CAB bit of @ref _PHYSR_.\n
N *          The masked bit values are as following. \n
N * - @ref PHYSR_CAB_OFF
N * - @ref PHYSR_CAB_ON
N * @sa getPHYSR()
N */
N#define PHYSR_CAB            (1<<7)
N
N/* PHY Status Register Bit Definition */
N/**
N * @brief Ethernet Cable Off
N * @details @ref PHYSR_CAB_OFF indicates the cable is off the Ethernet PHY.
N * @sa _PHYSR_, PHYSR_CAB, PHYSR_CAB_ON
N * @sa getPHYSR()
N */
N#define PHYSR_CAB_OFF        (1<<7)
N
N/**
N * @brief Ethernet PHY Cable On
N * @details @ref PHYSR_CAB_OFF indicates the cable is on the Ethernet PHY.
N * @sa _PHYSR_, PHYSR_CAB, PHYSR_CAB_OFF
N * @sa getPHYSR()
N */
N#define PHYSR_CAB_ON         (0<<7)
N
N/**
N * @brief Mask bits of @ref _PHYSR_
N * @details @ref PHYSR_MODE masks the MODE bits of @ref _PHYSR_.\n
N *          The masked bits values are as following. \n
N *            - @ref PHYSR_MODE_AUTO
N *            - @ref PHYSR_MODE_100F
N *            - @ref PHYSR_MODE_100H
N *            - @ref PHYSR_MODE_10F
N *            - @ref PHYSR_MODE_10H
N * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
N * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
N */
N#define PHYSR_MODE           (7<<3)
N
N/**
N * @brief PHY Mode - AUTO
N * @details @ref PHYSR_MODE_AUTO indicates the Ethernet PHY is operated as auto-negotiation mode.
N * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10F, PHYSR_MODE_10H
N * @sa getPHYSR()
N */
N#define PHYSR_MODE_AUTO      (0<<3)
N
N/**
N * @brief PHY Mode - 100F
N * @details @ref PHYSR_MODE_100F indicates the Ethernet PHY is operated as 100M full-duplex mode.
N * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100H, PHYSR_MODE_10F, PHYSR_MODE_10H
N * @sa getPHYSR()
N */
N#define PHYSR_MODE_100F      (4<<3)
N
N/**
N * @brief PHY Mode - 100H
N * @details @ref PHYSR_MODE_100H indicates the Ethernet PHY is operated as 100M half-duplex mode.
N * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_10F, PHYSR_MODE_10H
N * @sa getPHYSR()
N */
N#define PHYSR_MODE_100H      (5<<3)
N
N/**
N * @brief PHY Mode - 10F
N * @details @ref PHYSR_MODE_10F indicates the Ethernet PHY is operated as 10M full-duplex mode.
N * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10H
N * @sa getPHYSR()
N */
N#define PHYSR_MODE_10F       (6<<3)
N
N/**
N * @brief PHY Mode - 10H
N * @details @ref PHYSR_MODE_10H indicates the Ethernet PHY is operated as 10M half-duplex mode.
N * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10F
N * @sa getPHYSR() 
N */
N#define PHYSR_MODE_10H       (7<<3)
N
N/**
N * @brief DPX mask bit of @ref _PHYSR_
N * @details @ref PHYSR_DPX masks the DPX bit of @ref _PHYSR_. \n
N *          The masked bit values are as following. \n
N *            - @ref PHYSR_DPX_HALF
N *            - @ref PHYSR_DPX_FULL
N * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
N * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
N */
N#define PHYSR_DPX            (1<<2)
N
N/**
N * @brief PHY Duplex - HALF
N * @details @ref PHYSR_DPX_HALF indicates the Ethernet PHY is operated as half-duplex mode.
N * @sa _PHYSR_, PHYSR_DPX_FULL
N * @sa getPHYSR()
N */
N#define PHYSR_DPX_HALF       (1<<2)
N
N/**
N * @brief PHY Duplex - FULL
N * @details @ref PHYSR_DPX_FULL indicates the Ethernet PHY is operated as full-duplex mode.
N * @sa _PHYSR_, PHYSR_DPX_HALF
N * @sa getPHYSR()
N */
N#define PHYSR_DPX_FULL       (0<<2)
N
N/**
N * @brief SPD mask bit of @ref _PHYSR_
N * @details @ref PHYSR_SPD masks the SPD bit of @ref _PHYSR_. The masked bit values are as following. \n
N *   - @ref PHYSR_SPD_10M
N *   - @ref PHYSR_SPD_100M
N * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
N * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
N */
N#define PHYSR_SPD            (1<<1)
N
N /**
N * @brief PHY Speed - 10M
N * @details @ref PHYSR_SPD_10M indicates the Ethernet PHY is operated as 10Mbps speed.
N * @sa _PHYSR_, PHYSR_SPD_100M
N * @sa getPHYSR()
N */
N#define PHYSR_SPD_10M        (1<<1)
N
N /**
N * @brief PHY Speed - 100M
N * @details @ref PHYSR_SPD_100M indicates the Ethernet PHY is operated as 100Mbps speed.
N * @sa _PHYSR_, PHYSR_SPD_10M
N * @sa getPHYSR()
N */
N#define PHYSR_SPD_100M       (0<<1)
N
N/**
N * @brief LNK mask bit of @ref _PHYSR_
N * @details @ref PHYSR_LNK masks the LNK bit of @ref _PHYSR_. The masked bit values are as following. \n
N *   - @ref PHYSR_LNK_DOWN
N *   - @ref PHYSR_LNK_UP
N * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
N * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
N */
N#define PHYSR_LNK            (1<<0)
N
N/**
N * @brief PHY Link - Up
N * @details @ref PHYSR_LNK_UP indicates the link of Ethernet PHY is successfully established .\n
N * @sa _PHYSR_, PHYSR_LNK_DOWN
N * @sa getPHYSR()
N */
N#define PHYSR_LNK_UP         (1<<0)
N
N/**
N * @brief PHY Link - Down
N * @details @ref PHYSR_LNK_DOWN indicates the link of Ethernet PHY is not established yet.\n
N * @sa _PHYSR_, PHYSR_LNK_UP
N * @sa getPHYSR()
N */
N#define PHYSR_LNK_DOWN       (0<<0)
N
N/**
N * @brief Read a value  from the Ethernet PHY register specified by @ref _PHYRAR_.\n
N *        The read value can be checked by _PHYDOR_.
N * @sa _PHYACR_, _PHYDOR_, _PHYRAR_, _PHYDIR_, PHYACR_WRITE
N * @sa getPHYACR(), setPHYACR(), getPHYDOR(), getPHYRAR(), setPHYRAR(), setPHYDIR()
N */
N#define PHYACR_READ          (0x02)
N
N/**
N * @brief Write @ref _PHYDIR_ to the Ethernet PHY register specified by @ref _PHYRAR_.
N * @sa _PHYACR_, _PHYDIR_, _PHYRAR_, _PHYDOR_, PHYACR_READ
N * @sa getPHYACR(), setPHYACR(), setPHYDIR(), getPHYRAR(), setPHYRAR(), getPHYDOR()
N */
N#define PHYACR_WRITE         (0x01)
N
N/**
N * @brief PHY's MDC clock is the divided the system clock by 32
N * @sa _PHYDIVR_
N * @sa getPHYDIVR(), setPHYDIVR()
N */
N#define PHYDIVR_32           (0x00)
N
N/**
N * @brief PHY's MDC clock is the divided system clock by 64
N * @sa _PHYDIVR_
N * @sa getPHYDIVR(), setPHYDIVR()
N */
N#define PHYDIVR_64           (0x01)
N
N/**
N * @brief PHY's MDC clock is the divided system clock by 128
N * @sa _PHYDIVR_
N * @sa getPHYDIVR(), setPHYDIVR()
N */
N#define PHYDIVR_128          (0xFF)
N
N
N/* PHY Command Register Bit Definition */
N/**
N * @brief PHY Operation Mode - Auto Negotiation
N * @details @ref PHYCR0_AUTO sets the Ethernet PHY to operate on auto-negotiation mode.\n
N *          The Ethernet PHY can operate on auto-negotiation after @ref PHYCR1_RST is performed, \n
N *          and the result of @ref PHYCR0_AUTO can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H, BMCR_ANE 
N * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()  
N */
N#define PHYCR0_AUTO          (0x00)
N
N/**
N * @brief PHY Operation Mode - 100F 
N * @details @ref PHYCR0_100F sets the Ethernet PHY to operate on 100F\n
N *          The Ethernet PHY can operate on 100F after @ref PHYCR1_RST is performed,\n
N *          and the result of @ref PHYCR0_100F can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, BMCR_SPD, BMCR_DPX
N * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR0_100F          (0x04)
N
N/**
N * @brief PHY Operation Mode - 100H 
N * @details @ref PHYCR0_100H sets the Ethernet PHY to operate on 100H \n
N *          The Ethernet PHY can operate 100H after @ref PHYCR1_RST is performed, \n
N *          and the result of @ref PHYCR0_100H can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H, BMCR_SPD, BMCR_DPX
N * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR0_100H          (0x05)
N
N/**
N * @brief PHY Operation Mode - 10F 
N * @details @ref PHYCR0_10F sets the Ethernet PHY to operate on 10F \n
N *          The Ethernet PHY can operate 10H after @ref PHYCR1_RST is performed, \n
N *          and the result of @ref PHYCR0_10F can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100F, PHYCR0_100H, PHYCR0_10H, BMCR_SPD, BMCR_DPX
N * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR0_10F           (0x06)
N
N/**
N * @brief PHY Operation Mode - 10H 
N * @details @ref PHYCR0_10H sets the Ethernet PHY to operate on 10H \n
N *          The Ethernet PHY can operate 10H after @ref PHYCR1_RST is performed,  \n
N *          and the result of @ref PHYCR0_10H can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100F, PHYCR0_100H, PHYCR0_10H, BMCR_SPD, BMCR_DPX
N * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR0_10H           (0x07)
N
N
N/**
N * @brief PHY function - Power Down
N * @details @ref PHYCR1_PWDN enters the Ethernet PHY in power down mode. \n
N *          0 : Normal mode \n
N *          1 : Power down mode
N * @note The system clock changes to 25MHz in power down mode, and depends on @ref SYCR1_CLKSEL in normal mode.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR1_, SYCR1_CLKSEL, BMCR_PWDN
N * @sa getPHYCR1(), setPHYCR1(), getSYCR1(), setSYCR1(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR1_PWDN          (1<<5)
N
N/**
N * @brief PHY function - 10Base-TE Mode
N * @details @ref PHYCR1_TE sets the operation of Ethernet PHY to 10base-Te.
N * @note It is valid only when @ref PHYSR_MODE = @ref PHYSR_MODE_AUTO.
N * @note It can be set only when @ref SYSR_PHYL = 1. 
N * @sa _PHYCR1_
N * @sa getPHYCR1(), setPHYCR1()
N */
N#define PHYCR1_TE            (1<<3)
N
N/**
N * @brief PHY function - HW Reset
N * @details @ref PHYCR1_RST resets the Ethernet PHY in hardware, \n
N *          and it is automatically cleared after the H/W reset and it takes 60.3ms to stabilize.\n
N *          0 : Normal mode \n  
N *          1 : H/W Reset \n
N * @note The system clock changes to 25MHz in H/W reset time, and depends on @ref SYCR1_CLKSEL in normal mode.
N * @note It can be set only when @ref SYSR_PHYL = 1. 
N * @sa _PHYCR1_, BMCR_RST
N * @sa getPHYCR1(), setPHYCR1(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR1_RST           (1<<0)
N
N
N
N/* IPv4 Network Mode Register Bit Definition */
N/**
N * @brief UDP Unreachable Packet Block
N * @details @ref NETxMR_UNRB can block sending a ICMPv or ICMPv6 unreachable message to a peer.
N * @sa _NET4MR_, _NET6MR_
N * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
N */
N#define NETxMR_UNRB          (1<<3) 
N
N/**
N * @brief PING ARP Request
N * @details @ref NETxMR_PARP can send a ARP request before sending a ICMPv4 or ICMPv6 PING reply.
N * @sa _NET4MR_, _NET6MR_
N * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
N */
N#define NETxMR_PARP          (1<<2)
N
N/**
N * @brief TCP Reset Packet Block
N * @details @ref NETxMR_RSTB can block sending a TCP RST packet based on IPv4 or IPv6 \n
N *          when there is no SOCKET n opened with a listen port.
N * @sa _NET4MR_, _NET6MR_
N * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
N */
N#define NETxMR_RSTB          (1<<1)
N
N/**
N * @brief PING Reply Block
N * @details @ref NETxMR_PB can block sending a ICMPv4 or ICMPv6 PING reply to a peer.
N * @sa _NET4MR_, _NET6MR_
N * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
N */
N#define NETxMR_PB            (1<<0)
N
N
N/* Network Mode Register Bit Definition */
N/**
N * @brief All-node Multicating PING Reply Block
N * @details @ref NETMR_ANB can block sending a IPv6 PING reply to the peer ping requested to all-node multicast address.
N * @sa _NETMR_
N * @sa getNETMR(), setNETMR()
N */
N#define NETMR_ANB            (1<<5)
N
N/**
N * @brief Solicited Multicasting PING Reply Block
N * @details @ref NETMR_M6B can block sending a IPv6 PING reply to the peer ping requested to the own solicited multicast address.
N * @sa _NETMR_
N * @sa getNETMR(), setNETMR()
N */
N#define NETMR_M6B            (1<<4)
N
N/**
N * @brief Wake On LAN mode
N * @details @ref NETMR_WOL can receive a magic packet of WOL.
N * @sa _NETMR_
N * @sa getNETMR(), setNETMR()
N */
N#define NETMR_WOL            (1<<2)
N
N/**
N * @brief IPv6 Packet Block
N * @details @ref NETMR_IP6B can block receiving all IPv6 packets.
N * @sa _NETMR_
N * @sa getNETMR(), setNETMR()
N */
N#define NETMR_IP6B           (1<<1)
N
N/**
N * @brief IPv4 Packet Block
N * @details @ref NETMR_IP4B can block receiving all IPv4 packets.
N * @sa _NETMR_
N * @sa getNETMR(), setNETMR()
N */
N#define NETMR_IP4B           (1<<0)
N
N
N/**
N * @brief Destination Hardware Address Select
N * @details @ref NETMR2_DHAS masks the DHAS bit of @ref _NETMR2_. \n
N *          The masked bit values are as following.
N *            - @ref NETMR2_DHAS_ARP
N *            - @ref NETMR2_DHAS_ETH
N *
N * @note It is useful when the destination hardware address of Ethernet frame is different from the target address of ARP.
N * @sa _NETMR2_
N * @sa getNETMR2(), setNETMR2()
N */
N#define NETMR2_DHAS          (1<<7)
N
N/**
N * @brief Destination Hardware Address Select - ARP
N * @details @ref NETMR2_DHAS_ARP select the target address of ARP-replay packet to the destination hardware address.
N * @sa _NETMR2_, NETMR2_DHAS_ETH
N * @sa getNETMR2(), setNETMR2()
N */
N#define NETMR2_DHAS_ARP      (1<<7)
N
N/**
N * @brief Destination Hardware Address Select - Ethernet Frame
N * @details @ref NETMR2_DHAS_ETH select the destination address of Ethernet frame to the destination hardware address.
N * @sa _NETMR2_, NETMR2_DHAS_ARP
N * @sa getNETMR2(), setNETMR2()
N */
N#define NETMR2_DHAS_ETH      (0<<7)
N
N/**
N * @brief PPPoE Mode
N * @details @ref NETMR2_PPPoE enables PPPoE mode \n
N *          0 : Disable \n
N *          1 : Enable
N * @note For enabling a PPPoE mode, some information such like as _PTMR_, _PHAR_, _PSIDR_, and _PMRUR_ are needed. \n
N *       To get these information, You can use a SOCKET0 opened with @ref Sn_MR_MACRAW. 
N * @sa _NETMR2_, _PTMR_, _PHAR_, _PSIDR_, _PMRUR_, Sn_MR_MACRAW
N * @sa getNETMR2(), setNETMR2()
N */
N#define NETMR2_PPPoE         (1<<0)
N
N/* ICMPv6 Block Register Bit Definition */
N/**
N * @brief ICMPv6 PING Block
N * @details @ref ICMP6BLKR_PING6 can block a ping request from a peer
N * @sa _IMCP6BLKR_, NETxMR_PB
N * @sa getICMP6BLKR(), setICMP6BLKR(), getNET6MR(), setNET6MR()
N */
N#define ICMP6BLKR_PING6      (1<<4)
N
N/**
N * @brief ICMPv6 MLD Block
N * @details @ref ICMP6BLKR_MLD can block a multicast listener discovery(MLD) query.
N * @sa _ICMP6BLKR_
N * @sa getICMP6BLKR(), setICMP6BLKR()
N */
N#define ICMP6BLKR_MLD        (1<<3)
N
N/**
N * @brief ICMPv6 RA Block
N * @details @ref ICMP6BLKR_RA can block a RA packet from a router
N * @sa _ICMP6BLKR_
N * @sa getICMP6BLKR(), setICMP6BLKR()
N */
N#define ICMP6BLKR_RA         (1<<2)
N
N/**
N * @brief ICMPv6 NA Block
N * @details @ref ICMP6BLKR_NA can block a Neighbor Advertisement(NA) from a peer
N * @sa _ICMP6BLKR_
N * @sa getICMP6BLKR(), setICMP6BLKR()
N */
N#define ICMP6BLKR_NA         (1<<1)
N
N/**
N * @brief ICMPv6 NS Block
N * @details @ref ICMP6BLKR_NS can block a Neighbor Solicitation(NS) from a peer
N * @sa _ICMP6BLKR_
N * @sa getICMP6BLKR(), setICMP6BLKR()
N */
N#define ICMP6BLKR_NS         (1<<0)
N
N
N/* Sn_MR values */
N/**
N * @brief UDP Multicasting 
N * @details  @ref Sn_MR_MULTI enables to a multicast packet from a multicast group in UDP mode SOCKETn. \n
N *            To use multicasting, @ref _Sn_DIPR_, @ref _Sn_DIP6R_, & @ref _Sn_DPORTR_ should be respectively set with \n
N *            the multicast group IPv4, IPv6 address & port number before @ref Sn_CR_OPEN. \n
N *            0 : Disable Multicasting \n
N *            1 : Enable Multicasting \n
N * @note It is valid only in UDP mode such like as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
N * @sa _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_
N * @sa getSn_MR(), setSn_MR(), getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR().
N */
N#define Sn_MR_MULTI          (1<<7)
N
N/**
N * @brief MAC Filter 
N * @details @ref Sn_MR_MF filters other packets except broadcasting, multicasting, and packets sent to your own.\n
N *          0 : Disable MAC Filtering \n
N *          1 : Enable MAC Filtering \n
N * @note It is valid only in MACRAW SOCKET0 opened with @ref Sn_MR_MACRAW \n
N * @note If you want to implement a hybrid TCP/IP stack, \n
N *       It is recommended that @ref Sn_MR_MF enable for reducing host overhead to process the all received packets.
N * @sa _Sn_MR_, Sn_MR_MULTI
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_MF             (1<<7)
N
N/**
N * @brief Broadcasting packet block
N * @details @ref Sn_MR_BRDB can block a broadcasting packet in MACRAW SOCKET0 or UDP mode SOCKETn. \n
N *          0 : Disable Broadcast Blocking \n
N *          1 : Enable Broadcast Blocking \n
N * @note It is valid only in MACRAW mode such as @ref Sn_MR_MACRAW, or in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
N * @sa _Sn_MR_, Sn_MR_FPSH 
N * @sa getSn_MR(), setSn_MR()
N */
N #define Sn_MR_BRDB          (1<<6)
N
N/**
N * @brief Force PUSH flag
N * @details When @ref Sn_MR_FPSH is set, all TCP DATA packets with PSH flag set can be transmitted by @ref Sn_CR_SEND. \n
N *          When @ref Sn_MR_FPSH is not set, the PSH flag is set only in the last DATA packet among the DATA packets transmitted by @ref Sn_CR_SEND. \n
N *          0 : No Force PSH flag \n
N *          1 : Force PSH flag \n
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_MR_, Sn_CR_SEND, Sn_MR_BRDB
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
N */
N#define Sn_MR_FPSH           (1<<6)
N
N/**
N * @brief No Delayed Ack
N * @details When @ref Sn_MR_FPSH is set, It sends the ACK packet without delay as soon as a DATA packet is received from a peer.\n
N *          Otherwise, It sends the ACK packet after waiting the time set by @ref _Sn_RTR_. \n
N *          0 : Delayed ACK \n
N *          1 : No Delayed ACK \n
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.
N * @note Regardless of @ref Sn_MR_ND, It sends the ACK packet when SOCKETn window size is less than MSS after @ref Sn_CR_RECV.
N * @sa _Sn_MR_, _Sn_RTR_, Sn_CR_RECV, Sn_MR_MC, Sn_MR_SMB, Sn_MR_MMB
N * @sa getSn_MR(), setSn_MR(), getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
N */
N #define Sn_MR_ND            (1<<5)
N
N/**
N * @brief IGMP version for IPv4 Multicasting
N * @details @ref Sn_MR_MC decides IGMP version. \n
N *          0 : IGMPv2 \n
N *          1 : IGMPv1 \n
N * @note It is valid only when @ref Sn_MR_MULTI = '1' and UDP mode is @ref Sn_MR_UDP4.
N * @note IGMP packet can be automatically sent to the multicast group by @ref Sn_CR_OPEN.
N * @note @ref _WIZCHIP_ doesn't not support IGMP version 3.
N * @sa _Sn_MR_, Sn_MR_MULTI, Sn_MR_ND, Sn_MR_SMB, Sn_MR_MMB
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_MC             (1<<5)
N
N/**
N * @brief Solicited Mulitcast Block
N * @details @ref Sn_MR_SMB can block a received packet that have your own solicited multicast address. \n
N *          0 : Unblock a solicited multicast packet \n
N *          1 : Block a solicited multicast packet \n
N * @note It is valid only when UDP mode is @ref Sn_MR_UDP6 or @ref Sn_MR_UDPD.
N * @sa _Sn_MR_,  Sn_MR_ND, Sn_MR_MC, Sn_MR_MMB
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_SMB            (1<<5)
N
N/**
N * @brief UDP4 Multicast Block
N * @details @ref Sn_MR_MMB can block the UDP4 multicast packet when SOCKET0 is opend with @ref Sn_MR_MACRAW and @ref Sn_MR_MF is set.\n
N *          0 : Unblock a UDP multicast packet with IPv4 address \n
N *          1 : Block a UDP multicast packet with IPv4 address \n
N * @note It is valid only in MACRAW SOCKET0 with Sn_MR_MF = '1'.
N * @sa _Sn_MR_, Sn_MR_MMB6, Sn_MR_ND, Sn_MR_MC, Sn_MR_SMB
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_MMB            (1<<5)
N#define Sn_MR_MMB4           (Sn_MR_MMB)  /// Refer to @ref Sn_MR_MMB.
N
N/**
N * @brief Unicast Block
N * @details @ref Sn_MR_UNIB can block a unicast packet. \n
N *          0 : Unblock a UDP unicast packet \n
N *          1 : Block a UDP unicast packet \n
N * @note It is valid only when SOCKETn is opened with UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6 and @ref Sn_MR_UDPD, and @ref Sn_MR_MULTI is set.
N * @sa _Sn_MR_, Sn_MR_MULTIL, Sn_MR_MMB6
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_UNIB           (1<<4)
N
N/**
N * @brief UDP6 Multicast Block
N * @details @ref Sn_MR_MMB6 can block the UDP6 multicast packet. \n
N *          0 : Unblock a UDP multicast packet with IPv6 address \n
N *          1 : Block a UDP multicast packet with IPv6 address \n
N * @note  It is valid only when SOCKET0 is opend with @ref Sn_MR_MACRAW and @ref Sn_MR_MF is set.
N * @sa _Sn_MR_, Sn_MR_MMB
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_MMB6           (1<<4)
N
N/**
N * @brief SOCKETn Closed
N * @details @ref Sn_MR_CLOSE is not opened yet.\n
N *          It is the default mode when @ref _WIZCHIP_ is reset.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_CLOSE          (0x00)
N
N/**
N * @brief IPv4 TCP mode 
N * @details @ref Sn_MR_TCP(= @ref Sn_MR_TCP4) sets SOCKETn to TCP4 mode. \n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opend as TCP4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.
N * @note In oder to connect a peer, You should use @ref Sn_CR_CONNECT as command and @ref _Sn_DIPR_ as destination.
N * @note In order to send data, You should use @ref Sn_CR_SEND.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_TCP6, Sn_MR_TCPD
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_TCP            (0x01)
N#define Sn_MR_TCP4           (Sn_MR_TCP)   ///< Refer to @ref Sn_MR_TCP.
N
N/**
N * @brief IPv4 UDP mode
N * @details @ref Sn_MR_UDP(= @ref Sn_MR_UDP4) sets SOCKETn to UDP4 mode.\n
N *          It should be set before @ref Sn_CR_OPEN is performed. \n
N *          After @ref Sn_CR_OPEN, SOCKETn is opend as UDP4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
N * @note In order to send data, You should use @ref Sn_CR_SEND as command and @ref _Sn_DIPR_ as destination.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP6, Sn_MR_UDPD
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_UDP            (0x02)
N#define Sn_MR_UDP4           (Sn_MR_UDP)   ///< Refer to @ref Sn_MR_UDP
N
N/**
N * @brief IPv4 RAW mode
N * @details @ref Sn_MR_IPRAW(= @ref Sn_MR_IPRAW4) sets SOCKETn to IPRAW4 mode. \n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opend as IPRAW4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW(= @ref SOCK_IPRAW4).
N * @note In order to send data, You should use @ref Sn_CR_SEND as command and @ref _Sn_DIPR_ as destination.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_IPRAW6
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_IPRAW          (0x03)
N#define Sn_MR_IPRAW4         (Sn_MR_IPRAW)   ///< Refer to @ref Sn_MR_IPRAW.   
N
N/**
N * @brief MACRAW mode
N * @details @ref Sn_MR_MACRAW sets only SOCKET0 to MACRAW mode.\n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKET0 is opend as MACRAW mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_MACRAW.
N * @note In order to send data, You should use @ref Sn_CR_SEND.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_MACRAW         (0x07)
N
N/**
N * @brief IPv6 TCP mode 
N * @details @ref Sn_MR_TCP6 sets SOCKETn to TCP6 mode. \n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opend as TCP6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.
N * @note In oder to connect a peer, You should use @ref Sn_CR_CONNECT6 as command and @ref _Sn_DIP6R_ as destination.
N * @note In order to send data, You should use @ref Sn_CR_SEND, not @ref Sn_CR_SEND6.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_TCP4, Sn_MR_TCPD
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_TCP6           (0x09)
N
N/**
N * @brief IPv6 UDP mode
N * @details @ref Sn_MR_UDP6 sets SOCKETn to UDP6 mode.\n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opend as UDP6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
N * @note In order to send data, You should use @ref Sn_CR_SEND6 as command and @ref _Sn_DIP6R_ as destination.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP4, Sn_MR_UDPD
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_UDP6           (0x0A)
N
N/**
N * @brief IPv6 RAW mode
N * @details @ref Sn_MR_IPRAW6 sets SOCKETn to IPRAW6 mode.\n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opened as IPRAW6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW6.
N * @note In order to send data, You should use @ref Sn_CR_SEND6 as command and @ref _Sn_DIP6R_ as destination.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_IPRAW4
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_IPRAW6         (0x0B)
N
N/**
N * @brief Both IPv4 & IPv6 TCP mode (TCP dual mode)
N * @details @ref Sn_MR_TCPD sets SOCKETn to both TCP4 & TCP6 mode. \n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opened as TCP Dual mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.\n
N *          The real mode of TCP dual SOCKETn is decided when the connection with a peer is established.\n
N *   - In SOCKETn is operated as <b>TCP SERVER</b> mode 
N *     If the connection request client have a IPv4 address, \n
N *     TCP dual SOCKETn is changed to TCP4 mode and a destination IP address can be checked thru @ref _Sn_DIPR_, \n
N *     else if the client have a IPv6 address, \n
N *     TCP dual SOCKETn is changed to IPv6 mode and destination IP address can be checked by thru @ref _Sn_DIP6R_.
N *   - In SOCKETn is operated as <b>TCP CLIENT</b> mode, 
N *     If the IP address type of destination to connect is IPv4, \n
N *     the destination IP address should be set to @ref _Sn_DIPR_ and try to connect by @ref Sn_CR_CONNECT, \n
N *     else if the type is IPv6, \n
N *     the destination IP address should be set to @ref _Sn_DIP6R_ and try to connect by @ref Sn_CR_CONNECT6. \n
N *           
N * @note In <b>TCP SERVER</b> mode, You can check the IP type of the client with @ref Sn_ESR_TCPM.
N * @note If the connected client have a IPv6 address, You can check whether the address is LLA or GAU, thru @ref Sn_ESR_IP6T
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, _Sn_ESR_TCPM_, Sn_MR_TCP4, Sn_MR_TCP6
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR(), getSn_ESR()
N */
N#define Sn_MR_TCPD           (0x0D)
N
N/**
N * @brief UDP Dual mode
N * @details @ref Sn_MR_UDPD sets SOCKETn to both UDP4 & UDP6 mode. \n
N *          It should be set before @ref Sn_CR_OPEN is performed. \n
N *          After @ref Sn_CR_OPEN, SOCKETn is opened as UDP dual mode \n
N *          and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
N * @note In order to send data, \n
N *       You can use both @ref Sn_CR_SEND and @ref Sn_CR_SEND6 as command and both @ref _Sn_DIPR_ and @ref _Sn_DIP6R_ as destination.
N * @note You can know the destination IP address type is whether IPv6 or IPv4 thru @ref getsockopt() with @ref SO_PACKINFO.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP6, Sn_MR_UDP4
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_UDPD           (0x0E)
N
N/* SOCKETn  Command Register BIt Definition */
N/**
N * @brief Initialize or Open SOCKETn.
N * @details SOCKETn is initialized and opened according to the protocol mode selected by @ref _Sn_MR_ and with a source port set by @ref _Sn_PORTR_. \n
N *                   The table shows @ref _Sn_SR_ is changed according to @ref _Sn_MR_.\n
N * <table>
N *    <tr> <td> <b>@ref _Sn_MR_</b> (P[3:0])                      </td> <td><b>@ref _Sn_SR_</b> </td> </tr>
N *    <tr> <td> @ref Sn_MR_CLOSE                                  </td> <td> @ref SOCK_CLOSED   </td> </tr>
N *    <tr> <td> @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, @ref Sn_MR_TCPD </td> <td> @ref SOCK_INIT     </td> </tr>
N *    <tr> <td> @ref Sn_MR_UDP, @ref Sn_MR_UDP6, @ref Sn_MR_UDPD  </td> <td> @ref SOCK_UDP      </td> </tr>
N *    <tr> <td> @ref Sn_MR_IPRAW4                                 </td> <td> @ref SOCK_IPRAW4   </td> </tr>
N *    <tr> <td> @ref Sn_MR_IPRAW6                                 </td> <td> @ref SOCK_IPRAW6   </td> </tr>
N *    <tr> <td> @ref Sn_MR_MACRAW                                 </td> <td> @ref SOCK_MACRAW   </td> </tr>
N * </table>
N *
N * @note If you want to use a SOCKETn option such as Sn_MR_MF, Sn_MR_ND, Sn_MR_MUTIL and etc, \n
N *       these options should be set before @ref Sn_CR_OPEN is performed.
N * @note If you want to open a multicast UDP mode SOCKETn, \n
N *       You should set the multicast group with @ref _Sn_DIPR_ or @ref _Sn_DIP6R_ and @ref _Sn_DPORTR_ before @ref Sn_CR_OPEN is performed.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_PORTR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_,
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_PORTR(), setSn_PORTR(), getSn_DIPR(), setSn_DIPR(),
N *     getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR()
N */
N#define Sn_CR_OPEN           (0x01)
N
N/**
N * @brief Wait a connection request in <b>TCP SERVER</b> mode
N * @details SOCKETn operates as a <b>TCP SERVER</b> and waits for a connection-request (SYN packet) \n
N *          with corresponding @ref _Sn_PORTR_ port number from any <b>TCP CLIENT</b> \n
N *          The @ref _Sn_SR_ is changed from @ref SOCK_INIT to @ref SOCK_LISTEN. \n
N *          When a <b>TCP CLIENT</b> connection request is successfully accepted,\n
N *          the @ref _Sn_SR_ is changed from @ref SOCK_LISTEN to @ref SOCK_ESTABLISHED \n
N *          and the @ref Sn_IR_CON is set.\n
N *          But when a <b>TCP CLIENT</b> connection request is failed, \n
N *          @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to SOCK_CLOSED.
N * @note This is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_PORTR_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_PORTR(), setSn_PORTR()
N */
N#define Sn_CR_LISTEN         (0x02)
N
N/**
N * @brief Send a connection request in <b>TCP CLIENT</b> mode
N * @details To establish a connection, a connect-request (SYN packet) is sent to <b>TCP SERVER</b> set by @ref _Sn_DIPR_ & @ref _Sn_DPORTR_.\n
N *          If the connect-request is successful accepted by a <b>TCP SERVER</b>, \n
N *          the @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and the @ref Sn_IR_CON is set. \n
N *          The connect-request fails in the following three cases, \n
N *          and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n\n
N *  1. Until a ARP timeout is occurred (@ref Sn_IR_TIMEOUT = 1), a destination hardware address can not be acquired through the ARP-process.\n
N *  2. Until a TCP tmeout occurred (@ref Sn_IR_TIMEOUT = 1), a SYN/ACK packet is not received from the server\n
N *  3. When a RST packet is received instead of a SYN/ACK packet \n
N *
N * @note This is valid only in TCP mode such as @ref Sn_MR_TCP4 and @ref Sn_MR_TCPD. 
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_DIPR_, _Sn_DPORTR_, Sn_CR_CONNECT6, _Sn_IR_, _Sn_IRCLR_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIPR(), setSn_DIPR(), getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR()
N */
N#define Sn_CR_CONNECT        (0x04)
N
N/**
N * @brief Send connection request in <b>TCP CLIENT</b> mode
N * @details To establish a connection, a connect-request (SYN packet) is sent to <b>TCP SERVER</b> set by @ref _Sn_DIP6R_ & @ref _Sn_DPORTR_.\n
N *          If the connect-request is successful accepted by a <b>TCP SERVER</b>, \n
N *          the @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and the @ref Sn_IR_CON is set. \n
N *          The connect-request fails in the following three cases, and @ref _Sn_SR_ is changed @ref SOCK_CLOSED.\n
N *   1. Until a ARP timeout is occurred (@ref Sn_IR_TIMEOUT = 1), a destination hardware address can not be acquired through the ARP-process.\n
N *   2. Until a TCP tmeout occurred (@ref Sn_IR_TIMEOUT = 1), a @b SYN/ACK packet is not received from the server\n
N *   3. When a RST packet is received instead of a @b SYN/ACK packet \n
N *
N * @note This is valid only in TCP mode such as @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD. 
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_DIP6R_, _Sn_DPORTR_, Sn_CR_CONNECT, _Sn_IR_, _Sn_IRCLR_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR()
N */
N#define Sn_CR_CONNECT6       (0x84)
N
N/**
N * @brief Send a disconnect request in TCP mode
N * @details Regardless of <b>TCP SERVER</b> or <b>TCP CLIENT</b>, \n
N *          @ref Sn_CR_DISCON processes the disconnect-process (Active or Passive close).\n
N *          When the disconnect-process is successful (that is, FIN/ACK packet is received successfully from/to each other),\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n
N *          Otherwise, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N *   - Active close 
N *     It transmits first a disconnect-request(FIN packet) to the connected peer, and waits to receive two FIN/ACK and FIN packet from the peer. \n
N *     If two FIN/ACK and FIN packet is received successfully, @ref Sn_IR_DISCON is set and @ref _Sn_SR_ is changed @ref SOCK_CLOSED.
N *   - Passive close
N *     When a FIN packet is first received from the peer, the FIN/ACK packet is replied back to the peer and @ref Sn_IR_DISCON is set.\n
N *     And then, a FIN packet is sent by @ref Sn_CR_DISCON to the peer, and waits to receive the FIN/ACK packet from the peer. \n
N *     If the FIN/ACK packet is received successfully from the peer, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N *
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_DISCON, Sn_IR_TIMEOUT
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_IR(), setSn_IRCLR()
N */
N#define Sn_CR_DISCON         (0x08)
N
N/**
N * @brief Release or Close SOCKETn
N * @details In TCP mode, @ref Sn_CR_CLOSE force to close a SOCKETn without the disconnect-process.\n
N *          In other SOCKETn mode, @ref Sn_CR_CLOSE just closes a SOCKET.\n
N * @note @ref _Sn_SR_ can be changed from any status to @ref SOCK_CLOSED by @ref Sn_CR_CLOSE.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, Sn_CR_DISCON
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR()
N */
N#define Sn_CR_CLOSE          (0x10)
N
N/**
N * @brief Send Data  
N * @details @ref Sn_CR_SEND send the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX buffer \n
N *          to the destination specified by @ref _Sn_DIPR_ or @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_.\n
N *   - TCP mode(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6,  @ref Sn_MR_TCPD)
N *     If it starts to be sent the data by @ref Sn_CR_SEND, @ref Sn_IR_SENDOK is set. \n 
N *     And after sending the data, if the ACK to the sent data can not be received during @ref _Sn_RTR_, \n
N *     the sent data can be retransmitted as many as @ref _Sn_RCR_. \n
N *     During the retransmission, \n
N *     If the ACK is received, @ref _Sn_TX_FSR_ is increased as many as the sent data size, \n
N *     Otherwise, @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N *   - UDP mode(@ref Sn_MR_UDP4, @ref Sn_MR_UDPD) & IPRAW mode(@ref Sn_MR_IPRAW4)
N *     It first sends a ARP-request to a destination specified with @ref _Sn_DIPR_ before it starts to be sent data by @ref Sn_CR_SEND. \n
N *     If the ARP-reply can not be received during @ref _Sn_RTR_, the ARP-request can be retransmitted as many as @ref _Sn_RCR_. \n
N *     During the retransmission, \n
N *     If the ARP-reply is received and @ref Sn_IR_SENDOK is set, it starts to send data and then @ref _Sn_TX_FSR_ is increased as many as the sent data size. \n
N *     Otherwise, @ref Sn_IR_TIMEOUT is set but @ref _Sn_SR_ is not changed.
N *   - MACRAW mode(@ref Sn_MR_MACRAW)
N *     It just start to send data and @ref Sn_IR_SENDOK is set.
N *
N * @note Data size to be sent is calculated by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_. \n
N *       In TCP or UDP mode, It can not be sent bigger data than @ref _Sn_TX_FSR_.\n
N *       In IPRAW or Macraw case, it can not be sent bigger data than MTU(Maximum Transmit Unit).
N * @note In TCP or MACRAW mode, It can send data to a destination address whether IPv4 or IPv6. \n
N *       In UDP or IPRAW mode, It can send data only to a destination IPv4 address. \n
N *       For Sending to IPv6 address, It can be used with @ref Sn_CR_SEND6.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_, _Sn_IR_, _Sn_IRCLR_, _Sn_TX_FSR_, _Sn_TX_WR_, _Sn_TX_RD_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), \n
N *     getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR(), getSn_TX_FSR(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD()
N */
N#define Sn_CR_SEND           (0x20)
N
N/**
N * @brief Send Data       
N * @details @ref Sn_CR_SEND6 sends the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX buffer \n
N *          to the destination specified by @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_.\n
N *   - TCP mode(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6,  @ref Sn_MR_TCPD) & MACRAW mode(@ref Sn_MR_MACRAW)
N *     @ref Sn_CR_SEND6 is not recommended. In this case, Use @ref Sn_CR_SEND.
N *   - UDP mode(@ref Sn_MR_UDP6, @ref Sn_MR_UDPD) & IPRAW mode(@ref Sn_MR_IPRAW6)
N *     It first send a neighbor solicitation NS) of ICMPv6 to a destination specified with @ref _Sn_DIP6R_ \n
N *     before it starts to be sent data by @ref Sn_CR_SEND. \n
N *     If the neighbor advertisement(NA) of ICMPv6 can not be received during @ref _Sn_RTR_, \n
N *     the NS can be retransmitted as many as @ref _Sn_RCR_. \n
N *     During the retransmission, \n
N *     If the NA is received and @ref Sn_IR_SENDOK is set, \n
N *     it starts to send data and then @ref _Sn_TX_FSR_ is increased as many as the sent data size. \n
N *     Otherwise, @ref Sn_IR_TIMEOUT is set but @ref _Sn_SR_ is not changed.
N *
N * @note Data size to be sent is calculated by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_. \n
N *       In TCP or UDP mode, It can not be sent bigger data than @ref _Sn_TX_FSR_.\n
N *       In IPRAW or Macraw case, it can not be sent bigger data than MTU(Maximum Transmit Unit).
N * @note In UDP or IPRAW mode, It can send data only to a destination IPv6 address. \n
N *       For Sending to IPv4 address, It can be sent by @ref Sn_CR_SEND.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_DIP6R_, _Sn_DPORTR_, _Sn_IR_, _Sn_IRCLR_, _Sn_TX_FSR_, _Sn_TX_WR_, _Sn_TX_RD_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR(), \n
N *     getSn_IR(), setSn_IRCLR(), getSn_TX_FSR(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD()
N */
N #define Sn_CR_SEND6         (0xA0)
N
N/**
N * @brief Send keep alive message
N * @details @ref Sn_CR_SEND_KEEP checks whether the connection is established or not by sending 1 byte KA(Keep Alive) packet.\n
N *          If the destination can not respond to the KA packet during the time set by @ref _Sn_RTR_ and @ref _Sn_RCR_, \n
N *          the connection is terminated, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed @ref SOCK_CLOSED.
N * @note It is valid only after sending data over 1 byte in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_IR_, _Sn_IRCLR_, _Sn_RTR_, _Sn_RCR_, _Sn_KPALVTR_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_IR(), setSn_IRCLR(), \n
N *        getSn_RTR(), setSn_RTR(), getSn_RCR(), setSn_RCR(), getSn_KPALVTR(), getSn_KPALVTR()
N */
N#define Sn_CR_SEND_KEEP      (0x22)
N
N/**
N * @brief Receive data
N * @details @ref Sn_CR_RECV reads the saved from @ref _Sn_RX_RD_ to @ref _Sn_RX_WR_ data in SOCKETn RX buffer.\n
N *          When a data is saved in the SOCKETn RX buffer, \n
N *          @ref Sn_IR_RECV is set and @ref _Sn_RX_RSR_ is increased as many as the saved data size.\n
N *          The total size of saved data is calculated by the absolute difference between @ref _Sn_RX_WR_ and @ref _Sn_RX_RD_,\n
N *          and it can be checked thru @ref _Sn_RX_RSR_.\n
N *          After reading data, @ref _Sn_RX_RD_ should be increased as many as the read size before @ref Sn_CR_RECV is performed.\n
N *          After @ref Sn_CR_RECV, @ref _Sn_RX_RSR_ is decreased as many as the read size.\n
N *          If @ref _Sn_RX_RSR_ is remained still at none-zero, @ref Sn_IR_RECV is set again.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_IR_, _Sn_IRCLR_, _Sn_RX_RD_, _Sn_RX_WR_, _Sn_RX_RSR_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_IR(), getSn_IRCLR(), \n
N *     getSn_RX_RD(), setSn_RX_RD(), getSn_RX_TX(), getSn_RX_RSR()
N */
N#define Sn_CR_RECV           (0x40)
N
N
N/* Sn_IR values */
N/**
N * @brief SEND OK Interrupt
N * @details @ref Sn_IR_SENDOK is set when it is started to be sent data by @ref Sn_CR_SEND. 
N * @note Even though @ref Sn_IR_SENDOK is set, it does not means that the destination receives data successfully.\n
N *         - In TCP mode, The sent data maybe still transmitting or retransmitting. \n
N *         - In other modes, The sent data maybe lost by media collision or an other reason such as network traffic.
N * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_SEND
N * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
N */
N#define Sn_IR_SENDOK         (0x10)
N
N/**
N * @brief TIMEOUT Interrupt
N * @details @ref Sn_IR_TIMEOUT is set when a timeout occurs in ARP and ND process or TCP retransmission.
N * @note In TCP mode, If it is set, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED. \n
N *       In other modes, _Sn_SR_ is still remained at the previous status.
N * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_CONNECT, Sn_CR_CONNECT6, Sn_CR_SEND
N * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
N */
N#define Sn_IR_TIMEOUT        (0x08)
N
N/**
N * @brief RECV Interrupt
N * @details @ref Sn_IR_RECV is set whenever data is received from a peer, \n
N *          or if @ref _Sn_RX_RSR_ is still at none-zero whenever @ref Sn_CR_RECV is performed.
N * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_RECV
N * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
N */
N#define Sn_IR_RECV           (0x04)
N
N/**
N * @brief DISCON Interrupt
N * @details @ref Sn_IR_DISCON is set when a FIN or FIN/ACK packet is received from the connected peer.
N * @note When first a FIN packet is received from the connected peer and @ref _Sn_SR_ is changed to SOCK_CLOSE_WAIT, \n
N *       you should perform @ref Sn_CR_DISCON for a successful disconnect. \n
N *       If the disconnect-process is completed or failed, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valild only in TCP mode such as @ref Sn_MR_TCP4, @ ref Sn_MR_TCP6 and @ref Sn_MR_TCPD.
N * @sa _Sn_IR_, _Sn_IRCLR_, Sn_IR_DISCON, _Sn_SR_
N * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_IR_DISCON         (0x02)
N
N/**
N * @brief CONNECT Interrupt
N * @details @ref Sn_IR_CON is set once the connection with a peer is established and @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ ref Sn_MR_TCP6 adn @ref Sn_MR_TCPD.
N * @sa _Sn_IR_, _Sn_IRCLR_, _Sn_SR_
N * @sa getSn_IR(), setSn_IRCLR(), getSn_SR()
N */
N#define Sn_IR_CON            (0x01)
N
N/* Sn_SR values */
N/**
N * @brief SOCKETn Closed status
N * @details @ref SOCK_CLOSED indicates that SOCKETn is closed and released.\n
N *          It is set when @ref Sn_CR_DISCON , @ref Sn_CR_CLOSE is performed, or when @ref Sn_IR_TIMEOUT is set.\n
N *          It can be changed to @ref SOCK_CLOSED regardless of previous status.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
N * @sa getSn_SR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR()
N */
N#define SOCK_CLOSED          (0x00)
N
N/**
N * @brief TCP SOCKETn initialized status
N * @details @ref SOCK_INIT indicates SOCKETn is opened with TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.\n
N *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT when @ref Sn_CR_OPEN is performed in TCP mode.\n
N *          In @ref SOCK_INIT status, @ref Sn_CR_LISTEN for operating a <b>TCP SERVER</b> \n
N *          or @ref Sn_CR_CONNECT / @ref Sn_CR_CONNECT6 for operating a <b>TCP CLIENT</b> can be performed.
N * @note It is valid only in TCP mode.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_MR_
N * @sa getSn_SR, getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_INIT            (0x13)
N
N/**
N * @brief TCP SOCKETn Listen status
N * @details @ref SOCK_LISTEN indicates SOCKETn is operating as <b>TCP SERVER</b> mode \n
N *          and waiting for connection-request (SYN packet) from a peer (<b>TCP CLIENT</b>).\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_SYNRECV when the connection-request(SYN packet) is successfully accepted \n
N *          and It is changed from @ref SOCK_SYNRECV to @ref SOCK_ESTABLISHED \n
N *          when the SYN/ACK packet is sent successfully to the peer and then the ACK packet of SYN/ACK is received successfully.\n
N *          Otherwise, it is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_ 
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_LISTEN          (0x14)
N
N/**
N * @brief TCP Connection Request status
N * @details @ref SOCK_SYNSENT indicates TCP SOCKETn sent the connect-request packet(SYN packet)\n
N *          to the peer specified by @ref _Sn_DIPR_ / @ref _Sn_DIP6R_ and @ref _Sn_DPORTR_.\n
N *          It is temporarily shown when @ref _Sn_SR_ is changing from @ref SOCK_INIT to @ref SOCK_ESTABLISHED by @ref Sn_CR_CONNECT or @ref Sn_CR_CONNECT6.\n
N *          When the connect-accept packet (SYN/ACK packet) is received from the peer at @ref SOCK_SYNSENT and the ACK packet of SYN/ACK is sent successfully, \n
N *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED.\n
N *          Otherwise, it is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_  
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_SYNSENT         (0x15)
N
N/**
N * @brief TCP Connection Accept status
N * @details @ref SOCK_SYNRECV indicates TCP SOCKETn is successfully received the connect-request packet (SYN packet) from a peer.\n
N *          It is temporarily shown when @ref _Sn_SR_ is changing from @ref SOCK_LISTEN to @ref SOCK_ESTABLISHED by the SYN packet\n
N *          If SOCKETn sends the response (SYN/ACK  packet) to the peer successfully and the ACK packet of SYS/ACK is received successfully,\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED. \n
N *          Otherwise, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_SYNRECV         (0x16)
N
N/**
N * @brief TCP SOCKETn Established status
N * @details @ref SOCK_ESTABLISHED indicates TCP SOCKETn is connected successfully with a peer.\n
N *          when the <b>TCP SERVER</b> processes the SYN packet from the <b>TCP CLIENT</b> during @ref SOCK_LISTEN or \n
N *          when the <b>TCP CLIENT</b> performs successfully @ref Sn_CR_CONNECT or @ref Sn_CR_CONNECT6,\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and @ref Sn_IR_CON is set. \n
N *          During @ref SOCK_ESTABLISHED, a DATA packet can be sent to or received from the peer by @ref Sn_CR_SEND or @ref Sn_CR_RECV.  \n
N *          If the DATA/ACK packet is not received from the peer during data re-transmission, @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n
N *          Otherwise, @ref _Sn_SR_ is still at @ref SOCK_ESTABLISHED.
N * @note In <b>TCP SERVER</b>, \n
N *       You can check the IPv4/IPv6 address and port number of connected peer thru @ref _Sn_DIPR_, @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_ respectively.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
N *     getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR().
N */
N#define SOCK_ESTABLISHED     (0x17)
N
N/**
N * @brief TCP SOCKETn Closing status
N * @details @ref SOCK_FIN_WAIT indicates TCP mode SOCKETn waits until the disconnect-process is completed. \n
N *          It is temporarily shown in disconnect-process such as active-close. \n
N *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_TIME_WAIT, SOCK_LAST_ACK
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N *
N */
N#define SOCK_FIN_WAIT        (0x18)
N
N/**
N * @brief TCP SOCKETn Closing status
N * @details @ref SOCK_TIME_WAIT indicates TCP SOCKETn waits until the disconnect-process is completed.\n
N *          It is temporarily shown in disconnect-process such as active-close. \n
N *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_FIN_WAIT, SOCK_LAST_ACK 
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_TIME_WAIT       (0x1B)
N
N/**
N * @brief TCP SOCKETn Half Closing staus
N * @details @ref SOCK_CLOSE_WAIT indicates TCP SOCKETn receives the disconnect-request (FIN packet) from the connected peer.\n
N *          It is a half-closing status, and a DATA packet can be still sent or received by @ref Sn_CR_SEND or @ref Sn_CR_RECV.\n
N *          If you do not have any more need to send or received a DATA packet, You can perform @ref Sn_CR_DISCON for a full-closing.
N * @note If you have no need the successful closing, You maybe perform @ref Sn_CR_CLOSE.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_ 
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_CLOSE_WAIT      (0x1C)
N
N/**
N * @brief TCP SOCKETn Closing status
N * @details @ref SOCK_LAST_ACK indicates TCP SOCKETn waits until the disconnect-process is completed.\n
N *          It is temporarily shown in disconnect-process such as active-close and passive-close.\n
N *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_FIN_WAIT, SOCK_TIME_WAIT 
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_LAST_ACK        (0x1D)
N
N/**
N * @brief UDP SOCKETn status
N * @details @ref SOCK_UDP indicates SOCKETn is opened in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.\n
N *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT when @ref Sn_CR_OPEN is performed in UDP mode.\n
N *          Unlike TCP mode, during @ref SOCK_UDP, \n
N *          a DATA packet can be sent to or received from a peer by @ref Sn_CR_SEND / @ref Sn_CR_SEND6 or @ref Sn_CR_RECV without a connect-process.\n
N *          Before a DATA packet is sent by @ref Sn_CR_SEND / @ref Sn_CR_SEND6,\n
N *          the ARP is requested to the peer specified by @ref _Sn_DIPR_ / @ref _Sn_DIP6R_.\n
N *          In ARP processing, @ref _Sn_SR_ is stll at @ref SOCK_UDP even if @ref Sn_IR_TIMEOUT is set.\n
N *          If you do not have any more need to send or received a DATA packet, \n
N *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
N *     getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R()
N */
N#define SOCK_UDP             (0x22)
N
N/**
N * @brief IPRAW4 SOCKETn mode
N * @details @ref SOCK_IPRAW4(= @ref SOCK_IPRAW) SOCKETn indicates SOCKETn is opened as IPv4 RAW mode.\n
N *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW4 when @ref Sn_CR_OPEN is performed with @ref Sn_MR_IPRAW4. \n
N *          A DATA packet can be send to or received from a peer without a connection like as @ref SOCK_UDP. \n
N *          Before a DATA packet is sent by @ref Sn_CR_SEND, \n
N *          the ARP is requested to the peer specified by @ref _Sn_DIPR_.\n
N *          In ARP processing, @ref _Sn_SR_ is still at @ref SOCK_IPRAW4 even if @ref Sn_IR_TIMEOUT is set.\n
N *          IPRAW4 SOCKETn can receive only the packet specified by @ref _Sn_PNR_, and it discards the others packets.\n
N *          If you do not have any more need to send or received a DATA packet, \n
N *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in IPRAW4 mode such as @ref Sn_MR_IPRAW4.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_PNR_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
N *     getSn_DIPR(), setSn_DIPR(), getSn_PNR(), setSn_PNR() 
N */
N#define SOCK_IPRAW4          (0x32)
N#define SOCK_IPRAW           (SOCK_IPRAW4)   ///< Refer to @ref SOCK_IPRAW4.
N
N/**
N * @brief IPRAW6 SOCKETn mode
N * @details @ref SOCK_IPRAW6 SOCKETn indicates SOCKETn is opened as IPv6 RAW mode.\n
N *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW6 when @ref Sn_CR_OPEN is performed with @ref Sn_MR_IPRAW6. \n
N *          A DATA packet can be send to or received from a peer without a connection like as @ref SOCK_UDP.\n
N *          Before a DATA packet is sent by @ref Sn_CR_SEND6, \n
N *          the ICMPv6 NS is requested to the peer specified by @ref _Sn_DIPR_ or @ref _Sn_DIP6R_.\n
N *          In ND(Neighbor Discovery) is processing,\n
N *          @ref _Sn_SR_ is still at @ref SOCK_IPRAW6 even if @ref Sn_IR_TIMEOUT is set.\n
N *          IPRAW6 SOCKETn can receive only the packet specified by @ref _Sn_PNR_, and it discards the others packets.\n
N *          If you do not have any more need to send or received a DATA packet, \n
N *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in IPRAW6 mode such as @ref Sn_MR_IPRAW6.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIP6R_, _Sn_PNR_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
N *     getSn_DIP6R(), setSn_DIP6R(), getSn_PNR(), setSn_PNR() 
N */
N#define SOCK_IPRAW6          (0x33)
N
N/**
N * @brief MACRAW SOCKETn mode
N * @details @ref SOCK_MACRAW indicates SOCKET0 is opened as MACRAW mode.\n
N *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_MACRAW when @ref Sn_CR_OPEN command is ordered with @ref Sn_MR_MACRAW.\n
N *          MACRAW SOCKET0 can be sent or received a pure Ethernet frame packet to/from any peer.
N * @note  It is valid only in SOCKET0.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
N */
N#define SOCK_MACRAW          (0x42)
N
N/* Sn_ESR values */
N/**
N * @brief SOCKETn Extended Status : TCP Mode
N * @details @ref Sn_ESR_TCPM masks the TCPM bit of @ref _Sn_ESR_. \n
N *          The masked bit values are as following. \n
N *          - @ref Sn_ESR_TCPM_IPV4
N *          - @ref Sn_ESR_TCPM_IPV6
N * @note It is useful to know the destination IP version when TCPD(@ref Sn_MR_TCPD) mode SOCKETn is operated as <b>TCP SERVER</b>.
N * @sa _Sn_ESR_
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPM          (1<<2)
N
N/**
N * @brief TCP SOCKETn IP version - IPv4
N * @details @ref Sn_ESR_TCPM_IPV4 indicates TCP SOCKETn is operated on IPv4 .
N * @sa _Sn_ESR_, Sn_ESR_TCPM_IPV6
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPM_IPV4     (0<<2)
N
N/**
N * @brief TCP SOCKETn IP version - IPv6
N * @details @ref Sn_ESR_TCPM_IPV6 indicates TCP SOCKETn is operated on IPv6 .
N * @sa _Sn_ESR_, Sn_ESR_TCPM_IPV4
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPM_IPV6     (1<<2)
N
N/**
N * @brief SOCKETn Extended Status : TCP Operation Mode
N * @details @ref Sn_ESR_TCPOP masks the TCPOP bit of @ref _Sn_ESR_. The masked bit values are as following. \n
N *            - @ref Sn_ESR_TCPOP_SVR
N *            - @ref Sn_ESR_TCPOP_CLT
N * @note It is useful to check TCP mode SOCKETn is operated as whether <b>TCP SERVER</b> or <b>TCP CLIENT</b>.
N * @sa _Sn_ESR_
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPOP         (1<<1)
N
N/**
N * @brief TCP SOCKETn Operation Mode - <b>TCP SERVER</b>
N * @details @ref Sn_ESR_TCPOP_SVR indicates TCP mode SOCKET n is operated as <b>TCP SERVER</b>
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_ESR_, Sn_ESR_TCPOP_CLT
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPOP_SVR     (0<<1)
N
N/**
N * @brief TCP SOCKETn Operation Mode - <b>TCP CLIENT</b>
N * @details @ref Sn_ESR_TCPOP_SVR indicates TCP mode SOCKET n is operated as <b>TCP CLIENT</b>
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_ESR_, Sn_ESR_TCPOP_SVR
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPOP_CLT     (1<<1)
N
N/**
N * @brief SOCKETn Extended Status : Source IPv6 Address Type
N * @details @ref Sn_ESR_IP6T masks the IP6T bit of @ref _Sn_ESR_. \n
N *          The masked bit values are as following. \n
N *            - @ref Sn_ESR_IP6T_LLA
N *            - @ref Sn_ESR_IP6T_GUA
N * @note It is useful to check whether the connected peer IP address is LLA or GUA.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD.
N * @sa _Sn_ESR_
N * @sa getSn_ESR()
N */
N#define Sn_ESR_IP6T          (1<<0)
N
N/**
N * @brief Source IPv6 Address Type - LLA
N * @details @ref Sn_ESR_IP6T_LLA indicates the source IPv6 Address is used as @ref _LLAR_
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_ESR_, Sn_ESR_IP6T_GUA, _LLAR_
N * @sa getSn_ESR(), getLLAR(), setLLAR()
N */
N#define Sn_ESR_IP6T_LLA      (0<<0)
N
N/**
N * @brief Source IPv6 Address Type - LLA
N * @details @ref Sn_ESR_IP6T_GUA indicates the source IPv6 Address is used as @ref _GUAR_
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_ESR_, Sn_ESR_IP6T_LLA, _GUAR_
N * @sa getSn_ESR(), getGUAR(), setGUAR()
N */
N#define Sn_ESR_IP6T_GUA      (1<<0)
N
N/* Sn_MR2 values */
N/**
N * @brief Destination Hardware Address Mode 
N * @details @ref Sn_MR2_DHAM masks the DHAM bit of @ref _Sn_MR2_.\n
N *          The masked bit values are as following.
N *            - @ref Sn_MR2_DHAM_AUTO
N *            - @ref Sn_MR2_DHAM_MANUAL
N * @sa _Sn_MR2_
N * @sa getSn_MR2(), setSn_MR2()
N */
N#define Sn_MR2_DHAM          (1<<1)
N
N/**
N * @brief Destination Hardware Address Mode - AUTO
N * @details @ref Sn_MR2_DHAM_AUTO sets the destination hardware address as the address acquired by ARP-process.
N * @sa _Sn_MR2_, Sn_MR_DHAM_MANUAL, NETMR_DHAS
N * @sa getSn_MR2(), setSn_MR2(), getNETMR(), setNETMR()
N */
N#define Sn_MR2_DHAM_AUTO     (0<<1)
N
N/**
N * @brief Destination Hardware Address Mode - MANUAL
N * @details @ref Sn_MR2_DHAM_MANUAL sets the destination hardware address as @ref _Sn_DHAR_.
N * @sa _Sn_MR2_, Sn_MR_DHAM_MANUAL, NETMR_DHAS
N * @sa getSn_MR2(), setSn_MR2(), getNETMR(), setNETMR()
N */
N#define Sn_MR2_DHAM_MANUAL   (1<<1)
N
N/**
N * @brief Force ARP
N * @details @ref Sn_MR2_FARP force to perform the ARP-process for acquiring the destination hardware address, before data communication\n
N *          0 : Normal \n
N *          1 : Force ARP
N *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
N *     If SOCKETn is operated as <b>TCP SERVER</b>, It sets the destination hardware address as the address 
N *     acquired by the forced ARP-process before sending SYN/ACK packet.
N *   - In UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD 
N *     It sets the destination hardware address as the address acquired by the forced ARP-process whenever @ref Sn_CR_SEND or @ref Sn_CR_SEND6.
N * @note When @ref Sn_MR2_DHAM_MANUAL and @ref Sn_MR2_FARP = '1', It sets the destination hardware address as @ref _Sn_DHAR_ even if the ARP-process is forced.
N */
N#define Sn_MR2_FARP          (1<<0)
N
N
N/*----------------------------For PHY Control-------------------------------*/
N
N/**
N * @ingroup Common_register_group_W6100
N * @brief Basic Mode Control Register of Ethernet PHY [RW][0x3100]
N * @details @ref PHYRAR_BMCR can be controlled by MDC/MDIO controller of @ref _WIZCHIP_. \n
N *          Each bit of @ref PHYRAR_BMCR is defined as the following.
N * <table>
N *    <tr> <td>15</td>  <td>14</td> <td>13</td>  <td>12 </td>  <td>11</td>  <td>10  </td> <td>9  </td> <td>8  </td> <td>7   </td>  <td>6 ~ 0  </td> </tr>
N *    <tr> <td>RST</td> <td>LB</td> <td>SPD</td> <td>ANE</td> <td>PWDN</td> <td>ISOL</td> <td>RAN</td> <td>DPX</td> <td>COLT</td> <td>Reserved</td> </tr>
N * </table>
N *   - @ref BMCR_RST
N *   - @ref BMCR_LB
N *   - @ref BMCR_SPD
N *   - @ref BMCR_ANE
N *   - @ref BMCR_PWDN
N *   - @ref BMCR_ISOL : Not supported.
N *   - @ref BMCR_REAN
N *   - @ref BMCR_DPX
N *   - @ref BMCR_COLT
N *
N * @note Its some bits have the same function as @ref _PHYCR0_ and @ref _PHYCR1_.\n
N *       It can control the Ethernet PHY with software, while @ref _PHYCR0_ \n
N *       and @ref _PHYCR1_ can control the Ethernet PHY with hardware.
N *       
N * @sa PHYRAR_BMSR, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYCR0_, _PHYCR1_
N * @sa getPHYRAR(), setPHYRAR(), wiz_mdio_read(), wiz_mdio_write()
N */
N#define PHYRAR_BMCR          (0x00)
N
N//Basic mode status register, basic register
N/**
N * @ingroup Common_register_group_W6100
N * @brief Basic Mode Status Register of Ethernet PHY [RO][0x7809]
N * @details @ref PHYRAR_BMSR gets the status of Ethernet PHY through MDC/MDIO controller of @ref _WIZCHIP_. \n
N *          Each bit of @ref PHYRAR_BMSR is defined as the following.
N * <table>
N *    <tr> <td>15</td> <td>14</td> <td>13</td> <td>12</td> <td>11</td> <td>10~7</td> 
N *         <td>6 </td> <td>5 </td> <td>4 </td> <td>3 </td> <td>2 </td> <td>1   </td> <td>0</td> </tr>
N *    <tr> <td>100_T4  </td> <td>100_FDX     </td> <td>100_HDX    </td> <td>10_FDX     </td> <td>10_HDX       </td> <td>Reserved</td> <td>MF_SUP</td> 
N *         <td>ANG_COMP</td> <td>REMOTE_FAULT</td> <td>ANG_ABILITY</td> <td>LINK_STATUS</td> <td>JABBER_DETECT</td> <td>EXT_CAPA</td> </tr>
N * </table>
N *   - @ref BMSR_100_T4        : Not supported. Always 0
N *   - @ref BMSR_100_FDX
N *   - @ref BMSR_100_HDX
N *   - @ref BMSR_10_FDX
N *   - @ref BMSR_10_HDX
N *   - @ref BMSR_MF_SUP        : Not supported. Always 0.
N *   - @ref BMSR_AN_COMP
N *   - @ref BMSR_REMOTE_FAULT  : Not supported. Always 0.
N *   - @ref BMSR_AN_ABILITY
N *   - @ref BMSR_LINK_STATUS
N *   - @ref BMSR_JABBER_DETECT
N *   - @ref BMSR_EXT_CAPA      : Always 1. If you need a extended register information, send e-mail to support@wiznet.io
N *
N * @note Its some bits have the same function as @ref _PHYSR_.
N * @sa PHYRAR_BMCR, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYCR0_, _PHYCR1_
N * @sa getPHYRAR(), setPHYRAR(), wiz_mdio_read(), wiz_mdio_write()
N */
N#define PHYRAR_BMSR          (0x01)
N
N
N/********************/
N/* BMCR & BMSR Bit definitions  */
N/********************/
N
N/*For BMCR register*/
N/**
N * @brief Ethernet PHY S/W Reset.
N * @details 0 - Normal operation \n
N *          1 - Software reset
N * @sa PHYRAR_BMCR, PHYCR1_RST
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define BMCR_RST             (1<<15)
N
N/**
N * @brief Ethernet PHY Loopback.
N * @details 0 - Normal Operation \n
N *          1 - Loopback Enable
N * @sa PHYRAR_BMCR
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define BMCR_LB              (1<<14)  ///< Loopback. 0 - Noraml operation, 1 - Loopback enabled
N
N/**
N * @brief Ethernet PHY Speed 
N * @details 0 - 10  Mbps \n
N *          1 - 100 Mbps
N * @sa PHYCR_BMCR, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
N */
N#define BMCR_SPD             (1<<13)
N
N/**
N * @brief Ethernet PHY Auto-Negotiation
N * @details 0 - Disable \n
N *          1 - Enable
N * @note When it is set, @ref BMCR_SPD and @ref BMCR_DPX is ignored
N * @sa PHYCR_BMCR, PHYCR0_AUTO
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
N */
N#define BMCR_ANE             (1<<12)
N
N/**
N * @brief Ethernet PHY Power Down Mode
N * @details 0 - Normal Operation \n
N *          1 - Power Down mode
N * @sa PHYCR_BMCR, PHYCR0_PWDN
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
N */
N#define BMCR_PWDN            (1<<11)  ///< Power-down mode
N
N/**
N * @brief Ethernet PHY Isolation Mode
N * @details 0 - Normal Operation \n
N *          1 - Isolation Mode
N * @ Don't set it to '1'. It is not supported.
N * @sa PHYCR_BMCR
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define BMCR_ISOL            (1<<10)
N
N/**
N * @brief Ethernet PHY Restart Auto-Negotiation
N * @details 0 - Normal Operation \n
N *          1 - Restart Auto-Negotiation
N * @sa PHYCR_BMCR
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define BMCR_REAN            (1<<9)
N
N/**
N * @brief Ethernet PHY Duplex 
N * @details 0 - Half-Duplex \n
N *          1 - Full-Duplex
N * @sa PHYCR_BMCR, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
N */
N#define BMCR_DPX             (1<<8)
N
N/**
N * @brief Ethernet PHY Collision Test
N * @details 0 - Normal Operation \n
N *          1 - Collision Test
N * @sa PHYCR_BMCR
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define BMCR_COLT            (1<<7)
N
N/*For BMSR register*/
N
N/**
N * @brief Ethernet PHY 100 Base-T4 capable
N * @details @ref BMSR_100_T4 is always 0.
N * @note It is not supported. 
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_100_T4          (1<<15)
N
N/**
N * @brief Ethernet PHY 100 Base-TX Full-Duplex capable
N * @details @ref BMSR_100_FDX is always 1.
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_100_FDX         (1<<14)
N
N/**
N * @brief Ethernet PHY 100 Base-TX Half-Duplex capable
N * @details @ref BMSR_100_HDX is always 1.
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_100_HDX         (1<<13)
N
N/**
N * @brief Ethernet PHY 10 Base-T Full-Duplex capable
N * @details @ref BMSR_10_FDX is always 1.
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_10_FDX          (1<<12)
N
N/**
N * @brief Ethernet PHY 10 Base-T Half-Duplex capable
N * @details @ref BMSR_10_HDX is always 1.
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_10_HDX          (1<<11)
N
N/**
N * @brief Ethernet PHY Management Frame preamble suppression
N * @details @ref BMSR_MF_SUP is always 0.
N * @note It is not supported 
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_MF_SUP          (1<<6)
N
N/**
N * @brief Ethernet PHY Auto-Negotiation Complete
N * @details @ref BMSR_MF_SUP indicates the status of auto-negotiation. \n
N *          0 - Auto-negotiation process is not completed \n
N *          1 - Auto-negotiation process is completed
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_AN_COMP         (1<<5)
N
N/**
N * @brief Ethernet PHY Remote Fault
N * @details @ref BMSR_REMOTE_FAULT is always 0.
N * @note It is not supported 
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_REMOTE_FAULT    (1<<4)
N
N/**
N * @brief Ethernet PHY Auto-Negotiation Ability
N * @details @ref BMSR_AN_ABILITY is always 1.
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_AN_ABILITY      (1<<3)
N
N/**
N * @brief Ethernet PHY Link Status
N * @details @ref BMSR_LINK_STATUS indicates the status of link. \n
N *          0 - Link is not established
N *          1 - Valid link is established
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_LINK_STATUS     (1<<2)
N
N/**
N * @brief Ethernet PHY Jabber Detect
N * @details @ref BMSR_JABBER_DETECT indicates the status of auto-negotiation. \n
N *          0 - Jabber condition is not detected\n
N *          1 - Jabber condition is detected
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_JABBER_DETECT   (1<<1)
N
N/**
N * @brief Ethernet PHY Extended capability
N * @details @ref BMSR_EXT_CAPA indicates the extended register capability. \n
N *          0 - Only basic registers are capable\n
N *          1 - Extended registers are capable
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_EXT_CAPA        (1<<0)
N
N
N/**
N * @brief Enter a critical section
N * @details It is provided to protect your shared code and hardware resources against interference. \n
N *   - Non-OS environment
N *     It can be just implemented by disabling whole interrupt.
N *   - OS environment
N *     You can replace it to critical section API supported by OS.
N *
N * @note It is callback function that can be replaced it with your code, by calling @ref reg_wizchip_cris_cbfunc(). 
N * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * @sa WIZCHIP_CRITICAL_EXIT(), reg_wizchip_cris_cbfunc()
N */
N#define WIZCHIP_CRITICAL_ENTER()       WIZCHIP.CRIS._e_n_t_e_r_()
N
N
N/**
N * @brief Enter a critical section
N * @details It exits the protected code and hardware resources against interference. \n
N *   - Non-OS environment
N *     It can be just implemented by enabling whole interrupt.\n
N *   - OS environment
N *     You can replace it to critical section API supported by OS.
N *
N * @note It is callback function that can be replaced it with your code, by calling @ref reg_wizchip_cris_cbfunc(). 
N * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * @sa WIZCHIP_CRITICAL_EXIT(), reg_wizchip_cris_cbfunc()
N */
N#define WIZCHIP_CRITICAL_EXIT()        WIZCHIP.CRIS._e_x_i_t_()
N
N
N
N////////////////////////
N// Basic I/O Function //
N////////////////////////
N//
N//
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It reads 1 byte value from a register.
N * @param AddrSel Register address
N * @return The value of register
N * @sa WIZCHIP_READ_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_WRITE()
N */
Nuint8_t WIZCHIP_READ(uint32_t AddrSel);
N
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It writes 1 byte value to a register.
N * @param AddrSel Register address
N * @param wb Write data
N * @return void
N * @sa WIZCHIP_WRITE_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_READ()
N */
Nvoid WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb );
N
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It reads sequentail data from registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to read data
N * @param len Data length
N * @return void
N * @sa WIZCHIP_WRITE_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_READ()
N */
Nvoid WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, datasize_t len);
N
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It writes sequential data to registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to write data
N * @param len Data length
N * @return void
N * @sa WIZCHIP_READ_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_WRITE()
N */
Nvoid WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, datasize_t len);
N
N
N
N/////////////////////////////////
N// Common Register IO function //
N/////////////////////////////////
N/**
N * @addtogroup Common_register_access_function_W6100
N * @{
N */
N#define getCIDR() \
N        ((((uint16_t)WIZCHIP_READ(_CIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_CIDR_,1)))
X#define getCIDR()         ((((uint16_t)WIZCHIP_READ(_CIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_CIDR_,1)))
N
N#define getVER() \
N        ((((uint16_t)WIZCHIP_READ(_VER_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VER_,1)))
X#define getVER()         ((((uint16_t)WIZCHIP_READ(_VER_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VER_,1)))
N
N#define getSYSR() \
N        WIZCHIP_READ(_SYSR_)
X#define getSYSR()         WIZCHIP_READ(_SYSR_)
N
N#define getSYCR0() \
N        WIZCHIP_READ(_SYCR0_)
X#define getSYCR0()         WIZCHIP_READ(_SYCR0_)
N
N#define setSYCR0(sycr0) \
N        WIZCHIP_WRITE(_SYCR0_, (sycr0))
X#define setSYCR0(sycr0)         WIZCHIP_WRITE(_SYCR0_, (sycr0))
N
N#define getSYCR1() \
N        WIZCHIP_READ(_SYCR1_)
X#define getSYCR1()         WIZCHIP_READ(_SYCR1_)
N                  
N#define setSYCR1(sycr1) \
N        WIZCHIP_WRITE(_SYCR1_, (sycr1))
X#define setSYCR1(sycr1)         WIZCHIP_WRITE(_SYCR1_, (sycr1))
N
N#define getTCNTR() \
N        ((((uint16_t)WIZCHIP_READ(_TCNTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_TCNTR_,1)))
X#define getTCNTR()         ((((uint16_t)WIZCHIP_READ(_TCNTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_TCNTR_,1)))
N
N#define setTCNTRCLR(tcntrclr) \
N        WIZCHIP_WRITE(_TCNTRCLR_,(tcntrclr))
X#define setTCNTRCLR(tcntrclr)         WIZCHIP_WRITE(_TCNTRCLR_,(tcntrclr))
N
N#define getIR() \
N        WIZCHIP_READ(_IR_)
X#define getIR()         WIZCHIP_READ(_IR_)
N
N#define getSIR() \
N        WIZCHIP_READ(_SIR_)
X#define getSIR()         WIZCHIP_READ(_SIR_)
N
N#define getSLIR() \
N        WIZCHIP_READ(_SLIR_)
X#define getSLIR()         WIZCHIP_READ(_SLIR_)
N
N#define setIMR(imr) \
N        WIZCHIP_WRITE(_IMR_,(imr))
X#define setIMR(imr)         WIZCHIP_WRITE(_IMR_,(imr))
N
N#define getIMR() \
N        WIZCHIP_READ(_IMR_)
X#define getIMR()         WIZCHIP_READ(_IMR_)
N
N#define setIRCLR(irclr) \
N        WIZCHIP_WRITE(_IRCLR_,(irclr))
X#define setIRCLR(irclr)         WIZCHIP_WRITE(_IRCLR_,(irclr))
N#define setIR(ir)                setIRCLR(ir)
N
N#define setSIMR(simr) \
N        WIZCHIP_WRITE(_SIMR_,(simr))
X#define setSIMR(simr)         WIZCHIP_WRITE(_SIMR_,(simr))
N
N#define getSIMR() \
N        WIZCHIP_READ(_SIMR_)
X#define getSIMR()         WIZCHIP_READ(_SIMR_)
N
N#define setSLIMR(slimr) \
N        WIZCHIP_WRITE(_SLIMR_,(slimr))
X#define setSLIMR(slimr)         WIZCHIP_WRITE(_SLIMR_,(slimr))
N
N#define getSLIMR() \
N        WIZCHIP_READ(_SLIMR_)
X#define getSLIMR()         WIZCHIP_READ(_SLIMR_)
N
N#define setSLIRCLR(slirclr) \
N        WIZCHIP_WRITE(_SLIRCLR_,(slirclr))
X#define setSLIRCLR(slirclr)         WIZCHIP_WRITE(_SLIRCLR_,(slirclr))
N#define setSLIR(slir)            setSLIRCLR(slir)
N
N#define setSLPSR(slpsr) \
N        WIZCHIP_WRITE(_SLPSR_,(slpsr))
X#define setSLPSR(slpsr)         WIZCHIP_WRITE(_SLPSR_,(slpsr))
N
N#define getSLPSR() \
N        WIZCHIP_READ(_SLPSR_)
X#define getSLPSR()         WIZCHIP_READ(_SLPSR_)
N
N#define setSLCR(slcr) \
N        WIZCHIP_WRITE(_SLCR_,(slcr))
X#define setSLCR(slcr)         WIZCHIP_WRITE(_SLCR_,(slcr))
N                  
N#define getSLCR()      \
N        WIZCHIP_READ(_SLCR_)
X#define getSLCR()              WIZCHIP_READ(_SLCR_)
N
N#define getPHYSR() \
N        WIZCHIP_READ(_PHYSR_)
X#define getPHYSR()         WIZCHIP_READ(_PHYSR_)
N
N#define setPHYRAR(phyrar) \
N        WIZCHIP_WRITE(_PHYRAR_,(phyrar))
X#define setPHYRAR(phyrar)         WIZCHIP_WRITE(_PHYRAR_,(phyrar))
N
N#define getPHYRAR() \
N        WIZCHIP_READ(_PHYRAR_)
X#define getPHYRAR()         WIZCHIP_READ(_PHYRAR_)
N
N#define setPHYDIR(phydir)  \
N        do{                                                                       \
N           WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PHYDIR_,1), (uint8_t)((phydir)>>8)); \
N           WIZCHIP_WRITE(_PHYDIR_, (uint8_t)(phydir));                            \
N        }while(0);
X#define setPHYDIR(phydir)          do{                                                                                  WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PHYDIR_,1), (uint8_t)((phydir)>>8));            WIZCHIP_WRITE(_PHYDIR_, (uint8_t)(phydir));                                    }while(0);
N
N#define getPHYDOR() \
N        ((((uint16_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PHYDOR_,1))) << 8) + WIZCHIP_READ(_PHYDOR_))
X#define getPHYDOR()         ((((uint16_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PHYDOR_,1))) << 8) + WIZCHIP_READ(_PHYDOR_))
N
N#define setPHYACR(phyacr) \
N        WIZCHIP_WRITE(_PHYACR_,(phyacr))
X#define setPHYACR(phyacr)         WIZCHIP_WRITE(_PHYACR_,(phyacr))
N
N#define getPHYACR() \
N        WIZCHIP_READ(_PHYACR_)
X#define getPHYACR()         WIZCHIP_READ(_PHYACR_)
N
N#define setPHYDIVR(phydivr) \
N        WIZCHIP_WRITE(_PHYDIVR_,(phydivr))
X#define setPHYDIVR(phydivr)         WIZCHIP_WRITE(_PHYDIVR_,(phydivr))
N
N#define getPHYDIVR() \
N        WIZCHIP_READ(_PHYDIVR_)
X#define getPHYDIVR()         WIZCHIP_READ(_PHYDIVR_)
N
N#define setPHYCR0(phycr0) \
N        WIZCHIP_WRITE(_PHYCR0_,(phycr0))
X#define setPHYCR0(phycr0)         WIZCHIP_WRITE(_PHYCR0_,(phycr0))
N
N#define setPHYCR1(phycr1) \
N        WIZCHIP_WRITE(_PHYCR1_,(phycr1))
X#define setPHYCR1(phycr1)         WIZCHIP_WRITE(_PHYCR1_,(phycr1))
N
N#define getPHYCR1() \
N        WIZCHIP_READ(_PHYCR1_)
X#define getPHYCR1()         WIZCHIP_READ(_PHYCR1_)
N
N#define setNET4MR(net4mr) \
N        WIZCHIP_WRITE(_NET4MR_,(net4mr))
X#define setNET4MR(net4mr)         WIZCHIP_WRITE(_NET4MR_,(net4mr))
N
N#define setNET6MR(net6mr) \
N        WIZCHIP_WRITE(_NET6MR_,(net6mr))
X#define setNET6MR(net6mr)         WIZCHIP_WRITE(_NET6MR_,(net6mr))
N
N#define setNETMR(netmr) \
N        WIZCHIP_WRITE(_NETMR_,(netmr))
X#define setNETMR(netmr)         WIZCHIP_WRITE(_NETMR_,(netmr))
N
N#define setNETMR2(netmr2) \
N        WIZCHIP_WRITE(_NETMR2_,(netmr2))
X#define setNETMR2(netmr2)         WIZCHIP_WRITE(_NETMR2_,(netmr2))
N
N#define getNET4MR() \
N        WIZCHIP_READ(_NET4MR_)
X#define getNET4MR()         WIZCHIP_READ(_NET4MR_)
N
N#define getNET6MR() \
N        WIZCHIP_READ(_NET6MR_)
X#define getNET6MR()         WIZCHIP_READ(_NET6MR_)
N
N#define getNETMR() \
N        WIZCHIP_READ(_NETMR_)
X#define getNETMR()         WIZCHIP_READ(_NETMR_)
N
N#define getNETMR2() \
N        WIZCHIP_READ(_NETMR2_)
X#define getNETMR2()         WIZCHIP_READ(_NETMR2_)
N
N#define setPTMR(ptmr) \
N        WIZCHIP_WRITE(_PTMR_, (ptmr))
X#define setPTMR(ptmr)         WIZCHIP_WRITE(_PTMR_, (ptmr))
N
N#define getPTMR() \
N        WIZCHIP_READ(_PTMR_)
X#define getPTMR()         WIZCHIP_READ(_PTMR_)
N
N#define setPMNR(pmnr) \
N        WIZCHIP_WRITE(_PMNR_, (pmnr))
X#define setPMNR(pmnr)         WIZCHIP_WRITE(_PMNR_, (pmnr))
N
N#define getPMNR() \
N        WIZCHIP_READ(_PMNR_)
X#define getPMNR()         WIZCHIP_READ(_PMNR_)
N
N#define setPHAR(phar) \
N        WIZCHIP_WRITE_BUF(_PHAR_,(phar),6)
X#define setPHAR(phar)         WIZCHIP_WRITE_BUF(_PHAR_,(phar),6)
N
N#define getPHAR(phar) \
N        WIZCHIP_READ_BUF(_PHAR_,(phar),6)
X#define getPHAR(phar)         WIZCHIP_READ_BUF(_PHAR_,(phar),6)
N
N#define setPSIDR(psidr) \
N        do{                                                                \
N            WIZCHIP_WRITE(_PSIDR_,(uint8_t)((psidr) >> 8));                \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PSIDR_,1),(uint8_t)(psidr)); \
N        }while(0);
X#define setPSIDR(psidr)         do{                                                                            WIZCHIP_WRITE(_PSIDR_,(uint8_t)((psidr) >> 8));                            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PSIDR_,1),(uint8_t)(psidr));         }while(0);
N
N#define getPSIDR() \
N        ((((uint16_t)WIZCHIP_READ(_PSIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PSIDR_,1)))
X#define getPSIDR()         ((((uint16_t)WIZCHIP_READ(_PSIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PSIDR_,1)))
N
N#define setPMRUR(pmrur) \
N        do{                                                                \
N            WIZCHIP_WRITE(_PMRUR_,(uint8_t)((pmrur) >> 8));                \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PMRUR_,1),(uint8_t)(pmrur)); \
N        }while(0);
X#define setPMRUR(pmrur)         do{                                                                            WIZCHIP_WRITE(_PMRUR_,(uint8_t)((pmrur) >> 8));                            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PMRUR_,1),(uint8_t)(pmrur));         }while(0);
N
N#define getPMRUR() \
N        ((((uint16_t)WIZCHIP_READ(_PMRUR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PMRUR_,1)))
X#define getPMRUR()         ((((uint16_t)WIZCHIP_READ(_PMRUR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PMRUR_,1)))
N
N#define setSHAR(shar) \
N        WIZCHIP_WRITE_BUF(_SHAR_,(shar),6)
X#define setSHAR(shar)         WIZCHIP_WRITE_BUF(_SHAR_,(shar),6)
N
N#define getSHAR(shar) \
N        WIZCHIP_READ_BUF(_SHAR_,(shar),6)
X#define getSHAR(shar)         WIZCHIP_READ_BUF(_SHAR_,(shar),6)
N
N#define setGAR(gar) \
N        WIZCHIP_WRITE_BUF(_GAR_,(gar),4)
X#define setGAR(gar)         WIZCHIP_WRITE_BUF(_GAR_,(gar),4)
N
N#define getGAR(gar) \
N        WIZCHIP_READ_BUF(_GAR_,(gar),4)
X#define getGAR(gar)         WIZCHIP_READ_BUF(_GAR_,(gar),4)
N
N#define setGA4R(ga4r)            setGAR(ga4r)
N#define getGA4R(ga4r)            getGAR(ga4r)
N
N#define setSUBR(subr) \
N        WIZCHIP_WRITE_BUF(_SUBR_,(subr),4)
X#define setSUBR(subr)         WIZCHIP_WRITE_BUF(_SUBR_,(subr),4)
N
N#define getSUBR(subr) \
N        WIZCHIP_READ_BUF(_SUBR_,(subr),4)
X#define getSUBR(subr)         WIZCHIP_READ_BUF(_SUBR_,(subr),4)
N
N#define setSUB4R(sub4r)          setSUBR(sub4r)
N#define getSUB4R(sub4r)          getSUBR(sub4r)
N
N#define setSIPR(sipr) \
N        WIZCHIP_WRITE_BUF(_SIPR_,(sipr),4)
X#define setSIPR(sipr)         WIZCHIP_WRITE_BUF(_SIPR_,(sipr),4)
N
N#define getSIPR(sipr) \
N        WIZCHIP_READ_BUF(_SIPR_,(sipr),4)
X#define getSIPR(sipr)         WIZCHIP_READ_BUF(_SIPR_,(sipr),4)
N
N#define setLLAR(llar) \
N        WIZCHIP_WRITE_BUF(_LLAR_,(llar),16)
X#define setLLAR(llar)         WIZCHIP_WRITE_BUF(_LLAR_,(llar),16)
N
N#define getLLAR(llar) \
N        WIZCHIP_READ_BUF(_LLAR_,(llar),16)
X#define getLLAR(llar)         WIZCHIP_READ_BUF(_LLAR_,(llar),16)
N
N#define setGUAR(guar) \
N        WIZCHIP_WRITE_BUF(_GUAR_,(guar),16)
X#define setGUAR(guar)         WIZCHIP_WRITE_BUF(_GUAR_,(guar),16)
N
N#define getGUAR(guar) \
N        WIZCHIP_READ_BUF(_GUAR_,(guar),16)
X#define getGUAR(guar)         WIZCHIP_READ_BUF(_GUAR_,(guar),16)
N
N#define setSUB6R(sub6r) \
N        WIZCHIP_WRITE_BUF(_SUB6R_,(sub6r),16)
X#define setSUB6R(sub6r)         WIZCHIP_WRITE_BUF(_SUB6R_,(sub6r),16)
N
N#define getSUB6R(sub6r) \
N        WIZCHIP_READ_BUF(_SUB6R_,(sub6r),16)
X#define getSUB6R(sub6r)         WIZCHIP_READ_BUF(_SUB6R_,(sub6r),16)
N
N#define setGA6R(ga6r) \
N        WIZCHIP_WRITE_BUF(_GA6R_,(ga6r),16)
X#define setGA6R(ga6r)         WIZCHIP_WRITE_BUF(_GA6R_,(ga6r),16)
N
N#define getGA6R(ga6r) \
N        WIZCHIP_READ_BUF(_GA6R_,(ga6r),16)
X#define getGA6R(ga6r)         WIZCHIP_READ_BUF(_GA6R_,(ga6r),16)
N
N#define setSLDIPR(sldipr) \
N        WIZCHIP_WRITE_BUF(_SLDIPR_,(sldipr),4)
X#define setSLDIPR(sldipr)         WIZCHIP_WRITE_BUF(_SLDIPR_,(sldipr),4)
N#define setSLDIP4R(sldip4r)      setSLDIPR((sldip4r))
N
N#define getSLDIPR(sldipr) \
N        WIZCHIP_READ_BUF(_SLDIPR_,(sldipr),4)
X#define getSLDIPR(sldipr)         WIZCHIP_READ_BUF(_SLDIPR_,(sldipr),4)
N#define getSLDIP4R(sldip4r)      getSLDIPR((sldip4r))
N
N#define setSLDIP6R(sldip6r) \
N        WIZCHIP_WRITE_BUF(_SLDIP6R_, (sldip6r),16)
X#define setSLDIP6R(sldip6r)         WIZCHIP_WRITE_BUF(_SLDIP6R_, (sldip6r),16)
N
N#define getSLDIP6R(sldip6r) \
N        WIZCHIP_READ_BUF(_SLDIP6R_,(sldip6r),16)
X#define getSLDIP6R(sldip6r)         WIZCHIP_READ_BUF(_SLDIP6R_,(sldip6r),16)
N
N#define getSLDHAR(sldhar) \
N        WIZCHIP_READ_BUF(_SLDHAR_,(sldhar),6)
X#define getSLDHAR(sldhar)         WIZCHIP_READ_BUF(_SLDHAR_,(sldhar),6)
N
N#define setPINGIDR(pingidr) \
N        do{                                                                    \
N            WIZCHIP_WRITE(_PINGIDR_,(uint8_t)((pingidr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGIDR_,1),(uint8_t)(pingidr)); \
N        }while(0);
X#define setPINGIDR(pingidr)         do{                                                                                WIZCHIP_WRITE(_PINGIDR_,(uint8_t)((pingidr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGIDR_,1),(uint8_t)(pingidr));         }while(0);
N
N#define getPINGIDR() \
N        (((int16_t)(WIZCHIP_READ(_PINGIDR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGIDR_,1)))
X#define getPINGIDR()         (((int16_t)(WIZCHIP_READ(_PINGIDR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGIDR_,1)))
N
N#define setPINGSEQR(pingseqr) \
N        do{                                                                      \
N            WIZCHIP_WRITE(_PINGSEQR_,(uint8_t)((pingseqr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGSEQR_,1),(uint8_t)(pingseqr)); \
N        }while(0);
X#define setPINGSEQR(pingseqr)         do{                                                                                  WIZCHIP_WRITE(_PINGSEQR_,(uint8_t)((pingseqr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGSEQR_,1),(uint8_t)(pingseqr));         }while(0);
N
N#define getPINGSEQR() \
N        (((int16_t)(WIZCHIP_READ(_PINGSEQR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGSEQR_,1)))
X#define getPINGSEQR()         (((int16_t)(WIZCHIP_READ(_PINGSEQR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGSEQR_,1)))
N
N#define getUIPR(uipr) \
N        WIZCHIP_READ_BUF(_UIPR_, (uipr), 4)
X#define getUIPR(uipr)         WIZCHIP_READ_BUF(_UIPR_, (uipr), 4)
N
N#define getUIP4R(uip4r)          getUIPR(uip4r)
N
N#define getUPORTR() \
N        ((((uint16_t)WIZCHIP_READ(_UPORTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORTR_,1)))
X#define getUPORTR()         ((((uint16_t)WIZCHIP_READ(_UPORTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORTR_,1)))
N
N#define getUPORT4R()             getUPORTR()
N
N#define getUIP6R(uip6r) \
N        WIZCHIP_READ_BUF(_UIP6R_,(uip6r),16)
X#define getUIP6R(uip6r)         WIZCHIP_READ_BUF(_UIP6R_,(uip6r),16)
N
N#define getUPORT6R(uport6r) \
N        ((((uint16_t)WIZCHIP_READ(_UPORT6R_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORT6R_,1)))
X#define getUPORT6R(uport6r)         ((((uint16_t)WIZCHIP_READ(_UPORT6R_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORT6R_,1)))
N
N#define setINTPTMR(intptmr) \
N        do{                                                                     \
N            WIZCHIP_WRITE(_INTPTMR_,(uint8_t)((intptmr) >> 8));                 \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_INTPTMR_,1),(uint8_t)(intptmr));  \
N       }while(0);
X#define setINTPTMR(intptmr)         do{                                                                                 WIZCHIP_WRITE(_INTPTMR_,(uint8_t)((intptmr) >> 8));                             WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_INTPTMR_,1),(uint8_t)(intptmr));         }while(0);
N
N#define getINTPTMR() \
N        ((((uint16_t)WIZCHIP_READ(_INTPTMR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_INTPTMR_,1)))
X#define getINTPTMR()         ((((uint16_t)WIZCHIP_READ(_INTPTMR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_INTPTMR_,1)))
N
N#define getPLR() \
N        WIZCHIP_READ(_PLR_)
X#define getPLR()         WIZCHIP_READ(_PLR_)
N
N#define getPFR() \
N        WIZCHIP_READ(_PFR_)
X#define getPFR()         WIZCHIP_READ(_PFR_)
N
N#define getVLTR() \
N        ( (((uint32_t)WIZCHIP_READ(_VLTR_)) << 24) +                       \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,1))) << 16) + \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,2))) << 16) + \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,3))) << 16) )
X#define getVLTR()         ( (((uint32_t)WIZCHIP_READ(_VLTR_)) << 24) +                                 (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,1))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,2))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,3))) << 16) )
N
N#define getPLTR() \
N        ( (((uint32_t)WIZCHIP_READ(_PLTR_)) << 24) +                       \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,1))) << 16) + \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,2))) << 16) + \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,3))) << 16) )
X#define getPLTR()         ( (((uint32_t)WIZCHIP_READ(_PLTR_)) << 24) +                                 (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,1))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,2))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,3))) << 16) )
N
N#define getPAR(par) \
N        WIZCHIP_READ_BUF(_PAR_, (par), 16)
X#define getPAR(par)         WIZCHIP_READ_BUF(_PAR_, (par), 16)
N
N#define setICMP6BLKR(icmp6blkr) \
N        WIZCHIP_WRITE(_ICMP6BLKR_,(icmp6blkr))
X#define setICMP6BLKR(icmp6blkr)         WIZCHIP_WRITE(_ICMP6BLKR_,(icmp6blkr))
N
N#define getICMP6BLKR() \
N        WIZCHIP_READ(_ICMP6BLKR_)
X#define getICMP6BLKR()         WIZCHIP_READ(_ICMP6BLKR_)
N
N#define setCHPLCKR(chplckr) \
N        WIZCHIP_WRITE(_CHPLCKR_, (chplckr))
X#define setCHPLCKR(chplckr)         WIZCHIP_WRITE(_CHPLCKR_, (chplckr))
N
N#define getCHPLCKR() \
N        ((getSYSR() & SYSR_CHPL) >> 7)
X#define getCHPLCKR()         ((getSYSR() & SYSR_CHPL) >> 7)
N
N#define CHIPLOCK()      setCHPLCKR(0xFF)
N#define CHIPUNLOCK()    setCHPLCKR(0xCE)
N
N#define setNETLCKR(netlckr) \
N        WIZCHIP_WRITE(_NETLCKR_, (netlckr))
X#define setNETLCKR(netlckr)         WIZCHIP_WRITE(_NETLCKR_, (netlckr))
N
N#define getNETLCKR() \
N        ((getSYSR() & SYSR_NETL) >> 6)
X#define getNETLCKR()         ((getSYSR() & SYSR_NETL) >> 6)
N
N#define NETLOCK()      setNETLCKR(0xC5)
N#define NETUNLOCK()    setNETLCKR(0x3A)
N
N#define setPHYLCKR(phylckr) \
N        WIZCHIP_WRITE(_PHYLCKR_,(phylckr))
X#define setPHYLCKR(phylckr)         WIZCHIP_WRITE(_PHYLCKR_,(phylckr))
N
N#define getPHYLCKR() \
N        ((getSYSR() & SYSR_PHYL) >> 5)
X#define getPHYLCKR()         ((getSYSR() & SYSR_PHYL) >> 5)
N
N#define PHYLOCK()      setPHYLCKR(0xFF)
N#define PHYUNLOCK()    setPHYLCKR(0x53)
N
N#define setRTR(rtr) \
N        do{                                                            \
N            WIZCHIP_WRITE(_RTR_,(uint8_t)((rtr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_RTR_,1),(uint8_t)(rtr)); \
N        }while(0);
X#define setRTR(rtr)         do{                                                                        WIZCHIP_WRITE(_RTR_,(uint8_t)((rtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_RTR_,1),(uint8_t)(rtr));         }while(0);
N
N#define getRTR() \
N        ((((uint16_t)WIZCHIP_READ(_RTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_RTR_,1)))
X#define getRTR()         ((((uint16_t)WIZCHIP_READ(_RTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_RTR_,1)))
N
N#define setRCR(rcr) \
N        WIZCHIP_WRITE(_RCR_,(rcr))
X#define setRCR(rcr)         WIZCHIP_WRITE(_RCR_,(rcr))
N
N#define getRCR() \
N        WIZCHIP_READ(_RCR_)
X#define getRCR()         WIZCHIP_READ(_RCR_)
N
N#define setSLRTR(slrtr) \
N        do{                                                                \
N            WIZCHIP_WRITE(_SLRTR_,(uint8_t)((slrtr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_SLRTR_,1),(uint8_t)(slrtr)); \
N        }while(0);
X#define setSLRTR(slrtr)         do{                                                                            WIZCHIP_WRITE(_SLRTR_,(uint8_t)((slrtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_SLRTR_,1),(uint8_t)(slrtr));         }while(0);
N
N#define getSLRTR() \
N        ((((uint16_t)WIZCHIP_READ(_SLRTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_SLRTR_,1)))
X#define getSLRTR()         ((((uint16_t)WIZCHIP_READ(_SLRTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_SLRTR_,1)))
N
N#define setSLRCR(slrcr) \
N        WIZCHIP_WRITE(_SLRCR_,(slrcr))
X#define setSLRCR(slrcr)         WIZCHIP_WRITE(_SLRCR_,(slrcr))
N
N#define getSLRCR() \
N        WIZCHIP_READ(_SLRCR_)
X#define getSLRCR()         WIZCHIP_READ(_SLRCR_)
N
N#define setSLHOPR(slhopr) \
N        WIZCHIP_WRITE(_SLHOPR_,(slhopr))
X#define setSLHOPR(slhopr)         WIZCHIP_WRITE(_SLHOPR_,(slhopr))
N
N#define getSLHOPR() \
N        WIZCHIP_READ(_SLHOPR_)
X#define getSLHOPR()         WIZCHIP_READ(_SLHOPR_)
N/**
N * @}
N */
N
N
N////////////////////////////////////
N// SOCKETn  register I/O function //
N////////////////////////////////////
N/**
N * @addtogroup Socket_register_access_function_W6100
N * @{
N */
N#define setSn_MR(sn,mr) \
N        WIZCHIP_WRITE(_Sn_MR_(sn),(mr))
X#define setSn_MR(sn,mr)         WIZCHIP_WRITE(_Sn_MR_(sn),(mr))
N#define getSn_MR(sn) \
N        WIZCHIP_READ(_Sn_MR_(sn))
X#define getSn_MR(sn)         WIZCHIP_READ(_Sn_MR_(sn))
N
N#define setSn_PSR(sn,psr) \
N        WIZCHIP_WRITE(_Sn_PSR_(sn),(psr))
X#define setSn_PSR(sn,psr)         WIZCHIP_WRITE(_Sn_PSR_(sn),(psr))
N#define getSn_PSR(sn) \
N        WIZCHIP_READ(_Sn_PSR_(sn))
X#define getSn_PSR(sn)         WIZCHIP_READ(_Sn_PSR_(sn))
N
N#define setSn_CR(sn,cr) \
N        WIZCHIP_WRITE(_Sn_CR_(sn),(cr))
X#define setSn_CR(sn,cr)         WIZCHIP_WRITE(_Sn_CR_(sn),(cr))
N#define getSn_CR(sn) \
N        WIZCHIP_READ(_Sn_CR_(sn))
X#define getSn_CR(sn)         WIZCHIP_READ(_Sn_CR_(sn))
N
N#define getSn_IR(sn) \
N        WIZCHIP_READ(_Sn_IR_(sn))
X#define getSn_IR(sn)         WIZCHIP_READ(_Sn_IR_(sn))
N
N#define setSn_IMR(sn,imr) \
N        WIZCHIP_WRITE(_Sn_IMR_(sn),(imr))
X#define setSn_IMR(sn,imr)         WIZCHIP_WRITE(_Sn_IMR_(sn),(imr))
N#define getSn_IMR(sn) \
N        WIZCHIP_READ(_Sn_IMR_(sn))
X#define getSn_IMR(sn)         WIZCHIP_READ(_Sn_IMR_(sn))
N
N#define setSn_IRCLR(sn,irclr) \
N        WIZCHIP_WRITE(_Sn_IRCLR_(sn),(irclr))
X#define setSn_IRCLR(sn,irclr)         WIZCHIP_WRITE(_Sn_IRCLR_(sn),(irclr))
N#define setSn_IR(sn,ir)          setSn_IRCLR(sn,(ir))
N
N#define getSn_SR(sn) \
N        WIZCHIP_READ(_Sn_SR_(sn))
X#define getSn_SR(sn)         WIZCHIP_READ(_Sn_SR_(sn))
N
N#define getSn_ESR(sn) \
N        WIZCHIP_READ(_Sn_ESR_(sn))
X#define getSn_ESR(sn)         WIZCHIP_READ(_Sn_ESR_(sn))
N
N#define setSn_PNR(sn,pnr) \
N        WIZCHIP_WRITE(_Sn_PNR_(sn),(pnr))
X#define setSn_PNR(sn,pnr)         WIZCHIP_WRITE(_Sn_PNR_(sn),(pnr))
N#define setSn_NHR(sn,nhr)        setSn_PNR(_Sn_PNR_(sn),(nhr))
N
N#define getSn_PNR(sn) \
N        WIZCHIP_READ(_Sn_PNR_(sn))
X#define getSn_PNR(sn)         WIZCHIP_READ(_Sn_PNR_(sn))
N#define getSn_NHR(sn)            getSn_PNR(sn)
N
N#define setSn_TOSR(sn,tosr) \
N        WIZCHIP_WRITE(_Sn_TOSR_(sn),(tosr))
X#define setSn_TOSR(sn,tosr)         WIZCHIP_WRITE(_Sn_TOSR_(sn),(tosr))
N#define getSn_TOSR(sn) \
N        WIZCHIP_READ(_Sn_TOSR_(sn))
X#define getSn_TOSR(sn)         WIZCHIP_READ(_Sn_TOSR_(sn))
N
N#define setSn_TTLR(sn,ttlr) \
N        WIZCHIP_WRITE(_Sn_TTLR_(sn),(ttlr))
X#define setSn_TTLR(sn,ttlr)         WIZCHIP_WRITE(_Sn_TTLR_(sn),(ttlr))
N#define getSn_TTLR(sn) \
N        WIZCHIP_READ(_Sn_TTLR_(sn))
X#define getSn_TTLR(sn)         WIZCHIP_READ(_Sn_TTLR_(sn))
N
N#define setSn_HOPR(sn,hopr)      setSn_TTLR(sn),(ttlr))
N#define getSn_HOPR(sn)           getSn_TTLR(sn)
N
N#define setSn_FRGR(sn,frgr) \
N        do{                                                                      \
N            WIZCHIP_WRITE(_Sn_FRGR_(sn),(uint8_t)((frgr)>>8));                   \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1),(uint8_t)(frgr));  \
N        }while(0);
X#define setSn_FRGR(sn,frgr)         do{                                                                                  WIZCHIP_WRITE(_Sn_FRGR_(sn),(uint8_t)((frgr)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1),(uint8_t)(frgr));          }while(0);
N#define getSn_FRGR(sn,frgr) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_FRGR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1)))
X#define getSn_FRGR(sn,frgr)         ((((uint16_t)WIZCHIP_READ(_Sn_FRGR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1)))
N
N#define setSn_MSSR(sn,mssr) \
N        do{                                                                      \
N            WIZCHIP_WRITE(_Sn_MSSR_(sn),(uint8_t)((mssr)>>8));                   \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1),(uint8_t)(mssr));  \
N        }while(0);
X#define setSn_MSSR(sn,mssr)         do{                                                                                  WIZCHIP_WRITE(_Sn_MSSR_(sn),(uint8_t)((mssr)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1),(uint8_t)(mssr));          }while(0);
N#define getSn_MSSR(sn) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_MSSR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1)))
X#define getSn_MSSR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_MSSR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1)))
N
N#define setSn_PORTR(sn,portr) \
N        do{                                                                       \
N            WIZCHIP_WRITE(_Sn_PORTR_(sn),(uint8_t)((portr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1),(uint8_t)(portr)); \
N        }while(0);
X#define setSn_PORTR(sn,portr)         do{                                                                                   WIZCHIP_WRITE(_Sn_PORTR_(sn),(uint8_t)((portr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1),(uint8_t)(portr));         }while(0);
N#define getSn_PORTR(sn) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_PORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1)))
X#define getSn_PORTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_PORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1)))
N
N#define setSn_DHAR(sn,dhar) \
N        WIZCHIP_WRITE_BUF(_Sn_DHAR_(sn),(dhar),6)
X#define setSn_DHAR(sn,dhar)         WIZCHIP_WRITE_BUF(_Sn_DHAR_(sn),(dhar),6)
N#define getSn_DHAR(sn,dhar) \
N        WIZCHIP_READ_BUF(_Sn_DHAR_(sn),(dhar),6)
X#define getSn_DHAR(sn,dhar)         WIZCHIP_READ_BUF(_Sn_DHAR_(sn),(dhar),6)
N
N#define setSn_DIPR(sn,dipr) \
N        WIZCHIP_WRITE_BUF(_Sn_DIPR_(sn),(dipr),4)
X#define setSn_DIPR(sn,dipr)         WIZCHIP_WRITE_BUF(_Sn_DIPR_(sn),(dipr),4)
N#define getSn_DIPR(sn,dipr) \
N        WIZCHIP_READ_BUF(_Sn_DIPR_(sn),(dipr),4)
X#define getSn_DIPR(sn,dipr)         WIZCHIP_READ_BUF(_Sn_DIPR_(sn),(dipr),4)
N
N#define setSn_DIP4R(sn,dipr)      setSn_DIPR(sn,(dipr))
N#define getSn_DIP4R(sn,dipr)      getSn_DIPR(sn,(dipr))
N
N#define setSn_DIP6R(sn,dip6r) \
N        WIZCHIP_WRITE_BUF(_Sn_DIP6R_(sn),(dip6r),16)
X#define setSn_DIP6R(sn,dip6r)         WIZCHIP_WRITE_BUF(_Sn_DIP6R_(sn),(dip6r),16)
N#define getSn_DIP6R(sn,dip6r) \
N        WIZCHIP_READ_BUF(_Sn_DIP6R_(sn),(dip6r),16)
X#define getSn_DIP6R(sn,dip6r)         WIZCHIP_READ_BUF(_Sn_DIP6R_(sn),(dip6r),16)
N
N#define setSn_DPORTR(sn,dportr) \
N        do{                                                                         \
N            WIZCHIP_WRITE(_Sn_DPORTR_(sn),(uint8_t)((dportr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1),(uint8_t)(dportr)); \
N        }while(0);
X#define setSn_DPORTR(sn,dportr)         do{                                                                                     WIZCHIP_WRITE(_Sn_DPORTR_(sn),(uint8_t)((dportr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1),(uint8_t)(dportr));         }while(0);
N#define getSn_DPORTR(sn) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_DPORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1)))
X#define getSn_DPORTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_DPORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1)))
N
N#define setSn_MR2(sn,mr2) \
N        WIZCHIP_WRITE(_Sn_MR2_(sn),(mr2))
X#define setSn_MR2(sn,mr2)         WIZCHIP_WRITE(_Sn_MR2_(sn),(mr2))
N#define getSn_MR2(sn) \
N        WIZCHIP_READ(_Sn_MR2_(sn))
X#define getSn_MR2(sn)         WIZCHIP_READ(_Sn_MR2_(sn))
N
N#define setSn_RTR(sn,rtr) \
N        do{                                                                   \
N            WIZCHIP_WRITE(_Sn_RTR_(sn),(uint8_t)((rtr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1),(uint8_t)(rtr)); \
N        }while(0);
X#define setSn_RTR(sn,rtr)         do{                                                                               WIZCHIP_WRITE(_Sn_RTR_(sn),(uint8_t)((rtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1),(uint8_t)(rtr));         }while(0);
N#define getSn_RTR(sn) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_RTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1)))
X#define getSn_RTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_RTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1)))
N
N#define setSn_RCR(sn,rcr) \
N        WIZCHIP_WRITE(_Sn_RCR_(sn),(rcr))
X#define setSn_RCR(sn,rcr)         WIZCHIP_WRITE(_Sn_RCR_(sn),(rcr))
N#define getSn_RCR(sn) \
N        WIZCHIP_READ(_Sn_RCR_(sn))
X#define getSn_RCR(sn)         WIZCHIP_READ(_Sn_RCR_(sn))
N
N#define setSn_KPALVTR(sn,kpalvtr) \
N        WIZCHIP_WRITE(_Sn_KPALVTR_(sn),(kpalvtr))
X#define setSn_KPALVTR(sn,kpalvtr)         WIZCHIP_WRITE(_Sn_KPALVTR_(sn),(kpalvtr))
N#define getSn_KPALVTR(sn) \
N        WIZCHIP_READ(_Sn_KPALVTR_(sn))
X#define getSn_KPALVTR(sn)         WIZCHIP_READ(_Sn_KPALVTR_(sn))
N
N#define setSn_TX_BSR(sn, tmsr) \
N        WIZCHIP_WRITE(_Sn_TX_BSR_(sn),(tmsr))
X#define setSn_TX_BSR(sn, tmsr)         WIZCHIP_WRITE(_Sn_TX_BSR_(sn),(tmsr))
N#define setSn_TXBUF_SIZE(sn, tmsr)      setSn_TX_BSR(sn,(tmsr))
N
N#define getSn_TX_BSR(sn) \
N        WIZCHIP_READ(_Sn_TX_BSR_(sn))
X#define getSn_TX_BSR(sn)         WIZCHIP_READ(_Sn_TX_BSR_(sn))
N#define getSn_TXBUF_SIZE(sn)            getSn_TX_BSR(sn)
N              
N#define getSn_TxMAX(sn) \
N	  (getSn_TX_BSR(sn) << 10)
X#define getSn_TxMAX(sn) 	  (getSn_TX_BSR(sn) << 10)
N
Ndatasize_t getSn_TX_FSR(uint8_t sn);
N
N#define getSn_TX_RD(sn) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_TX_RD_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_RD_(sn),1)))
X#define getSn_TX_RD(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_TX_RD_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_RD_(sn),1)))
N
N#define setSn_TX_WR(sn,txwr) \
N        do{                                                                       \
N            WIZCHIP_WRITE(_Sn_TX_WR_(sn), (uint8_t)((txwr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1), (uint8_t)(txwr)); \
N        }while(0);
X#define setSn_TX_WR(sn,txwr)         do{                                                                                   WIZCHIP_WRITE(_Sn_TX_WR_(sn), (uint8_t)((txwr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1), (uint8_t)(txwr));         }while(0);
N#define getSn_TX_WR(sn) \
N        (((uint16_t)WIZCHIP_READ(_Sn_TX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1)))
X#define getSn_TX_WR(sn)         (((uint16_t)WIZCHIP_READ(_Sn_TX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1)))
N
N#define setSn_RX_BSR(sn,rmsr) \
N        WIZCHIP_WRITE(_Sn_RX_BSR_(sn),(rmsr))
X#define setSn_RX_BSR(sn,rmsr)         WIZCHIP_WRITE(_Sn_RX_BSR_(sn),(rmsr))
N#define setSn_RXBUF_SIZE(sn,rmsr)      setSn_RX_BSR(sn,(rmsr))
N
N#define getSn_RX_BSR(sn) \
N        WIZCHIP_READ(_Sn_RX_BSR_(sn))
X#define getSn_RX_BSR(sn)         WIZCHIP_READ(_Sn_RX_BSR_(sn))
N#define getSn_RXBUF_SIZE(sn)           getSn_RX_BSR(sn)
N
N#define getSn_RxMAX(sn) \
N        (getSn_RX_BSR(sn) <<10)
X#define getSn_RxMAX(sn)         (getSn_RX_BSR(sn) <<10)
N
Ndatasize_t getSn_RX_RSR(uint8_t s);
N
N#define setSn_RX_RD(sn,rxrd) \
N        do{                                                                        \
N            WIZCHIP_WRITE(_Sn_RX_RD_(sn), (uint8_t)((rxrd)>>8));                   \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1), (uint8_t)(rxrd)) ; \
N        }while(0);
X#define setSn_RX_RD(sn,rxrd)         do{                                                                                    WIZCHIP_WRITE(_Sn_RX_RD_(sn), (uint8_t)((rxrd)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1), (uint8_t)(rxrd)) ;         }while(0);
N
N#define getSn_RX_RD(sn) \
N        (((uint16_t)WIZCHIP_READ(_Sn_RX_RD_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1)))
X#define getSn_RX_RD(sn)         (((uint16_t)WIZCHIP_READ(_Sn_RX_RD_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1)))
N
N#define getSn_RX_WR(sn) \
N        (((uint16_t)WIZCHIP_READ(_Sn_RX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_WR_(sn),1)))
X#define getSn_RX_WR(sn)         (((uint16_t)WIZCHIP_READ(_Sn_RX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_WR_(sn),1)))
N/**
N * @}
N */
N                  
N
N/////////////////////////////////////
N// Sn_TXBUF & Sn_RXBUF IO function //
N/////////////////////////////////////
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It saves data to be sent in the SOCKETn TX buffer.
N * @details This function reads first @ref _Sn_TX_WR_ \n
N *          and starts to copy <i>wizdata</i> from @ref _Sn_TX_WR_ address of SOCKETn TX buffer as many as <i>len</i>.\n
N *          After it is completed to copy <i><wizdata</i>, \n
N *          It increases @ref _Sn_TX_WR_ as many as <i>len</i>.
N * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param wizdata Pointer buffer to write data
N * @param len Data length
N * @sa wiz_recv_data()
N */
Nvoid wiz_send_data(uint8_t sn, uint8_t *wizdata, datasize_t len);
N
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It reads the received data from the SOCKETn RX buffer and copies the data to your system memory specified by <i>wizdata</i>.
N * @details This function reads first @ref _Sn_RX_RD_ \n
N *          and starts to copy the received data to <i>wizdata</i> as many as <i>len</i>.\n
N *          After it is completed to copy the received data, \n
N *          It increases @ref _Sn_RX_RD_ as many as <i>len</i>.
N * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param wizdata Pointer buffer to read data
N * @param len Data length
N * @sa wiz_send_data()
N */
Nvoid wiz_recv_data(uint8_t sn, uint8_t *wizdata, datasize_t len);
N
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It discards the received data in the SOCKETn RX buffer.
N * @details This function discards the received data by increasing @ref _Sn_RX_RD_ as manay as <i>len</i> without coping the data.
N * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param len Data length
N */
Nvoid wiz_recv_ignore(uint8_t sn, datasize_t len);
N
N/// @cond DOXY_APPLY_CODE
N#if (_PHY_IO_MODE_ == _PHY_IO_MODE_MII_)
X#if (0x0000 == 0x0010)
S/// @endcond
S/**
S * @ingroup Special_function_W6100
S * @brief Write data to the PHY via MDC/MDIO interface.
S * @details Write command data to the PHY via MDC/MDIO interface.
S * @param phyregaddr Address of the PHY register. It should be @ref PHYRAR_BMCR, @ref PHYRAR_BMSR, and etc.
S * @param var Data to write to the PHY register. Please refer to the bit definitions of the BMCR and BMSR register.
S * @note In order to use it, You should define @ref _PHY_IO_MODE_ to @ref _PHY_IO_MODE_MII_.
S */
Svoid wiz_mdio_write(uint8_t phyregaddr, uint16_t var);
S
S/**
S * @ingroup Special_function_W6100
S * @brief Read data from the PHY via MDC/MDIO interface.
S * @details Read command or status data from the PHY via MDC/MDIO interface.
S * @param phyregaddr Address of the PHY register. It should be @ref PHYRAR_BMCR, @ref PHYRAR_BMSR, and etc.
S * @return The value of the PHY register
S * @note In order to use it, You should define @ref _PHY_IO_MODE_ to @ref _PHY_IO_MODE_MII_.
S */
Suint16_t wiz_mdio_read(uint8_t phyregaddr);
S/// @cond DOXY_APPLY_CODE
N#endif
N/// @endcond
N
N/// @cond DOXY_APPLY_CODE
N#endif  // _WIZCHIP_ == 6100
N/// @endcond
N
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif //_W6100_H_
L 7 "AddressAutoConfig.h" 2
N#include "socket.h"
L 1 "..\..\Libraries\io6Library\Ethernet\socket.h" 1
N//* ****************************************************************************
N//! \file socket.h
N//! \brief SOCKET APIs Header File.
N//! \version 1.0.0
N//! \date 2019/01/01
N//! \par  Revision history
N//!       <2019/01/01> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2019, WIZnet Co., LTD.
N//!
N//! Permission is hereby granted, free of charge, to any person obtaining a copy
N//! of this software and associated documentation files (the "Software"), to deal
N//! in the Software without restriction, including without limitation the rights 
N//! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N//! copies of the Software, and to permit persons to whom the Software is 
N//! furnished to do so, subject to the following conditions: 
N//!
N//! The above copyright notice and this permission notice shall be included in
N//! all copies or substantial portions of the Software. 
N//!
N//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
N//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
N//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
N//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
N//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
N//! SOFTWARE. 
N//!
N//*****************************************************************************
N
N/**
N * @defgroup WIZnet_socket_APIs 1. WIZnet socket APIs
N * @brief WIZnet socket APIs are based on Berkeley socket APIs,  thus it has much similar name and interface.
N *        But there is a little bit of difference.
N * @details
N * <b> Comparison between WIZnet and Berkeley SOCKET APIs </b>
N * <table>
N *    <tr> <td><b>API       </b></td> <td><b>WIZnet</b></td> <td><b>Berkeley</b></td> </tr>
N *    <tr> <td><b>socket()  </b></td> <td>O            </td> <td>O              </td> </tr>
N *    <tr> <td><b>bind()    </b></td> <td>X            </td> <td>O              </td> </tr>
N *    <tr> <td><b>listen()  </b></td> <td>O            </td> <td>O              </td> </tr>
N *    <tr> <td><b>connect() </b></td> <td>O            </td> <td>O              </td> </tr>
N *    <tr> <td><b>accept()  </b></td> <td>X            </td> <td>O              </td> </tr>
N *    <tr> <td><b>recv()    </b></td> <td>O            </td> <td>O              </td> </tr>
N *    <tr> <td><b>send()    </b></td> <td>O            </td> <td>O              </td> </tr>
N *    <tr> <td><b>recvfrom()</b></td> <td>O            </td> <td>O              </td> </tr>
N *    <tr> <td><b>sendto()  </b></td> <td>O            </td> <td>O              </td> </tr>
N *    <tr> <td><b>closesocket()</b></td> <td>O<br>close() & disconnect()</td> <td>O</td> </tr>
N * </table>
N * There are <b>bind()</b> and <b>accept()</b> functions in <b>Berkeley SOCKET API</b> but, not in <b>WIZnet SOCKET API</b>. \n
N * Because socket() of WIZnet is not only creating a SOCKET but also binding a local port number, \n
N * and listen() of WIZnet is not only listening to connection request from client but also accepting the connection request. \n
N * When you program "TCP SERVER" with Berkeley SOCKET API, you can use only one listen port. \n
N * When the listen SOCKET accepts a connection request from a client, it keeps listening. \n
N * After accepting the connection request, a new SOCKET is created and the new SOCKET is used in communication with the client. \n
N * Following figure shows network flow diagram by Berkeley SOCKET API. \n
N *  <table width=0 >
N *  <tr> <td>@image html Berkeley_SOCKET.jpg "<Berkeley SOCKET API>"</td> </tr>
N *  </table>
N * But, When you program "TCP SERVER" with WIZnet SOCKET API, you can use as many as 8 listen SOCKET with same port number. \n
N * Because there's no accept() in WIZnet SOCKET APIs, when the listen SOCKET accepts a connection request from a client, \n
N * it is changed in order to communicate with the client.\n
N * And the changed SOCKET is not listening any more and is dedicated for communicating with the client. \n
N * If there're many listen SOCKET with same listen port number and a client requests a connection, \n
N * the SOCKET which has the smallest SOCKET number accepts the request and is changed as communication SOCKET. \n
N * Following figure shows network flow diagram by WIZnet SOCKET API.
N *  <table width=0 >
N *  <tr> <td>@image html WIZnet_SOCKET.jpg "<WIZnet SOCKET API>"</td> </tr>
N *  </table>
N */
N
N#ifndef _SOCKET_H_
N#define _SOCKET_H_
N
N#include "stdint.h"
N#include "wizchip_conf.h"
N
N#define SOCKET               uint8_t  ///< SOCKET type define for legacy driver
N
N#define SOCK_OK              1        ///< Result is OK about socket process.
N#define SOCK_BUSY            0        ///< Socket is busy on processing the operation. Valid only Non-block IO Mode.
N#define SOCK_FATAL           (-1000)    ///< Result is fatal error about socket process.
N
N#define SOCK_ERROR           0        
N#define SOCKERR_SOCKNUM      (SOCK_ERROR - 1)     ///< Invalid socket number
N#define SOCKERR_SOCKOPT      (SOCK_ERROR - 2)     ///< Invalid socket option
N#define SOCKERR_SOCKINIT     (SOCK_ERROR - 3)     ///< Socket is not initialized or SIPR is Zero IP address when Sn_MR_TCP
N#define SOCKERR_SOCKCLOSED   (SOCK_ERROR - 4)     ///< Socket unexpectedly closed.
N#define SOCKERR_SOCKMODE     (SOCK_ERROR - 5)     ///< Invalid socket mode for socket operation.
N#define SOCKERR_SOCKFLAG     (SOCK_ERROR - 6)     ///< Invalid socket flag
N#define SOCKERR_SOCKSTATUS   (SOCK_ERROR - 7)     ///< Invalid socket status for socket operation.
N#define SOCKERR_ARG          (SOCK_ERROR - 10)    ///< Invalid argument.
N#define SOCKERR_PORTZERO     (SOCK_ERROR - 11)    ///< Port number is zero
N#define SOCKERR_IPINVALID    (SOCK_ERROR - 12)    ///< Invalid source or destination IP address
N#define SOCKERR_TIMEOUT      (SOCK_ERROR - 13)    ///< Timeout occurred
N#define SOCKERR_DATALEN      (SOCK_ERROR - 14)    ///< Invalid data length
N#define SOCKERR_BUFFER       (SOCK_ERROR - 15)    ///< Socket buffer is not enough for data communication.
N//#define SOCKERR_IPvMISMATCH   (SOCK_ERROR - 16)    ///< Socket IP version invalid
N//#define SOCKERR_IPLENINVALID  (SOCK_ERROR - 17)    ///< Socket IP version invalid
N
N#define SOCKFATAL_PACKLEN    (SOCK_FATAL - 1)     ///< Invalid packet length. Fatal Error.
N
N/*
N * - @ref Sn_MR_MULTI : Support UDP Multicasting
N * - @ref Sn_MR_MF    : Support MAC Filter Enable
N * - @ref Sn_MR_BRDB  : Broadcast Block
N * - @ref Sn_MR_FPSH  : Force PSH flag
N * - @ref Sn_MR_ND    : No Delay ACK flag
N * - @ref Sn_MR_MC    : IGMP ver2, ver1
N * - @ref Sn_MR_SMB   : Solicited Multicast Block
N * - @ref Sn_MR_MMB   : IPv4 Multicast block
N * - @ref Sn_MR_UNIB  : Unicast Block
N * - @ref Sn_MR_MMB6  : IPv6 UDP Multicast Block </b>
N
N * - @ref Sn_MR2_DHAM : @ref Sn_MR2_DHAM_AUTO, @ref Sn_MR2_DHAM_MANUAL
N * - @ref Sn_MR_FARP   
N*/
N
N/*
N * SOCKET FLAG
N */
N/**
N * @brief In UDP mode such as @ref Sn_MR_UDP4 and @ref Sn_MR_UDP6, @ref Sn_MR_UDP6, Enable multicast mode. When @ref Sn_MR_UDP6, Enable only IPv6 Multicating.
N */
N#define SF_MULTI_ENABLE      (Sn_MR_MULTI)    
N#define SF_ETHER_OWN         (Sn_MR_MF)       ///< In MACRAW mode such as @ref Sn_MR_MACRAW, Receive only the packet as broadcast, multicast and own packet
N
N/**
N * @brief In UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6 and @ref Sn_MR_UDPD, or In MACRAW mode sucha as @ref Sn_MR_MACRAW, Block a broadcast packet. 
N */
N#define SF_BROAD_BLOCK       (Sn_MR_BRDB)       
N#define SF_TCP_FPSH          (Sn_MR_FPSH)       ///< In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD, Use to forced push flag.
N
N#define SF_TCP_NODELAY       (Sn_MR_ND)       ///< In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD, Use to nodelayed ack.
N#define SF_IGMP_VER2         (Sn_MR_MC)       ///< In UDP mode such as @ref Sn_MR_UDP4 with @ref SF_MULTI_ENABLE, Select IGMP version 2.   
N#define SF_SOLICIT_BLOCK     (Sn_MR_SMB)      ///< In UDP mode such as @ref Sn_MR_UDP6 and @ref Sn_MR_UDPD, Block a solicited mutlicast packet.
N#define SF_ETHER_MULTI4B     (Sn_MR_MMB4)     ///< In MACRAW mode such as @ref Sn_MR_MACRAW with @ref SF_MULTI_ENABLE, Block a IPv4 multicast packet. 
N
N#define SF_UNI_BLOCK         (Sn_MR_UNIB)     ///< In UDP mdoe such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6 and @ref Sn_MR_UDPD with @ref SF_MULTI_ENABLE, Block a unicast packet. 
N#define SF_ETHER_MULIT6B     (Sn_MR_MMB6)     ///< In MACRAW mode such as @ref Sn_MR_MACRAW with @ref SF_MULTI_ENABLE, Block a IPv6 multicast packet. 
N
N/**
N * @brief Force to APR.
N * @details In datagram mode such as @ref Sn_MR_IPRAW4, @ref Sn_MR_IPRAW6, @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD,
N *          Force to request ARP before a packet is sent to a destination.\n
N *          In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD and <b>TCP SERVER</b> operation mode, 
N *          Force to request ARP before SYN/ACK packet is sent to a <b>TCP CLIENT</b>. \n
N *          When @ref SF_DHA_MANUAL is set, the ARP is process but the destination hardware address is fixed by user.
N */
N#define SF_FORCE_ARP         (Sn_MR2_FARP)
N
N/**
N * @brief The destination hardware address of packet to be transmitted is set by user through @ref _Sn_DHAR_. It is invalid in MACRAW mode such as @ref Sn_MR_MACRAW.
N */
N#define SF_DHA_MANUAL        (Sn_MR2_DHAM)
N
N#define SF_IO_NONBLOCK       (0x01 << 3)     ///< Socket nonblock io mode. It used parameter in @ref socket().
N
N/*
N * UDP, IPRAW, MACRAW Packet Infomation
N */
N#define PACK_IPv6            (1<<7)                ///< It indicates the destination IP address of the received packet is IPv6 or IPv4.
N#define PACK_IPV6_ALLNODE    (PACK_IPv6 | (1<<6))  ///< It indicates the destination IP address of the received packet is allnode multicast(broadcast) address or not.
N#define PACK_IPV6_MULTI      (PACK_IPv6 | (1<<5))  ///< It indicates the destination IP address of the received packet is multicast address or not.
N#define PACK_IPV6_LLA        (PACK_IPv6 | (1<<4))  ///< It indicates the destination IP address of the received packet is lla or gua.
N#define PACK_COMPLETED       (1<<3)                ///< It indicates the read data is last in the received packet.
N#define PACK_REMAINED        (1<<2)                ///< It indicates to remain data in the received packet
N#define PACK_FIRST           (1<<1)                ///< It indicates the read data is first in the received packet.
N#define PACK_NONE            (0x00)                ///< It indicates no information of a packet
N
N#define SRCV6_PREFER_AUTO    (PSR_AUTO)            ///< Soruce IPv6 address is preferred to auto-selection. Refer to @ref _Sn_PSR_
N#define SRCV6_PREFER_LLA     (PSR_LLA)             ///< Soruce IPv6 address is preferred to link local address. Refer to @ref _Sn_PSR_
N#define SRCV6_PREFER_GUA     (PSR_GUA)             ///< Soruce IPv6 address is preferred to global unique address. Refer to @ref _Sn_PSR_
N
N#define TCPSOCK_MODE         (Sn_ESR_TCPM)         ///< It indicates the IP version when SOCKETn is opened as TCP6 or TCPD mode.(0 - IPv4 , 1 - IPv6)
N#define TCPSOCK_OP           (Sn_ESR_TCPOP)        ///< It indicates the operation mode when SOCKETn is connected.(0 - <b>TCP CLIENT</b> , 1 - <b>TCP SERVER</b>)
N#define TCPSOCK_SIP          (Sn_ESR_IP6T)         ///< It indicates the source ip address type when SOCKET is connected. (0 - Link Local, 1 - Global Unique) 
N
N/////////////////////////////
N// SOCKET CONTROL & OPTION //
N/////////////////////////////
N#define SOCK_IO_BLOCK         0  ///< Socket Block IO Mode in @ref setsockopt().
N#define SOCK_IO_NONBLOCK      1  ///< Socket Non-block IO Mode in @ref setsockopt().
N
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Open a socket.
N * @details Initializes the SOCKET have the <i>sn</i> number open it.
N *
N * @param sn SOCKET number. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param protocol Protocol type to operate such as TCP, UDP IPRAW, and MACRAW. \n
N *  - TCP    : @ref Sn_MR_TCP(= @ref Sn_MR_TCP4), @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
N *  - UDP    : @ref Sn_MR_UDP(= @ref Sn_MR_UDP4), @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD
N *  - IPRAW  : @ref Sn_MR_IPRAW(= @ref Sn_MR_IPRAW4) and @ref Sn_MR_IPRAW6
N *  - MACRAW : @ref Sn_MR_MACRAW       
N * @param port Source port number to be binded.
N * @param flag SOCKET flags are as following. It is used together with OR operation.
N *  - @ref SF_MULTI_ENABLE
N *  - @ref SF_ETHER_OWN    
N *  - @ref SF_BROAD_BLOCK 
N *  - @ref SF_TCP_FPSH 
N *  - @ref SF_TCP_NODELAY 
N *  - @ref SF_IGMP_VER2 
N *  - @ref SF_SOLICIT_BLOCK
N *  - @ref SF_ETHER_MULTI4B
N *  - @ref SF_UNI_BLOCK
N *  - @ref SF_ETHER_MULIT6B
N *  - @ref SF_DHA_MANUAL
N *  - @ref SF_FORCE_ARP
N *  - @ref SF_IO_NONBLOCK
N * @return Success : The SOCKET number sn passed as parameter\n
N *         Fail    :\n @ref SOCKERR_SOCKNUM     - Invalid SOCKETn, <i>sn</i>\n
N *                     @ref SOCKERR_SOCKMODE    - Invalid SOCKETn mode\n
N *                     @ref SOCKERR_SOCKFLAG    - Invaild SOCKETn flag.
N * @sa _Sn_MR_, _Sn_MR2_ 
N */
Nint8_t socket(uint8_t sn, uint8_t protocol, uint16_t port, uint8_t flag);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Close a SOCKET.
N * @details It closes the SOCKET  with <b>'sn'</b> passed as parameter.
N * @param sn SOCKET number. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @return Success : @ref SOCK_OK \n
N *         Fail    : @ref SOCKERR_SOCKNUM - Invalid SOCKET number
N */
Nint8_t close(uint8_t sn);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Listen to a connection request from a <b>TCP CLIENT</b>.
N * @details It is listening to a connection request from a client.
N *          If connection request is accepted successfully, the connection is established. \n
N *          SOCKET <i>sn</i> is used as passive(<b>TCP SERVER</b>) mode.
N * @param sn SOCKET number. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @return Success : @ref SOCK_OK \n
N *         Fail    :\n @ref SOCKERR_SOCKINIT   - Socket is not initialized \n
N *                     @ref SOCKERR_SOCKCLOSED - Socket closed unexpectedly.
N */
Nint8_t listen(uint8_t sn);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Try to connect to a <b>TCP SERVER</b>.
N * @details It sends a connection-reqeust message to the server with destination IP address and port number passed as parameter.\n
N *          SOCKET <i>sn</i> is used as active(<b>TCP CLIENT</b>) mode.
N * @param sn SOCKET number. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param addr Pointer variable of destination IPv6 or IPv4 address. 
N * @param port Destination port number.
N * @param addrlen the length of <i>addr</i>. \n
N *                If addr is IPv6 address it should be 16,else if addr is IPv4 address it should be 4. Otherwize, return @ref SOCKERR_IPINVALID.
N * @return Success : @ref SOCK_OK \n
N *         Fail    :\n @ref SOCKERR_SOCKNUM   - Invalid socket number\n
N *                     @ref SOCKERR_SOCKMODE  - Invalid socket mode\n
N *                     @ref SOCKERR_SOCKINIT  - Socket is not initialized\n
N *                     @ref SOCKERR_IPINVALID - Wrong server IP address\n
N *                     @ref SOCKERR_PORTZERO  - Server port zero\n
N *                     @ref SOCKERR_TIMEOUT   - Timeout occurred during request connection\n
N *                     @ref SOCK_BUSY         - In non-block io mode, it returns immediately\n
N * @note It is valid only in TCP client mode. \n
N *       In block io mode, it does not return until connection is completed. \n
N *       In Non-block io mode(@ref SF_IO_NONBLOCK), it returns @ref SOCK_BUSY immediately.
N */
Nint8_t connect(uint8_t sn, uint8_t * addr, uint16_t port, uint8_t addrlen);
N
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Try to disconnect to the connected peer.
N * @details It sends disconnect-request message to the connected peer which is <b>TCP SERVER</b> or <b>TCP CLIENT</b>.
N * @param sn SOCKET number. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @return Success :   @ref SOCK_OK \n
N *         Fail    :\n @ref SOCKERR_SOCKNUM  - Invalid SOCKET number \n
N *                     @ref SOCKERR_SOCKMODE - Invalid operation in the SOCKET \n
N *                     @ref SOCKERR_TIMEOUT  - Timeout occurred \n
N *                     @ref SOCK_BUSY        - In non-block io mode, it returns immediately.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD. \n
N *       In block io mode, it does not return until disconnection is completed. \n
N *       In Non-block io mode(@ref SF_IO_NONBLOCK), it returns @ref SOCK_BUSY immediately. \n
N */
Nint8_t disconnect(uint8_t sn);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Send data to the connected peer.
N * @details It sends data to the connected peer by using TCP mode SOCKET <i>sn</i>.
N * @param sn SOCKET number. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param buf Pointer of data buffer to be sent.
N * @param len The byte length of data in <i>buf</i>.
N * @return   Success : The real sent data size. It may be equal to <i>len</i> or small. \n
N *          Fail    : \n @ref SOCKERR_SOCKSTATUS - Invalid SOCKET status for SOCKET operation \n
N *                          @ref SOCKERR_TIMEOUT    - Timeout occurred \n
N *                          @ref SOCKERR_SOCKMODE     - Invalid operation in the SOCKET \n
N *                          @ref SOCKERR_SOCKNUM    - Invalid SOCKET number \n
N *                          @ref SOCK_BUSY          - SOCKET is busy.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, Sn_MR_TCP6, and Sn_MR_TCPD. \n
N *       It can send data as many as SOCKET TX buffer size if data is greater than SOCKET TX buffer size. \n
N *       In block io mode, It doesn't return until data sending is completed when SOCKET transmittable buffer size is greater than data. \n
N *       In non-block io mode(@ref SF_IO_NONBLOCK), It return @ref SOCK_BUSY immediately when SOCKET transmittable buffer size is not enough or the previous sent data is not completed. \n
N */
Ndatasize_t send(uint8_t sn, uint8_t * buf, datasize_t len);
N
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Receive data from the connected peer.
N * @details It can read data received from the connected peer by using TCP mode SOCKET <i>sn</i>.\n
N * @param sn SOCKET number. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param buf Pointer buffer to read the received data.
N * @param len The max data length of data in buf.
N * @return Success : The real received data size. It may be equal to <i>len</i> or small. \n
N *         Fail    :\n
N *                  @ref SOCKERR_SOCKSTATUS - Invalid SOCKET status for SOCKET operation \n
N *                  @ref SOCKERR_SOCKMODE   - Invalid operation in the SOCKET \n
N *                  @ref SOCKERR_SOCKNUM    - Invalid SOCKET number \n
N *                   @ref SOCK_BUSY         - SOCKET is busy.
N * @note It is valid only in <b>TCP SERVER</b> or <b>TCP CLIENT</b> mode. \n
N *       It can read data as many as SOCKET RX buffer size if data is greater than SOCKET RX buffer size. \n
N *       In block io mode, it doesn't return until data reception is completed. that is, it waits until any data is received in SOCKET RX buffer. \n
N *       In non-block io mode(@ref SF_IO_NONBLOCK), it return @ref SOCK_BUSY immediately when SOCKET RX buffer is empty. \n
N *
N */
Ndatasize_t recv(uint8_t sn, uint8_t * buf, datasize_t len);
N
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Send datagram to the peer specifed by destination IP address and port number passed as parameter.
N * @details It sends datagram data by using UDP,IPRAW, or MACRAW mode SOCKET.
N * @param sn SOCKET number. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param buf Pointer of data buffer to be sent.
N * @param len The byte length of data in buf.
N * @param addr Pointer variable of destination IPv6 or IPv4 address. 
N * @param port Destination port number.
N * @param addrlen the length of <i>addr</i>. \n
N *                If addr is IPv6 address it should be 16,else if addr is IPv4 address it should be 4. Otherwize, return @ref SOCKERR_IPINVALID.
N * @return Success : The real sent data size. It may be equal to <i>len</i> or small.\n
N *         Fail    :\n @ref SOCKERR_SOCKNUM     - Invalid SOCKET number \n
N *                     @ref SOCKERR_SOCKMODE    - Invalid operation in the SOCKET \n
N *                     @ref SOCKERR_SOCKSTATUS  - Invalid SOCKET status for SOCKET operation \n
N *                     @ref SOCKERR_IPINVALID   - Invalid IP address\n
N *                     @ref SOCKERR_PORTZERO    - Destination port number is zero\n
N *                     @ref SOCKERR_DATALEN     - Invalid data length \n
N *                     @ref SOCKERR_SOCKCLOSED  - SOCKET unexpectedly closed \n
N *                     @ref SOCKERR_TIMEOUT     - Timeout occurred \n
N *                     @ref SOCK_BUSY           - SOCKET is busy.
N * @note It is valid only in @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, @ref Sn_MR_UDPD, @ref Sn_MR_IPRAW4, @ref Sn_MR_IPRAW6, and @ref Sn_MR_MACRAW. \n
N *       In UDP mode, It can send data as many as SOCKET RX buffer size if data is greater than SOCKET TX buffer size. \n
N *       In IPRAW and MACRAW mode, It should send data as many as MTU(maxium transmission unit) if data is greater than MTU. That is, <i>len</i> can't exceed to MTU.
N *       In block io mode, It doesn't return until data send is completed. 
N *       In non-block io mode(@ref SF_IO_NONBLOCK), It return @ref SOCK_BUSY immediately when SOCKET transimttable buffer size is not enough.
N */
Ndatasize_t sendto(uint8_t sn, uint8_t * buf, datasize_t len, uint8_t * addr, uint16_t port, uint8_t addrlen);
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Receive datagram from a peer 
N * @details It can read a data received from a peer by using UDP, IPRAW, or MACRAW mode SOCKET.
N * @param sn   SOCKET number. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param buf  Pointer buffer to be saved the received data.
N * @param len  The max read data length. \n
N *             When the received packet size <= <i>len</i>, it can read data as many as the packet size. \n
N *             When others, it can read data as many as len and remain to the rest data of the packet.
N * @param addr Pointer variable of destination IP address.\n
N *             It is valid only when @ref recvfrom() is first called for receiving the datagram packet.
N *             You can check it valid or not through @ref PACK_FIRST. You can get it through @ref getsockopt(sn, @ref SO_PACKINFO, &packinfo).\n
N *             In UDP4, IPRAW mode SOCKET, it should be allocated over 4bytes. \n
N *             In UDP6, UDPD mode SOCKET, it should be allocated over 16bytes.
N * @param port Pointer variable of destination port number. \n
N *             It is valid only when @ref recvfrom() is first called for receiving the datagram packet, same as <i>port</i> case.
N * @param addrlen The byte length of destination IP address. \n
N *                It is valid only when @ref recvfrom() is first called for receiving the datagram packet, same as <i>port</i> case.\n
N *                When the destination has a IPv4 address, it is set to 4. \n
N *                when the destination has a IPv6 address, it is set to 16. 
N * @return   Success : The real received data size. It may be equal to <i>len</i> or small.\n
N *          Fail    : @ref SOCKERR_SOCKMODE   - Invalid operation in the socket \n
N *                    @ref SOCKERR_SOCKNUM    - Invalid socket number \n
N *                    @ref SOCKERR_ARG        - Invalid parameter such as <i>addr</i>, <i>port</i>
N *                    @ref SOCK_BUSY          - SOCKET is busy.
N * @note It is valid only in @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, @ref Sn_MR_UDPD, @ref Sn_MR_IPRAW4, @ref Sn_MR_IPRAW6, and @ref Sn_MR_MACRAW. \n
N *       When SOCKET is opened with @ref Sn_MR_MACRAW or When it reads the the remained data of the previous datagram packet,
N *       the parameters such as <i>addr</i>, <i>port</i>, <i>addrlen</i> is ignored. \n
N *       Also, It can read data as many as the received datagram packet size if <i>len</i> is greater than the datagram packet size. \n
N *       In block io mode, it doesn't return until data reception is completed. that is, it waits until any datagram packet is received in SOCKET RX buffer. \n
N *       In non-block io mode(@ref SF_IO_NONBLOCK), it return @ref SOCK_BUSY immediately when SOCKET RX buffer is empty. \n
N */
Ndatasize_t recvfrom(uint8_t sn, uint8_t * buf, datasize_t len, uint8_t * addr, uint16_t *port, uint8_t *addrlen);
N
N
N
N/**
N * @defgroup DATA_TYPE DATA TYPE
N */
N
N/**
N * @ingroup DATA_TYPE
N * @brief The kind of SOCKET Interrupt.
N * @sa _Sn_IR_, _Sn_IMR_, setSn_IR(), getSn_IR(), setSn_IMR(), getSn_IMR()
N */
Ntypedef enum
N{
N   SIK_CONNECTED     = (1 << 0),    ///< connected
N   SIK_DISCONNECTED  = (1 << 1),    ///< disconnected
N   SIK_RECEIVED      = (1 << 2),    ///< data received
N   SIK_TIMEOUT       = (1 << 3),    ///< timeout occurred
N   SIK_SENT          = (1 << 4),    ///< send ok
N   SIK_ALL           = 0x1F         ///< all interrupt
N}sockint_kind;
N
N/**
N * @ingroup DATA_TYPE
N * @brief The type of @ref ctlsocket().
N */
Ntypedef enum
N{
N   CS_SET_IOMODE,          ///< set SOCKET IO mode with @ref SOCK_IO_BLOCK or @ref SOCK_IO_NONBLOCK
N   CS_GET_IOMODE,          ///< get SOCKET IO mode
N   CS_GET_MAXTXBUF,        ///< get the size of SOCKET TX buffer allocated in TX memory
N   CS_GET_MAXRXBUF,        ///< get the size of SOCKET RX buffer allocated in RX memory
N   CS_CLR_INTERRUPT,       ///< clear the interrupt of SOCKET with @ref sockint_kind.
N   CS_GET_INTERRUPT,       ///< get the SOCKET interrupt. refer to @ref sockint_kind.
N   CS_SET_INTMASK,         ///< set the interrupt mask of SOCKET with @ref sockint_kind.
N   CS_GET_INTMASK,         ///< get the masked interrupt of SOCKET. refer to @ref sockint_kind.
N   CS_SET_PREFER,          ///< set the preferred source IPv6 address of transmission packet.\n Refer to @ref SRCV6_PREFER_AUTO, @ref SRCV6_PREFER_LLA and @ref SRCV6_PREFER_GUA.
N   CS_GET_PREFER,          ///< get the preferred source IPv6 address of transmission packet.\n Refer to @ref SRCV6_PREFER_AUTO, @ref SRCV6_PREFER_LLA and @ref SRCV6_PREFER_GUA.
N}ctlsock_type;
N
N
N/**
N * @ingroup DATA_TYPE
N * @brief The type of socket option in @ref setsockopt() or @ref getsockopt()
N */ 
Ntypedef enum
N{
N   SO_FLAG,             ///< Valid only in @ref getsockopt(), For set flag of socket refer to <i>flag</i> in @ref socket(). \n
N   SO_TTL,              ///< Set/Get TTL. ( @ref setSn_TTLR(), @ref getSn_TTLR() ) \n
N   SO_TOS,              ///< Set/Get TOS. ( @ref setSn_TOSR(), @ref getSn_TOSR() )
N   SO_MSS,              ///< Set/Get MSS. ( @ref setSn_MSSR(), @ref getSn_MSSR() )
N   SO_DESTIP,           ///< Set/Get the destination IP address with argument @ref wiz_IPAddress. To get it, SOCKETn should be TCP mode.
N   SO_DESTPORT,         ///< Set/Get the destination Port number. To get it, SOCKETn should be TCP mode.
N   SO_KEEPALIVESEND,    ///< Valid only in @ref setsockopt(). Manually send keep-alive packet in TCP mode.
N   SO_KEEPALIVEAUTO,    ///< Set/Get keep-alive auto transmission timer in TCP mode 
N   SO_SENDBUF,          ///< Valid only in @ref getsockopt(). Get the free data size of SOCKETn TX buffer. @ref getSn_TX_FSR()
N   SO_RECVBUF,          ///< Valid only in @ref getsockopt(). Get the received data size in SOCKETn RX buffer. @ref getSn_RX_RSR()
N   SO_STATUS,           ///< Valid only in @ref getsockopt(). Get the SOCKETn status. @ref getSn_SR()
N   SO_EXTSTATUS,        ///< Valid only in @ref getsockopt(). Get the extended TCP SOCKETn status. @ref getSn_ESR()
N   SO_REMAINSIZE,       ///< Valid only in @ref getsockopt(). Get the remained packet size in non-TCP mode.
N   SO_MODE,
N   SO_PACKINFO          ///< Valid only in @ref getsockopt(). Get the packet information as @ref PACK_FIRST, @ref PACK_REMAINED, and etc.
N}sockopt_type;
N
N/**
N * @ingroup WIZnet_socket_APIs
N * @brief Control SOCKETn.
N * @details Control IO mode, Interrupt & Mask of SOCKETn and get the SOCKETn buffer information.
N *          Refer to @ref ctlsock_type.
N * @param sn socket number
N * @param cstype type of control SOCKETn. refer to @ref ctlsock_type.
N * @param arg Data type and value is determined according to @ref ctlsock_type. \n
N *          <table>
N *             <tr> <td> @b cstype                                </td> <td> <i>@b arg</i> type</td>
N *                  <td>@b value</td> </tr>
N *             <tr> <td> @ref CS_SET_IOMODE \n @ref CS_GET_IOMODE </td> <td> uint8_t           </td>
N *                  <td>@ref SOCK_IO_BLOCK, @ref SOCK_IO_NONBLOCK </td> </tr>
N *             <tr> <td> @ref CS_GET_MAXTXBUF \n @ref CS_GET_MAXRXBUF   </td> <td> datasize_t  </td>
N *                  <td> 0,1,2,4,8,16 KB </td> </tr>
N *             <tr> <td> @ref CS_CLR_INTERRUPT \n @ref CS_GET_INTERRUPT \n @ref CS_SET_INTMASK \n @ref CS_GET_INTMASK </td> 
N *                  <td> @ref sockint_kind </td> <td> @ref SIK_CONNECTED, etc.  </td> </tr> 
N *             <tr> <td> @ref CS_SET_PREFER \n @ref CS_GET_PREFER       </td> <td> uint8_t </td>
N *                  <td> @ref SRCV6_PREFER_AUTO, @ref SRCV6_PREFER_LLA, @ref SRCV6_PREFER_GUA  </td>< /tr>
N *          </table>
N * @return Success @ref SOCK_OK \n
N *         Fail   : \n
N *         - @ref SOCKERR_ARG         - Invalid argument\n
N *         - @ref SOCKERR_SOCKNUM     - Invalid Socket number \n
N */
Nint8_t ctlsocket(uint8_t sn, ctlsock_type cstype, void* arg);
N
N/** 
N * @ingroup WIZnet_socket_APIs
N *  @brief Set SOCKETn options
N *  @details Set SOCKETn option like as TTL, MSS, TOS, and so on. Refer to @ref sockopt_type.
N *               
N *  @param sn SOCKET number
N *  @param sotype SOCKET option type. refer to @ref sockopt_type
N *  @param arg Data type and value is determined according to <I>sotype</I>. \n
N *           <table>
N *              <tr> <td> @b sotype             </td> <td> <i>@b >arg</i> type</td><td>@b value   </td> </tr> 
N *              <tr> <td> @ref SO_TTL           </td> <td> uint8_t            </td><td> 0 ~ 255   </td> </tr>
N *              <tr> <td> @ref SO_TOS           </td> <td> uint8_t            </td><td> 0 ~ 255   </td> </tr>
N *              <tr> <td> @ref SO_MSS           </td> <td> uint16_t           </td><td> 0 ~ 65535 </td> </tr>
N *              <tr> <td> @ref SO_DESTIP        </td> <td> @ref wiz_IPAddress </td><td>           </td> </tr> 
N *              <tr> <td> @ref SO_DESTPORT      </td> <td> uint16_t           </td><td> 1 ~ 65535 </td> </tr>
N *              <tr> <td> @ref SO_KEEPALIVESEND </td> <td> null               </td><td> null      </td> </tr> 
N *              <tr> <td> @ref SO_KEEPALIVEAUTO </td> <td> uint8_t            </td><td> 0 ~ 255   </td> </tr> 
N *           </table>
N * @return 
N *   - Success : @ref SOCK_OK \n
N *   - Fail
N *     - @ref SOCKERR_SOCKNUM     - Invalid SOCKET number \n
N *     - @ref SOCKERR_SOCKMODE    - Invalid SOCKET mode \n
N *     - @ref SOCKERR_SOCKOPT     - Invalid SOCKET option or its value \n
N *     - @ref SOCKERR_TIMEOUT     - Timeout occurred when sending keep-alive packet
N */
Nint8_t setsockopt(uint8_t sn, sockopt_type sotype, void* arg);
N
N/** 
N * @ingroup WIZnet_socket_APIs
N *  @brief get SOCKETn options
N *  @details Get SOCKETn option like as FLAG, TTL, MSS, and so on. Refer to @ref sockopt_type
N *  @param sn SOCKET number
N *  @param sotype SOCKET option type. refer to @ref sockopt_type
N *  @param arg Data type and value is determined according to <I>sotype</I>.
N *           <table>
N *              <tr> <td> @b sotype             </td> <td> <i>@b arg</i> type </td><td> @b value                   </td></tr>
N *              <tr> <td> @ref SO_FLAG          </td> <td> uint8_t            </td><td> @ref SF_ETHER_OWN, etc...  </td> </tr>
N *              <tr> <td> @ref SO_TOS           </td> <td> uint8_t            </td><td> 0 ~ 255                    </td> </tr>
N *              <tr> <td> @ref SO_MSS           </td> <td> uint16_t           </td><td> 0 ~ 65535                  </td> </tr>
N *              <tr> <td> @ref SO_DESTIP        </td> <td> @ref wiz_IPAddress </td><td>                            </td></tr> 
N *              <tr> <td> @ref SO_DESTPORT      </td> <td> uint16_t           </td><td> 1 ~ 65535                  </td></tr>
N *              <tr> <td> @ref SO_KEEPALIVEAUTO </td> <td> uint8_t            </td><td> 0 ~ 255                    </td></tr> 
N *              <tr> <td> @ref SO_SENDBUF       </td> <td> @ref datasize_t    </td><td> 0 ~                        </td></tr>
N *              <tr> <td> @ref SO_RECVBUF       </td> <td> @ref datasize_t    </td><td> 0 ~                        </td></tr>
N *              <tr> <td> @ref SO_STATUS        </td> <td> uint8_t            </td><td> @ref SOCK_ESTABLISHED, etc. </td></tr>  
N *              <tr> <td> @ref SO_EXTSTATUS     </td> <td> uint8_t            </td><td> @ref TCPSOCK_MODE, @ref TCPSOCK_OP, @ref TCPSOCK_SIP </td></tr>   
N *              <tr> <td> @ref SO_REMAINSIZE    </td> <td> @ref datasize_t    </td><td> 0~                         </td></tr>
N *              <tr> <td> @ref SO_PACKINFO      </td> <td> uint8_t            </td><td> @ref PACK_FIRST, etc.      </td></tr>
N *           </table>
N * @return 
N *   - Success : @ref SOCK_OK \n
N *   - Fail
N *     - @ref SOCKERR_SOCKNUM   - Invalid Socket number \n
N *     - @ref SOCKERR_SOCKOPT   - Invalid socket option or its value \n
N *     - @ref SOCKERR_SOCKMODE  - Invalid socket mode \n
N * @note
N *   The option as @ref PACK_REMAINED of @ref SO_PACKINFO is valid only in NON-TCP mode. 
N */
Nint8_t getsockopt(uint8_t sn, sockopt_type sotype, void* arg);
N
N#endif   // _SOCKET_H_
L 8 "AddressAutoConfig.h" 2
N#include "dhcpv6.h"
L 1 "..\..\Libraries\io6Library\Internet\DHCP6\dhcpv6.h" 1
N//*****************************************************************************
N//
N//! \file dhcp6.h
N//! \brief DHCPv6 APIs Header file.
N//! \details Processig DHCPv6 protocol as SOLICIT, ADVERTISE.
N//! \version 0.0.1
N//! \date 2016/06/08
N//! \par  Revision history
N//!       <2016/07/18> 1st Release
N//! \author JustinKim
N//! \copyright
N//!
N//! Copyright (c)  2016, WIZnet Co., LTD.
N//! All rights reserved.
N//! 
N//! Redistribution and use in source and binary forms, with or without 
N//! modification, are permitted provided that the following conditions 
N//! are met: 
N//! 
N//!     * Redistributions of source code must retain the above copyright 
N//! notice, this list of conditions and the following disclaimer. 
N//!     * Redistributions in binary form must reproduce the above copyright
N//! notice, this list of conditions and the following disclaimer in the
N//! documentation and/or other materials provided with the distribution. 
N//!     * Neither the name of the <ORGANIZATION> nor the names of its 
N//! contributors may be used to endorse or promote products derived 
N//! from this software without specific prior written permission. 
N//! 
N//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N//! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N//! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N//! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
N//! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
N//! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
N//! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N//! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N//! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
N//! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
N//! THE POSSIBILITY OF SUCH DAMAGE.
N//
N//*****************************************************************************
N#ifndef _DHCP6_H_
N#define _DHCP6_H_
N#include <stdint.h>
N#include "W6100.h"
N#include "socket.h"
N/*
N * @brief 
N * @details If you want to display debug & procssing message, Define _DHCP_DEBUG_ 
N * @note    If defined, it dependens on <stdio.h>
N */
N//#define _DHCP_DEBUG_
N
N
N/* Retry to processing DHCP */
N#define	MAX_DHCP_RETRY          2        ///< Maxium retry count
N#define	DHCP_WAIT_TIME          10       ///< Wait Time 10s
N
N
N/* UDP port numbers for DHCP */
N#define DHCP_SERVER_PORT      	 547	      ///< DHCP server port number
N#define DHCP_CLIENT_PORT         546	      ///< DHCP client port number
N
N#define DCHP_HOST_NAME           "WIZnet\0"
N    
N/* 
N * @brief return value of @ref DHCP_run()
N */
Nenum
N{
N   DHCP_FAILED = 0,  ///< Procssing Fail
N   DHCP_RUNNING,     ///< Procssing DHCP proctocol
N   DHCP_IP_ASSIGN,   ///< First Occupy IP from DHPC server      (if cbfunc == null, act as default default_ip_assign)
N   DHCP_IP_CHANGED,  ///< Change IP address by new ip from DHCP (if cbfunc == null, act as default default_ip_update)
N   DHCP_IP_LEASED,   ///< Stand by 
N   DHCP_STOPPED      ///< Stop procssing DHCP protocol
N};
N
Nvoid InitDhcpOption(unsigned asize, unsigned agrowby);
Nvoid InsertDhcpOption(int idx, uint8_t value);
Nvoid DeleteDhcpOption(int idx);
Nvoid AppendDhcpOption(uint8_t value);
Nvoid UnInitDhcpOption(void);
Nvoid DumpDhcpOption(char *sMark);
Nvoid DHCP_Option_Select(uint8_t Option);
N/*
N * @brief DHCP client initialization (outside of the main loop)
N * @param s   - socket number
N * @param buf - buffer for procssing DHCP message
N */
Nvoid DHCP_init(uint8_t s, uint8_t * buf);
N
N/*
N * @brief DHCP 1s Tick Timer handler
N * @note SHOULD BE register to your system 1s Tick timer handler 
N */
Nvoid DHCP_time_handler(void);
N
N/*
N * @brief DHCP client in the main loop
N * @return    The value is as the follow \n
N *            @ref DHCP_FAILED     \n
N *            @ref DHCP_RUNNING    \n
N *            @ref DHCP_IP_ASSIGN  \n
N *            @ref DHCP_IP_CHANGED \n
N * 			  @ref DHCP_IP_LEASED  \n
N *            @ref DHCP_STOPPED    \n
N *
N * @note This function is always called by you main task.
N */ 
Nuint8_t DHCP_run(void);
Nuint8_t DHCP_run2(void);
N
N/*
N * @brief Stop DHCP procssing
N * @note If you want to restart. call DHCP_init() and DHCP_run()
N */ 
Nvoid    DHCP_stop(void);
N
N#endif	/* _DHCP_H_ */
L 9 "AddressAutoConfig.h" 2
N
N#define AutoConfig_debug debug_on
N#define debug_on 1
N#define debug_off 0
N
N#define PROTOCOL_NUM_ICMPv6 58
N
N#define ROUTER_ADVERTISEMENT 134
N
N#define SUCCESS 0
N#define ERROR_DAD_FAIL -1
N#define ERROR_SLCMD    -2
N#define ERROR_TIMEOUT  -3
N
N#define SLAAC_RDNSS  0
N#define SLAAC_DHCP6  1
N#define SFAAC_DHCP6  3
N
N#define RAO_SLLA	 1
N#define RAO_TLLA	 2
N#define RAO_PI		 3
N#define RAO_RH		 4
N#define RAO_MTU		 5
N#define RAO_RDNS	25
N
Nvoid Generate_EUI64(uint8_t *mac_addr, uint8_t *Link_Local_Addr);
Nuint8_t Duplicate_Address_Detection(uint8_t *mac_addr);
Nuint8_t Address_Auto_Config_RA(uint8_t sn, uint8_t *icmpbuf, uint16_t buf_size);
Nuint8_t Address_Auto_Config_SLDHCP(uint8_t sn, uint8_t* test_buf);
Nuint8_t Address_Auto_Config_SFDHCP(uint8_t sn, uint8_t* test_buf);
N
N#endif // _ADDRESSAUTOCONFIG_
L 2 "AddressAutoConfig.c" 2
N
N#define MY_MAX_DHCP_RETRY 3
N
Nextern uint8_t DNS6_Address[16];
N
Nuint8_t Address_Auto_Config_SLDHCP(uint8_t sn, uint8_t* test_buf)
N{
N	uint8_t result;
N	uint8_t tmp[16];
N	uint32_t toggle = 1;
N	uint32_t my_dhcp_retry = 0;
N	
N	DHCP_init(sn, test_buf);
N
N	while(1)
N	{
N        switch(DHCP_run2())
N        {
N            case DHCP_IP_ASSIGN:
N            case DHCP_IP_CHANGED:
N                /* If this block empty, act with default_ip_assign & default_ip_update  */
N                //
N                // This example calls the registered 'my_ip_assign' in the two case.
N                //
N                // Add to ...
N                //
N                //
N                toggle = 1;
N                if(toggle)
N                {
N                    getGAR(tmp);  printf("> DHCP GW : %d.%d.%d.%d\r\n", tmp[0], tmp[1], tmp[2], tmp[3]);
X                    WIZCHIP_READ_BUF((0x60000000 + (0x4130 << 8) + (0x00 <<3)),(tmp),4);  printf("> DHCP GW : %d.%d.%d.%d\r\n", tmp[0], tmp[1], tmp[2], tmp[3]);
N                    getSUBR(tmp); printf("> DHCP SN : %d.%d.%d.%d\r\n", tmp[0], tmp[1], tmp[2], tmp[3]);
X                    WIZCHIP_READ_BUF((0x60000000 + (0x4134 << 8) + (0x00 <<3)),(tmp),4); printf("> DHCP SN : %d.%d.%d.%d\r\n", tmp[0], tmp[1], tmp[2], tmp[3]);
N                    getSIPR(tmp); printf("> DHCP IP : %d.%d.%d.%d\r\n", tmp[0], tmp[1], tmp[2], tmp[3]);
X                    WIZCHIP_READ_BUF((0x60000000 + (0x4138 << 8) + (0x00 <<3)),(tmp),4); printf("> DHCP IP : %d.%d.%d.%d\r\n", tmp[0], tmp[1], tmp[2], tmp[3]);
N                    toggle = 0;
N                    close(0); /* 
N								If renewal IP address was defferent previous IP address, 
N								socket becomes to disconnect or close for new connection.
N								*/
N                }  						
N                break;
N            case DHCP_IP_LEASED:
N                //
N                if(toggle)
N                {
N                    getSHAR(tmp);
X                    WIZCHIP_READ_BUF((0x60000000 + (0x4120 << 8) + (0x00 <<3)),(tmp),6);
N					printf("Mac address : %.2x:%.2x:%.2x:%.2x:%.2x:%.2x \r\n",tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5]);
N					getLLAR(tmp);
X					WIZCHIP_READ_BUF((0x60000000 + (0x4140 << 8) + (0x00 <<3)),(tmp),16);
N					printf("your Link Local IP is %.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x \r\n", tmp[ 0], tmp[ 1], tmp[ 2], tmp[ 3], 
N																																 tmp[ 4], tmp[ 5], tmp[ 6], tmp[ 7], 
N																																 tmp[ 8], tmp[ 9], tmp[10], tmp[11], 
N																																 tmp[12], tmp[13], tmp[14], tmp[15]);
N					getGUAR(tmp);
X					WIZCHIP_READ_BUF((0x60000000 + (0x4150 << 8) + (0x00 <<3)),(tmp),16);
N					printf("your Global IP is %.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x \r\n", tmp[ 0], tmp[ 1], tmp[ 2], tmp[ 3], 
N																															 tmp[ 4], tmp[ 5], tmp[ 6], tmp[ 7], 
N																															 tmp[ 8], tmp[ 9], tmp[10], tmp[11], 
N																															 tmp[12], tmp[13], tmp[14], tmp[15]);
N					getGA6R(tmp);
X					WIZCHIP_READ_BUF((0x60000000 + (0x4170 << 8) + (0x00 <<3)),(tmp),16);
N					printf("your Gateway IP is %.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x \r\n", tmp[ 0], tmp[ 1], tmp[ 2], tmp[ 3], 
N																															  tmp[ 4], tmp[ 5], tmp[ 6], tmp[ 7], 
N																															  tmp[ 8], tmp[ 9], tmp[10], tmp[11], 
N																															  tmp[12], tmp[13], tmp[14], tmp[15]);	
N					
N					printf("your DNSv6 is %.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x \r\n", DNS6_Address[ 0], DNS6_Address[ 1], DNS6_Address[ 2], DNS6_Address[ 3], 
N																														 DNS6_Address[ 4], DNS6_Address[ 5], DNS6_Address[ 6], DNS6_Address[ 7], 
N																														 DNS6_Address[ 8], DNS6_Address[ 9], DNS6_Address[10], DNS6_Address[11], 
N																														 DNS6_Address[12], DNS6_Address[13], DNS6_Address[14], DNS6_Address[15]);
N                    toggle = 0;
N                }
N                return 1;
N
N            case DHCP_FAILED:
N                /* ===== Example pseudo code =====  */
N                // The below code can be replaced your code or omitted.
N                // if omitted, retry to process DHCP
N                my_dhcp_retry++;
N                if(my_dhcp_retry > MY_MAX_DHCP_RETRY)
X                if(my_dhcp_retry > 3)
N                {	
N#if DEBUG_MODE != DEBUG_NO
S                    printf(">> DHCP %d Failed\r\n",my_dhcp_retry);
N#endif
N                    my_dhcp_retry = 0;
N                    DHCP_stop();      // if restart, recall DHCP_init()
N                }
N                break;
N            default:
N                break;
N        }	
N
N
N    }
N	
W "AddressAutoConfig.c" 93 2 statement is unreachable
N	return result;
N}
N
Nuint8_t Address_Auto_Config_SFDHCP(uint8_t sn, uint8_t* test_buf)
N{
N	uint8_t result;
N	uint8_t tmp[16];
N	uint32_t toggle = 1;
N	uint32_t my_dhcp_retry = 0;
N	
N	DHCP_init(sn, test_buf);
N
N	while(1)
N	{
N        switch(DHCP_run())
N        {
N            case DHCP_IP_ASSIGN:
N            case DHCP_IP_CHANGED:
N                /* If this block empty, act with default_ip_assign & default_ip_update  */
N                //
N                // This example calls the registered 'my_ip_assign' in the two case.
N                //
N                // Add to ...
N                //
N                //
N                toggle = 1;
N                if(toggle)
N                {
N//                    getGAR(tmp);  printf("> DHCP GW : %d.%d.%d.%d\r\n", tmp[0], tmp[1], tmp[2], tmp[3]);
N//                    getSUBR(tmp); printf("> DHCP SN : %d.%d.%d.%d\r\n", tmp[0], tmp[1], tmp[2], tmp[3]);
N//                    getSIPR(tmp); printf("> DHCP IP : %d.%d.%d.%d\r\n", tmp[0], tmp[1], tmp[2], tmp[3]);
N                    toggle = 0;
N                    close(0); /* 
N								If renewal IP address was defferent previous IP address, 
N								socket becomes to disconnect or close for new connection.
N								*/
N                }  						
N                break;
N            case DHCP_IP_LEASED:
N                //
N                if(toggle)
N                {
N                    getSHAR(tmp);
X                    WIZCHIP_READ_BUF((0x60000000 + (0x4120 << 8) + (0x00 <<3)),(tmp),6);
N					printf("Mac address : %.2x:%.2x:%.2x:%.2x:%.2x:%.2x \r\n",tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5]);
N					getLLAR(tmp);
X					WIZCHIP_READ_BUF((0x60000000 + (0x4140 << 8) + (0x00 <<3)),(tmp),16);
N					printf("your Link Local IP is %.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x \r\n", tmp[ 0], tmp[ 1], tmp[ 2], tmp[ 3], 
N																																 tmp[ 4], tmp[ 5], tmp[ 6], tmp[ 7], 
N																																 tmp[ 8], tmp[ 9], tmp[10], tmp[11], 
N																																 tmp[12], tmp[13], tmp[14], tmp[15]);
N					getGUAR(tmp);
X					WIZCHIP_READ_BUF((0x60000000 + (0x4150 << 8) + (0x00 <<3)),(tmp),16);
N					printf("your Global IP is %.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x \r\n", tmp[ 0], tmp[ 1], tmp[ 2], tmp[ 3], 
N																															 tmp[ 4], tmp[ 5], tmp[ 6], tmp[ 7], 
N																															 tmp[ 8], tmp[ 9], tmp[10], tmp[11], 
N																															 tmp[12], tmp[13], tmp[14], tmp[15]);
N					getGA6R(tmp);
X					WIZCHIP_READ_BUF((0x60000000 + (0x4170 << 8) + (0x00 <<3)),(tmp),16);
N					printf("your Gateway IP is %.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x \r\n", tmp[ 0], tmp[ 1], tmp[ 2], tmp[ 3], 
N																															  tmp[ 4], tmp[ 5], tmp[ 6], tmp[ 7], 
N																															  tmp[ 8], tmp[ 9], tmp[10], tmp[11], 
N																															  tmp[12], tmp[13], tmp[14], tmp[15]);	
N					
N					printf("your DNSv6 is %.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x:%.2x%.2x \r\n", DNS6_Address[ 0], DNS6_Address[ 1], DNS6_Address[ 2], DNS6_Address[ 3], 
N																														 DNS6_Address[ 4], DNS6_Address[ 5], DNS6_Address[ 6], DNS6_Address[ 7], 
N																														 DNS6_Address[ 8], DNS6_Address[ 9], DNS6_Address[10], DNS6_Address[11], 
N																														 DNS6_Address[12], DNS6_Address[13], DNS6_Address[14], DNS6_Address[15]);
N                    toggle = 0;
N                }
N                return 1;
N
N            case DHCP_FAILED:
N                /* ===== Example pseudo code =====  */
N                // The below code can be replaced your code or omitted.
N                // if omitted, retry to process DHCP
N                my_dhcp_retry++;
N                if(my_dhcp_retry > MY_MAX_DHCP_RETRY)
X                if(my_dhcp_retry > 3)
N                {	
N#if DEBUG_MODE != DEBUG_NO
S                    printf(">> DHCP %d Failed\r\n",my_dhcp_retry);
N#endif
N                    my_dhcp_retry = 0;
N                    DHCP_stop();      // if restart, recall DHCP_init()
N                    return 0;
N                }
N                break;
N            default:
N                break;
N        }	
N
N
N    }
N	
W "AddressAutoConfig.c" 183 2 statement is unreachable
N	return result;
N}
N
Nuint8_t Address_Auto_Config_RA(uint8_t sn, uint8_t *icmpbuf, uint16_t buf_size)
N{
N	uint8_t result;
N	
N	uint16_t size;
N	uint8_t  destip[16];
N    uint16_t destport;
N	uint8_t addr_len, o_len;
N	uint8_t flags;
N	
N	uint8_t * p;
N	uint8_t * e;
N	int i;
N	uint8_t o_type, type, code, RA_flag, MO_flag;//, O_flag;
N	uint16_t Router_lifetime;
N	uint32_t Reachable_time, Retrans_time;
N	uint32_t end_point;
N	uint8_t prefix_len, pi_flag;
N	uint32_t validtime, prefertime, dnstime;
N	uint8_t prefix[16];
N	uint8_t subnet[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
N
N	#if (AutoConfig_debug == debug_on)
X	#if (1 == 1)
N	printf("\n\n\n================================================================\r\n");
N    printf("==================== RQ_AUTO_RS_Send TEST_START ================\r\n");
N    printf("================================================================\r\n");
N	#endif
N
N	if(getSLCR() != 0x00) //check clear CMD
X	if(WIZCHIP_READ((0x60000000 + (0x2130 << 8) + (0x00 <<3))) != 0x00) 
N    {
N		#if (AutoConfig_debug == debug_on)
X		#if (1 == 1)
N        printf("ERROR : RQCMD is not clear\r\n");
N		#endif
W "AddressAutoConfig.c" 219 18 integer conversion resulted in a change of sign
N        result = ERROR_SLCMD;
N		return result;
N    }
N    
N	setICMP6BLKR(ICMP6BLKR_RA);
X	WIZCHIP_WRITE((0x60000000 + (0x41F0 << 8) + (0x00 <<3)),((1<<2)));
N	setSn_PNR(sn, PROTOCOL_NUM_ICMPv6); //ICMPv6 : 58
X	WIZCHIP_WRITE((0x60000000 + (0x0100 << 8) + ((1+4*sn)<<3)),(58)); 
N	socket(sn, Sn_MR_IPRAW6, 0, 0);
X	socket(sn, (0x0B), 0, 0);
N	
N	#if (AutoConfig_debug == debug_on)
X	#if (1 == 1)
N	printf("Sn_SR : %x \r\n",getSn_SR(sn));
X	printf("Sn_SR : %x \r\n",WIZCHIP_READ((0x60000000 + (0x0030 << 8) + ((1+4*sn)<<3))));
N	#endif
N	
N	setSLRTR(4000);
X	do{ WIZCHIP_WRITE((0x60000000 + (0x4208 << 8) + (0x00 <<3)),(uint8_t)((4000)>>8)); WIZCHIP_WRITE(((0x60000000 + (0x4208 << 8) + (0x00 <<3)) + (1<<8)),(uint8_t)(4000)); }while(0);;
N	setSLRCR(0);
X	WIZCHIP_WRITE((0x60000000 + (0x420C << 8) + (0x00 <<3)),(0));
N	
N	setSLCR(SLCR_RS);
X	WIZCHIP_WRITE((0x60000000 + (0x2130 << 8) + (0x00 <<3)),((1<<1)));
N	#if (AutoConfig_debug == debug_on)
X	#if (1 == 1)
N    printf("Wait SLIR.....\r\n");
N	#endif
N	//printf("p : %x , *p : %x , RX_RSR : %x \r\n", p, *p , getSn_RX_RSR(sn));
N	//delay_ms(1000);
N	do
N	{
N		if(getSn_RX_RSR(sn) > 0)
N		{
N			//size = recvfrom(sn, icmpbuf, size, destip, &destport, &addr_len);
N			size = recvfrom(sn, icmpbuf, buf_size, destip, &destport, &addr_len);
N			printf("after addr_len : %x, size : %x \r\n",addr_len,size);
N			for(i=0; i<size; i++){
N				printf("%.2x",icmpbuf[i]);
N				printf(" ");
N				if((i+1)%8==0)
N					printf("\r\n");
N			}
N			printf("\r\n");
N			printf("recvfrom IP : %x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x \r\n"
N			             ,destip[ 0],destip[ 1],destip[ 2],destip[ 3],destip[ 4],destip[ 5],destip[ 6],destip[ 7]
N			             ,destip[ 8],destip[ 9],destip[10],destip[11],destip[12],destip[13],destip[14],destip[15]);
N			NETUNLOCK();
X			WIZCHIP_WRITE((0x60000000 + (0x41F5 << 8) + (0x00 <<3)), (0x3A));
N			setGA6R(destip);
X			WIZCHIP_WRITE_BUF((0x60000000 + (0x4170 << 8) + (0x00 <<3)),(destip),16);
N			NETLOCK();
X			WIZCHIP_WRITE((0x60000000 + (0x41F5 << 8) + (0x00 <<3)), (0xC5));
N		}
N		
N		p = icmpbuf;		
N	}while(*p != ROUTER_ADVERTISEMENT);
X	}while(*p != 134);
N	e = p + size;
N	switch ( *p ) {
N		case ROUTER_ADVERTISEMENT : {
X		case 134 : {
N			printf("RA\r\n");
N			type = *p++;
N			printf("type : %x \r\n",type);
N			code = *p++;
N			printf("code : %x \r\n",code);
N			p++;p++;//checksum
N			p++;//Cur hop limit
N			RA_flag = *p++;
N			printf("RA_flag : %x \r\n",RA_flag);
N			Router_lifetime = *p++<<8;
N			Router_lifetime = Router_lifetime + (*p++);
N			printf("Router_lifetime : %d s \r\n",Router_lifetime);
N			Reachable_time = *p++<<24;
N			Reachable_time = Reachable_time + (*p++<<16);
N			Reachable_time = Reachable_time + (*p++<<8);
N			Reachable_time = Reachable_time + (*p++);
N			printf("Reachable_time : %d ms \r\n",Reachable_time);
N			Retrans_time = *p++<<24;
N			Retrans_time = Retrans_time + (*p++<<16);
N			Retrans_time = Retrans_time + (*p++<<8);
N			Retrans_time = Retrans_time + (*p++);
N			printf("Retrans_time : %d ms \r\n",Retrans_time);
N			
N			while( p < e ) {
N				switch ( *p ) {
N					case RAO_SLLA : {
X					case 1 : {
N						o_type = *p++;
N						printf("Option Type : %d (Source LLA) \r\n",o_type);
N						o_len = (*p++)*8;
N						printf("Option length : %d \r\n",o_len);
N						p += (o_len-2);
N						break;
N					}
N					case RAO_TLLA : {
X					case 2 : {
N						o_type = *p++;
N						printf("Option Type : %d (Target LLA) \r\n",o_type);
N						o_len = (*p++)*8;
N						printf("Option length : %d \r\n",o_len);
N						p += (o_len-2);
N						break;
N					}
N					case RAO_PI : {
X					case 3 : {
N						o_type = *p++;
N						printf("Option Type : %d (Prefix information) \r\n",o_type);
N						o_len = (*p++)*8;
N						printf("Option length : %d \r\n",o_len);
N						end_point = (uint32_t)p - 2 + o_len;
N						prefix_len = *p++;
N						printf("Prefix Length : %d \r\n", prefix_len);
N						pi_flag = *p++;
N						printf("Prefix Information Flag : %.2x \r\n", pi_flag);
N						validtime = (*p++<<24);
N						validtime += (*p++<<16);
N						validtime += (*p++<<8);
N						validtime += (*p++);
N						printf("valid lifetime : %d \r\n", validtime);
N						prefertime = (*p++<<24);
N						prefertime += (*p++<<16);
N						prefertime += (*p++<<8);
N						prefertime += (*p++);
N						printf("preferred lifetime : %d \r\n", prefertime);
N						p++;p++;p++;p++;//reserved
N						getLLAR(prefix);
X						WIZCHIP_READ_BUF((0x60000000 + (0x4140 << 8) + (0x00 <<3)),(prefix),16);
N						
N						for(i=0; i<prefix_len/8; i++)
N						{
N							prefix[i] = *p++;
N							if((prefix_len % 8)==0)
N							{
N								subnet[i] = 0xFF;
N							}
N						}
N						NETUNLOCK();
X						WIZCHIP_WRITE((0x60000000 + (0x41F5 << 8) + (0x00 <<3)), (0x3A));
N						setGUAR(prefix);
X						WIZCHIP_WRITE_BUF((0x60000000 + (0x4150 << 8) + (0x00 <<3)),(prefix),16);
N						setSUB6R(subnet);
X						WIZCHIP_WRITE_BUF((0x60000000 + (0x4160 << 8) + (0x00 <<3)),(subnet),16);
N						NETLOCK();
X						WIZCHIP_WRITE((0x60000000 + (0x41F5 << 8) + (0x00 <<3)), (0xC5));
N						while((uint32_t)p != end_point)
N						{
N							p++;
N						}
N						printf("prefix : ");
N						for(i=0; i<prefix_len/8; i++){
N							printf("%.2x",prefix[i]);
N							if(1==(i%2))
N								printf(":");
N						}
N						printf(":\r\n");
N						break;
N					}
N					case RAO_RH : {
X					case 4 : {
N						o_type = *p++;
N						printf("Option Type : %d (Redirected Header) \r\n",o_type);
N						o_len = (*p++)*8;
N						printf("Option length : %d \r\n",o_len);
N						p += (o_len-2);
N						break;
N					}
N					case RAO_MTU : {
X					case 5 : {
N						o_type = *p++;
N						printf("Option Type : %d (MTU) \r\n",o_type);
N						o_len = (*p++)*8;
N						printf("Option length : %d \r\n",o_len);
N						p += (o_len-2);
N						break;
N					}
N					case RAO_RDNS : {
X					case 25 : {
N						o_type = *p++;
N						printf("Option Type : %d (Recursive DNS Server) \r\n",o_type);
N						o_len = (*p++)*8;
N						printf("Option length : %d \r\n",o_len);
N						end_point = (uint32_t)p - 2 + o_len;
N						p++;p++;//reserved
N						dnstime = (*p++<<24);
N						dnstime += (*p++<<16);
N						dnstime += (*p++<<8);
N						dnstime += (*p++);
N						printf("DNS lifetime : %d \r\n", dnstime);
N						DNS6_Address[ 0] = *p++; DNS6_Address[ 1] = *p++; DNS6_Address[ 2] = *p++; DNS6_Address[ 3] = *p++;
N						DNS6_Address[ 4] = *p++; DNS6_Address[ 5] = *p++; DNS6_Address[ 6] = *p++; DNS6_Address[ 7] = *p++;
N						DNS6_Address[ 8] = *p++; DNS6_Address[ 9] = *p++; DNS6_Address[10] = *p++; DNS6_Address[11] = *p++;
N						DNS6_Address[12] = *p++; DNS6_Address[13] = *p++; DNS6_Address[14] = *p++; DNS6_Address[15] = *p++;
N						while((uint32_t)p != end_point)
N						{
N							p++;
N						}
N						printf("DNS IP : ");
N						for(i=0; i<15; i++){
N							printf("%.2x",DNS6_Address[i]);
N							if(1==(i%2))
N								printf(":");
N						}
N						printf("%.2x\r\n",DNS6_Address[15]);
N						break;
N					}
N					default : {
N						printf("default\r\n");
N						o_type = *p++;
N						printf("o_type : %d \r\n",o_type);
N						o_len = (*p++)*8;
N						printf("o_len : %d \r\n",o_len);
N						p += (o_len-2);
N						break;
N					}
N				}// ICMP option
N			}//while
N		}// ICMP RA message
N	}
N	
N	close(sn);
N	
N	//M_flag = RA_flag >> 7;
N	MO_flag = RA_flag >> 6;
N	
N	printf("MO : %x \r\n",MO_flag);
N		
N	result = MO_flag;
N	
N	for(i=0; i<buf_size; i++){ // buf initialize
N	
N		icmpbuf[i] = 0;
N	}
N	
N	return result;
W "AddressAutoConfig.c" 194 10 variable "flags"  was declared but never referenced
N}
N
Nuint8_t Duplicate_Address_Detection(uint8_t *mac_addr)
N{
N	uint8_t result;
N	
N	uint8_t WIZ_LLA[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
N	
N    uint8_t flags;
N	uint8_t tmp_array[16];
N
N	#if (AutoConfig_debug == debug_on)
X	#if (1 == 1)
N	printf("\n\n\n=================================================\r\n");
N    printf("==================== DAD_NS_Send ================\r\n");
N    printf("=================================================\r\n");
N	#endif
N	
N    setSLRTR(2000);
X    do{ WIZCHIP_WRITE((0x60000000 + (0x4208 << 8) + (0x00 <<3)),(uint8_t)((2000)>>8)); WIZCHIP_WRITE(((0x60000000 + (0x4208 << 8) + (0x00 <<3)) + (1<<8)),(uint8_t)(2000)); }while(0);;
N    setSLRCR(5);
X    WIZCHIP_WRITE((0x60000000 + (0x420C << 8) + (0x00 <<3)),(5));
N	
N	Generate_EUI64(mac_addr, WIZ_LLA);
N	
N	setSLDIP6R(WIZ_LLA);//target address setting
X	WIZCHIP_WRITE_BUF((0x60000000 + (0x4180 << 8) + (0x00 <<3)), (WIZ_LLA),16);
N	
N	//setSLIMR(SLIR_TIOUT|SLIR_NS); //only external interrupt???
N	
N	if(getSLCR() != 0x00) //check clear CMD
X	if(WIZCHIP_READ((0x60000000 + (0x2130 << 8) + (0x00 <<3))) != 0x00) 
N    {
N		#if (AutoConfig_debug == debug_on)
X		#if (1 == 1)
N        printf("ERROR : RQCMD is not clear %x \r\n",getSLCR());
X        printf("ERROR : RQCMD is not clear %x \r\n",WIZCHIP_READ((0x60000000 + (0x2130 << 8) + (0x00 <<3))));
N		#endif
N        while(1);
N    }
N	
N	setSLCR(SLCR_NS);	
X	WIZCHIP_WRITE((0x60000000 + (0x2130 << 8) + (0x00 <<3)),((1<<2)));	
N
N	#if (AutoConfig_debug == debug_on)
X	#if (1 == 1)
N    printf("Wait RQIR.....\r\n");
N	#endif
N
N    do
N	{
N		flags = getSLIR();
X		flags = WIZCHIP_READ((0x60000000 + (0x2102 << 8) + (0x00 <<3)));
N				
N		if(flags&SLIR_TOUT)
X		if(flags&(1<<7))
N		{
N			#if (AutoConfig_debug == debug_on)
X			#if (1 == 1)
N			printf("\nTimeout !!! DAD SUCCESSED\r\n");
N			#endif
N			NETUNLOCK();
X			WIZCHIP_WRITE((0x60000000 + (0x41F5 << 8) + (0x00 <<3)), (0x3A));
N			//-- Set MAC Address
N			setLLAR(WIZ_LLA);
X			WIZCHIP_WRITE_BUF((0x60000000 + (0x4140 << 8) + (0x00 <<3)),(WIZ_LLA),16);
N			NETLOCK();
X			WIZCHIP_WRITE((0x60000000 + (0x41F5 << 8) + (0x00 <<3)), (0xC5));
N			getLLAR(tmp_array);
X			WIZCHIP_READ_BUF((0x60000000 + (0x4140 << 8) + (0x00 <<3)),(tmp_array),16);
N			#if (AutoConfig_debug == debug_on)
X			#if (1 == 1)
N			printf("\r\nLLA : %.2X%.2X:%.2X%.2X:%.2X%.2X:%.2X%.2X:%.2X%.2X:%.2X%.2X:%.2X%.2X:%.2X%.2X",
N                    tmp_array[0], tmp_array[1], tmp_array[2], tmp_array[3],
N                    tmp_array[4], tmp_array[5], tmp_array[6], tmp_array[7],
N                    tmp_array[8], tmp_array[9], tmp_array[10],tmp_array[11],
N                    tmp_array[12],tmp_array[13],tmp_array[14],tmp_array[15]);
N			#endif
N			result = SUCCESS;
X			result = 0;
N		}
N		else if(flags&SLIR_NS)
X		else if(flags&(1<<2))
N		{
N			#if (AutoConfig_debug == debug_on)
X			#if (1 == 1)
N			printf("\nReceived NA !!! DAD FAILED\r\n");
N			#endif
W "AddressAutoConfig.c" 498 13 integer conversion resulted in a change of sign
N			result = ERROR_DAD_FAIL;
N		}
N	}
N	while(!((flags&SLIR_TOUT)||(flags&SLIR_NS)));
X	while(!((flags&(1<<7))||(flags&(1<<2))));
N        
N    setSLIRCLR(flags);
X    WIZCHIP_WRITE((0x60000000 + (0x2128 << 8) + (0x00 <<3)),(flags));
N	
N	return result;
N}
N
Nvoid Generate_EUI64(uint8_t *mac_addr, uint8_t *Link_Local_Addr)
N{
N	*Link_Local_Addr = 0xfe;
N	*(Link_Local_Addr+ 1) = 0x80;
N	//00:00:00:00:00:00
N	*(Link_Local_Addr+ 8) = *(mac_addr); //flip the 7th bit of 1st byte
N	*(Link_Local_Addr+ 8) ^= 1 << 1;
N	*(Link_Local_Addr+ 9) = *(mac_addr+1);
N	*(Link_Local_Addr+10) = *(mac_addr+2);
N	*(Link_Local_Addr+11) = 0xFF;
N	*(Link_Local_Addr+12) = 0xFE;
N	*(Link_Local_Addr+13) = *(mac_addr+3);
N	*(Link_Local_Addr+14) = *(mac_addr+4);
N	*(Link_Local_Addr+15) = *(mac_addr+5);
W "AddressAutoConfig.c" 522 2 last line of file ends without a newline
N}
