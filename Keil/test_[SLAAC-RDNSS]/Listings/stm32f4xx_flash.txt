; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\objects\stm32f4xx_flash.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_flash.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\test_[SLAAC-RDNSS] -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\io6Library\Application\loopback -I..\..\Libraries\io6Library\Ethernet -I..\..\Libraries\io6Library\Ethernet\W6100 -I..\..\Libraries\io6Library\Internet\DHCP -I..\..\Libraries\io6Library\Internet\DNS -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\io6Library\Internet\DHCP6 -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Ic:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F4XX -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f4xx_flash.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;165      */
;;;166    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  49de              LDR      r1,|L1.892|
;;;167    {
;;;168      /* Check the parameters */
;;;169      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;170      
;;;171      /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
;;;172      *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
000002  7008              STRB     r0,[r1,#0]
;;;173    }
000004  4770              BX       lr
;;;174    
                          ENDP

                  FLASH_PrefetchBufferCmd PROC
;;;180      */
;;;181    void FLASH_PrefetchBufferCmd(FunctionalState NewState)
000006  49dd              LDR      r1,|L1.892|
;;;182    {
;;;183      /* Check the parameters */
;;;184      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;185      
;;;186      /* Enable or disable the Prefetch Buffer */
;;;187      if(NewState != DISABLE)
000008  2800              CMP      r0,#0
;;;188      {
;;;189        FLASH->ACR |= FLASH_ACR_PRFTEN;
;;;190      }
;;;191      else
;;;192      {
;;;193        FLASH->ACR &= (~FLASH_ACR_PRFTEN);
00000a  6808              LDR      r0,[r1,#0]
00000c  d002              BEQ      |L1.20|
00000e  f4407080          ORR      r0,r0,#0x100          ;189
000012  e001              B        |L1.24|
                  |L1.20|
000014  f4207080          BIC      r0,r0,#0x100
                  |L1.24|
000018  6008              STR      r0,[r1,#0]            ;189
;;;194      }
;;;195    }
00001a  4770              BX       lr
;;;196    
                          ENDP

                  FLASH_InstructionCacheCmd PROC
;;;202      */
;;;203    void FLASH_InstructionCacheCmd(FunctionalState NewState)
00001c  49d7              LDR      r1,|L1.892|
;;;204    {
;;;205      /* Check the parameters */
;;;206      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;207      
;;;208      if(NewState != DISABLE)
00001e  2800              CMP      r0,#0
;;;209      {
;;;210        FLASH->ACR |= FLASH_ACR_ICEN;
;;;211      }
;;;212      else
;;;213      {
;;;214        FLASH->ACR &= (~FLASH_ACR_ICEN);
000020  6808              LDR      r0,[r1,#0]
000022  d002              BEQ      |L1.42|
000024  f4407000          ORR      r0,r0,#0x200          ;210
000028  e001              B        |L1.46|
                  |L1.42|
00002a  f4207000          BIC      r0,r0,#0x200
                  |L1.46|
00002e  6008              STR      r0,[r1,#0]            ;210
;;;215      }
;;;216    }
000030  4770              BX       lr
;;;217    
                          ENDP

                  FLASH_DataCacheCmd PROC
;;;223      */
;;;224    void FLASH_DataCacheCmd(FunctionalState NewState)
000032  49d2              LDR      r1,|L1.892|
;;;225    {
;;;226      /* Check the parameters */
;;;227      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;228      
;;;229      if(NewState != DISABLE)
000034  2800              CMP      r0,#0
;;;230      {
;;;231        FLASH->ACR |= FLASH_ACR_DCEN;
;;;232      }
;;;233      else
;;;234      {
;;;235        FLASH->ACR &= (~FLASH_ACR_DCEN);
000036  6808              LDR      r0,[r1,#0]
000038  d002              BEQ      |L1.64|
00003a  f4406080          ORR      r0,r0,#0x400          ;231
00003e  e001              B        |L1.68|
                  |L1.64|
000040  f4206080          BIC      r0,r0,#0x400
                  |L1.68|
000044  6008              STR      r0,[r1,#0]            ;231
;;;236      }
;;;237    }
000046  4770              BX       lr
;;;238    
                          ENDP

                  FLASH_InstructionCacheReset PROC
;;;244      */
;;;245    void FLASH_InstructionCacheReset(void)
000048  48cc              LDR      r0,|L1.892|
;;;246    {
;;;247      FLASH->ACR |= FLASH_ACR_ICRST;
00004a  6801              LDR      r1,[r0,#0]
00004c  f4416100          ORR      r1,r1,#0x800
000050  6001              STR      r1,[r0,#0]
;;;248    }
000052  4770              BX       lr
;;;249    
                          ENDP

                  FLASH_DataCacheReset PROC
;;;255      */
;;;256    void FLASH_DataCacheReset(void)
000054  48c9              LDR      r0,|L1.892|
;;;257    {
;;;258      FLASH->ACR |= FLASH_ACR_DCRST;
000056  6801              LDR      r1,[r0,#0]
000058  f4415180          ORR      r1,r1,#0x1000
00005c  6001              STR      r1,[r0,#0]
;;;259    }
00005e  4770              BX       lr
;;;260    
                          ENDP

                  FLASH_Unlock PROC
;;;299      */
;;;300    void FLASH_Unlock(void)
000060  48c6              LDR      r0,|L1.892|
;;;301    {
;;;302      if((FLASH->CR & FLASH_CR_LOCK) != RESET)
000062  3010              ADDS     r0,r0,#0x10
000064  6800              LDR      r0,[r0,#0]
000066  2800              CMP      r0,#0
000068  da05              BGE      |L1.118|
;;;303      {
;;;304        /* Authorize the FLASH Registers access */
;;;305        FLASH->KEYR = FLASH_KEY1;
00006a  48c4              LDR      r0,|L1.892|
00006c  49c4              LDR      r1,|L1.896|
00006e  1d00              ADDS     r0,r0,#4
000070  6001              STR      r1,[r0,#0]
;;;306        FLASH->KEYR = FLASH_KEY2;
000072  49c4              LDR      r1,|L1.900|
000074  6001              STR      r1,[r0,#0]
                  |L1.118|
;;;307      }  
;;;308    }
000076  4770              BX       lr
;;;309    
                          ENDP

                  FLASH_Lock PROC
;;;314      */
;;;315    void FLASH_Lock(void)
000078  48c0              LDR      r0,|L1.892|
;;;316    {
;;;317      /* Set the LOCK Bit to lock the FLASH Registers access */
;;;318      FLASH->CR |= FLASH_CR_LOCK;
00007a  3010              ADDS     r0,r0,#0x10
00007c  6801              LDR      r1,[r0,#0]
00007e  f0414100          ORR      r1,r1,#0x80000000
000082  6001              STR      r1,[r0,#0]
;;;319    }
000084  4770              BX       lr
;;;320    
                          ENDP

                  FLASH_GetStatus PROC
;;;978      */
;;;979    FLASH_Status FLASH_GetStatus(void)
000086  49bd              LDR      r1,|L1.892|
;;;980    {
;;;981      FLASH_Status flashstatus = FLASH_COMPLETE;
000088  2008              MOVS     r0,#8
;;;982      
;;;983      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
00008a  310c              ADDS     r1,r1,#0xc
00008c  680a              LDR      r2,[r1,#0]
00008e  03d2              LSLS     r2,r2,#15
000090  d501              BPL      |L1.150|
;;;984      {
;;;985        flashstatus = FLASH_BUSY;
000092  2001              MOVS     r0,#1
;;;986      }
;;;987      else 
;;;988      {  
;;;989        if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
;;;990        { 
;;;991          flashstatus = FLASH_ERROR_WRP;
;;;992        }
;;;993        else 
;;;994        {
;;;995          if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
;;;996          {
;;;997            flashstatus = FLASH_ERROR_PROGRAM; 
;;;998          }
;;;999          else
;;;1000         {
;;;1001           if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
;;;1002           {
;;;1003             flashstatus = FLASH_ERROR_OPERATION;
;;;1004           }
;;;1005           else
;;;1006           {
;;;1007             flashstatus = FLASH_COMPLETE;
;;;1008           }
;;;1009         }
;;;1010       }
;;;1011     }
;;;1012     /* Return the FLASH Status */
;;;1013     return flashstatus;
;;;1014   }
000094  4770              BX       lr
                  |L1.150|
000096  680a              LDR      r2,[r1,#0]            ;989
000098  06d2              LSLS     r2,r2,#27             ;989
00009a  d501              BPL      |L1.160|
00009c  2005              MOVS     r0,#5                 ;991
00009e  4770              BX       lr
                  |L1.160|
0000a0  680a              LDR      r2,[r1,#0]            ;995
0000a2  f0120fef          TST      r2,#0xef              ;995
0000a6  d001              BEQ      |L1.172|
0000a8  2006              MOVS     r0,#6                 ;997
                  |L1.170|
0000aa  4770              BX       lr
                  |L1.172|
0000ac  6809              LDR      r1,[r1,#0]            ;1001
0000ae  0789              LSLS     r1,r1,#30             ;1001
0000b0  d5fb              BPL      |L1.170|
0000b2  2007              MOVS     r0,#7                 ;1003
0000b4  4770              BX       lr
;;;1015   
                          ENDP

                  FLASH_WaitForLastOperation PROC
;;;1021     */
;;;1022   FLASH_Status FLASH_WaitForLastOperation(void)
0000b6  b508              PUSH     {r3,lr}
;;;1023   { 
;;;1024     __IO FLASH_Status status = FLASH_COMPLETE;
0000b8  2008              MOVS     r0,#8
0000ba  f88d0000          STRB     r0,[sp,#0]
                  |L1.190|
;;;1025      
;;;1026     /* Check for the FLASH Status */
;;;1027     status = FLASH_GetStatus();
;;;1028   
;;;1029     /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
;;;1030        Even if the FLASH operation fails, the BUSY flag will be reset and an error
;;;1031        flag will be set */
;;;1032     while(status == FLASH_BUSY)
;;;1033     {
;;;1034       status = FLASH_GetStatus();
0000be  f7fffffe          BL       FLASH_GetStatus
0000c2  f88d0000          STRB     r0,[sp,#0]
0000c6  f89d0000          LDRB     r0,[sp,#0]            ;1032
0000ca  2801              CMP      r0,#1                 ;1032
0000cc  d0f7              BEQ      |L1.190|
;;;1035     }
;;;1036     /* Return the operation status */
;;;1037     return status;
0000ce  f89d0000          LDRB     r0,[sp,#0]
;;;1038   }
0000d2  bd08              POP      {r3,pc}
;;;1039   
                          ENDP

                  FLASH_EraseSector PROC
;;;340      */
;;;341    FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
0000d4  b570              PUSH     {r4-r6,lr}
;;;342    {
0000d6  4606              MOV      r6,r0
;;;343      uint32_t tmp_psize = 0x0;
0000d8  2500              MOVS     r5,#0
0000da  b129              CBZ      r1,|L1.232|
;;;344      FLASH_Status status = FLASH_COMPLETE;
;;;345    
;;;346      /* Check the parameters */
;;;347      assert_param(IS_FLASH_SECTOR(FLASH_Sector));
;;;348      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;349      
;;;350      if(VoltageRange == VoltageRange_1)
;;;351      {
;;;352         tmp_psize = FLASH_PSIZE_BYTE;
;;;353      }
;;;354      else if(VoltageRange == VoltageRange_2)
0000dc  2901              CMP      r1,#1
0000de  d028              BEQ      |L1.306|
;;;355      {
;;;356        tmp_psize = FLASH_PSIZE_HALF_WORD;
;;;357      }
;;;358      else if(VoltageRange == VoltageRange_3)
0000e0  2902              CMP      r1,#2
0000e2  d029              BEQ      |L1.312|
;;;359      {
;;;360        tmp_psize = FLASH_PSIZE_WORD;
;;;361      }
;;;362      else
;;;363      {
;;;364        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
0000e4  f44f7540          MOV      r5,#0x300
                  |L1.232|
;;;365      }
;;;366      /* Wait for last operation to be completed */
;;;367      status = FLASH_WaitForLastOperation();
0000e8  f7fffffe          BL       FLASH_WaitForLastOperation
;;;368      
;;;369      if(status == FLASH_COMPLETE)
0000ec  2808              CMP      r0,#8
0000ee  d11f              BNE      |L1.304|
;;;370      { 
;;;371        /* if the previous operation is completed, proceed to erase the sector */
;;;372        FLASH->CR &= CR_PSIZE_MASK;
0000f0  4ca2              LDR      r4,|L1.892|
0000f2  3410              ADDS     r4,r4,#0x10
0000f4  6820              LDR      r0,[r4,#0]
0000f6  f4207040          BIC      r0,r0,#0x300
0000fa  6020              STR      r0,[r4,#0]
;;;373        FLASH->CR |= tmp_psize;
0000fc  6820              LDR      r0,[r4,#0]
0000fe  4328              ORRS     r0,r0,r5
000100  6020              STR      r0,[r4,#0]
;;;374        FLASH->CR &= SECTOR_MASK;
000102  6820              LDR      r0,[r4,#0]
000104  f02000f8          BIC      r0,r0,#0xf8
000108  6020              STR      r0,[r4,#0]
;;;375        FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
00010a  6820              LDR      r0,[r4,#0]
00010c  f0460102          ORR      r1,r6,#2
000110  4308              ORRS     r0,r0,r1
000112  6020              STR      r0,[r4,#0]
;;;376        FLASH->CR |= FLASH_CR_STRT;
000114  6820              LDR      r0,[r4,#0]
000116  f4403080          ORR      r0,r0,#0x10000
00011a  6020              STR      r0,[r4,#0]
;;;377        
;;;378        /* Wait for last operation to be completed */
;;;379        status = FLASH_WaitForLastOperation();
00011c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;380        
;;;381        /* if the erase operation is completed, disable the SER Bit */
;;;382        FLASH->CR &= (~FLASH_CR_SER);
000120  6821              LDR      r1,[r4,#0]
000122  f0210102          BIC      r1,r1,#2
000126  6021              STR      r1,[r4,#0]
;;;383        FLASH->CR &= SECTOR_MASK; 
000128  6821              LDR      r1,[r4,#0]
00012a  f02101f8          BIC      r1,r1,#0xf8
00012e  6021              STR      r1,[r4,#0]
                  |L1.304|
;;;384      }
;;;385      /* Return the Erase Status */
;;;386      return status;
;;;387    }
000130  bd70              POP      {r4-r6,pc}
                  |L1.306|
000132  f44f7580          MOV      r5,#0x100             ;356
000136  e7d7              B        |L1.232|
                  |L1.312|
000138  f44f7500          MOV      r5,#0x200             ;360
00013c  e7d4              B        |L1.232|
;;;388    
                          ENDP

                  FLASH_EraseAllSectors PROC
;;;405      */
;;;406    FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
00013e  b530              PUSH     {r4,r5,lr}
;;;407    {
000140  4604              MOV      r4,r0
;;;408      uint32_t tmp_psize = 0x0;
000142  2500              MOVS     r5,#0
;;;409      FLASH_Status status = FLASH_COMPLETE;
;;;410      
;;;411      /* Wait for last operation to be completed */
;;;412      status = FLASH_WaitForLastOperation();
000144  f7fffffe          BL       FLASH_WaitForLastOperation
;;;413      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;414      
;;;415      if(VoltageRange == VoltageRange_1)
000148  b12c              CBZ      r4,|L1.342|
;;;416      {
;;;417         tmp_psize = FLASH_PSIZE_BYTE;
;;;418      }
;;;419      else if(VoltageRange == VoltageRange_2)
00014a  2c01              CMP      r4,#1
00014c  d01d              BEQ      |L1.394|
;;;420      {
;;;421        tmp_psize = FLASH_PSIZE_HALF_WORD;
;;;422      }
;;;423      else if(VoltageRange == VoltageRange_3)
00014e  2c02              CMP      r4,#2
000150  d01e              BEQ      |L1.400|
;;;424      {
;;;425        tmp_psize = FLASH_PSIZE_WORD;
;;;426      }
;;;427      else
;;;428      {
;;;429        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000152  f44f7540          MOV      r5,#0x300
                  |L1.342|
;;;430      }  
;;;431      if(status == FLASH_COMPLETE)
000156  2808              CMP      r0,#8
000158  d116              BNE      |L1.392|
;;;432      {
;;;433        /* if the previous operation is completed, proceed to erase all sectors */
;;;434         FLASH->CR &= CR_PSIZE_MASK;
00015a  4c88              LDR      r4,|L1.892|
00015c  3410              ADDS     r4,r4,#0x10
00015e  6820              LDR      r0,[r4,#0]
000160  f4207040          BIC      r0,r0,#0x300
000164  6020              STR      r0,[r4,#0]
;;;435         FLASH->CR |= tmp_psize;
000166  6820              LDR      r0,[r4,#0]
000168  4328              ORRS     r0,r0,r5
00016a  6020              STR      r0,[r4,#0]
;;;436         FLASH->CR |= FLASH_CR_MER;
00016c  6820              LDR      r0,[r4,#0]
00016e  f0400004          ORR      r0,r0,#4
000172  6020              STR      r0,[r4,#0]
;;;437         FLASH->CR |= FLASH_CR_STRT;
000174  6820              LDR      r0,[r4,#0]
000176  f4403080          ORR      r0,r0,#0x10000
00017a  6020              STR      r0,[r4,#0]
;;;438        
;;;439        /* Wait for last operation to be completed */
;;;440        status = FLASH_WaitForLastOperation();
00017c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;441    
;;;442        /* if the erase operation is completed, disable the MER Bit */
;;;443        FLASH->CR &= (~FLASH_CR_MER);
000180  6821              LDR      r1,[r4,#0]
000182  f0210104          BIC      r1,r1,#4
000186  6021              STR      r1,[r4,#0]
                  |L1.392|
;;;444    
;;;445      }   
;;;446      /* Return the Erase Status */
;;;447      return status;
;;;448    }
000188  bd30              POP      {r4,r5,pc}
                  |L1.394|
00018a  f44f7580          MOV      r5,#0x100             ;421
00018e  e7e2              B        |L1.342|
                  |L1.400|
000190  f44f7500          MOV      r5,#0x200             ;425
000194  e7df              B        |L1.342|
;;;449    
                          ENDP

                  FLASH_ProgramDoubleWord PROC
;;;458      */
;;;459    FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
000196  b5f0              PUSH     {r4-r7,lr}
;;;460    {
000198  4616              MOV      r6,r2
00019a  461f              MOV      r7,r3
00019c  4605              MOV      r5,r0
;;;461      FLASH_Status status = FLASH_COMPLETE;
;;;462    
;;;463      /* Check the parameters */
;;;464      assert_param(IS_FLASH_ADDRESS(Address));
;;;465    
;;;466      /* Wait for last operation to be completed */
;;;467      status = FLASH_WaitForLastOperation();
00019e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;468      
;;;469      if(status == FLASH_COMPLETE)
0001a2  2808              CMP      r0,#8
0001a4  d115              BNE      |L1.466|
;;;470      {
;;;471        /* if the previous operation is completed, proceed to program the new data */
;;;472        FLASH->CR &= CR_PSIZE_MASK;
0001a6  4c75              LDR      r4,|L1.892|
0001a8  3410              ADDS     r4,r4,#0x10
0001aa  6820              LDR      r0,[r4,#0]
0001ac  f4207040          BIC      r0,r0,#0x300
0001b0  6020              STR      r0,[r4,#0]
;;;473        FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
0001b2  6820              LDR      r0,[r4,#0]
0001b4  f4407040          ORR      r0,r0,#0x300
0001b8  6020              STR      r0,[r4,#0]
;;;474        FLASH->CR |= FLASH_CR_PG;
0001ba  6820              LDR      r0,[r4,#0]
0001bc  f0400001          ORR      r0,r0,#1
0001c0  6020              STR      r0,[r4,#0]
;;;475      
;;;476        *(__IO uint64_t*)Address = Data;
0001c2  602e              STR      r6,[r5,#0]
0001c4  606f              STR      r7,[r5,#4]
;;;477            
;;;478        /* Wait for last operation to be completed */
;;;479        status = FLASH_WaitForLastOperation();
0001c6  f7fffffe          BL       FLASH_WaitForLastOperation
;;;480    
;;;481        /* if the program operation is completed, disable the PG Bit */
;;;482        FLASH->CR &= (~FLASH_CR_PG);
0001ca  6821              LDR      r1,[r4,#0]
0001cc  f0210101          BIC      r1,r1,#1
0001d0  6021              STR      r1,[r4,#0]
                  |L1.466|
;;;483      } 
;;;484      /* Return the Program Status */
;;;485      return status;
;;;486    }
0001d2  bdf0              POP      {r4-r7,pc}
;;;487    
                          ENDP

                  FLASH_ProgramWord PROC
;;;496      */
;;;497    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
0001d4  b570              PUSH     {r4-r6,lr}
;;;498    {
0001d6  460d              MOV      r5,r1
0001d8  4606              MOV      r6,r0
;;;499      FLASH_Status status = FLASH_COMPLETE;
;;;500    
;;;501      /* Check the parameters */
;;;502      assert_param(IS_FLASH_ADDRESS(Address));
;;;503    
;;;504      /* Wait for last operation to be completed */
;;;505      status = FLASH_WaitForLastOperation();
0001da  f7fffffe          BL       FLASH_WaitForLastOperation
;;;506      
;;;507      if(status == FLASH_COMPLETE)
0001de  2808              CMP      r0,#8
0001e0  d114              BNE      |L1.524|
;;;508      {
;;;509        /* if the previous operation is completed, proceed to program the new data */
;;;510        FLASH->CR &= CR_PSIZE_MASK;
0001e2  4c66              LDR      r4,|L1.892|
0001e4  3410              ADDS     r4,r4,#0x10
0001e6  6820              LDR      r0,[r4,#0]
0001e8  f4207040          BIC      r0,r0,#0x300
0001ec  6020              STR      r0,[r4,#0]
;;;511        FLASH->CR |= FLASH_PSIZE_WORD;
0001ee  6820              LDR      r0,[r4,#0]
0001f0  f4407000          ORR      r0,r0,#0x200
0001f4  6020              STR      r0,[r4,#0]
;;;512        FLASH->CR |= FLASH_CR_PG;
0001f6  6820              LDR      r0,[r4,#0]
0001f8  f0400001          ORR      r0,r0,#1
0001fc  6020              STR      r0,[r4,#0]
;;;513      
;;;514        *(__IO uint32_t*)Address = Data;
0001fe  6035              STR      r5,[r6,#0]
;;;515            
;;;516        /* Wait for last operation to be completed */
;;;517        status = FLASH_WaitForLastOperation();
000200  f7fffffe          BL       FLASH_WaitForLastOperation
;;;518    
;;;519        /* if the program operation is completed, disable the PG Bit */
;;;520        FLASH->CR &= (~FLASH_CR_PG);
000204  6821              LDR      r1,[r4,#0]
000206  f0210101          BIC      r1,r1,#1
00020a  6021              STR      r1,[r4,#0]
                  |L1.524|
;;;521      } 
;;;522      /* Return the Program Status */
;;;523      return status;
;;;524    }
00020c  bd70              POP      {r4-r6,pc}
;;;525    
                          ENDP

                  FLASH_ProgramHalfWord PROC
;;;534      */
;;;535    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
00020e  b570              PUSH     {r4-r6,lr}
;;;536    {
000210  460d              MOV      r5,r1
000212  4606              MOV      r6,r0
;;;537      FLASH_Status status = FLASH_COMPLETE;
;;;538    
;;;539      /* Check the parameters */
;;;540      assert_param(IS_FLASH_ADDRESS(Address));
;;;541    
;;;542      /* Wait for last operation to be completed */
;;;543      status = FLASH_WaitForLastOperation();
000214  f7fffffe          BL       FLASH_WaitForLastOperation
;;;544      
;;;545      if(status == FLASH_COMPLETE)
000218  2808              CMP      r0,#8
00021a  d114              BNE      |L1.582|
;;;546      {
;;;547        /* if the previous operation is completed, proceed to program the new data */
;;;548        FLASH->CR &= CR_PSIZE_MASK;
00021c  4c57              LDR      r4,|L1.892|
00021e  3410              ADDS     r4,r4,#0x10
000220  6820              LDR      r0,[r4,#0]
000222  f4207040          BIC      r0,r0,#0x300
000226  6020              STR      r0,[r4,#0]
;;;549        FLASH->CR |= FLASH_PSIZE_HALF_WORD;
000228  6820              LDR      r0,[r4,#0]
00022a  f4407080          ORR      r0,r0,#0x100
00022e  6020              STR      r0,[r4,#0]
;;;550        FLASH->CR |= FLASH_CR_PG;
000230  6820              LDR      r0,[r4,#0]
000232  f0400001          ORR      r0,r0,#1
000236  6020              STR      r0,[r4,#0]
;;;551      
;;;552        *(__IO uint16_t*)Address = Data;
000238  8035              STRH     r5,[r6,#0]
;;;553            
;;;554        /* Wait for last operation to be completed */
;;;555        status = FLASH_WaitForLastOperation();
00023a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;556    
;;;557        /* if the program operation is completed, disable the PG Bit */
;;;558        FLASH->CR &= (~FLASH_CR_PG);
00023e  6821              LDR      r1,[r4,#0]
000240  f0210101          BIC      r1,r1,#1
000244  6021              STR      r1,[r4,#0]
                  |L1.582|
;;;559      } 
;;;560      /* Return the Program Status */
;;;561      return status;
;;;562    }
000246  bd70              POP      {r4-r6,pc}
;;;563    
                          ENDP

                  FLASH_ProgramByte PROC
;;;572      */
;;;573    FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
000248  b570              PUSH     {r4-r6,lr}
;;;574    {
00024a  460d              MOV      r5,r1
00024c  4606              MOV      r6,r0
;;;575      FLASH_Status status = FLASH_COMPLETE;
;;;576    
;;;577      /* Check the parameters */
;;;578      assert_param(IS_FLASH_ADDRESS(Address));
;;;579    
;;;580      /* Wait for last operation to be completed */
;;;581      status = FLASH_WaitForLastOperation();
00024e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;582      
;;;583      if(status == FLASH_COMPLETE)
000252  2808              CMP      r0,#8
000254  d112              BNE      |L1.636|
;;;584      {
;;;585        /* if the previous operation is completed, proceed to program the new data */
;;;586        FLASH->CR &= CR_PSIZE_MASK;
000256  4c49              LDR      r4,|L1.892|
000258  3410              ADDS     r4,r4,#0x10
00025a  6820              LDR      r0,[r4,#0]
00025c  f4207040          BIC      r0,r0,#0x300
000260  6020              STR      r0,[r4,#0]
;;;587        FLASH->CR |= FLASH_PSIZE_BYTE;
000262  6820              LDR      r0,[r4,#0]
000264  6020              STR      r0,[r4,#0]
;;;588        FLASH->CR |= FLASH_CR_PG;
000266  6820              LDR      r0,[r4,#0]
000268  f0400001          ORR      r0,r0,#1
00026c  6020              STR      r0,[r4,#0]
;;;589      
;;;590        *(__IO uint8_t*)Address = Data;
00026e  7035              STRB     r5,[r6,#0]
;;;591            
;;;592        /* Wait for last operation to be completed */
;;;593        status = FLASH_WaitForLastOperation();
000270  f7fffffe          BL       FLASH_WaitForLastOperation
;;;594    
;;;595        /* if the program operation is completed, disable the PG Bit */
;;;596        FLASH->CR &= (~FLASH_CR_PG);
000274  6821              LDR      r1,[r4,#0]
000276  f0210101          BIC      r1,r1,#1
00027a  6021              STR      r1,[r4,#0]
                  |L1.636|
;;;597      } 
;;;598    
;;;599      /* Return the Program Status */
;;;600      return status;
;;;601    }
00027c  bd70              POP      {r4-r6,pc}
;;;602    
                          ENDP

                  FLASH_OB_Unlock PROC
;;;657      */
;;;658    void FLASH_OB_Unlock(void)
00027e  483f              LDR      r0,|L1.892|
;;;659    {
;;;660      if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
000280  3014              ADDS     r0,r0,#0x14
000282  6800              LDR      r0,[r0,#0]
000284  07c0              LSLS     r0,r0,#31
000286  d005              BEQ      |L1.660|
;;;661      {
;;;662        /* Authorizes the Option Byte register programming */
;;;663        FLASH->OPTKEYR = FLASH_OPT_KEY1;
000288  483c              LDR      r0,|L1.892|
00028a  493f              LDR      r1,|L1.904|
00028c  3008              ADDS     r0,r0,#8
00028e  6001              STR      r1,[r0,#0]
;;;664        FLASH->OPTKEYR = FLASH_OPT_KEY2;
000290  493e              LDR      r1,|L1.908|
000292  6001              STR      r1,[r0,#0]
                  |L1.660|
;;;665      }  
;;;666    }
000294  4770              BX       lr
;;;667    
                          ENDP

                  FLASH_OB_Lock PROC
;;;672      */
;;;673    void FLASH_OB_Lock(void)
000296  4839              LDR      r0,|L1.892|
;;;674    {
;;;675      /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
;;;676      FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
000298  3014              ADDS     r0,r0,#0x14
00029a  6801              LDR      r1,[r0,#0]
00029c  f0410101          ORR      r1,r1,#1
0002a0  6001              STR      r1,[r0,#0]
;;;677    }
0002a2  4770              BX       lr
;;;678    
                          ENDP

                  FLASH_OB_WRPConfig PROC
;;;688      */
;;;689    void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
0002a4  b530              PUSH     {r4,r5,lr}
;;;690    { 
0002a6  460d              MOV      r5,r1
0002a8  4604              MOV      r4,r0
;;;691      FLASH_Status status = FLASH_COMPLETE;
;;;692      
;;;693      /* Check the parameters */
;;;694      assert_param(IS_OB_WRP(OB_WRP));
;;;695      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;696        
;;;697      status = FLASH_WaitForLastOperation();
0002aa  f7fffffe          BL       FLASH_WaitForLastOperation
;;;698    
;;;699      if(status == FLASH_COMPLETE)
0002ae  2808              CMP      r0,#8
0002b0  d107              BNE      |L1.706|
;;;700      { 
;;;701        if(NewState != DISABLE)
;;;702        {
;;;703          *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
0002b2  4832              LDR      r0,|L1.892|
0002b4  3016              ADDS     r0,r0,#0x16
;;;704        }
;;;705        else
;;;706        {
;;;707          *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
0002b6  8801              LDRH     r1,[r0,#0]
0002b8  b10d              CBZ      r5,|L1.702|
0002ba  43a1              BICS     r1,r1,r4              ;703
0002bc  e000              B        |L1.704|
                  |L1.702|
0002be  4321              ORRS     r1,r1,r4
                  |L1.704|
0002c0  8001              STRH     r1,[r0,#0]
                  |L1.706|
;;;708        }
;;;709      }
;;;710    }
0002c2  bd30              POP      {r4,r5,pc}
;;;711    
                          ENDP

                  FLASH_OB_RDPConfig PROC
;;;723      */
;;;724    void FLASH_OB_RDPConfig(uint8_t OB_RDP)
0002c4  b510              PUSH     {r4,lr}
;;;725    {
0002c6  4604              MOV      r4,r0
;;;726      FLASH_Status status = FLASH_COMPLETE;
;;;727    
;;;728      /* Check the parameters */
;;;729      assert_param(IS_OB_RDP(OB_RDP));
;;;730    
;;;731      status = FLASH_WaitForLastOperation();
0002c8  f7fffffe          BL       FLASH_WaitForLastOperation
;;;732    
;;;733      if(status == FLASH_COMPLETE)
0002cc  2808              CMP      r0,#8
0002ce  d102              BNE      |L1.726|
;;;734      {
;;;735        *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
0002d0  482a              LDR      r0,|L1.892|
0002d2  3015              ADDS     r0,r0,#0x15
0002d4  7004              STRB     r4,[r0,#0]
                  |L1.726|
;;;736    
;;;737      }
;;;738    }
0002d6  bd10              POP      {r4,pc}
;;;739    
                          ENDP

                  FLASH_OB_UserConfig PROC
;;;755      */
;;;756    void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
0002d8  b570              PUSH     {r4-r6,lr}
;;;757    {
0002da  4615              MOV      r5,r2
0002dc  460c              MOV      r4,r1
0002de  4606              MOV      r6,r0
;;;758      uint8_t optiontmp = 0xFF;
;;;759      FLASH_Status status = FLASH_COMPLETE; 
;;;760    
;;;761      /* Check the parameters */
;;;762      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;763      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;764      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;765    
;;;766      /* Wait for last operation to be completed */
;;;767      status = FLASH_WaitForLastOperation();
0002e0  f7fffffe          BL       FLASH_WaitForLastOperation
;;;768      
;;;769      if(status == FLASH_COMPLETE)
0002e4  2808              CMP      r0,#8
0002e6  d108              BNE      |L1.762|
;;;770      { 
;;;771        /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
;;;772        optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
0002e8  4924              LDR      r1,|L1.892|
0002ea  3114              ADDS     r1,r1,#0x14
0002ec  7808              LDRB     r0,[r1,#0]
0002ee  f000000f          AND      r0,r0,#0xf
;;;773    
;;;774        /* Update User Option Byte */
;;;775        *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
0002f2  4304              ORRS     r4,r4,r0
0002f4  432c              ORRS     r4,r4,r5
0002f6  4334              ORRS     r4,r4,r6
0002f8  700c              STRB     r4,[r1,#0]
                  |L1.762|
;;;776      }  
;;;777    }
0002fa  bd70              POP      {r4-r6,pc}
;;;778    
                          ENDP

                  FLASH_OB_BORConfig PROC
;;;788      */
;;;789    void FLASH_OB_BORConfig(uint8_t OB_BOR)
0002fc  491f              LDR      r1,|L1.892|
;;;790    {
;;;791      /* Check the parameters */
;;;792      assert_param(IS_OB_BOR(OB_BOR));
;;;793    
;;;794      /* Set the BOR Level */
;;;795      *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
0002fe  3114              ADDS     r1,r1,#0x14
000300  780a              LDRB     r2,[r1,#0]
000302  f022020c          BIC      r2,r2,#0xc
000306  700a              STRB     r2,[r1,#0]
;;;796      *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
000308  780a              LDRB     r2,[r1,#0]
00030a  4302              ORRS     r2,r2,r0
00030c  700a              STRB     r2,[r1,#0]
;;;797    
;;;798    }
00030e  4770              BX       lr
;;;799    
                          ENDP

                  FLASH_OB_Launch PROC
;;;805      */
;;;806    FLASH_Status FLASH_OB_Launch(void)
000310  481a              LDR      r0,|L1.892|
;;;807    {
;;;808      FLASH_Status status = FLASH_COMPLETE;
;;;809    
;;;810      /* Set the OPTSTRT bit in OPTCR register */
;;;811      *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
000312  3014              ADDS     r0,r0,#0x14
000314  7801              LDRB     r1,[r0,#0]
000316  f0410102          ORR      r1,r1,#2
00031a  7001              STRB     r1,[r0,#0]
;;;812    
;;;813      /* Wait for last operation to be completed */
;;;814      status = FLASH_WaitForLastOperation();
00031c  e7fe              B        FLASH_WaitForLastOperation
;;;815    
;;;816      return status;
;;;817    }
;;;818    
                          ENDP

                  FLASH_OB_GetUser PROC
;;;824      */
;;;825    uint8_t FLASH_OB_GetUser(void)
00031e  4817              LDR      r0,|L1.892|
;;;826    {
;;;827      /* Return the User Option Byte */
;;;828      return (uint8_t)(FLASH->OPTCR >> 5);
000320  3014              ADDS     r0,r0,#0x14
000322  6800              LDR      r0,[r0,#0]
000324  f3c01047          UBFX     r0,r0,#5,#8
;;;829    }
000328  4770              BX       lr
;;;830    
                          ENDP

                  FLASH_OB_GetWRP PROC
;;;835      */
;;;836    uint16_t FLASH_OB_GetWRP(void)
00032a  4814              LDR      r0,|L1.892|
;;;837    {
;;;838      /* Return the FLASH write protection Register value */
;;;839      return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
00032c  3016              ADDS     r0,r0,#0x16
00032e  8800              LDRH     r0,[r0,#0]
;;;840    }
000330  4770              BX       lr
;;;841    
                          ENDP

                  FLASH_OB_GetRDP PROC
;;;848      */
;;;849    FlagStatus FLASH_OB_GetRDP(void)
000332  4912              LDR      r1,|L1.892|
;;;850    {
;;;851      FlagStatus readstatus = RESET;
000334  2000              MOVS     r0,#0
;;;852    
;;;853      if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
000336  3115              ADDS     r1,r1,#0x15
000338  7809              LDRB     r1,[r1,#0]
00033a  29aa              CMP      r1,#0xaa
00033c  d000              BEQ      |L1.832|
;;;854      {
;;;855        readstatus = SET;
00033e  2001              MOVS     r0,#1
                  |L1.832|
;;;856      }
;;;857      else
;;;858      {
;;;859        readstatus = RESET;
;;;860      }
;;;861      return readstatus;
;;;862    }
000340  4770              BX       lr
;;;863    
                          ENDP

                  FLASH_OB_GetBOR PROC
;;;872      */
;;;873    uint8_t FLASH_OB_GetBOR(void)
000342  480e              LDR      r0,|L1.892|
;;;874    {
;;;875      /* Return the FLASH BOR level */
;;;876      return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
000344  3014              ADDS     r0,r0,#0x14
000346  7800              LDRB     r0,[r0,#0]
000348  f000000c          AND      r0,r0,#0xc
;;;877    }
00034c  4770              BX       lr
;;;878    
                          ENDP

                  FLASH_ITConfig PROC
;;;902      */
;;;903    void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
00034e  4a0b              LDR      r2,|L1.892|
;;;904    {
;;;905      /* Check the parameters */
;;;906      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;907      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;908    
;;;909      if(NewState != DISABLE)
;;;910      {
;;;911        /* Enable the interrupt sources */
;;;912        FLASH->CR |= FLASH_IT;
000350  3210              ADDS     r2,r2,#0x10
000352  2900              CMP      r1,#0                 ;909
;;;913      }
;;;914      else
;;;915      {
;;;916        /* Disable the interrupt sources */
;;;917        FLASH->CR &= ~(uint32_t)FLASH_IT;
000354  6811              LDR      r1,[r2,#0]
000356  d001              BEQ      |L1.860|
000358  4301              ORRS     r1,r1,r0              ;912
00035a  e000              B        |L1.862|
                  |L1.860|
00035c  4381              BICS     r1,r1,r0
                  |L1.862|
00035e  6011              STR      r1,[r2,#0]            ;912
;;;918      }
;;;919    }
000360  4770              BX       lr
;;;920    
                          ENDP

                  FLASH_GetFlagStatus PROC
;;;933      */
;;;934    FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000362  4601              MOV      r1,r0
;;;935    {
;;;936      FlagStatus bitstatus = RESET;
;;;937      /* Check the parameters */
;;;938      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
;;;939    
;;;940      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
000364  4a05              LDR      r2,|L1.892|
000366  2000              MOVS     r0,#0                 ;936
000368  320c              ADDS     r2,r2,#0xc
00036a  6812              LDR      r2,[r2,#0]
00036c  420a              TST      r2,r1
00036e  d000              BEQ      |L1.882|
;;;941      {
;;;942        bitstatus = SET;
000370  2001              MOVS     r0,#1
                  |L1.882|
;;;943      }
;;;944      else
;;;945      {
;;;946        bitstatus = RESET;
;;;947      }
;;;948      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;949      return bitstatus; 
;;;950    }
000372  4770              BX       lr
;;;951    
                          ENDP

                  FLASH_ClearFlag PROC
;;;963      */
;;;964    void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000374  4901              LDR      r1,|L1.892|
;;;965    {
;;;966      /* Check the parameters */
;;;967      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
;;;968      
;;;969      /* Clear the flags */
;;;970      FLASH->SR = FLASH_FLAG;
000376  310c              ADDS     r1,r1,#0xc
000378  6008              STR      r0,[r1,#0]
;;;971    }
00037a  4770              BX       lr
;;;972    
                          ENDP

                  |L1.892|
                          DCD      0x40023c00
                  |L1.896|
                          DCD      0x45670123
                  |L1.900|
                          DCD      0xcdef89ab
                  |L1.904|
                          DCD      0x08192a3b
                  |L1.908|
                          DCD      0x4c5d6e7f

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_flash.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f4xx_flash_c_a2a150d6____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____REVSH|
#line 128
|__asm___17_stm32f4xx_flash_c_a2a150d6____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
