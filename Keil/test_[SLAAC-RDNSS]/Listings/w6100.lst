L 1 "..\..\Libraries\io6Library\Ethernet\W6100\w6100.c"
N//*****************************************************************************
N//
N//! \file w6100.c
N//! \brief W6100 HAL Implements file.
N//! \version 1.0.0
N//! \date 2019/01/01
N//! \par  Revision history
N//!       <2019/01/01> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2019, WIZnet Co., LTD.
N//!
N//! Permission is hereby granted, free of charge, to any person obtaining a copy
N//! of this software and associated documentation files (the "Software"), to deal
N//! in the Software without restriction, including without limitation the rights 
N//! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N//! copies of the Software, and to permit persons to whom the Software is 
N//! furnished to do so, subject to the following conditions: 
N//!
N//! The above copyright notice and this permission notice shall be included in
N//! all copies or substantial portions of the Software. 
N//!
N//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
N//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
N//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
N//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
N//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
N//! SOFTWARE. 
N//!
N//*****************************************************************************
N
N#include "w6100.h"
L 1 "..\..\Libraries\io6Library\Ethernet\W6100\w6100.h" 1
N//* ****************************************************************************
N//! \file w6100.h
N//! \brief W6100 HAL Header File.
N//! \version 1.0.0
N//! \date 2019/01/01
N//! \par  Revision history
N//!             <2019/01/01> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2019, WIZnet Co., LTD.
N//!
N//! Permission is hereby granted, free of charge, to any person obtaining a copy
N//! of this software and associated documentation files (the "Software"), to deal
N//! in the Software without restriction, including without limitation the rights 
N//! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N//! copies of the Software, and to permit persons to whom the Software is 
N//! furnished to do so, subject to the following conditions: 
N//!
N//! The above copyright notice and this permission notice shall be included in
N//! all copies or substantial portions of the Software. 
N//!
N//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
N//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
N//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
N//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
N//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
N//! SOFTWARE. 
N//!
N//*****************************************************************************
N
N
N#ifndef      _W6100_H_
N#define      _W6100_H_
N
N#include <stdint.h>
L 1 "c:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 38 "..\..\Libraries\io6Library\Ethernet\W6100\w6100.h" 2
N#include "wizchip_conf.h"
L 1 "..\..\Libraries\io6Library\Ethernet\wizchip_conf.h" 1
N//* ****************************************************************************
N//! \file wizchip_conf.h
N//! \brief WIZCHIP Config Header File.
N//! \version 1.0.0
N//! \date 2019/01/01
N//! \par  Revision history
N//!       <2019/01/01> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2019, WIZnet Co., LTD.
N//!
N//! Permission is hereby granted, free of charge, to any person obtaining a copy
N//! of this software and associated documentation files (the "Software"), to deal
N//! in the Software without restriction, including without limitation the rights 
N//! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N//! copies of the Software, and to permit persons to whom the Software is 
N//! furnished to do so, subject to the following conditions: 
N//!
N//! The above copyright notice and this permission notice shall be included in
N//! all copies or substantial portions of the Software. 
N//!
N//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
N//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
N//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
N//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
N//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
N//! SOFTWARE. 
N//!
N//*****************************************************************************
N
N
N
N#ifndef  _WIZCHIP_CONF_H_
N#define  _WIZCHIP_CONF_H_
N
N#include <stdint.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @defgroup extra_functions 2. WIZnet Extra Functions
N *
N * @brief These functions is optional function. 
N * @details @ref extra_functions could be replaced with @ref WIZCHIP_IO_Functions_W6100, \n
N *          because they were made by @ref Basic_IO_function_W6100.\n
N *          These functions configure or indicate @ref _WIZCHIP_, network information, interrupt, PHY, and timer.
N */
N
N
N#define W6100                          6100     ///< W6100 Definition
N//Add to
N//
N
N#ifndef _WIZCHIP_
N/**
N * @brief Select WIZCHIP.
N * @todo You should select one, \b W6100, etc. \n\n
N *       ex> <code> #define _WIZCHIP_      W6100 </code>
N *
N */
N#define _WIZCHIP_                      W6100    // W6100
N#endif
N
N#define _WIZCHIP_IO_MODE_NONE_         0x0000
N#define _WIZCHIP_IO_MODE_BUS_          0x0100   ///< Bus interface mode.\n Refer to @ref _WIZCHIP_IO_MODE_BUS_DIR_ or @ref _WIZCHIP_IO_MODE_BUS_INDIR_.
N#define _WIZCHIP_IO_MODE_SPI_          0x0200   ///< SPI interface mode.\n Refer to @ref _WIZCHIP_IO_MODE_SPI_VDM_ or @ref _WIZCHIP_IO_MODE_SPI_FDM_.
N//#define _WIZCHIP_IO_MODE_IIC_          0x0400
N//#define _WIZCHIP_IO_MODE_SDIO_         0x0800
N// Add to
N//
N
N#define _WIZCHIP_IO_MODE_BUS_DIR_      (_WIZCHIP_IO_MODE_BUS_ + 1) ///< BUS interface mode for direct.\n Refer to @ref _WIZCHIP_IO_MODE_BUS_.
N#define _WIZCHIP_IO_MODE_BUS_INDIR_    (_WIZCHIP_IO_MODE_BUS_ + 2) ///< BUS interface mode for indirect.\n Refer to @ref _WIZCHIP_IO_MODE_BUS_.
N
N#define _WIZCHIP_IO_MODE_SPI_VDM_      (_WIZCHIP_IO_MODE_SPI_ + 1) ///< SPI interface mode for variable length data.\n Refer to @ref _WIZCHIP_IO_MODE_SPI_
N/**
N * @brief SPI interface mode for fixed length data mode.
N * @note If you want to use SPI FDM, Feel free to send a email to support@wiznet.io.
N * @sa _WIZCHIP_IO_MODE_SPI_
N */
N#define _WIZCHIP_IO_MODE_SPI_FDM_      (_WIZCHIP_IO_MODE_SPI_ + 2) 
N
N
N/**
N * @brief PHY can be accessed by @ref _PHYCR0_, _PHYCR1_.
N * @details It provides hardware access method. 
N * @note It is smaller s/w footprint than @ref _PHY_IO_MODE_MII_.
N * @sa _PHY_IO_MODE_MII_, _PHY_IO_MODE_
N * @sa ctlwizchip(), getPHYCR0(), getPHYCR1(), setPHYCR1(), getPHYSR()
N */
N#define _PHY_IO_MODE_PHYCR_            0x0000
N
N/**
N * @brief PHY can be accessed by MDC/MDIO signals of MII interface. 
N * @details It provide software access method. 
N * @note It is bigger s/w footprint than @ref _PHY_IO_MODE_PHYCR_.
N * @sa _PHY_IO_MODE_PHYCR_, _PHY_IO_MODE_
N * @sa ctlwizchip(), wiz_read_mdio(), wiz_write_mdio()
N */
N#define _PHY_IO_MODE_MII_              0x0010
N
N/**
N * @brief Select PHY Access Mode
N * @details @ref _PHY_IO_MODE_ selects PHY access method.
N * @todo You should select one of @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_.
N * @sa ctlwizchip()
N */
N#define _PHY_IO_MODE_                  _PHY_IO_MODE_PHYCR_ //_PHY_IO_MODE_MII_
N
N
N#if (_WIZCHIP_ == W6100)
X#if (6100 == 6100)
N   #define _WIZCHIP_ID_                "W6100\0"
N   /**
N   * @brief Define @ref _WIZCHIP_ interface mode.
N   * @todo You should select interface mode of @ref _WIZCHIP_.\n\n
N   *       Select one of @ref _WIZCHIP_IO_MODE_SPI_VDM_, @ref _WIZCHIP_IO_MODE_SPI_FDM_, and @ref _WIZCHIP_IO_MODE_BUS_INDIR_
N   * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N   */
N   #define _WIZCHIP_IO_MODE_           _WIZCHIP_IO_MODE_BUS_INDIR_
N   //#define _WIZCHIP_IO_MODE_         _WIZCHIP_IO_MODE_SPI_VDM_
N   //#define _WIZCHIP_IO_MODE_         _WIZCHIP_IO_MODE_SPV_FDM_
N
N   typedef   uint8_t   iodata_t;       ///< IO access unit. bus width
N   typedef   int16_t   datasize_t;     ///< sent or received data size
N   #include "./W6100/w6100.h"
L 1 "..\..\Libraries\io6Library\Ethernet\./W6100/w6100.h" 1
N//* ****************************************************************************
N//! \file w6100.h
N//! \brief W6100 HAL Header File.
N//! \version 1.0.0
N//! \date 2019/01/01
N//! \par  Revision history
N//!             <2019/01/01> 1st Release
N//! \author MidnightCow
N//! \copyright
N//!
N//! Copyright (c)  2019, WIZnet Co., LTD.
N//!
N//! Permission is hereby granted, free of charge, to any person obtaining a copy
N//! of this software and associated documentation files (the "Software"), to deal
N//! in the Software without restriction, including without limitation the rights 
N//! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N//! copies of the Software, and to permit persons to whom the Software is 
N//! furnished to do so, subject to the following conditions: 
N//!
N//! The above copyright notice and this permission notice shall be included in
N//! all copies or substantial portions of the Software. 
N//!
N//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
N//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
N//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
N//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
N//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
N//! SOFTWARE. 
N//!
N//*****************************************************************************
N
N
N#ifndef      _W6100_H_
S#define      _W6100_H_
S
S#include <stdint.h>
S#include "wizchip_conf.h"
S
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/// @cond DOXY_APPLY_CODE
S#if      (_WIZCHIP_ == W6100)
S/// @endcond
S
S#define _W6100_SPI_READ_                  (0x00 << 2)        ///< SPI interface Read operation in Control Phase
S#define _W6100_SPI_WRITE_                 (0x01 << 2)        ///< SPI interface Write operation in Control Phase
S
S#define WIZCHIP_CREG_BLOCK                (0x00   <<3)       ///< Common register block
S#define WIZCHIP_SREG_BLOCK(N)             ((1+4*N)<<3)       ///< SOCKETn register block
S#define WIZCHIP_TXBUF_BLOCK(N)            ((2+4*N)<<3)       ///< SOCKETn Tx buffer address block
S#define WIZCHIP_RXBUF_BLOCK(N)            ((3+4*N)<<3)       ///< SOCKETn Rx buffer address block
S
S#define WIZCHIP_OFFSET_INC(ADDR, N) (ADDR + (N<<8)) ///< Increase offset address
S
S#if (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)      
S   #define IDM_AR0                        ((_WIZCHIP_IO_BASE_ + 0x0000))      ///< Indirect High Address Register
S   #define IDM_AR1                        ((_WIZCHIP_IO_BASE_ + 0x0001))      ///< Indirect Low Address Register
S   #define IDM_BSR                        ((_WIZCHIP_IO_BASE_ + 0x0002))      ///< Block Select Register
S   #define IDM_DR                         ((_WIZCHIP_IO_BASE_ + 0x0003))      ///< Indirect Data Register
S   #define _W6100_IO_BASE_       _WIZCHIP_IO_BASE_
S#elif (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
S   #define _W6100_IO_BASE_       0x00000000
S#endif
S
S
S//-----------       defgroup --------------------------------
S
S/**
S * @defgroup W6100 W6100
S * @brief @ref _WIZCHIP_ register defines and I/O functions
S * @details
S *   - @ref WIZCHIP_register_W6100 : @ref Common_register_group_W6100, @ref Socket_register_group_W6100
S *   - @ref WIZCHIP_IO_Functions_W6100 : @ref Basic_IO_function_W6100, @ref Common_register_access_function_W6100, @ref Socket_register_access_function_W6100
S */
S
S /**
S * @defgroup WIZCHIP_register_W6100 WIZCHIP register
S * @ingroup W6100
S * @brief @ref WIZCHIP_register_W6100 defines register group of @b W6100.
S * @details
S *   - @ref Common_register_group_W6100 : Common register group W6100
S *   - @ref Socket_register_group_W6100 : SOCKET n register group W6100
S */
S
S/**
S * @defgroup Basic_IO_function_W6100 Basic I/O function
S * @ingroup WIZCHIP_IO_Functions_W6100
S * @brief These are basic input/output functions to read values from register or write values to register.
S */
S
S/**
S * @defgroup Common_register_access_function_W6100 Common register access functions
S * @ingroup WIZCHIP_IO_Functions_W6100
S * @brief These are functions to access @ref Common_register_group_W6100.
S */
S
S/**
S * @defgroup Socket_register_access_function_W6100 Socket register access functions
S * @ingroup WIZCHIP_IO_Functions_W6100
S * @brief These are functions to access @ref Socket_register_group_W6100.
S */
S
S/**
S * @defgroup WIZCHIP_IO_Functions_W6100 WIZCHIP I/O functions
S * @ingroup W6100
S * @brief @ref WIZCHIP_IO_Functions_W6100 supports the basic I/O functions for @ref WIZCHIP_register_W6100.
S * @details
S *   - @ref WIZCHIP_IO_Functions_W6100 \n
S *     WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
S *   - @ref Common_register_access_function_W6100 \n
S *     - @ref _WIZCHIP_ Mode \n
S *       getCIDR(), getVER() \n
S *       getSYSR()  \n
S *       setCHPLCKR(), setNETLCKR(), setPHYLCKR() \n
S *       setSYCR0(), getSYCR1(), setSYCR1()
S *     - Network Mode \n
S *       getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR(), getNETMR(), setNETMR(), getNETMR2(), setNETMR2()
S *     - Interrupt \n
S *       getIR(), setIRCLR(), getIMR(), setIMR() \n
S *       getSIR(), getSIMR(), setSIMR() \n
S *       getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR() \n
S *       getINTPTMR(), setINTPTMR()
S *     - Network Information \n
S *       NETLOCK(), NETUNLOCK() \n
S *       getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), setSUBR(), getSIPR(), setSIPR() \n
S *       getLLAR(), setLLAR(), getGUAR(), setGUAR(), getGA6R(), setGA6R(), getSUB6R(), setSUB6R() \n
S *       getPLR(), getPFR(), getVLTR(), getPLTR(), getPAR() \n
S *     - SOCKET-less Commands for PING, ARP and IPv6 Auto-Configuration \n
S *       getSLCR(), setSLCR() \n
S *       getPINGIDR(), setPINGIDR(), getPINGSEQR(), setPINGSEQR() \n
S *       getSLDHAR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLHOPR(), setSLHOPR() \n
S *     - Retransmission  \n
S *       getRCR(), setRCR() \n
S *       getSLRCR(), setSLRCR(), getSLRTR(), setSLRTR() \n
S *     - ICMP \n
S *       getUIPR(), getUIP6R(), getUPORTR(), getUPORT6R() \n
S *       getICMP6BLKR(), setICMP6BLKR() \n
S *     - PPPoE \n
S *       getPTMR(), setPTMR(), getPMNR(), getPMNR() \n
S *       getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR()
S *     - PHY Configuration \n
S *       getPHYSR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK() \n
S *       setPHYCR0(), getPHYCR1(), setPHYCR1() \n
S *       getPHYRAR(), setPHYRAR(), setPHYDIR(), getPHYDOR(), getPHYACR(), setPHYACR(), getPHYDIVR(), setPHYDIVR()
S *     - etc \n
S *       getTCNTR(), setTCNTRCLR()
S *   - @ref Socket_register_access_function_W6100 \n
S *     - SOCKET control \n
S *       getSn_MR(), setSn_MR(), getSn_MR2(), setSn_MR2(), getSn_PSR(), setSn_PSR(), getSn_CR(), setSn_CR() \n
S *       getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR()  \n
S *       getSn_RTR(), setSn_RTR(), getSn_RCR(), setSn_RCR(), getSn_KPALVTR(), setSn_KPALVTR()
S *     - SOCKET information \n
S *       getSn_SR(), getSn_ESR() \n
S *       getSn_DHAR(), setSn_DHAR(),  getSn_PORTR(), setSn_PORTR(), getSn_DPORTR(), setSn_DPORTR() \n
S *       getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R() \n
S *       getSn_MSSR(), setSn_MSSR()
S *     - SOCKET communication \n
S *       getSn_RX_BSR(), setSn_RX_BSR(), getSn_TX_BSR(), setSn_TX_BSR() \n
S *       getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR() \n
S *       getSn_RX_RD(), setSn_RX_RD(), getSn_RX_WR() \n
S *       getSn_TX_FSR(), getSn_RX_RSR()
S *     - IP header field \n
S *       getSn_FRGR(), setSn_FRGR(),  getSn_TOSR(), setSn_TOSR() \n
S *       getSn_TTLR(), setSn_TTLR()
S */
S
S/**
S * @defgroup Common_register_group_W6100 Common register
S * @ingroup WIZCHIP_register_W6100
S * @brief Common register group \n
S * @details It set the general configuration such as interrupt, network information, ICMP, and etc.
S * @sa
S * <table width=0>
S *    <tr><td> @ref _WIZCHIP_ Information   </td><td>: _CIDR_, _VER_                                                                   </td></tr>
S *    <tr><td> @ref _WIZCHIP_ Mode          </td><td>: _SYSR_, _SYCR0_, _SYCR1_, _CHPLCKR_, _NETLCKR_, _PHYLCKR_                       </td></tr>
S *    <tr><td> Network Mode                 </td><td>: _NET4MR_, _NET6MR_, _NETMR_, _NETMR2_                                           </td></tr>
S *    <tr><td> Network Information          </td><td>: _GAR_, _SUBR_, _SHAR_, _SIPR_, _GA6R_, _LLAR_, _GUAR_, _SUB6R_                  </td></tr>
S *    <tr><td> Interrupt                    </td><td>: _IR_, _IRCLR_, _IMR_, _SIR_, _SIMR_, _SLIR_, _SLIMR_, _SLIRCLR_, _INTPTMR_      </td></tr>
S *    <tr><td> Data retransmission          </td><td>: _RTR_, _RCR_, _SLRTR_, _SLRCR_, _SLHOPR_                                        </td></tr>
S *    <tr><td> PPPoE                        </td><td>: _PHAR_, _PSIDR_, _PMRUR_, _PTMR_, _PMNR_                                        </td></tr>
S *    <tr><td> SOCKET-less command          </td><td>: _SLCR_, _SLIR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _PINGIDR_, _PINGSEQR_ </td></tr>
S *    <tr><td> ICMP v4 & v6                 </td><td>: _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_, _ICMP6BLKR_                               </td></tr>
S *    <tr><td> IPv6 Auto-configuration      </td><td>: _PLR_, _PFR_, _VLTR_, _PAR_                                                     </td></tr>
S *    <tr><td> PHY Configuration            </td><td>: _PHYSR_, _PHYCR0_, _PHYCR1_, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYDIVR_  </td></tr>
S * </table>
S */
S 
S
S/**
S * @defgroup Socket_register_group_W6100 Socket register
S * @ingroup WIZCHIP_register_W6100
S * @brief Socket register group\n
S * @details
S * SOCKETn registers configure and control SOCKETn which is necessary to data communication.
S * @sa
S * <table width=0>
S *    <tr><td> SOCKETn Control       </td><td>: _Sn_MR_, _Sn_MR2_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, _Sn_PSR_                                </td></tr>
S *    <tr><td> SOCKETn Information   </td><td>: _Sn_SR_, _Sn_ESR_, _Sn_PORTR_, _Sn_DHAR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_                       </td></tr>
S *    <tr><td> SOCKETn Retransmission </td><td>: _Sn_RTR_, _Sn_RCR_                                                                                 </td></tr>
S *    <tr><td> Internet protocol     </td><td>: _Sn_MSSR_, _Sn_TOSR_, _Sn_TTLR_, _Sn_FRGR_                                                         </td></tr>
S *    <tr><td> Data communication    </td><td>: _Sn_RX_BSR_, _Sn_TX_BSR_, _Sn_TX_FSR_, _Sn_TX_RD_, _Sn_TX_WR_, _Sn_RX_RSR_, _Sn_RX_RD_, _Sn_RX_WR_ </td></tr>
S * </table>
S */
S
S//-----------------------------------------------------------------------------------
S
S//----------------------------- W6100 Common Registers IOMAP -----------------------------
S
S/**
S * @addtogroup Common_register_group_W6100
S * @{
S */
S
S/**
S * @brief Chip Identification Register address [RO] [0x6100]
S * @sa getCIDR()
S */
S#define _CIDR_               (_W6100_IO_BASE_ + (0x0000 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Chip Version Register address [RO] [0x4661]
S * @sa getVER()
S */
S#define _VER_                (_W6100_IO_BASE_ + (0x0002 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief System Status Register address [RO] [0xEU]
S * @details @ref _SYSR_ shows the information such as CHIP, NET, PHY Locking and Host I/F
S * <table>
S *    <tr> <td>7   </td> <td>6   </td> <td>5   </td> <td>4 ~ 2   </td> <td>1  </td> <td>0  </td> </tr>
S *    <tr> <td>CHPL</td> <td>NETL</td> <td>PHYL</td> <td>Reserved</td> <td>IND</td> <td>SPI</td> </tr>
S * </table>
S *  - @ref SYSR_CHPL 
S *  - @ref SYSR_NETL 
S *  - @ref SYSR_PHYL 
S *  - @ref SYSR_IND  : HOST use Parallel BUS Interface(Indirect Bus Mode)
S *  - @ref SYSR_SPI  : HOST use SPI Interface
S *
S * @sa _CHPLCKR_, _NETLCKR_, _PHYLCKR_, 
S * @sa getSYSR(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK() \n
S *        setPHYLCKR(), getPHYLCKR(), PHYLOCK(), PHYUNLOCK()
S */
S#define _SYSR_               (_W6100_IO_BASE_ + (0x2000 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief System Config Register 0 address [WO][0x80] 
S * @details @ref _SYCR0_ softly reset to _WIZCHIP_.
S * <table>
S *    <tr> <td>7  </td> <td>6 ~ 0   </td> </tr>
S *    <tr> <td>RST</td> <td>Reserved</td> </tr>
S * </table>
S *   - @ref SYCR0_RST : Software Reset.
S *
S * @note It can be accessed only when @ref SYSR_CHPL = 1.
S * @sa _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa setSYCR0(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SYCR0_              (_W6100_IO_BASE_ + (0x2004 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief System Config Register 1 address [R=W][0x80] 
S * @details @ref _SYCR1_ controls the global interrupt enable, and selects the system clock.
S * <table>
S *    <tr> <td>7  </td> <td>6 ~ 1   </td> <td>0     </td> </tr>
S *    <tr> <td>IEN</td> <td>Reserved</td> <td>CLKSEL</td> </tr>
S * </table>
S *   - @ref SYCR1_IEN
S *   - @ref SYCR1_CLKSEL
S *
S * @note SYCR1_CLKSEL bit can be accessed only when @ref SYSR_CHPL = 1.
S * @sa _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSYCR1(), setSYCR1(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SYCR1_              (WIZCHIP_OFFSET_INC(_SYCR0_,1))
S
S/**
S * @brief Ticker Counter Register address [RO][0x0000]
S * @details @ref _TCNTR_ increase by 1 every 100us after _WIZCHIP_ reset.
S * @sa _TCNTRCLR_
S * @sa getTCNTR(), setTCNTRCLR() 
S */
S#define _TCNTR_              (_W6100_IO_BASE_ + (0x2016 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Ticker Counter Clear Register address [RO][0x00]
S * @details @ref _TCNTRCLR_ clear @ref _TCNTR_.
S * @sa setTCNTRCLR(), getTCNTR()
S */
S#define _TCNTRCLR_           (_W6100_IO_BASE_ + (0x2020 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Interrupt Register address [RO][0x00]
S * @details @ref _IR_ indicates the interrupt status.
S *          If @ref _IR_ is not equal to x00 INTn PIN is asserted to low until it is x00.
S * 
S * <table>
S *    <tr> <td>7  </td> <td>6 ~ 5   </td> <td>4   </td> <td>3       </td> <td>2     </td> <td>1   </td> <td>0    </td> </tr>
S *    <tr> <td>WOL</td> <td>Reserved</td> <td>UNR6</td> <td>Reserved</td> <td>IPCONF</td> <td>UNR4</td> <td>PTERM</td> </tr>
S * </table>
S *  - @ref IR_WOL    : Wake On LAN
S *  - @ref IR_UNR6   : Destination Port Unreachable for IPv6
S *  - @ref IR_IPCONF : @ref _SIPR_ is Conflict
S *  - @ref IR_UNR4   : Destination Port Unreachable for IPv4
S *  - @ref IR_PTERM  : PPPoE Terminated
S *
S * @sa _IMR_, _IRCLR_, SYCR1_IEN, _CHIPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getIR(), setIRCLR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR() 
S */
S#define _IR_                 (_W6100_IO_BASE_ + (0x2100 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET Interrupt Register address [RO][0x00]
S * @details @ref _SIR_ indicates whether a socket interrupt is occurred or not.\n
S *          Each bit of @ref _SIR_ be still until @ref _Sn_IR_ is cleared by @ref _Sn_IRCLR_
S * @sa _SIMR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, SYCR1_IEN , _CHIPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSIR(), getSn_IR(), setSn_IRCLR(), getSIMR(), setSIMR(), getSn_IMR(), setSn_IMR(), getSYCR1(), setSYCR1(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SIR_                (_W6100_IO_BASE_ + (0x2101 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Interrupt Register address [RO][0x00]
S * @details @ref _SLIR_ indicates the completion of @ref _SLCR_ or timeout.
S * <table>
S *    <tr> <td>7   </td> <td>6   </td> <td>5    </td> <td>4   </td> <td>3    </td> <td>2 </td> <td>1 </td> <td>0 </td> </tr>
S *    <tr> <td>TOUT</td> <td>ARP4</td> <td>PING4</td> <td>ARP6</td> <td>PING6</td> <td>NS</td> <td>RS</td> <td>RA</td> </tr>
S * </table>
S *  - @ref SLIR_TOUT  : The timeout occurrence after @ref _SLCR_ is performed
S *  - @ref SLIR_ARP4  : The completion of @ref SLCR_ARP4
S *  - @ref SLIR_PING4 : The completion of @ref SLCR_PING4
S *  - @ref SLIR_ARP6  : The completion f @ref SLCR_ARP6
S *  - @ref SLIR_PING6 : The completion of @ref SLCR_PING6
S *  - @ref SLIR_NS    : The completion of @ref SLCR_NS
S *  - @ref SLIR_RS    : The completion of @ref SLIR_RS
S *  - @ref SLIR_RA    : The reception from Router Advertisement
S *
S * @sa _SLIRCLR_, _SLIMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSLIR(), setSLIRCLR(),  getSLIR(), getSLIMR(), setSLIMR(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SLIR_               (_W6100_IO_BASE_ + (0x2102 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Interrupt Mask Register address [R=W][0x00]
S * @details @ref _IMR_ is used to mask interrupts of @ref _IR_.\n
S *          When a bit of @ref _IMR_ and the corresponding bit of @ref _IR_ is set, an interrupt will be issued.
S * @sa _IR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getIMR(), setIMR(),  getIR(), setIRCLR(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _IMR_                (_W6100_IO_BASE_ + (0x2104 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief @ref _IR_  Clear Register address [WO][0x00]
S * @details @ref _IRCLR_ clears @ref _IR_
S * @sa _IR_, _IMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa setIRCLR(), getIR(), getIMR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _IRCLR_              (_W6100_IO_BASE_ + (0x2108 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET Interrupt Mask Register address [R=W]][0x00]
S * @details @ref _SIMR_ is used to mask interrupts of @ref _SIR_.\n
S *          When a bit of @ref _SIMR_ and the corresponding bit of @ref _SIR_ is set, an interrupt will be issued.\n
S *          when @ref _Sn_IR_ is not 0,  The N-th bit of @ref _SIR_ is set. Otherwise, this bit is automatically clear.\n
S * @sa _SIR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSIMR(), setSIMR(), getSIR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SIMR_               (_W6100_IO_BASE_ + (0x2114 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Interrupt Mask Register address [R=W][0x00]
S * @details @ref _SLIMR_ is used to mask interrupts of @ref _SLIR_\n
S *          When a bit of @ref _SLIMR_ and the corresponding bit of @ref _SLIR_ is set, an interrupt will be issued.
S * @sa _SLIR_, _SLIRCLR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSLIMR(), setSLIMR(), getSLIR(), setSLIRCLR(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SLIMR_              (_W6100_IO_BASE_ + (0x2124 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Interrupt Clear Register address [WO][0x00]
S * @details @ref _SLIRCLR_ clears @ref _SLIR_
S * @sa _SLIR_, _SLIRCLR_, _SLIMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), \n
S *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SLIRCLR_            (_W6100_IO_BASE_ + (0x2128 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Prefer Source IPv6 Address Register address [R=W][0x00]
S * @details @ref _SLPSR_ select the Source IPv6 Address to transmit a packet by @ref _SLCR_.
S *   - @ref PSR_AUTO 
S *   - @ref PSR_LLA 
S *   - @ref PSR_GUA 
S * @sa _SLCR_, _Sn_PSR_
S * @sa getSLPSR(), setSLPSR(), getSLCR(), setSLCR(), getSn_PSR(), setSn_PSR()
S */
S#define _SLPSR_              (_W6100_IO_BASE_ + (0x212C << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Command Register address [RW,AC][0x00]
S * @details @ref _SLCR_ can be request a message such like as ARP, PING, and ICMPv6 without SOCKET.
S * <table>
S *    <tr> <td>7       </td> <td>6   </td> <td>5    </td> <td>4   </td> <td>3    </td> <td>2 </td> <td>1 </td> <td>0  </td> </tr>
S *    <tr> <td>Reserved</td> <td>ARP4</td> <td>PING4</td> <td>ARP6</td> <td>PING6</td> <td>NS</td> <td>RS</td> <td>UNA</td> </tr>
S * </table>
S *   - @ref SLCR_ARP4
S *   - @ref SLCR_PING4
S *   - @ref SLCR_ARP6
S *   - @ref SLCR_PING6
S *   - @ref SLCR_NS
S *   - @ref SLCR_RS
S *   - @ref SLCR_UNA
S *
S * @sa _SLIR_, _SLIMR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDIPR(),setSLDIPR(), getSLDIP4R(),setSLDIP4R(), 
S *     getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _SLCR_               (_W6100_IO_BASE_ + (0x2130 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Status Register address [RO][0x00]
S * @details @ref _PHYSR_ shows the operation mode of PHY, the link status and etc.
S *   - @ref PHYSR_CAB  : @ref PHYSR_CAB_OFF, @ref PHYSR_CAB_ON
S *   - @ref PHYSR_MODE : @ref PHYSR_MODE_AUTO, @ref PHYSR_MODE_100F, @ref PHYSR_MODE_100H, @ref PHYSR_MODE_10F, @ref PHYSR_MODE_10H
S *   - @ref PHYSR_DPX  : @ref PHYSR_DPX_FULL, @ref PHYSR_DPX_HALF
S *   - @ref PHYSR_SPD  : @ref PHYSR_SPD_100M, @ref PHYSR_SPD_10M
S *   - @ref PHYSR_LNK  : @ref PHYSR_LNK_UP, @ref PHYSR_LNK_DOWN
S *
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL
S * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), getPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
S */
S#define _PHYSR_              (_W6100_IO_BASE_ + (0x3000 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Internal Register Address Register address(R/W)
S * @details @ref _PHYRAR_ specifies the address of register in the Ethernet PHY.
S *   - @ref PHYRAR_BMCR
S *   - @ref PHYRAR_BMSR
S * @sa _PHYACR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
S * @sa getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
S */
S#define _PHYRAR_             (_W6100_IO_BASE_ + (0x3008 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Data Input Register address [R=W][0x00]
S * @details @ref _PHYDIR_ specifies the value to write to the register in PHY
S * @sa _PHYRAR_, _PHYACR_, _PHYDOR_, _PHYDIVR_
S * @sa setPHYDIR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
S */
S#define _PHYDIR_             (_W6100_IO_BASE_ + (0x300C << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Data Output Register address [WO][0x00]
S * @details @ref _PHYDOR_ read the value from the register in PHY
S * @sa _PHYRAR_, _PHYACR_, _PHYDIR_, _PHYDIVR_
S * @sa getPHYDOR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
S */
S#define _PHYDOR_             (_W6100_IO_BASE_ + (0x3010 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Access Register address [RW,AC][0x00]
S * @details @ref _PHYACR_ write(read)  to(from) the value of register in the Ethernet PHY
S *   - @ref PHYACR_READ
S *   - @ref PHYACR_WRITE
S * @sa _PHYRAR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
S * @sa getPHYACR(), setPHYACR(), getPHYDOR(), getPHYRAR(), setPHYRAR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
S */
S#define _PHYACR_             (_W6100_IO_BASE_ + (0x3014 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY's MDC Clock Division Register address [R=W][0x01]
S * @details @ref _PHYDIVR_ divides the system clock for the MDC clock of Ethernet PHY'
S *   - @ref PHYDIVR_32
S *   - @ref PHYDIVR_64
S *   - @ref PHYDIVR_128
S * @sa _PHYRAR_, _PHYACR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
S * @sa getPHYDIVR(), setPHYDIVR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR()
S */
S#define _PHYDIVR_            (_W6100_IO_BASE_ + (0x3018 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Control Register address [WO][0x00]
S * @details @ref _PHYCR0_ controls the operation mode of PHY.
S *          The result will be checked by @ref _PHYSR_ after PHY HW reset by @ref PHYCR1_RST.
S *   - @ref PHYCR0_AUTO
S *   - @ref PHYCR0_100F
S *   - @ref PHYCR0_100H
S *   - @ref PHYCR0_10F
S *   - @ref PHYCR0_10H
S *
S * @note It can be only accessed when @ref SYSR_PHYL is unlock.  
S * @sa _SYSR_, _PHYCR1_
S * @sa setPHYCR0(), getSYSR(), getPHYCR1(), setPHYCR1() 
S */
S#define _PHYCR0_             (_W6100_IO_BASE_ + (0x301C << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY Control Register address [R=W][0x40]
S * @details @ref _PHYCR1_ controls the Ethernet PHY function such as HW reset, Power down and etc.
S * <table>
S *    <tr> <td>7       </td> <td>6       </td> <td>5   </td> <td>4      </td> <td>3 </td> <td>2 ~ 1   </td> <td>0  </td> </tr>
S *    <tr> <td>Reserved</td> <td>Always 1</td> <td>PWDN</td> <td>Reseved</td> <td>TE</td> <td>Reserved</td> <td>RST</td> </tr>
S * </table>
S *   - @ref PHYCR1_PWDN
S *   - @ref PHYCR1_TE
S *   - @ref PHYCR1_RST
S *
S * @note It can be only accessed when @ref SYSR_PHYL is unlock.  
S * @sa _SYSR_, _PHYCR0_
S * @sa getPHYCR1(), setPHYCR1(), setPHYCR0(), getSYSR() 
S */
S#define _PHYCR1_             WIZCHIP_OFFSET_INC(_PHYCR0_,1)
S
S/**
S * @brief Network IPv4 Mode Register address [R=W][0x00]
S * @details @ref _NET4MR_ can block the transmission such like as unreachable message, TCP reset, and ping relay.\n
S *          It can ARP request before ping relpy.
S *
S * <table>
S *    <tr> <td>7 ~ 4   </td> <td>3   </td> <td>2   </td> <td>1   </td> <td>0 </td> </tr>
S *    <tr> <td>Reserved</td> <td>UNRB</td> <td>PARP</td> <td>RSTB</td> <td>PB</td> </tr>
S * </table>
S *   - @ref NETxMR_UNRB
S *   - @ref NETxMR_PARP
S *   - @ref NETxMR_RSTB
S *   - @ref NETxMR_PB
S * @sa _NET6MR_
S * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
S */
S#define _NET4MR_             (_W6100_IO_BASE_ + (0x4000 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Network IPv6 Mode Register address [R=W][0x00]
S * @details @ref _NET6MR_ can block the transmission such like as unreachable message, TCP reset, and ping relay.\n
S *          It can ARP request before ping reply.
S *
S * <table>
S *    <tr> <td>7 ~ 4   </td> <td>3   </td> <td>2   </td> <td>1   </td> <td>0 </td> </tr>
S *    <tr> <td>Reserved</td> <td>UNRB</td> <td>PARP</td> <td>RSTB</td> <td>PB</td> </tr>
S * </table>
S *   - @ref NETxMR_UNRB
S *   - @ref NETxMR_PARP
S *   - @ref NETxMR_RSTB
S *   - @ref NETxMR_PB
S * @sa _NET4MR_
S * @sa getNET6MR(), setNET6MR(), getNET4MR(), setNET4MR() 
S */
S#define _NET6MR_             (_W6100_IO_BASE_ + (0x4004 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Network Mode Register address [R=W][0x00]
S * @details @ref _NETMR_ set WOL(Wake On Lan) mode.\n
S *          It also can block a packet such as \n
S *          IPv6 PING request from an all-node broadcasting, \n
S *          IPv6 PING request from a solicited mulitcasting address,\n
S *          IPv4 packets, \n
S *          and IPv6 packets.
S * 
S * <table>
S *    <tr> <td>7 ~ 6   </td> <td>5  </td> <td>4  </td> <td>3       </td> <td>2  </td> <td>1   </td> <td>0  </td> </tr>
S *    <tr> <td>Reserved</td> <td>ANB</td> <td>M6B</td> <td>Always 0</td> <td>WOL</td> <td>IP6B</td> <td>IP4B</td> </tr> 
S * </table>
S * - @ref NETMR_ANB
S * - @ref NETMR_M6B
S * - @ref NETMR_WOL
S * - @ref NETMR_IP6B
S * - @ref NETMR_IP4B
S * @sa getNETMR(), setNETMR()
S *
S */
S#define _NETMR_              (_W6100_IO_BASE_ + (0x4008 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Network Mode Register 2 address [R=W][0x00]
S * @details @ref _NETMR2_ set PPPoE mode.\n
S *          It also can select the destination hardware address to either Ethernet frame MAC or target MAC in the ARP-reply message
S * <table>
S *    <tr> <td>7   </td> <td>6 ~ 1</td> <td>0    </td> </tr>
S *    <tr> <td>DHAS</td> <td>6 ~ 1</td> <td>PPPoE</td> </tr>
S * </table>
S *   - @ref NETMR2_DHAS : @ref NETMR2_DHAS_ARP, @ref NETMR2_DHAS_ETH
S *   - @ref NETMR2_PPPoE
S * @sa getNETMR2(), setNETMR2()
S */
S#define _NETMR2_             (_W6100_IO_BASE_ + (0x4009 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PPP LCP request Timer Register address [R=W][0x28]
S * @details @ref _PTMR_ sets the time for sending LCP echo request.\n
S *          The unit of time is 25ms.
S * @sa _PMNR_, _PHAR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
S * @sa getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
S */
S#define _PTMR_               (_W6100_IO_BASE_ + (0x4100 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PPP LCP Magic Number Register address [R=W][0x00]
S * @details @ref _PMNR_ sets the 4bytes magic number to be used in LCP negotiation.
S * @sa _PTMR_, _PHAR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
S * @sa getPMNR(), setPMNR(), getPTMR(), setPTMR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
S */
S#define _PMNR_               (_W6100_IO_BASE_ + (0x4104 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PPPoE Hardware Address Register address [R=W][0x00]
S * @details @ref _PHAR_ sets the PPPoE server hardware address that is acquired during PPPoE connection process.
S * @sa _PTMR_, _PMNR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
S * @sa getPHAR(), setPHAR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
S */
S#define _PHAR_               (_W6100_IO_BASE_ + (0x4108 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PPP Session ID Register address [R=W][0X0000]
S * @details @ref  _PSIDR_ sets the PPPoE sever session ID acquired during PPPoE connection process.
S * @sa _PTMR_, _PMNR_, _PHAR_, _PMRUR_, NETMR2_PPPoE
S * @sa getPSIDR(), setPSIDR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
S */
S#define _PSIDR_              (_W6100_IO_BASE_ + (0x4110 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PPP Maximum Receive Unit Register address [R=W][0xFFFF]
S * @details @ref _PMRUR_ sets the maximum receive unit of PPPoE.
S * @sa _PTMR_, _PMNR_, _PHAR_, _PSIDR_, NETMR2_PPPoE
S * @sa  getPMRUR(), setPMRUR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getNETMR2(), setNETMR2()
S */
S#define _PMRUR_              (_W6100_IO_BASE_ + (0x4114 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Source Hardware Address Register address [R=W][00:00:00:00:00:00]
S * @details @ref _SHAR_ sets the source hardware address.
S * @note It can be accessed only when @ref SYSR_NETL is unlock.
S * @sa SYSR_NETL, _NETLCKR_
S * @sa getSHAR(), setSHAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK()
S */
S#define _SHAR_               (_W6100_IO_BASE_ + (0x4120 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv4 Gateway Address Register address [R=W][0.0.0.0]
S * @details @ref _GAR_ sets the default gateway IPv4 address.
S * @note It can be accessed only when @ref SYSR_NETL is unlock.
S * @sa SYSR_NETL, _NETLCKR_, _GA6R_
S * @sa getGAR(), setGAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getGA6R(), setGA6R()
S */
S#define _GAR_                (_W6100_IO_BASE_ + (0x4130 << 8) + WIZCHIP_CREG_BLOCK)
S#define _GA4R_               (_GAR_)      ///< Refer to @ref _GAR_
S/**
S * @brief IPv4 Subnet Mask Register address [R=W][0.0.0.0]
S * @details @ref _SUBR_ sets the default subnet mask address of IPv4.
S * @note It can be accessed only when @ref SYSR_NETL is unlock. 
S * @sa SYSR_NETL, _NETLCKR_, _SUB6R_
S * @sa getSUBR(), setSUBR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getSUB6R(), setSUB6R()
S */
S#define _SUBR_               (_W6100_IO_BASE_ + (0x4134 << 8) + WIZCHIP_CREG_BLOCK)
S#define _SUB4R_              (_SUBR_)      ///< Refer to @ref _SUBR_
S
S/**
S * @brief IPv4 Source IP Register address [R=W][0.0.0.0]
S * @details @ref _SIPR_ sets the source IPv4 address.
S * @note It can be accessed only when @ref SYSR_NETL is unlock. 
S * @sa SYSR_NETL, _NETLCKR_, _LLAR_, _GUAR_
S * @sa getSIPR(), setSIPR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getLLAR(), setLLAR(), getGUAR(),setGUAR()
S */
S#define _SIPR_               (_W6100_IO_BASE_ + (0x4138 << 8) + WIZCHIP_CREG_BLOCK)
S#define _SIP4R_              (_SIPR_)   ///< Refer to @ref _SIPR_.
S
S/**
S * @brief IPv6 LLA(Link Local Address) Register address [R=W][::]
S * @details @ref _LLAR_ sets the LLA address of IPv6.
S * @note It can be accessed only when @ref SYSR_NETL is unlock. 
S * @sa SYSR_NETL, _NETLCKR_, _GUAR_, _SIPR_
S * @sa getLLAR(), setLLAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getGUAR(),setGUAR(), getSIPR(), setSIPR()
S */
S#define _LLAR_               (_W6100_IO_BASE_ + (0x4140 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv6 GUA(Global Unicast Address) Register address [R=W][::]
S * @details @ref _GUAR_ sets the GUA address of IPv6.
S * @note It can be accessed only when @ref SYSR_NETL is unlock.  
S * @sa SYSR_NETL, _NETLCKR_, _LLAR_, _SIPR_
S * @sa getGUAR(), setGUAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getLLAR(),setLLAR(), getSIPR(), setSIPR()
S */
S#define _GUAR_               (_W6100_IO_BASE_ + (0x4150 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv6 Subnet Mask Register address [R=W][]
S * @details @ref _SUB6R_ sets the default subnet mask address of IPv6.
S * @note It can be accessed only when @ref SYSR_NETL is unlock. 
S * @sa SYSR_NETL, _NETLCKR_, _SUBR_
S * @sa getSUB6R(), setSUB6R(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getSUBR(), setSUBR()
S */
S#define _SUB6R_              (_W6100_IO_BASE_ + (0x4160 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv6 Gateway Address Register address [R/W][::]
S * @details @ref _GA6R_ sets the default gateway IPv6 address.
S * @sa _GAR_
S * @sa getGA6R(), setGA6R(), getGAR(), setGAR()
S */
S#define _GA6R_               (_W6100_IO_BASE_ + (0x4170 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Peer IPv6 Register address [R=W][::]
S * @details @ref _SLDIP6R_ sets the destination IP address of @ref _SLCR_.
S * @sa _SLDIP6R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_, _SLDHAR_, _SLDIPR_, _SLDIP4R_
S * @sa getSLDIP6R(), setSLDIP6R(), getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDHAR(),
S *     getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R()
S */
S#define _SLDIP6R_            (_W6100_IO_BASE_ + (0x4180 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Peer IPv6 Register address [R=W][0.0.0.0]
S * @details @ref _SLDIPR_(= @ref _SLDIP4R_) sets the destination IPv4 address of @ref _SLCR_.
S * @sa _SLDIP4R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_, _SLDHAR_, _SLDIP6R_
S * @sa getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDHAR(),
S *     getSLDIP6R(), setSLDIP6R()
S */
S#define _SLDIPR_             (_W6100_IO_BASE_ + (0x418C << 8) + WIZCHIP_CREG_BLOCK)
S#define _SLDIP4R_            (_SLDIPR_)            ///< Refer to @ref _SLDIPR_.
S
S
S/**
S * @brief SOCKET-less Peer Hardware Address Register address [RO][00:00:00:00:00:00]
S * @details @ref _SLDHAR_ gets the destination hardware address acquired by of @ref SLCR_ARP4, SLCR_ARP6, SLCR_PING4, and SLCR_PING6.
S * @sa _SLDIP4R_, _SLDIP6R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_
S * @sa getSLDHAR(), getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLCR(), setSLCR(), \n
S *     getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR() 
S */
S#define _SLDHAR_             (_W6100_IO_BASE_ + (0x4190 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Ping ID Register address [R=W][0x00]
S * @details @ref _PINGIDR_ sets the PING-request ID to be sent by @ref SLCR_PING4 or @ref SLCR_PING6.
S * @sa _SLCR_, _PINGSEQR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLIMR_
S * @sa getPINGIDR(), setPINGIDR(), getSLCR(), setSLCR(), getPINGSEQR(), setPINGSEQR(), getSLDIPR(), setSLDIPR(), 
S *     getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR()
S */
S#define _PINGIDR_            (_W6100_IO_BASE_ + (0x4198 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less ping Sequence number Register address [R=W][0x0000]
S * @details @ref _PINGIDR_ sets the PING-request sequence number to be sent by @ref SLCR_PING4 or @ref SLCR_PING6.
S * @sa _SLCR_, _PINGIDR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLIMR_
S * @sa getPINGSEQR(), setPINGSEQR(), getSLCR(), setSLCR(), getPINGIDR(), setPINGIDR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(),
S *     getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR()
S */
S#define _PINGSEQR_           (_W6100_IO_BASE_ + (0x419C << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv4 Unreachable Address Register address [RO][0.0.0.0]
S * @details @ref _UIPR_ is set when a unreachable ICMPv4 message is received.
S * @sa _UPORTR_, _UIP6R_, _UPORT6R_
S * @sa getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUIPR6(), setUIPR6(), getUPORT6R(), setUPORT6R()
S */
S#define _UIPR_               (_W6100_IO_BASE_ + (0x41A0 << 8) + WIZCHIP_CREG_BLOCK)
S#define _UIP4R_              (_UIPR_)   ///< Refer to @ref _UPORTR_
S
S/**
S * @brief IPv4 Unreachable Port number Register address [RO][0x0000]
S * @details @ref _UPORTR_ is set when a unreachable ICMPv4 message is received.
S * @sa _UIPR_, _UIP6R_, _UPORT6R_
S * @sa getUPORTR(), setUPORTR(), getUIPR(), setUIPR(), getUIPR6(), setUIPR6(), getUPORT6R(), setUPORT6R()
S */
S#define _UPORTR_             (_W6100_IO_BASE_ + (0x41A4 << 8) + WIZCHIP_CREG_BLOCK)
S#define _UPORT4R_            (_UPORTR_)   ///< Refer to @ref _UPORTR_
S/**
S * @brief IPv6 Unreachable IP Address Register address [RO][::]
S * @details @ref _UIP6R_ is set when a unreachable ICMPv6 message is received.
S * @sa _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_
S * @sa getUIPR6(), setUIPR6(), getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUPORT6R(), setUPORT6R()
S */
S#define _UIP6R_              (_W6100_IO_BASE_ + (0x41B0 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief IPv6 Unreachable Port number Register address [RO][0x0000]
S * @details @ref _UIP6R_ is set when a unreachable ICMPv6 message is received.
S * @sa _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_
S * @sa getUIPR6(), setUIPR6(), getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUPORT6R(), setUPORT6R()
S */
S#define _UPORT6R_            (_W6100_IO_BASE_ + (0x41C0 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Interrupt Pending Time Register address [R=w][0x0000]
S * @details @ref _INTPTMR_ pends the next interrupt issued by the INTn pin of @ref _WIZCHIP_.\n
S *          It is decreased 1 every 4 SYS_CLK. \n
S *          If it is zero and some interrupt is still remained, the INTn pin is issued.
S * @sa _IR_, _IRCLR_, _IMR_, _SIR_, _Sn_IRCLR_, _SIMR_, _SLIR_, _SLIRCLR_, _SLIMR_, SYCR_IEN
S * @sa getINTPTMR(), setINTPTMR(), getIR(), setIRCLR(), getIMR(), setIMR(), getSIR(), setSn_IRCLR(), getSIMR(), setSIMR(), \n
S *     getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSYCR1(), setSYCR1()
S */
S#define _INTPTMR_            (_W6100_IO_BASE_ + (0x41C5 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief RA Prefix Length Register address [RO][0x00]
S * @details @ref _PLR_ is set when RA packet is received from a router.
S * @sa SLIR_RA, _SLIRCLR_, _PFR_, _VLTR_, _PLTR_, _PAR_
S * @sa getPLR(), getSLIR(), setSLIRCLR(), getPFR(), getVLTR(), getPLTR(), getPAR()
S */
S#define _PLR_                (_W6100_IO_BASE_ + (0x41D0 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief RA Prefix Flag Register address [RO][0x00]
S * @details @ref _PFR_ is set when RA packet is received from a router.
S * @sa SLIR_RA, _SLIRCLR_, _PLR_, _VLTR_, _PLTR_, _PAR_
S * @sa getPFR(), getSLIR(), setSLIRCLR(), getPLR(), getVLTR(), getPLTR(), getPAR()
S */
S#define _PFR_                (_W6100_IO_BASE_ + (0x41D4 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief RA Valid Life Time Register address [RO][0x00000000]
S * @details @ref _VLTR_ is set when RA packet is received from a router.
S * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _PLTR_, _PAR_
S * @sa getVLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(),  getPLTR(), getPAR()
S */
S#define _VLTR_               (_W6100_IO_BASE_ + (0x41D8 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief RA Prefered Life Time Register address [RO][0x00000000]
S * @details @ref _PLTR_ is set when RA packet is received from a router.
S * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _PLTR_, _PAR_
S * @sa getPLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(), getVLTR(), getPAR()
S */
S#define _PLTR_               (_W6100_IO_BASE_ + (0x41DC << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief RA Prefix Address Register address[RO][::]
S * @details @ref _PAR_ is set when RA packet is received from a router.
S * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _VLTR_, _PLTR_, _PAR_
S * @sa getPAR(), getPLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(), getVLTR() 
S */
S#define _PAR_                (_W6100_IO_BASE_ + (0x41E0 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief ICMPv6 Block Register address [R=W][0x00]
S * @details @ref _ICMP6BLKR_ can block ICMPv6 message such like as PING, MLD, RA, NS and NA.\n
S *          In this blocked case, @ref Sn_MR_IPRAW6 SOCKET can receive it.
S * <table>
S *    <tr> <td>7 ~ 5</td> <td>4    </td> <td>3  </td> <td>2 </td> <td>1 </td> <td>0 </td> </tr>
S *    <tr> <td>7 ~ 5</td> <td>PING6</td> <td>MLD</td> <td>RA</td> <td>NA</td> <td>NS</td> </tr>
S * </table>
S *   - @ref ICMP6BLKR_PING6 : The same as @ref NETxMR_PB
S *   - @ref ICMP6BLKR_MLD
S *   - @ref ICMP6BLKR_RA
S *   - @ref ICMP6BLKR_NA
S *   - @ref ICMP6BLKR_NS
S *
S * @note The blocked message can be accepted by SOCKETn opened with @ref Sn_MR_IPRAW6.
S * @sa NETxMR_PB
S * @sa getICMP6BLKR(), setICMP6BLKR(), getNET6MR(), setNET6MR()
S */
S#define _ICMP6BLKR_          (_W6100_IO_BASE_ + (0x41F0 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Chip configuration Lock Register address [WO][0x00]
S * @details @ref _CHPLCKR_ can lock or unlock to access @ref _SYCR0_ and @ref _SYCR1_.\n
S *          The lock state can be checked from @ref SYSR_CHPL.
S * @sa _SYCR0_, _SYCR1_, _SYSR_, SYSR_CHPL
S * @sa getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define _CHPLCKR_            (_W6100_IO_BASE_ + (0x41F4 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Network configuration Lock Register address [WO][0x00]
S * @details @ref _NETLCKR_ can lock or unlock to access the network information register such as @ref _SIPR_, @ref _LLAR_, and etc.\n
S *          The lock state can be checked from @ SYSR_NETL.
S * @sa _SHAR_, _SIPR_, _SUBR_, _GAR_, _LLAR_, _GUAR_, _SUB6R_, _SYSR_, SYSR_NETL
S * @sa getNETLCKR(), setNETLCKR(), NETLOCK(), NETUNLOCK(), getSHAR(), setSHAR(), getSIPR(), getSIPR(), getSUBR(), setSUBR(), \n
S *     getGAR(), setGAR(), getLLAR(), setLLAR(), getGUAR(), setGUAR(), getSUB6R(), setSUB6R(), getSYSR()
S */
S#define _NETLCKR_            (_W6100_IO_BASE_ + (0x41F5 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief PHY configuration Lock Register address [WO][0x00]
S * @details @ref _PHYLCKR_ can lock or unlock to access @ref _PHYCR0_ and @ref _PHYCR1_.\n
S *          The lock state can be checked from @ref SYSR_PHYL.
S * @sa _PHYCR0_, _PHYCR1_, _SYSR_, SYSR_PHYL.
S * @sa getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), setPHYCR0(), getPHYCR1(), setPHYCR1(), getSYSR()
S */
S#define _PHYLCKR_            (_W6100_IO_BASE_ + (0x41F6 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Retransmission Time Register address [R=W][0x07D0]
S * @details @ref _RTR_ sets the default timeout value of @ref _Sn_RTR_.\n
S *          When @ref _Sn_RTR_ is 0, @ref _Sn_RTR_ is reset to @ref _RTR_ after @ref Sn_CR_OPEN.
S * @sa _Sn_RTR_, _RCR_, _Sn_RCR_, _Sn_CR_, Sn_CR_OPEN, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
S * @sa getRTR(), setRTR(), getSn_RTR(), setSn_RTR(), getRCR(), setRCR(), getSn_RCR(), setSn_RCR(),  \n
S *     getSn_CR(), getSn_CR(), getSn_IR(), setSn_IRCLR()
S */
S#define _RTR_                (_W6100_IO_BASE_ + (0x4200 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief Retransmission Counter Register address [R=W][0x08]
S * @details @ref _RCR_ sets the default retransmission count of @ref _Sn_RCR_.\n
S *          When @ref _Sn_RCR_ is 0, @ref _Sn_RCR_ is initialized as @ref _Sn_RTR_ after @ref Sn_CR_OPEN.
S * @sa _Sn_RCR_, _RTR_, _Sn_RTR_, _Sn_CR_, Sn_CR_OPEN, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
S * @sa getRCR(), setRCR(), getSn_RCR(), setSn_RCR(), getRTR(), setRTR(), getSn_RTR(), setSn_RTR(), \n 
S *     getSn_CR(), getSn_CR(), getSn_IR(), setSn_IRCLR()
S */
S#define _RCR_                (_W6100_IO_BASE_ + (0x4204 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Retransmission Time Register address [R=W][0x07D0]
S * @details @ref _SLRTR_ sets the timeout value of packet to be retransmitted by @ref _SLCR_.
S * @sa _SLRCR_, _SLIR_, _SLIRCLR_, SLIR_TOUT
S * @sa getSLRTR(), setSLRTR(), getSLRCR(), setSLRCR(), getSLIR(), setSLIRCLR() 
S */
S#define _SLRTR_              (_W6100_IO_BASE_ + (0x4208 << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Retransmission Count Register address [R=W][0x00]
S * @details @ref _SLRCR_ sets the retry counter of packet to be retransmitted by @ref _SLCR_.
S * @sa _SLRTR_, _SLIR_, _SLIRCLR_, SLIR_TOUT
S * @sa getSLRCR(), setSLRCR(), getSLRTR(), setSLRTR(), setSLIRCLR(), getSLIR(), setSLIRCLR(),
S */
S#define _SLRCR_              (_W6100_IO_BASE_ + (0x420C << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @brief SOCKET-less Hop Limit Register address [R=W][0x80]
S * @details @ref _SLHOPR_ sets the hop limit value of packet to be transmitted by @ref _SLCR_.
S * @sa _SLCR_
S * @sa getSLHOPR(), setSLHOPR(), getSLCR(), setSLCR()
S */
S#define _SLHOPR_             (_W6100_IO_BASE_ + (0x420F << 8) + WIZCHIP_CREG_BLOCK)
S
S/**
S * @}
S */
S
S//----------------------------- W6100 Socket Registers -----------------------------
S/**
S * @addtogroup Socket_register_group_W6100
S * @{
S */
S/**
S * @brief Socket Mode Register Address [R=W][0x00]
S * @details @ref _Sn_MR_ sets the option or protocol type of SOCKETn before @ref Sn_CR_OPEN is performed.\n\n
S *          Each bit of @ref _Sn_MR_ is defined as the following.
S * <table>
S *    <tr> <td>7       </td> <td>6        </td> <td>5            </td> <td>4        </td> <td>3 ~ 0 </td> </tr>
S *    <tr> <td>MULTI/MF</td> <td>BRDB/FPSH</td> <td>ND/MC/SMB/MMB</td> <td>UNIB/MMB6</td> <td>P[3:0]</td> </tr>
S * </table>
S *   - @ref Sn_MR_MULTI : Support UDP Multicasting
S *   - @ref Sn_MR_MF    : Support MAC Filter Enable
S *   - @ref Sn_MR_BRDB  : Broadcast Block
S *   - @ref Sn_MR_FPSH  : Force PSH flag
S *   - @ref Sn_MR_ND    : No Delay ACK flag
S *   - @ref Sn_MR_MC    : IGMP ver2, ver1
S *   - @ref Sn_MR_SMB   : Solicited Multicast Block
S *   - @ref Sn_MR_MMB   : IPv4 Multicast block
S *   - @ref Sn_MR_UNIB  : Unicast Block
S *   - @ref Sn_MR_MMB6  : IPv6 UDP Multicast Block
S *   - <b>P[3:0]</b>
S * <table>
S *    <tr> <td> P[3:0] </td> <td> Protocol Mode  </td> </tr>
S *    <tr> <td> 0000   </td> <td> SOCKET Closed  </td> </tr>
S *    <tr> <td> 0001   </td> <td> TCP4           </td> </tr>
S *    <tr> <td> 0010   </td> <td> UDP4           </td> </tr>
S *    <tr> <td> 0011   </td> <td> IPRAW4         </td> </tr>
S *    <tr> <td> 0100   </tr> <td> MACRAW         </td> </tr>
S *    <tr> <td> 1001   </td> <td> TCP6           </td> </tr>
S *    <tr> <td> 1010   </td> <td> UDP6           </td> </tr>
S *    <tr> <td> 1100   </td> <td> IPRAW6         </td> </tr>
S *    <tr> <td> 1101   </td> <td> TCP Dual(TCPD) </td> </tr>
S *    <tr> <td> 1110   </td> <td> UDP Dual (UDPD)</td> </tr>
S * </table>
S *   - @ref Sn_MR_CLOSE                      : SOCKET Closed
S *   - @ref Sn_MR_TCP4(= @ref Sn_MR_TCP)     : TCP4 mode
S *   - @ref Sn_MR_UDP4(= @ref Sn_MR_UDP)     : UDP4 mode
S *   - @ref Sn_MR_IPRAW4(= @ref Sn_MR_IPRAW) : IPRAW4 mode
S *   - @ref Sn_MR_MACRAW                     : MACRAW mode
S *   - @ref Sn_MR_TCP6                       : TCP6 mode
S *   - @ref Sn_MR_UDP6                       : UDP6 mode
S *   - @ref Sn_MR_IPRAW6                     : IPRAW6 mode
S *   - @ref Sn_MR_TCPD                       : TCP Dual (TCPD) mode
S *   - @ref Sn_MR_UDPD                       : UDP Dual (UDPD) mode
S *
S * @note MACRAW mode should be only used in Socket 0.
S * @sa _Sn_CR_, Sn_CR_OPEN, _Sn_SR_, _Sn_MR2_
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR(), getSn_MR2(), setSn_MR2()
S */
S#define _Sn_MR_(N)           (_W6100_IO_BASE_ + (0x0000 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKET n Prefer Source IPv6 Address Register Address [R=W][0x00]
S * @details @ref _Sn_PSR_ select the Source IPv6 Address to transmit a packet by @ref _Sn_CR_.
S * This function is same as @ref _SLPSR_.
S *   - @ref PSR_AUTO 
S *   - @ref PSR_LLA 
S *   - @ref PSR_GUA 
S * @sa _Sn_CR_, _Sn_PSR_, _SLPSR_
S * @sa getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSLPSR(), setSLPSR(), 
S */
S #define _Sn_PSR_(N)         (_W6100_IO_BASE_ + (0x0004 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief Socket Command Register Address [RW,AC][0x00]
S * @details @ref _Sn_CR_ is used to set the command for SOCKET n such as OPEN, CLOSE, CONNECT, LISTEN, SEND, and RECEIVE.\n
S *          It is automatically cleared to 0x00 after the command is recognized by @ref _WIZCHIP_.\n
S *          Even though @ref _Sn_CR_ is cleared to 0x00, the command is still being processed.\n
S *          To check whether the command is completed or not, please check the @ref _Sn_IR_ or @ref _Sn_SR_.
S *   - @ref Sn_CR_OPEN            : Initialize or open socket.
S *   - @ref Sn_CR_LISTEN       : Wait connection request on TCP4/TCP6/TCPD mode(<b>Server mode</b>)
S *   - @ref Sn_CR_CONNECT      : Send connection request on TCP4/TCPD mode(<b>Client mode</b>)
S *   - @ref Sn_CR_CONNECT6  : Send connection request on TCP6/TCPD mode(<b>Client mode</b>):nohl
S *   - @ref Sn_CR_DISCON       : Send closing request on TCP/TCP6/TCPD mode.
S *   - @ref Sn_CR_CLOSE        : Close socket.
S *   - @ref Sn_CR_SEND            : Update TX buffer pointer and send data in IPv4 socket.
S *   - @ref Sn_CR_SEND6        : Update TX buffer pointer and send data in IPv6 socket.
S *   - @ref Sn_CR_SEND_KEEP : Send keep alive message.
S *   - @ref Sn_CR_RECV            : Update RX buffer pointer and receive data.
S *
S * @note These commands should be exclusive executed.\n That is, the other command can not executed when one command is not cleared yet.
S * @sa _Sn_IR_, _Sn_IRCLR_, Sn_IMR_, _SIR_, _Sn_SR_
S * @sa getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), getSIR(), getSn_SR()
S */
S#define _Sn_CR_(N)           (_W6100_IO_BASE_ + (0x0010 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Interrupt Register Address [RO][0x00]
S * @details @ref _Sn_IR_ gets the status of SOCKETn interrupt such as establishment, termination, receiving data, timeout.\n
S *          If SOCKETn interrupt occurs and the n-th bit of @ref _SIMR_ is set, then @ref SIR_INT(n) is set.\n
S *          In order to clear the @ref _Sn_IR_ bit, Set the corresponding bit of _Sn_IRCLR_ to 1.\n
S *          If all @ref _Sn_IR_ bits are cleared, the @ref SIR_INT(n) is automatically cleared.
S * <table>
S *     <tr> <td>7 ~ 5   </td> <td>4     </td> <td>3      </td> <td>2   </td> <td>1     </td> <td>0  </td> </tr>
S *     <tr> <td>Reserved</td> <td>SENDOK</td> <td>TIMEOUT</td> <td>RECV</td> <td>DISCON</td> <td>CON</td> </tr>
S * </table>
S *   - @ref Sn_IR_SENDOK 
S *   - @ref Sn_IR_TIMEOUT 
S *   - @ref Sn_IR_RECV 
S *   - @ref Sn_IR_DISCON 
S *   - @ref Sn_IR_CON 
S *  
S * @sa _Sn_IRCLR_, _Sn_IMR_, _SIR_, _SIMR_
S * @sa getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), getSIR(), getSIMR(), setSIMR()
S */
S#define _Sn_IR_(N)           (_W6100_IO_BASE_ + (0x0020 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Interrupt Mask Register Address [R=W][0xFF]
S * @details @ref _Sn_IMR_ is used to mask interrupts of @ref _Sn_IR_.
S * @sa _Sn_IR_, _Sn_IRCR_, _SIR_, _SIMR_
S * @sa getSn_IMR(), setSn_IMR(), getSn_IR(), setSn_IRCLR(), getSIR(), getSIMR(), setSIMR()
S */
S#define _Sn_IMR_(N)          (_W6100_IO_BASE_ + (0x0024 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Interrupt Clear Register Address [WO][0x00]
S * @details @ref _Sn_IRCLR_ clears @ref _Sn_IR_
S * @sa _Sn_IR_, _SIR_, _SIMR_
S * @sa setSn_IRCLR(), getSn_IR(), getSIR(), getSIMR(), setSIMR()
S */
S#define _Sn_IRCLR_(N)        (_W6100_IO_BASE_ + (0x0028 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S
S
S/**
S * @brief SOCKETn Status Register Address [RO][0x00]
S * @details @ref _Sn_SR_ indicates the status of SOCKETn.\n
S *          The status of SOCKETn can be changed by @ref _Sn_CR_, some TCP packets such as SYN, FIN, RST packet, or @ref Sn_IR_TIMEOUT.
S *  - Normal status
S *    - @ref SOCK_CLOSED      : Closed
S *    - @ref SOCK_INIT        : Initiate state
S *    - @ref SOCK_LISTEN      : Listen state
S *    - @ref SOCK_ESTABLISHED : Success to connect
S *    - @ref SOCK_CLOSE_WAIT  : Closing state
S *    - @ref SOCK_UDP         : UDP socket
S *    - @ref SOCK_IPRAW       : IPRAW socket
S *    - @ref SOCK_IPRAW6      : IPv6 IPRAW socket
S *    - @ref SOCK_MACRAW      : MAC raw mode socket
S *  - Temporary status during changing the status of SOCKETn .
S *    - @ref SOCK_SYNSENT     : This indicates SOCKETn  sent the connect-request packet (SYN packet) to a peer.
S *    - @ref SOCK_SYNRECV     : It indicates SOCKETn  successfully received the connect-request packet (SYN packet) from a peer.
S *    - @ref SOCK_FIN_WAIT    : Connection state
S *    - @ref SOCK_TIME_WAIT   : Closing state
S *    - @ref SOCK_LAST_ACK    : Closing state
S *
S * @sa _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT 
S * @sa getSn_SR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR()
S * 
S *  <table width=0 >
S *     <tr> <td>@image html SocketStatus.png "<SOCKETn Status Transition>"</td> </tr>
S *  </table>
S *
S */
S#define _Sn_SR_(N)           (_W6100_IO_BASE_ + (0x0030 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Extension Status Register Address [RO][0x00]
S * @details @ref _Sn_ESR_ indicates the connected client IP address information such as IP version, IPv6 address type(LLA or GUA), \n
S *          and TCP operation mode such as <b>TCP SERVER</b> and <b>TCP CLIENT</b>
S * <table>
S *    <tr> <td> 7 ~ 3   </td> <td>2   </td> <td>1    </td> <td>0   </td> </tr> 
S *    <tr> <td> Reserved</td> <td>TCPM</td> <td>TCPOP</td> <td>IP6T</td> </tr> 
S * </table>
S * - @ref Sn_ESR_TCPM  : @ref Sn_ESR_TCPM_IPV4, @ref Sn_ESR_TCPM_IPV6
S * - @ref Sn_ESR_TCPOP : @ref Sn_ESR_TCPOP_SVR, @ref Sn_ESR_TCPOP_CLT
S * - @ref Sn_ESR_IP6T  : @ref Sn_ESR_IP6T_LLA,  @ref Sn_ESR_IP6T_GUA
S * 
S * @note It is valid only on TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_MR_, _Sn_PSR_
S * @sa getSn_ESR(), getSn_MR(), setSn_MR(), getSn_PSR(), setSn_PSR()
S */
S#define _Sn_ESR_(N)          (_W6100_IO_BASE_ + (0x0031 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn IP Protocol Number(PN) Register Address [R/W][0x0000]
S * @details \ref _Sn_PNR_ that sets the protocol number/next header field of the IPv4/IPv6 header at the IP layer.
S * @note It is valid only in IPRAW mode such as @ref Sn_MR_IPRAW4 and @ref Sn_MR_IPRAW6.
S * @note It is set before @ref Sn_CR_OPEN is performed.
S * @sa _Sn_NHR_, _Sn_MR_, Sn_CR_OPEN
S * @sa getSn_PNR(), setSn_PNR(), getSn_NHR(), setSn_NHR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
S */
S#define _Sn_PNR_(N)          (_W6100_IO_BASE_ + (0x0100 << 8) + WIZCHIP_SREG_BLOCK(N))
S#define _Sn_NHR_(N)          (_Sn_PNR_(N))      ///< Refer to @ref _Sn_PNR_.
S
S/**
S * @brief SOCKETn IPv4 Type of Service(TOS) Register Address [R=W][0x00]
S * @details @ref _Sn_TOSR_ sets the TOS(Type Of Service) field in IPv4 Header.
S * @sa getSn_TOSR(), setSn_TOSR()
S */
S#define _Sn_TOSR_(N)         (_W6100_IO_BASE_ + (0x0104 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn IP Time to live(TTL) Register Address [R=W][0x80]
S * @details @ref _Sn_TTLR_ sets the TTL(Time To Live)/HOP(Hop Limit) field in IPv4/IPv6 header at the IP layer.
S * @sa _Sn_HOPR_
S * @sa getSn_TTLR(), setSn_TTLR(), getSn_HOPR(), setSn_HOPR()
S */
S#define _Sn_TTLR_(N)         (_W6100_IO_BASE_ + (0x0108 << 8) + WIZCHIP_SREG_BLOCK(N))
S#define _Sn_HOPR_(N)         (_Sn_TTLR_(N))   ///< Refer to @ref _Sn_TTLR_.
S
S/**
S * @brief SOCKETn Fragment Register Address [R=W][0x4000]
S * @details @ref _Sn_FRGR_ sets the fragment flag & offset in IPv4 header.
S * @note @ref _WIZCHIP_ can not support IP fragment & re-assembly.\n So It is not recommended to set @ref _Sn_FRGR_ to any other value.
S * @sa getSn_FRGR(), setSn_FRGR()
S */
S#define _Sn_FRGR_(N)         (_W6100_IO_BASE_ + (0x010C << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Maximum Segment Size(MSS) Register Address [RW][0x0000]
S * @details @ref _Sn_MSSR_ sets or gets the MTU(Maximum Transfer Unit) of SOCKETn. \n
S *          The MTU of each protocol is as following.
S * <table>
S *    <tr> <td> @ref _Sn_MR_[3:0] </td> <td>@ref NETMR2_PPPoE = 0 </td> <td>@ref NETMR2_PPPoE = '1'</td> </tr>
S *    <tr> <td> @ref Sn_MR_TCP4   </td> <td> 1 ~ 1460             </td> <td> 1 ~ 1452              </td> </tr>
S *    <tr> <td> @ref Sn_MR_TCP6   </td> <td> 1 ~ 1440             </td> <td> 1 ~ 1432              </td> </tr>
S *    <tr> <td> @ref Sn_MR_UDP4   </td> <td> 1 ~ 1472             </td> <td> 1 ~ 1464              </td> </tr>
S *    <tr> <td> @ref Sn_MR_UDP6   </td> <td> 1 ~ 1452             </td> <td> 1 ~ 1444              </td> </tr>
S *    <tr> <td> @ref Sn_MR_IPRAW4 </td> <td> 1 ~ 1480             </td> <td> 1 ~ 1472              </td> </tr>
S *    <tr> <td> @ref Sn_MR_IPRAW6 </td> <td> 1 ~ 1460             </td> <td> 1 ~ 1452              </td> </tr>
S *    <tr> <td> @ref Sn_MR_MACRAW </td> <td colspan = "2">      1 ~ 1514                                              </td> </tr>
S * </table>
S *
S * @note It is not set exceeding the MTU for each protocol of SOCKETn even if _Sn_MSSR_ is set over the MTU.
S * @sa _Sn_MR_, NETMR2_PPPoE
S * @sa getSn_MSSR(), setSn_MSSR(), getSn_MR(), setSn_MR(), getNETMR2(), setNETMR2()
S */
S#define _Sn_MSSR_(N)         (_W6100_IO_BASE_ + (0x0110 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Source Port Register Address [R=W][0x0000]
S * @details @ref _Sn_PORTR_ sets the source port number of SOCKETn .
S * @note It is valid in TCP(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6, @ref Sn_MR_TCPD) and UDP(@ref Sn_MR_UDP4, @ref Sn_MR_UDP6, @ref Sn_MR_UDPD) mode.
S * @note It should be set before @ref Sn_CR_OPEN is performed.
S * @sa _Sn_MR_, Sn_CR_OPEN
S * @sa getSn_PORTR(), getSn_PORTR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
S*/
S#define _Sn_PORTR_(N)        (_W6100_IO_BASE_ + (0x0114 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Destination Hardware Address Register Address [RW][00:00:00:00:00:00]
S * @details @ref _Sn_DHAR_ sets or gets the destination hardware address of SOCKETn.\n
S *   - When @ref Sn_MR2_DHAM = 1 and @ref _Sn_MR_[3:0] != @ref Sn_MR_MACRAW
S *     The destination hardware address is set by @ref _Sn_DHAR_ without ARP processed by @ref Sn_CR_CONNECT, @ref Sn_CR_CONNECT6, @ref Sn_CR_SEND, and @ref Sn_CR_SEND6.\n
S *     Also, when SOCKETn is opened with @ref Sn_MR_UDP4 or @ref Sn_MR_UDP6 and @ref Sn_MR_MULTI is set, @ref _Sn_DHAR_ sets the Multicast Group Hardware address.
S *   - Others
S *     In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD, \n
S *     @ref _Sn_DHAR_ gets the destination hardware address when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
S * @sa _Sn_MR_, _Sn_MR2_, _Sn_CR_, _Sn_SR_
S * @sa getSn_DHAR(), setSn_DHAR(), getSn_MR(), setSn_MR(), getSn_MR2(), setSn_MR2(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define _Sn_DHAR_(N)         (_W6100_IO_BASE_ + (0x0118 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Destination IPv4 Address Register Address [RW][0.0.0.0]
S * @details @ref _Sn_DIPR_(= @ref _Sn_DIP4R_) sets or gets the destination IPv4 address of SOCKETn. \n
S *   - In TCP mode such as @ref Sn_MR_TCP4, and @ref Sn_MR_TCPD
S *      - <b>TCP CLIENT</b> mode : It sets the IPv4 address of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT is performed. 
S *      - <b>TCP SERVER</b> mode : It gets the IPv4 address of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
S *   - In UDP(@ref Sn_MR_UDP4, @ref Sn_MR_UDPD) mode & IPRAW4(@ref Sn_MR_IPRAW4) mode
S *     It sets the destination IPv4 address before @ref Sn_CR_SEND is performed. \n
S *     When Sn_MR_MULTI = 1, It sets the multicast group IPv4 address.
S * @sa _Sn_DIP4R_, _Sn_MR_, _Sn_CR_, _Sn_SR_ 
S * @sa getSn_DIPR(), getSn_DIPR(), getSn_DIP4R(), getSn_DIP4R(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define _Sn_DIPR_(N)         (_W6100_IO_BASE_ + (0x0120 << 8) + WIZCHIP_SREG_BLOCK(N))
S#define _Sn_DIP4R_(N)        (_Sn_DIPR_(N))            ///< Refer to @ref _Sn_DIPR_.
S
S/**
S * @brief SOCKETn Destination IPv6 Address Register Address [RW][::]
S * @details @ref _Sn_DIP6R_ sets or gets the destination IPv6 address of SOCKETn.
S *   - In TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
S *      - <b>TCP CLIENT</b> mode : It sets the IPv6 address of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT6 is performed. 
S *      - <b>TCP SERVER</b> mode : It gets the IPv6 address of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
S *   - In UDP(@ref Sn_MR_UDP6, @ref Sn_MR_UDPD) mode & IPRAW4(@ref Sn_MR_IPRAW6) mode
S *     It sets the destination IPv6 address before @ref Sn_CR_SEND6 is performed.\n
S *     When Sn_MR_MULTI = 1, It sets the multicast group IPv6 address.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
S * @sa getSn_DIP6R(), setSn_DIP6R(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define _Sn_DIP6R_(N)        (_W6100_IO_BASE_ + (0x0130 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Destination Port Register Address [RW][0x0000]
S * @details @ref _Sn_DPORTR_ sets or gets the destination port number of SOCKETn.
S *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
S *      - <b>TCP CLIENT</b> mode : It sets the port number of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT is performed.
S *      - <b>TCP SERVER</b> mode : It gets the port number of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
S *   - In UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD
S *     It sets the destination port number before @ref Sn_CR_SEND is performed. \n
S *     When Sn_MR_MULTI = 1, It sets the multicast group group port number.
S *
S * @note It is valid SOCKETn is opened with @ref Sn_MR_TCP4,  @ref Sn_MR_TCP6, @ref Sn_MR_TCPD, @ref Sn_MR_UDP4, @ref Sn_MR_UDP4, and @ref Sn_MR_UDPD.
S * @note It should be set before OPEN command is ordered.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_ 
S * @sa getSn_DPORTR(), getSn_DPORTR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define _Sn_DPORTR_(N)       (_W6100_IO_BASE_ + (0x0140 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Mode Register 2 Address [R=W][0x00]
S * @details @ref _Sn_MR2_ sets the option of SOCKETn with @ref _Sn_MR_, before @ref Sn_CR_OPEN is performed.\n
S *          Each bit of @ref _Sn_MR2_ is defined as the following.
S * <table>
S *    <tr> <td>7 ~ 2   </td> <td>1   </td> <td>0   </td> </tr>
S *    <tr> <td>Reserved</td> <td>DHAM</td> <td>FARP</td> </tr>
S * </table>
S *   - @ref Sn_MR2_DHAM : @ref Sn_MR2_DHAM_AUTO, @ref Sn_MR2_DHAM_MANUAL
S *   - @ref Sn_MR2_FARP
S * @sa _Sn_MR_, _Sn_CR_
S * @sa getSn_MR2(), setSn_MR2(), getSn_MR(), getSn_MR(), getSn_CR()
S */
S#define _Sn_MR2_(N)          (_W6100_IO_BASE_ + (0x0144 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S
S/**
S * @brief SOCKETn Retransmission Time Register Address [R=W][0x0000]
S * @details @ref _Sn_RTR_ sets the timeout value of packet to be retransmitted by @ref _SLCR_.\n
S * @note It should be set before @ref Sn_CR_OPEN is performed.\n
S *       It is initialized as @ref _RTR_ if you do not set it to none-zero value.
S * @sa _RTR_, _Sn_CR_
S * @sa getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
S */
S#define _Sn_RTR_(N)          (_W6100_IO_BASE_ + (0x0180 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Retransmission Count Register Address [R=W][0x00]
S * @details @ref _Sn_RCR_ sets the retry count value of packet to be retransmitted by @ref _SLCR_.\n
S * @note It should be set before @ref Sn_CR_OPEN is performed.\n
S *       It is initialized as @ref _RTR_ if you do not set it to any none-zero value.
S * @sa _RTR_, _Sn_CR_
S * @sa getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
S */
S#define _Sn_RCR_(N)          (_W6100_IO_BASE_ + (0x0184 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn Keep Alive Time Register Address [R=W][0x00]
S * @details @ref _Sn_KPALVTR_ sets the auto-retransmission time of KA(Keep Alive) packet. \n
S *          If the destination can not respond to the KA packet during the time set by @ref _Sn_KPALVTR_,\n
S *          the connection is terminated, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed @ref SOCK_CLOSED.\n
S *          Before the time is expierd, if the destination sends a KA/ACK packet or any packet, the connection is still valid,\n
S *          @ref _Sn_SR_ remained at @ref SOCK_ESTABLISHED.
S * @note It is valid only after sending data over 1 byte in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @note If it is set to 0, KA packet can be sent by @ref Sn_CR_SEND_KEEP.
S * @sa Sn_CR_SEND_KEEP, Sn_IR_TIMEOUT, Sn_IRCLR, Sn_SR, Sn_MR
S * @sa getSn_KPALVTR(), setSn_KPALVTR(), getSn_IR(), setSn_IRCLR(), getSn_SR(), getSn_MR(), setSn_MR()
S */
S#define _Sn_KPALVTR_(N)      (_W6100_IO_BASE_ + (0x0188 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn TX Buffer Size Register Address [R=W][0x02]
S * @details @ref _Sn_TX_BSR_ sets the TX buffer size of SOCKETn in the 16KB TX memory.\n
S *          It can be set only with 0,1,2,4,8, and 16K bytes.
S * @note The 16KB TX memory is allocated as many as @ref _Sn_TX_BSR_ sequentially from SOCKET0 to SOCKETn(Here, 0 <= n <= @ref _WIZCHIP_SOCK_NUM_ - 1).\n
S *       The total sum of Sn_TX_BSR can not be exceed 16KB of TX memory. \n
S *       If the total size is exceeded, SOCKETn can't be normally sent data to a destination.
S * @sa _Sn_RX_BSR_
S * @sa getSn_TX_BSR(), setSn_TX_BSR(), getSn_TXBUF_SIZE(), setSn_TXBUF_SIZE(), getSn_TxMAX(), setSn_TX_BSR(), getSn_RX_BSR(), setSn_RX_BSR()
S */
S#define _Sn_TX_BSR_(N)       (_W6100_IO_BASE_ + (0x0200 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn TX Free Buffer Size Register Address [RO][0x0800]
S * @details @ref _Sn_TX_FSR_ gets the transmittable free size of SOCKETn TX buffer.
S * @note Data should not be saved bigger than it because the data overwrites the previous saved data not to be sent yet.\n
S *       Therefore, Check it before saving the data to the SOCKETn TX buffer. \n
S *       If the data size is equal or smaller than it, transmit the data with @ref Sn_CR_SEND / @ref Sn_CR_SEND6 after saving the data in SOCKETn TX buffer.\n
S *       If the data size is greater than it, transmit the data after dividing into it and saving in the SOCKETn TX buffer.
S * @note \n
S *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD, \n
S *     It is automatically increased by the absolute difference between @ref _Sn_TX_WR_ and interanl TX ACK pointer.
S *   - In other mode \n
S *     It is automatically increased by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_.
S * @sa _Sn_RX_RSR_, _Sn_TX_WR_, _Sn_TX_RD_, _Sn_CR_
S * @sa getSn_TX_FSR(), getSn_TX_WR(), getSn_TX_WR(), getSn_TX_RD(), getSn_CR(), setSn_CR()
S */
S#define _Sn_TX_FSR_(N)       (_W6100_IO_BASE_ + (0x0204 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKET TX Memory Read Pointer Register Address[R][0x0000]
S * @details @ref _Sn_TX_RD_ gets the start pointer of data to be sent by @ref Sn_CR_SEND. \n
S *          @ref Sn_CR_SEND / @ref Sn_CR_SEND6 starts to transmit the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX Buffer,\n
S *          and when @ref Sn_IR_SENDOK is set, It is automatically increased to equal @ref _Sn_TX_WR_.
S * @note It is initialized by @ref Sn_CR_OPEN, But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
S *       it is re-initialized when the TCP connection is completed.
S * @note If it exceeds the maximum value 0xFFFF, (that is, it is greater than 0x10000 and the carry bit occurs),\n
S *       then the carry bit is ignored and it automatically is updated with its the lower 16bits value.
S * @sa _Sn_TX_WR_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
S * @sa getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
S */
S#define _Sn_TX_RD_(N)        (_W6100_IO_BASE_ + (0x0208 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S
S/**
S * @brief SOCKETn TX Memory Write Pointer Register Address [RW][0x0000]
S * @details @ref _Sn_TX_WR_ gets the start pointer of data to be saved in the SOCKETn TX buffer, \n
S *          or sets the end pointer of data to be sent by @ref Sn_CR_SEND. \n
S *          If you have completed to save the data to be sent in the SOCKETn TX buffer,
S *          increase it as many as the saved size of data before @ref Sn_CR_SEND is performed.\n
S *          @ref Sn_CR_SEND starts to transmit the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX Buffer, \n
S *          and when @ref Sn_IR_SENDOK is set, @ref _Sn_TX_RD_ is automatically increased to equal it.
S * @note It is initialized by @ref Sn_CR_OPEN.\n
S *       But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
S *       it is re-initialized when the TCP connection is completed.
S * @note The size of data to be saved can't exceed @ref _Sn_TX_FSR_.
S * @note If it exceeds the maximum value 0xFFFF(that is, it is greater than 0x10000 and the carry bit occurs),\n
S *       then ignore the carry bit and update it with its lower 16bits value.
S * @sa _Sn_TX_RD_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
S * @sa getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
S */
S#define _Sn_TX_WR_(N)        (_W6100_IO_BASE_ + (0x020C << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn RX Buffer Size Register Address [R=W][0x02]
S * @details @ref _Sn_RX_BSR_ sets the RX buffer size of SOCKETn in the 16KB RX memory.\n
S *          It can be set only with 0,1,2,4,8, and 16K bytes.
S * @note The 16KB RX memory is allocated as many as @ref _Sn_RX_BSR_ sequentially from SOCKET0 to SOCKETn(Here, 0 <= n <= @ref _WIZCHIP_SOCK_NUM_ - 1).\n
S *       The total sum of @ref _Sn_RX_BSR_ can not be exceed 16KB of RX memory. \n
S *       If the total size is exceeded, SOCKETn can't be normally received data from a destination.
S * @sa _Sn_RX_BSR_
S * @sa getSn_TX_BSR(), setSn_TX_BSR(), getSn_RXBUF_SIZE(), setSn_RXBUF_SIZE(), getSn_RxMAX(), getSn_RX_BSR(), setSn_RX_BSR()
S */
S#define _Sn_RX_BSR_(N)       (_W6100_IO_BASE_ + (0x0220 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn RX Received Size Register Address [RO][0x0000]
S * @details @ref _Sn_RX_RSR_ gets the received data size of SOCKETn RX buffer.
S * @note The real received data size maybe smaller than it, \n
S *       because it maybe included the size of 'PACKET NFO' such like as \n
S *       the destination IP address, destination port number and data size of the received DATA PACKET.
S * @note Do not read bigger data than @ref _Sn_RX_RSR_.
S * @note It is automatically increased by the absolute difference between @ref _Sn_RX_WR_ and @ref _Sn_RX_RD_ \n
S *       after @ref Sn_CR_RECV is performed.
S * @sa _Sn_RX_RSR_, _Sn_TX_WR_, _Sn_TX_RD_, _Sn_CR_, _Sn_TX_FSR_
S * @sa getSn_RX_RSR(), getSn_TX_WR(), getSn_TX_WR(), getSn_CR(), setSn_CR(), getSn_TX_FSR()
S */
S#define _Sn_RX_RSR_(N)       (_W6100_IO_BASE_ + (0x0224 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKET RX Memory Read Pointer Register Address[R][0x0000]
S * @details @ref _Sn_RX_RD_ gets the start pointer of the received data in the SOCKETn RX buffer,\n
S *          or sets the end data pointer of the read completed data by @ref Sn_CR_RECV. \n
S *          You can read the received data from it to @ref _Sn_RX_WR_ in the SOCKET RX buffer.\n
S *          After completing to read data, you should increase it as many as the read size before @ref Sn_CR_RECV is performed.
S * @note It is initialized by @ref Sn_CR_OPEN, But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
S *       it is re-initialized when the TCP connection is completed.
S * @note If it exceeds the maximum value 0xFFFF, (that is, it is greater than 0x10000 and the carry bit occurs),\n
S *       Ignore the carry bit and update with its the lower 16bits value.
S * @sa _Sn_RX_WR_, _Sn_RX_RSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
S * @sa getSn_RX_WR(), setSn_RX_RD(), getSn_RX_WR(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
S */
S#define _Sn_RX_RD_(N)        (_W6100_IO_BASE_ + (0x0228 << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @brief SOCKETn TX Memory Write Pointer Register Address [RW][0x0000]
S * @details @ref _Sn_TX_WR_ gets the end pointer of the data that has been completely received in the SOCKETn RX buffer. \n
S *          Whenever a data has been completely received from a destination, \n
S *          It is automatically increased as many as the sum size of the received data and the 'PACKET INFO'. \n
S *          You can read the recevied data from @ref _Sn_RX_RD_ to it in the SOCKET RX buffer.
S * @note It is initialized by @ref Sn_CR_OPEN. But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
S *       it is re-initialized when the TCP connection is completed.
S * @note If it exceeds the maximum value 0xFFFF(that is, it is greater than 0x10000 and the carry bit occurs),\n
S *       then ignore the carry bit and update it with its lower 16bits value.
S * @sa _Sn_TX_RD_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, Sn_IRCLR_, _Sn_MR_
S * @sa getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
S */
S#define _Sn_RX_WR_(N)        (_W6100_IO_BASE_ + (0x022C << 8) + WIZCHIP_SREG_BLOCK(N))
S
S/**
S * @}
S */
S
S/*----------------------------- W6100 Register values  -----------------------------*/
S
S/* System Status Register Bit Definition */
S/**
S * @brief CHIP Lock staus bit of @ref _SYSR_.
S * @details @ref SYSR_CHPL indicates the lock status of @ref _SYCR0_ and @ref _SYCR1_.\n
S *          1 : Lock \n
S *          0 : unlock 
S * @note It is set by only @ref _CHPLCKR_.
S * @sa _SYSR_, _CHPLCKR_, _SYCR0_, _SYCR1_
S * @sa getSYSR(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), setSYCR0(), setSYCR1()
S */
S#define SYSR_CHPL            (1 << 7)
S
S/**
S * @brief NET Lock status bit of @ref _SYSR_.
S * @details @ref SYSR_NETL indicates the lock of network information registers such as 
S *          @ref _SHAR_, @ref _GAR_, @ref _SUBR_, @ref _SIPR_, @ref _LLAR_, @ref _GUAR_, and @ref _SUB6R_. \n
S *          1 : Lock \n
S *          0 : unlock 
S * @note It is set by only @ref _NETLCKR_.
S * @note @ref _GA6R_ can be accessed regardless of @ref SYSR_NETL.
S * @sa _SYSR_, _NETLCKR_, _SHAR_, _GAR_, _SUBR_, _SIPR_, _LLAR_, _GUAR_, _SUB6R_
S * @sa getSYSR(), getNETLCKR(), setNETLCKR(), NETLOCK(), NETUNLOCK(),\n
S *     getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), getSIR(), setSIPR(), \n
S *     getLLAR(), setLLAR(), getGUAR(),setGUAR(), getSUB6R(), setSUB6R()
S */
S#define SYSR_NETL            (1 << 6)
S
S/**
S * @brief PHY Lock status bit of @ref _SYSR_. Refer to @ref _PHYLCKR_.
S * @details @ref SYSR_PHYL indicates the lock status of @ref _PHYCR0_ and _PHYCR1_.\n
S *          1 : Lock \n
S *          0 : unlock
S * @note It is set by only @ref _PHYLCKR_.
S * @sa _SYSR_, _PHYCLKR_, _PHYCR0_, _PHYCR1_
S * @sa getSYSR(), getPHYLCKR(), setPHYLCKR(), setPHYCR0(), getPHYCR1(), setPHYCR1()
S */
S#define SYSR_PHYL            (1 << 5)
S
S/**
S * @brief Parallel Bus Mode bit of @ref _SYSR_
S * @details @ref SYSR_IND is set when @ref _WIZCHIP_ PIN MODE[3:0] == "010X".
S *          It indicates to use the parallel BUS mode. 
S * @sa _SYSR_, _WIZCHIP_IO_MODE_BUS_
S * @sa getSYSR()
S */
S#define SYSR_IND             (1 << 5)
S
S/**
S * @brief SPI I/F Mode bit of @ref _SYSR_.
S * @details @ref SYSR_SPI is set when @ref _WIZCHIP_ PIN MODE[3:0] == "000X".
S *          It indicates to use the SPI mode.
S * @sa _SYSR_, _WIZCHIP_IO_MODE_SPI_
S * @sa getSYSR()
S */
S#define SYSR_SPI             (1 << 0)
S
S
S/* System Config Register Bit Definition */
S/**
S * @brief RST bit of @ref _SYCR0_
S * @details @ref SYCR0_RST resets to @ref _WIZCHIP_ softly. \n
S *          0 : Soft reset \n
S *          1 : Normal operation
S * @note It can be set only when @ref SYSR_CHPL = 1.
S * @sa _SYSR0_, _CHPLCKR_, _SYSR_, SYSR_CHPL
S * @sa setSYCR0(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
S */
S#define SYCR0_RST            (0x00)
S
S/**
S * @brief IEN bit of @ref _SYCR1_.
S * @details @ref SYCR1_IEN is globally enable or disable the interrupt of @ref _WIZCHIP_,\n
S *          regardless of the related interrupt mask registers such as @ref _IMR_, @ref _SIMR_, @ref _SLIMR_, and @ref _Sn_IMR_.\n
S *          1 : Enable  \n
S *          0 : Disable
S * @sa _SYCR1_, _IR_, _SIR_, _SLIR_, _Sn_IR_, _IRCLR_,  _SLIRCLR_, _Sn_IRCLR_
S * @sa getSYCR1(), setSYCR1(), getIR(), getSIR(), getSLIR(), getSn_IR(), setIRCLR(), setSLIRCLR(), setSn_IRCLR()
S */
S#define SYCR1_IEN            (1 << 7)
S
S/**
S * @brief System Clock select mask bit of @ref _SYCR1_.
S * @details @ref SYCR1_CLKSEL selects a system clock to 100MHz or 25MHz. \n
S *          The masked bit values are as following.
S *            - @ref SYCR1_CLKSEL_25M
S *            - @ref SYCR1_CLKSEL_100M
S * @note It can be set only when @ref SYSR_CHPL = 1.
S * @note The system clock is automatically changed to 25MHz while the reset of @ref _WIZCHIP_ H/W reset, the Ethernet PHY H/W reset and power down. \n
S *       On the other hand, the system clock is set by @ref SYCR1_CLKSEL during normal operating.
S * @sa _SYCR1_, _SYSR_, _CHPLCKR_, SYSL_CHPL, PHYCR1_RST, PHYCR1_PWDN
S * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getPHYCR1(), setPHYCR1()
S */
S#define SYCR1_CLKSEL         (1 << 0)
S
S/**
S * @brief System Clock - 25MHz
S * @details @ref SYCR1_CLKSEL_25M selects a system clock to 25MHz.
S * @note It can be set only when @ref SYSR_CHPL = 1.
S * @sa _SYCR1_, SYCR1_CLKSEL, SYCR1_CLKSEL_100M
S * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK()
S */
S#define SYCR1_CLKSEL_25M     1
S
S/**
S * @brief System Clock - 100MHz
S * @details @ref SYCR1_CLKSEL_100M selects a system clock to 100MHz.
S * @note It can be set only when @ref SYSR_CHPL = 1.
S * @sa _SYCR1_, SYCR1_CLKSEL, SYCR1_CLKSEL_25M
S * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK()
S */
S#define SYCR1_CLKSEL_100M    0
S
S
S/* Interrupt Register Bit Definition */
S/**
S * @brief WOL bit of @ref _IR_
S * @details @ref IR_WOL is set when @ref _WIZCHIP_ receives a magic packet of WOL.
S * @sa _IR_, _IRCLR_, _IMR_ 
S * @sa getIR(), setIRCLR(), getIMR(), setIMR()
S */
S#define IR_WOL               (1<<7) 
S
S/**
S * @brief UNR6 bit of @ref _IR_
S * @details @ref IR_UNR6 is set when @ref _WIZCHIP_ receives the unreachable message of ICMPv6.
S * @sa _IR_, _IRCLR_, _IMR_
S * @sa getIR(), setIRCLR(), getIMR(), setIMR()
S */
S#define IR_UNR6              (1<<4)
S
S/**
S * @brief IPCONF bit of @ref _IR_
S * @details @ref IR_IPCONF is set when @ref _WIZCHIP_ receives a ARP reply with the same IPv4 address as @ref _SIPR_.
S * @sa _IR_, _IRCLR_, _IMR_
S * @sa getIR(), setIRCLR(), getIMR(), setIMR()
S */
S#define IR_IPCONF            (1<<2)
S
S/**
S * @brief UNR4 bit of @ref _IR_
S * @details @ref IR_UNR4 is set when @ref _WIZCHIP_ receives the unreachable message of ICMPv4.
S * @sa _IR_, _IRCLR_, _IMR_
S * @sa getIR(), setIRCLR(), getIMR(), setIMR()
S */
S#define IR_UNR4              (1<<1)
S
S/**
S * @brief PTERM bit of @ref _IR_
S * @details @ref IR_PTERM is set when @ref _WIZCHIP_ receives the PPP termination packet
S * @sa _IR_, _IRCLR_, _IMR_
S * @sa getIR(), setIRCLR(), getIMR(), setIMR()
S */
S#define IR_PTERM             (1<<0) 
S
S
S/* SOCKET Interrupt Register Bit Definition */
S/**
S * @brief N-th INT bit of @@ref _SIR_
S * @details @ref SIR_INT(N) is set when @ref _Sn_IR_(N) is not equal to zero.
S * @sa _SIR_, _Sn_IRCLR_, _SIMR_
S * @sa getSIR(), setSn_IRCLR(), getSIMR()
S */
S#define SIR_INT(N)           (1<<N)
S
S
S/* SOCKET-less Interrupt Register Bit Definition */
S/**
S * @brief TOUT bit of @ref _SLIR_
S * @details @ref SLIR_TOUT is set when the timeout is occurred after @ref _SLCR_ is performed.
S * @sa _SLIR_, _SLIRCLR_, _SLCR_
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR()
S */
S#define SLIR_TOUT            (1<<7)
S
S/**
S * @brief ARP4 bit of @ref _SLIR_
S * @details @ref SLIR_ARP4 is set when the ARP-relay is received successfully after @ref SLCR_ARP4 is performed \n
S *          and the destination hardware address can be checked by @ref _SLDHAR_. \n
S *          Otherwise, @ref SLIR_TOUT is set.
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, SLIR_TOUT
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR() 
S */
S#define SLIR_ARP4            (1<<6)
S
S/**
S * @brief PING4 bit of @ref _SLIR_
S * @details @ref SLIR_PING4 is set when the PING-relay is received successfully after @ref SLCR_PING4 is performed \n
S *          and the destination hardware address can be checked by @ref _SLDHAR_ like as @ref SLIR_ARP4.\n
S *          Otherwise, @ref SLIR_TOUT is set. 
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, SLIR_TOUT
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR() 
S */
S#define SLIR_PING4           (1<<5)
S
S/**
S * @brief ARP6 bit of @ref _SLIR_
S * @details @ref SLIR_ARP6 is set when the ARP6-relay is received successfully after @ref SLCR_ARP6 is performed \n
S *          and the destination hardware address can be checked by @ref _SLDHAR_. \n
S *          Otherwise, @ref SLIR_TOUT is set.
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, _SLDHAR_, SLIR_TOUT
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR() 
S */
S#define SLIR_ARP6            (1<<4)
S
S/**
S * @brief PING6 bit of @ref _SLIR_
S * @details @ref SLIR_PING6 is set when the PING-relay is received successfully after @ref SLCR_PING6 is performed \n
S *          and the destination hardware address can be checked by @ref _SLDHAR_ like as @ref SLIR_ARP6. \n
S *          Otherwise, @ref SLIR_TOUT is set.
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, _SLDHAR_, SLIR_TOUT
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR() 
S */
S#define SLIR_PING6           (1<<3)
S
S/**
S * @brief NS bit of @ref _SLIR_
S * @details @ref SLIR_NS is set when the ICMPv6 NA is received after @ref SLCR_NS is performed. \n
S *          Its set means IPv6 address such like as @ref _LLAR_ or @ref _GUAR_ is conflict. \n
S *          If @ref SLIR_TOUT is set, You can use @ref _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_.
S * @note It is used for IPv6 state-less address auto-configuration(SLAAC).
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, SLIR_TOUT, _LLAR_, _GUAR_
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getLLAR(), setLLAR(), getGAUR(), setGUAR()
S */
S#define SLIR_NS              (1<<2) 
S
S/**
S * @brief RS bit of @ref _SLIR_
S * @details @ref SLIR_RS is set when the ICMPv6 RA is received successfully after @ref SLCR_RS is performed \n
S *          and the prefix length, the prefix flag, the valid life time, the preferred life time and the prefix address of RA option message \n
S *          can be checked by @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_, respectively.\n
S *          Otherwise, @ref SLIR_TOUT is set.
S * @bug Only when the first received RA option is the source link-layer address(0x01) and the second is prefix information(0x03),\n
S *      and the prefix information is in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address,\n
S *      @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_ is correctly set.\n
S *      Other case, these registers are not valid.\n\n
S *      To solve this errata,\n
S *      You should use a IPRAW6 mode SOCKETn opened with Sn_MR_IPRAW6 and set the @ref _Sn_PNR_ to ICMPv6 number 58.\n
S *      This SOCKETn can be received a RA message or other ICMPv6 message, and a ICMPv6 message can be selectively filtered out by @ref _ICMP6BLKR_.\n
S *      For more details, Refer to "IPv6 Auto-configuration" document.
S *
S * @sa _SLIR_, _SLIRCLR_, _SLCR_, SLIR_TOUT
S * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR()
S */
S#define SLIR_RS              (1<<1)
S
S/**
S * @brief ICMPv6 RA Received Interrupt
S * @details @ref SLIR_RA is set when a RA is received from a router without @ref SLCR_RS.\n
S *          Like as @ref SLIR_RS, a RA option message can be checked by @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_.\n
S * @bug Only when RA options are received in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address,\n
S *      @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_ is correctly set. \n
S *      Other case, these registers are not valid.\n\n
S *      To solve this errata, You should use a IPRAW6 mode SOCKETn opened with @ref Sn_MR_IPRAW6 and set the @ref _Sn_PNR_ to ICMPv6 number 58.\n
S *      This SOCKETn can be received a RA message or other ICMPv6 message, and a ICMPv6 message can be selectively filtered out by @ref _ICMP6BLKR_.\n
S *      For more details, Refer to "IPv6 Auto-configuration" document.
S *
S * @sa _SLIR_, _SLIRCLR_ 
S * @sa getSLIR(), setSLIRCLR(), 
S  */
S#define SLIR_RA              (1<<0)
S
S
S/* SOCKET-less & SOCKETn  Prefer Source IPv6 Address Register Bit Definition */
S/**
S * @brief Select the source IPv6 address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to AUTO
S * @details The source IPv6 address depends on IPv6 address type of @ref _SLDIP6R_ or @ref _Sn_DIP6R_.\n
S *          If @ref _Sn_DIP6R_ is a link-local, the source IPv6 address is selected to @ref _LLAR_.\n
S *          Otherwise, the source IPv6 address is selected to @ref _GUAR_.
S * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDI6PR_, _Sn_DIP6R_, _LLAR_, _GUAR_
S * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
S *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
S */
S#define PSR_AUTO             (0x00)
S
S/**
S * @brief Select the source IP address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to @ref _LLAR_
S * @details Regardless of the destination IPv6 address type of @ref _SLDIP6R_ or @ref _Sn_DIP6R_, the source IP is selected to @ref _LLAR_.
S * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDIP6R_, _Sn_DIP6R_, _LLAR_, _GUAR_
S * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
S *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
S */
S#define PSR_LLA              (0x02)
S
S/**
S * @brief Select the source IP address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to @ref _GUAR_
S * @details Regardless of the destination IPv6 address type of @ref _SLDIP6R_, or @ref _Sn_DIP6R_, the source IP is selected to @ref _GUAR_.
S * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDIP6R_, _Sn_DIP6R_, _LLAR_, _GUAR_
S * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
S *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
S */
S#define PSR_GUA              (0x03)
S
S
S/* SOCKET-less Command Register Bit Definition */
S/**
S * @brief IPv4 ARP Command
S * @details It sends a IPv4 ARP request message to @ref _SLDIP4R_ without SOCKETn. \n
S *          The results can be ether @ref SLIR_TOUT or @ref SLIR_ARP4.\n
S *          If the result is @ref SLIR_ARP4, It is success to receive the reply from @ref _SLDIP4R_. \n
S *          You can check the destination hardware address thru @ref _SLDHAR_. \n
S *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP4R_ \n
S *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
S * @sa _SLCR_, _SLDIPR_, _SLDIP4R_ _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
S * @sa getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
S */
S#define SLCR_ARP4            (1<<6)
S
S/**
S * @brief IPv4 PING Command
S * @details It sends a IPv4 PING request message to @ref _SLDIP4R_ without SOCKETn.\n
S *          The results can be ether @ref SLIR_TOUT or @ref SLIR_PING4.\n
S *          If the result is @ref SLIR_PING4, It is success to receive the reply from @ref _SLDIP4R_. \n
S *          Also such like as @ref SLCR_ARP4, You can check the destination hardware address thru @ref _SLDHAR_.\n
S *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP4R_ \n
S *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
S * @sa _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
S * @sa getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
S */
S#define SLCR_PING4           (1<<5)
S
S/**
S * @brief IPv6 ARP Command
S * @details It sends a IPv6 ARP request message to @ref _SLDIP6R_ without SOCKETn. \n
S *          The results can be either @ref SLIR_TOUT or @ref SLIR_ARP6.
S *          If the result is @ref SLIR_ARP6, It is success to receive the reply from @ref _SLDIP6R_. \n
S *          You can check the destination hardware address thru @ref _SLDHAR_.\n
S *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP6R_
S *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
S * @sa _SLCR_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
S * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
S */
S#define SLCR_ARP6            (1<<4)
S
S/**
S * @brief IPv6 PING Command
S * @details It sends a IPv6 PING request message to @ref _SLDIP6R_ without SOCKET. \n
S *          The results can be either @ref SLIR_TOUT or @ref SLIR_PING6.\n
S *          If the result is @ref SLIR_PING6, It is success to receive the reply from @ref _SLDIP6R_.\n
S *          Also such like as @ref SLCR_ARP6, You can check the destination hardware address thru @ref _SLDHAR_.\n
S *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP6R_ \n
S *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
S * @sa _SLCR_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
S * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
S */
S#define SLCR_PING6           (1<<3)
S
S/**
S * @brief IPv6 DAD(Duplicate Address Detection) NS Command
S * @details It sends NS message for DAD to @ref _SLDIP6R_ that is set the address to be used as as @ref _LLAR_ or @ref _GUAR_, without SOCKET.\n
S *          The result can be ether @ref SLIR_TOUT and @ref SLIR_NS.\n
S *          If @ref SLIR_TOUT is set then you can use @ref _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_,\n
S *          else if @ref SLIR_NS is set then you can not use _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_.\n
S *          That means the IPv6 Address are Conflict.
S * @sa _SLCR_, _SLDIP6R_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_, _LLAR_, _GUAR_
S * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR(), \n
S *        getLLAR(), setLLAR(), getGUAR(), setGUAR()
S */
S#define SLCR_NS              (1<<2) 
S
S/**
S * @brief IPv6 Auto-configuration RS Command
S * @details It sends RS message to All-router for IPv6 Auto-configuration without SOCKET.\n
S *         The result can be ether @ref SLIR_RS or @ref SLIR_TOUT. \n
S *         If the result is @ref SLIR_RS, You can some information of router such as a prefix length, a Prefix flag, a valid life time, \n
S *         a preferred life time, and a prefix address respectively thru @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_, and @ref _PAR_.\n
S *         @ref SLIR_TOUT is set when it is no reply from a IPv6 router \n
S *         while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
S * @sa _SLCR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_, _PLR_, _PFR_, _VLTR_, _PLTR_, _PAR_.
S * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR(), \n
S *        getPLR(), getPFR(), getVLTR(), getPLTR(), getPAR().
S */
S#define SLCR_RS              (1<<1)
S
S/**
S * @brief IPv6 Unsolicited NA Command
S * @details It sends the IPv6 unsolicited NA message for updating the network information such as @ref _LLAR_, @ref _GUAR_, and @ref _SHAR_.\n
S *          The result is none.\n
S *          When @ref _SLPSR_ = @ref PSR_GUA, It can send the GUA unsolicited NA message.\n
S *          When @ref _SLPSR_ = Others, It can send the LLA unsolicited NA message.
S * @sa _SLCR_, _SLIR_, _SLIRCLR_, _SLPSR_
S * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCR(), getSLPFR(), setSLPFR()
S */
S#define SLCR_UNA             (1<<0)
S
S
S
S/* PHY Status Register Bit Definition */
S/**
S * @brief CAB mask bit
S * @details @ref PHYSR_CAB masks the CAB bit of @ref _PHYSR_.\n
S *          The masked bit values are as following. \n
S * - @ref PHYSR_CAB_OFF
S * - @ref PHYSR_CAB_ON
S * @sa getPHYSR()
S */
S#define PHYSR_CAB            (1<<7)
S
S/* PHY Status Register Bit Definition */
S/**
S * @brief Ethernet Cable Off
S * @details @ref PHYSR_CAB_OFF indicates the cable is off the Ethernet PHY.
S * @sa _PHYSR_, PHYSR_CAB, PHYSR_CAB_ON
S * @sa getPHYSR()
S */
S#define PHYSR_CAB_OFF        (1<<7)
S
S/**
S * @brief Ethernet PHY Cable On
S * @details @ref PHYSR_CAB_OFF indicates the cable is on the Ethernet PHY.
S * @sa _PHYSR_, PHYSR_CAB, PHYSR_CAB_OFF
S * @sa getPHYSR()
S */
S#define PHYSR_CAB_ON         (0<<7)
S
S/**
S * @brief Mask bits of @ref _PHYSR_
S * @details @ref PHYSR_MODE masks the MODE bits of @ref _PHYSR_.\n
S *          The masked bits values are as following. \n
S *            - @ref PHYSR_MODE_AUTO
S *            - @ref PHYSR_MODE_100F
S *            - @ref PHYSR_MODE_100H
S *            - @ref PHYSR_MODE_10F
S *            - @ref PHYSR_MODE_10H
S * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
S * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
S */
S#define PHYSR_MODE           (7<<3)
S
S/**
S * @brief PHY Mode - AUTO
S * @details @ref PHYSR_MODE_AUTO indicates the Ethernet PHY is operated as auto-negotiation mode.
S * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10F, PHYSR_MODE_10H
S * @sa getPHYSR()
S */
S#define PHYSR_MODE_AUTO      (0<<3)
S
S/**
S * @brief PHY Mode - 100F
S * @details @ref PHYSR_MODE_100F indicates the Ethernet PHY is operated as 100M full-duplex mode.
S * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100H, PHYSR_MODE_10F, PHYSR_MODE_10H
S * @sa getPHYSR()
S */
S#define PHYSR_MODE_100F      (4<<3)
S
S/**
S * @brief PHY Mode - 100H
S * @details @ref PHYSR_MODE_100H indicates the Ethernet PHY is operated as 100M half-duplex mode.
S * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_10F, PHYSR_MODE_10H
S * @sa getPHYSR()
S */
S#define PHYSR_MODE_100H      (5<<3)
S
S/**
S * @brief PHY Mode - 10F
S * @details @ref PHYSR_MODE_10F indicates the Ethernet PHY is operated as 10M full-duplex mode.
S * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10H
S * @sa getPHYSR()
S */
S#define PHYSR_MODE_10F       (6<<3)
S
S/**
S * @brief PHY Mode - 10H
S * @details @ref PHYSR_MODE_10H indicates the Ethernet PHY is operated as 10M half-duplex mode.
S * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10F
S * @sa getPHYSR() 
S */
S#define PHYSR_MODE_10H       (7<<3)
S
S/**
S * @brief DPX mask bit of @ref _PHYSR_
S * @details @ref PHYSR_DPX masks the DPX bit of @ref _PHYSR_. \n
S *          The masked bit values are as following. \n
S *            - @ref PHYSR_DPX_HALF
S *            - @ref PHYSR_DPX_FULL
S * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
S * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
S */
S#define PHYSR_DPX            (1<<2)
S
S/**
S * @brief PHY Duplex - HALF
S * @details @ref PHYSR_DPX_HALF indicates the Ethernet PHY is operated as half-duplex mode.
S * @sa _PHYSR_, PHYSR_DPX_FULL
S * @sa getPHYSR()
S */
S#define PHYSR_DPX_HALF       (1<<2)
S
S/**
S * @brief PHY Duplex - FULL
S * @details @ref PHYSR_DPX_FULL indicates the Ethernet PHY is operated as full-duplex mode.
S * @sa _PHYSR_, PHYSR_DPX_HALF
S * @sa getPHYSR()
S */
S#define PHYSR_DPX_FULL       (0<<2)
S
S/**
S * @brief SPD mask bit of @ref _PHYSR_
S * @details @ref PHYSR_SPD masks the SPD bit of @ref _PHYSR_. The masked bit values are as following. \n
S *   - @ref PHYSR_SPD_10M
S *   - @ref PHYSR_SPD_100M
S * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
S * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
S */
S#define PHYSR_SPD            (1<<1)
S
S /**
S * @brief PHY Speed - 10M
S * @details @ref PHYSR_SPD_10M indicates the Ethernet PHY is operated as 10Mbps speed.
S * @sa _PHYSR_, PHYSR_SPD_100M
S * @sa getPHYSR()
S */
S#define PHYSR_SPD_10M        (1<<1)
S
S /**
S * @brief PHY Speed - 100M
S * @details @ref PHYSR_SPD_100M indicates the Ethernet PHY is operated as 100Mbps speed.
S * @sa _PHYSR_, PHYSR_SPD_10M
S * @sa getPHYSR()
S */
S#define PHYSR_SPD_100M       (0<<1)
S
S/**
S * @brief LNK mask bit of @ref _PHYSR_
S * @details @ref PHYSR_LNK masks the LNK bit of @ref _PHYSR_. The masked bit values are as following. \n
S *   - @ref PHYSR_LNK_DOWN
S *   - @ref PHYSR_LNK_UP
S * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
S * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
S */
S#define PHYSR_LNK            (1<<0)
S
S/**
S * @brief PHY Link - Up
S * @details @ref PHYSR_LNK_UP indicates the link of Ethernet PHY is successfully established .\n
S * @sa _PHYSR_, PHYSR_LNK_DOWN
S * @sa getPHYSR()
S */
S#define PHYSR_LNK_UP         (1<<0)
S
S/**
S * @brief PHY Link - Down
S * @details @ref PHYSR_LNK_DOWN indicates the link of Ethernet PHY is not established yet.\n
S * @sa _PHYSR_, PHYSR_LNK_UP
S * @sa getPHYSR()
S */
S#define PHYSR_LNK_DOWN       (0<<0)
S
S/**
S * @brief Read a value  from the Ethernet PHY register specified by @ref _PHYRAR_.\n
S *        The read value can be checked by _PHYDOR_.
S * @sa _PHYACR_, _PHYDOR_, _PHYRAR_, _PHYDIR_, PHYACR_WRITE
S * @sa getPHYACR(), setPHYACR(), getPHYDOR(), getPHYRAR(), setPHYRAR(), setPHYDIR()
S */
S#define PHYACR_READ          (0x02)
S
S/**
S * @brief Write @ref _PHYDIR_ to the Ethernet PHY register specified by @ref _PHYRAR_.
S * @sa _PHYACR_, _PHYDIR_, _PHYRAR_, _PHYDOR_, PHYACR_READ
S * @sa getPHYACR(), setPHYACR(), setPHYDIR(), getPHYRAR(), setPHYRAR(), getPHYDOR()
S */
S#define PHYACR_WRITE         (0x01)
S
S/**
S * @brief PHY's MDC clock is the divided the system clock by 32
S * @sa _PHYDIVR_
S * @sa getPHYDIVR(), setPHYDIVR()
S */
S#define PHYDIVR_32           (0x00)
S
S/**
S * @brief PHY's MDC clock is the divided system clock by 64
S * @sa _PHYDIVR_
S * @sa getPHYDIVR(), setPHYDIVR()
S */
S#define PHYDIVR_64           (0x01)
S
S/**
S * @brief PHY's MDC clock is the divided system clock by 128
S * @sa _PHYDIVR_
S * @sa getPHYDIVR(), setPHYDIVR()
S */
S#define PHYDIVR_128          (0xFF)
S
S
S/* PHY Command Register Bit Definition */
S/**
S * @brief PHY Operation Mode - Auto Negotiation
S * @details @ref PHYCR0_AUTO sets the Ethernet PHY to operate on auto-negotiation mode.\n
S *          The Ethernet PHY can operate on auto-negotiation after @ref PHYCR1_RST is performed, \n
S *          and the result of @ref PHYCR0_AUTO can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H, BMCR_ANE 
S * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()  
S */
S#define PHYCR0_AUTO          (0x00)
S
S/**
S * @brief PHY Operation Mode - 100F 
S * @details @ref PHYCR0_100F sets the Ethernet PHY to operate on 100F\n
S *          The Ethernet PHY can operate on 100F after @ref PHYCR1_RST is performed,\n
S *          and the result of @ref PHYCR0_100F can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, BMCR_SPD, BMCR_DPX
S * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR0_100F          (0x04)
S
S/**
S * @brief PHY Operation Mode - 100H 
S * @details @ref PHYCR0_100H sets the Ethernet PHY to operate on 100H \n
S *          The Ethernet PHY can operate 100H after @ref PHYCR1_RST is performed, \n
S *          and the result of @ref PHYCR0_100H can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H, BMCR_SPD, BMCR_DPX
S * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR0_100H          (0x05)
S
S/**
S * @brief PHY Operation Mode - 10F 
S * @details @ref PHYCR0_10F sets the Ethernet PHY to operate on 10F \n
S *          The Ethernet PHY can operate 10H after @ref PHYCR1_RST is performed, \n
S *          and the result of @ref PHYCR0_10F can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100F, PHYCR0_100H, PHYCR0_10H, BMCR_SPD, BMCR_DPX
S * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR0_10F           (0x06)
S
S/**
S * @brief PHY Operation Mode - 10H 
S * @details @ref PHYCR0_10H sets the Ethernet PHY to operate on 10H \n
S *          The Ethernet PHY can operate 10H after @ref PHYCR1_RST is performed,  \n
S *          and the result of @ref PHYCR0_10H can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100F, PHYCR0_100H, PHYCR0_10H, BMCR_SPD, BMCR_DPX
S * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR0_10H           (0x07)
S
S
S/**
S * @brief PHY function - Power Down
S * @details @ref PHYCR1_PWDN enters the Ethernet PHY in power down mode. \n
S *          0 : Normal mode \n
S *          1 : Power down mode
S * @note The system clock changes to 25MHz in power down mode, and depends on @ref SYCR1_CLKSEL in normal mode.
S * @note It can be set only when @ref SYSR_PHYL = 1.
S * @sa _PHYCR1_, SYCR1_CLKSEL, BMCR_PWDN
S * @sa getPHYCR1(), setPHYCR1(), getSYCR1(), setSYCR1(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR1_PWDN          (1<<5)
S
S/**
S * @brief PHY function - 10Base-TE Mode
S * @details @ref PHYCR1_TE sets the operation of Ethernet PHY to 10base-Te.
S * @note It is valid only when @ref PHYSR_MODE = @ref PHYSR_MODE_AUTO.
S * @note It can be set only when @ref SYSR_PHYL = 1. 
S * @sa _PHYCR1_
S * @sa getPHYCR1(), setPHYCR1()
S */
S#define PHYCR1_TE            (1<<3)
S
S/**
S * @brief PHY function - HW Reset
S * @details @ref PHYCR1_RST resets the Ethernet PHY in hardware, \n
S *          and it is automatically cleared after the H/W reset and it takes 60.3ms to stabilize.\n
S *          0 : Normal mode \n  
S *          1 : H/W Reset \n
S * @note The system clock changes to 25MHz in H/W reset time, and depends on @ref SYCR1_CLKSEL in normal mode.
S * @note It can be set only when @ref SYSR_PHYL = 1. 
S * @sa _PHYCR1_, BMCR_RST
S * @sa getPHYCR1(), setPHYCR1(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define PHYCR1_RST           (1<<0)
S
S
S
S/* IPv4 Network Mode Register Bit Definition */
S/**
S * @brief UDP Unreachable Packet Block
S * @details @ref NETxMR_UNRB can block sending a ICMPv or ICMPv6 unreachable message to a peer.
S * @sa _NET4MR_, _NET6MR_
S * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
S */
S#define NETxMR_UNRB          (1<<3) 
S
S/**
S * @brief PING ARP Request
S * @details @ref NETxMR_PARP can send a ARP request before sending a ICMPv4 or ICMPv6 PING reply.
S * @sa _NET4MR_, _NET6MR_
S * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
S */
S#define NETxMR_PARP          (1<<2)
S
S/**
S * @brief TCP Reset Packet Block
S * @details @ref NETxMR_RSTB can block sending a TCP RST packet based on IPv4 or IPv6 \n
S *          when there is no SOCKET n opened with a listen port.
S * @sa _NET4MR_, _NET6MR_
S * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
S */
S#define NETxMR_RSTB          (1<<1)
S
S/**
S * @brief PING Reply Block
S * @details @ref NETxMR_PB can block sending a ICMPv4 or ICMPv6 PING reply to a peer.
S * @sa _NET4MR_, _NET6MR_
S * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
S */
S#define NETxMR_PB            (1<<0)
S
S
S/* Network Mode Register Bit Definition */
S/**
S * @brief All-node Multicating PING Reply Block
S * @details @ref NETMR_ANB can block sending a IPv6 PING reply to the peer ping requested to all-node multicast address.
S * @sa _NETMR_
S * @sa getNETMR(), setNETMR()
S */
S#define NETMR_ANB            (1<<5)
S
S/**
S * @brief Solicited Multicasting PING Reply Block
S * @details @ref NETMR_M6B can block sending a IPv6 PING reply to the peer ping requested to the own solicited multicast address.
S * @sa _NETMR_
S * @sa getNETMR(), setNETMR()
S */
S#define NETMR_M6B            (1<<4)
S
S/**
S * @brief Wake On LAN mode
S * @details @ref NETMR_WOL can receive a magic packet of WOL.
S * @sa _NETMR_
S * @sa getNETMR(), setNETMR()
S */
S#define NETMR_WOL            (1<<2)
S
S/**
S * @brief IPv6 Packet Block
S * @details @ref NETMR_IP6B can block receiving all IPv6 packets.
S * @sa _NETMR_
S * @sa getNETMR(), setNETMR()
S */
S#define NETMR_IP6B           (1<<1)
S
S/**
S * @brief IPv4 Packet Block
S * @details @ref NETMR_IP4B can block receiving all IPv4 packets.
S * @sa _NETMR_
S * @sa getNETMR(), setNETMR()
S */
S#define NETMR_IP4B           (1<<0)
S
S
S/**
S * @brief Destination Hardware Address Select
S * @details @ref NETMR2_DHAS masks the DHAS bit of @ref _NETMR2_. \n
S *          The masked bit values are as following.
S *            - @ref NETMR2_DHAS_ARP
S *            - @ref NETMR2_DHAS_ETH
S *
S * @note It is useful when the destination hardware address of Ethernet frame is different from the target address of ARP.
S * @sa _NETMR2_
S * @sa getNETMR2(), setNETMR2()
S */
S#define NETMR2_DHAS          (1<<7)
S
S/**
S * @brief Destination Hardware Address Select - ARP
S * @details @ref NETMR2_DHAS_ARP select the target address of ARP-replay packet to the destination hardware address.
S * @sa _NETMR2_, NETMR2_DHAS_ETH
S * @sa getNETMR2(), setNETMR2()
S */
S#define NETMR2_DHAS_ARP      (1<<7)
S
S/**
S * @brief Destination Hardware Address Select - Ethernet Frame
S * @details @ref NETMR2_DHAS_ETH select the destination address of Ethernet frame to the destination hardware address.
S * @sa _NETMR2_, NETMR2_DHAS_ARP
S * @sa getNETMR2(), setNETMR2()
S */
S#define NETMR2_DHAS_ETH      (0<<7)
S
S/**
S * @brief PPPoE Mode
S * @details @ref NETMR2_PPPoE enables PPPoE mode \n
S *          0 : Disable \n
S *          1 : Enable
S * @note For enabling a PPPoE mode, some information such like as _PTMR_, _PHAR_, _PSIDR_, and _PMRUR_ are needed. \n
S *       To get these information, You can use a SOCKET0 opened with @ref Sn_MR_MACRAW. 
S * @sa _NETMR2_, _PTMR_, _PHAR_, _PSIDR_, _PMRUR_, Sn_MR_MACRAW
S * @sa getNETMR2(), setNETMR2()
S */
S#define NETMR2_PPPoE         (1<<0)
S
S/* ICMPv6 Block Register Bit Definition */
S/**
S * @brief ICMPv6 PING Block
S * @details @ref ICMP6BLKR_PING6 can block a ping request from a peer
S * @sa _IMCP6BLKR_, NETxMR_PB
S * @sa getICMP6BLKR(), setICMP6BLKR(), getNET6MR(), setNET6MR()
S */
S#define ICMP6BLKR_PING6      (1<<4)
S
S/**
S * @brief ICMPv6 MLD Block
S * @details @ref ICMP6BLKR_MLD can block a multicast listener discovery(MLD) query.
S * @sa _ICMP6BLKR_
S * @sa getICMP6BLKR(), setICMP6BLKR()
S */
S#define ICMP6BLKR_MLD        (1<<3)
S
S/**
S * @brief ICMPv6 RA Block
S * @details @ref ICMP6BLKR_RA can block a RA packet from a router
S * @sa _ICMP6BLKR_
S * @sa getICMP6BLKR(), setICMP6BLKR()
S */
S#define ICMP6BLKR_RA         (1<<2)
S
S/**
S * @brief ICMPv6 NA Block
S * @details @ref ICMP6BLKR_NA can block a Neighbor Advertisement(NA) from a peer
S * @sa _ICMP6BLKR_
S * @sa getICMP6BLKR(), setICMP6BLKR()
S */
S#define ICMP6BLKR_NA         (1<<1)
S
S/**
S * @brief ICMPv6 NS Block
S * @details @ref ICMP6BLKR_NS can block a Neighbor Solicitation(NS) from a peer
S * @sa _ICMP6BLKR_
S * @sa getICMP6BLKR(), setICMP6BLKR()
S */
S#define ICMP6BLKR_NS         (1<<0)
S
S
S/* Sn_MR values */
S/**
S * @brief UDP Multicasting 
S * @details  @ref Sn_MR_MULTI enables to a multicast packet from a multicast group in UDP mode SOCKETn. \n
S *            To use multicasting, @ref _Sn_DIPR_, @ref _Sn_DIP6R_, & @ref _Sn_DPORTR_ should be respectively set with \n
S *            the multicast group IPv4, IPv6 address & port number before @ref Sn_CR_OPEN. \n
S *            0 : Disable Multicasting \n
S *            1 : Enable Multicasting \n
S * @note It is valid only in UDP mode such like as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
S * @sa _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_
S * @sa getSn_MR(), setSn_MR(), getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR().
S */
S#define Sn_MR_MULTI          (1<<7)
S
S/**
S * @brief MAC Filter 
S * @details @ref Sn_MR_MF filters other packets except broadcasting, multicasting, and packets sent to your own.\n
S *          0 : Disable MAC Filtering \n
S *          1 : Enable MAC Filtering \n
S * @note It is valid only in MACRAW SOCKET0 opened with @ref Sn_MR_MACRAW \n
S * @note If you want to implement a hybrid TCP/IP stack, \n
S *       It is recommended that @ref Sn_MR_MF enable for reducing host overhead to process the all received packets.
S * @sa _Sn_MR_, Sn_MR_MULTI
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_MF             (1<<7)
S
S/**
S * @brief Broadcasting packet block
S * @details @ref Sn_MR_BRDB can block a broadcasting packet in MACRAW SOCKET0 or UDP mode SOCKETn. \n
S *          0 : Disable Broadcast Blocking \n
S *          1 : Enable Broadcast Blocking \n
S * @note It is valid only in MACRAW mode such as @ref Sn_MR_MACRAW, or in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
S * @sa _Sn_MR_, Sn_MR_FPSH 
S * @sa getSn_MR(), setSn_MR()
S */
S #define Sn_MR_BRDB          (1<<6)
S
S/**
S * @brief Force PUSH flag
S * @details When @ref Sn_MR_FPSH is set, all TCP DATA packets with PSH flag set can be transmitted by @ref Sn_CR_SEND. \n
S *          When @ref Sn_MR_FPSH is not set, the PSH flag is set only in the last DATA packet among the DATA packets transmitted by @ref Sn_CR_SEND. \n
S *          0 : No Force PSH flag \n
S *          1 : Force PSH flag \n
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_MR_, Sn_CR_SEND, Sn_MR_BRDB
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
S */
S#define Sn_MR_FPSH           (1<<6)
S
S/**
S * @brief No Delayed Ack
S * @details When @ref Sn_MR_FPSH is set, It sends the ACK packet without delay as soon as a DATA packet is received from a peer.\n
S *          Otherwise, It sends the ACK packet after waiting the time set by @ref _Sn_RTR_. \n
S *          0 : Delayed ACK \n
S *          1 : No Delayed ACK \n
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.
S * @note Regardless of @ref Sn_MR_ND, It sends the ACK packet when SOCKETn window size is less than MSS after @ref Sn_CR_RECV.
S * @sa _Sn_MR_, _Sn_RTR_, Sn_CR_RECV, Sn_MR_MC, Sn_MR_SMB, Sn_MR_MMB
S * @sa getSn_MR(), setSn_MR(), getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
S */
S #define Sn_MR_ND            (1<<5)
S
S/**
S * @brief IGMP version for IPv4 Multicasting
S * @details @ref Sn_MR_MC decides IGMP version. \n
S *          0 : IGMPv2 \n
S *          1 : IGMPv1 \n
S * @note It is valid only when @ref Sn_MR_MULTI = '1' and UDP mode is @ref Sn_MR_UDP4.
S * @note IGMP packet can be automatically sent to the multicast group by @ref Sn_CR_OPEN.
S * @note @ref _WIZCHIP_ doesn't not support IGMP version 3.
S * @sa _Sn_MR_, Sn_MR_MULTI, Sn_MR_ND, Sn_MR_SMB, Sn_MR_MMB
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_MC             (1<<5)
S
S/**
S * @brief Solicited Mulitcast Block
S * @details @ref Sn_MR_SMB can block a received packet that have your own solicited multicast address. \n
S *          0 : Unblock a solicited multicast packet \n
S *          1 : Block a solicited multicast packet \n
S * @note It is valid only when UDP mode is @ref Sn_MR_UDP6 or @ref Sn_MR_UDPD.
S * @sa _Sn_MR_,  Sn_MR_ND, Sn_MR_MC, Sn_MR_MMB
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_SMB            (1<<5)
S
S/**
S * @brief UDP4 Multicast Block
S * @details @ref Sn_MR_MMB can block the UDP4 multicast packet when SOCKET0 is opend with @ref Sn_MR_MACRAW and @ref Sn_MR_MF is set.\n
S *          0 : Unblock a UDP multicast packet with IPv4 address \n
S *          1 : Block a UDP multicast packet with IPv4 address \n
S * @note It is valid only in MACRAW SOCKET0 with Sn_MR_MF = '1'.
S * @sa _Sn_MR_, Sn_MR_MMB6, Sn_MR_ND, Sn_MR_MC, Sn_MR_SMB
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_MMB            (1<<5)
S#define Sn_MR_MMB4           (Sn_MR_MMB)  /// Refer to @ref Sn_MR_MMB.
S
S/**
S * @brief Unicast Block
S * @details @ref Sn_MR_UNIB can block a unicast packet. \n
S *          0 : Unblock a UDP unicast packet \n
S *          1 : Block a UDP unicast packet \n
S * @note It is valid only when SOCKETn is opened with UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6 and @ref Sn_MR_UDPD, and @ref Sn_MR_MULTI is set.
S * @sa _Sn_MR_, Sn_MR_MULTIL, Sn_MR_MMB6
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_UNIB           (1<<4)
S
S/**
S * @brief UDP6 Multicast Block
S * @details @ref Sn_MR_MMB6 can block the UDP6 multicast packet. \n
S *          0 : Unblock a UDP multicast packet with IPv6 address \n
S *          1 : Block a UDP multicast packet with IPv6 address \n
S * @note  It is valid only when SOCKET0 is opend with @ref Sn_MR_MACRAW and @ref Sn_MR_MF is set.
S * @sa _Sn_MR_, Sn_MR_MMB
S * @sa getSn_MR(), setSn_MR()
S */
S#define Sn_MR_MMB6           (1<<4)
S
S/**
S * @brief SOCKETn Closed
S * @details @ref Sn_MR_CLOSE is not opened yet.\n
S *          It is the default mode when @ref _WIZCHIP_ is reset.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_CLOSE          (0x00)
S
S/**
S * @brief IPv4 TCP mode 
S * @details @ref Sn_MR_TCP(= @ref Sn_MR_TCP4) sets SOCKETn to TCP4 mode. \n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opend as TCP4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.
S * @note In oder to connect a peer, You should use @ref Sn_CR_CONNECT as command and @ref _Sn_DIPR_ as destination.
S * @note In order to send data, You should use @ref Sn_CR_SEND.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_TCP6, Sn_MR_TCPD
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_TCP            (0x01)
S#define Sn_MR_TCP4           (Sn_MR_TCP)   ///< Refer to @ref Sn_MR_TCP.
S
S/**
S * @brief IPv4 UDP mode
S * @details @ref Sn_MR_UDP(= @ref Sn_MR_UDP4) sets SOCKETn to UDP4 mode.\n
S *          It should be set before @ref Sn_CR_OPEN is performed. \n
S *          After @ref Sn_CR_OPEN, SOCKETn is opend as UDP4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
S * @note In order to send data, You should use @ref Sn_CR_SEND as command and @ref _Sn_DIPR_ as destination.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP6, Sn_MR_UDPD
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_UDP            (0x02)
S#define Sn_MR_UDP4           (Sn_MR_UDP)   ///< Refer to @ref Sn_MR_UDP
S
S/**
S * @brief IPv4 RAW mode
S * @details @ref Sn_MR_IPRAW(= @ref Sn_MR_IPRAW4) sets SOCKETn to IPRAW4 mode. \n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opend as IPRAW4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW(= @ref SOCK_IPRAW4).
S * @note In order to send data, You should use @ref Sn_CR_SEND as command and @ref _Sn_DIPR_ as destination.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_IPRAW6
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_IPRAW          (0x03)
S#define Sn_MR_IPRAW4         (Sn_MR_IPRAW)   ///< Refer to @ref Sn_MR_IPRAW.   
S
S/**
S * @brief MACRAW mode
S * @details @ref Sn_MR_MACRAW sets only SOCKET0 to MACRAW mode.\n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKET0 is opend as MACRAW mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_MACRAW.
S * @note In order to send data, You should use @ref Sn_CR_SEND.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_MACRAW         (0x07)
S
S/**
S * @brief IPv6 TCP mode 
S * @details @ref Sn_MR_TCP6 sets SOCKETn to TCP6 mode. \n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opend as TCP6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.
S * @note In oder to connect a peer, You should use @ref Sn_CR_CONNECT6 as command and @ref _Sn_DIP6R_ as destination.
S * @note In order to send data, You should use @ref Sn_CR_SEND, not @ref Sn_CR_SEND6.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_TCP4, Sn_MR_TCPD
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_TCP6           (0x09)
S
S/**
S * @brief IPv6 UDP mode
S * @details @ref Sn_MR_UDP6 sets SOCKETn to UDP6 mode.\n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opend as UDP6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
S * @note In order to send data, You should use @ref Sn_CR_SEND6 as command and @ref _Sn_DIP6R_ as destination.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP4, Sn_MR_UDPD
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_UDP6           (0x0A)
S
S/**
S * @brief IPv6 RAW mode
S * @details @ref Sn_MR_IPRAW6 sets SOCKETn to IPRAW6 mode.\n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opened as IPRAW6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW6.
S * @note In order to send data, You should use @ref Sn_CR_SEND6 as command and @ref _Sn_DIP6R_ as destination.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_IPRAW4
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_IPRAW6         (0x0B)
S
S/**
S * @brief Both IPv4 & IPv6 TCP mode (TCP dual mode)
S * @details @ref Sn_MR_TCPD sets SOCKETn to both TCP4 & TCP6 mode. \n
S *          It should be set before @ref Sn_CR_OPEN is performed.\n
S *          After @ref Sn_CR_OPEN, SOCKETn is opened as TCP Dual mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.\n
S *          The real mode of TCP dual SOCKETn is decided when the connection with a peer is established.\n
S *   - In SOCKETn is operated as <b>TCP SERVER</b> mode 
S *     If the connection request client have a IPv4 address, \n
S *     TCP dual SOCKETn is changed to TCP4 mode and a destination IP address can be checked thru @ref _Sn_DIPR_, \n
S *     else if the client have a IPv6 address, \n
S *     TCP dual SOCKETn is changed to IPv6 mode and destination IP address can be checked by thru @ref _Sn_DIP6R_.
S *   - In SOCKETn is operated as <b>TCP CLIENT</b> mode, 
S *     If the IP address type of destination to connect is IPv4, \n
S *     the destination IP address should be set to @ref _Sn_DIPR_ and try to connect by @ref Sn_CR_CONNECT, \n
S *     else if the type is IPv6, \n
S *     the destination IP address should be set to @ref _Sn_DIP6R_ and try to connect by @ref Sn_CR_CONNECT6. \n
S *           
S * @note In <b>TCP SERVER</b> mode, You can check the IP type of the client with @ref Sn_ESR_TCPM.
S * @note If the connected client have a IPv6 address, You can check whether the address is LLA or GAU, thru @ref Sn_ESR_IP6T
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, _Sn_ESR_TCPM_, Sn_MR_TCP4, Sn_MR_TCP6
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR(), getSn_ESR()
S */
S#define Sn_MR_TCPD           (0x0D)
S
S/**
S * @brief UDP Dual mode
S * @details @ref Sn_MR_UDPD sets SOCKETn to both UDP4 & UDP6 mode. \n
S *          It should be set before @ref Sn_CR_OPEN is performed. \n
S *          After @ref Sn_CR_OPEN, SOCKETn is opened as UDP dual mode \n
S *          and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
S * @note In order to send data, \n
S *       You can use both @ref Sn_CR_SEND and @ref Sn_CR_SEND6 as command and both @ref _Sn_DIPR_ and @ref _Sn_DIP6R_ as destination.
S * @note You can know the destination IP address type is whether IPv6 or IPv4 thru @ref getsockopt() with @ref SO_PACKINFO.
S * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP6, Sn_MR_UDP4
S * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_MR_UDPD           (0x0E)
S
S/* SOCKETn  Command Register BIt Definition */
S/**
S * @brief Initialize or Open SOCKETn.
S * @details SOCKETn is initialized and opened according to the protocol mode selected by @ref _Sn_MR_ and with a source port set by @ref _Sn_PORTR_. \n
S *                   The table shows @ref _Sn_SR_ is changed according to @ref _Sn_MR_.\n
S * <table>
S *    <tr> <td> <b>@ref _Sn_MR_</b> (P[3:0])                      </td> <td><b>@ref _Sn_SR_</b> </td> </tr>
S *    <tr> <td> @ref Sn_MR_CLOSE                                  </td> <td> @ref SOCK_CLOSED   </td> </tr>
S *    <tr> <td> @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, @ref Sn_MR_TCPD </td> <td> @ref SOCK_INIT     </td> </tr>
S *    <tr> <td> @ref Sn_MR_UDP, @ref Sn_MR_UDP6, @ref Sn_MR_UDPD  </td> <td> @ref SOCK_UDP      </td> </tr>
S *    <tr> <td> @ref Sn_MR_IPRAW4                                 </td> <td> @ref SOCK_IPRAW4   </td> </tr>
S *    <tr> <td> @ref Sn_MR_IPRAW6                                 </td> <td> @ref SOCK_IPRAW6   </td> </tr>
S *    <tr> <td> @ref Sn_MR_MACRAW                                 </td> <td> @ref SOCK_MACRAW   </td> </tr>
S * </table>
S *
S * @note If you want to use a SOCKETn option such as Sn_MR_MF, Sn_MR_ND, Sn_MR_MUTIL and etc, \n
S *       these options should be set before @ref Sn_CR_OPEN is performed.
S * @note If you want to open a multicast UDP mode SOCKETn, \n
S *       You should set the multicast group with @ref _Sn_DIPR_ or @ref _Sn_DIP6R_ and @ref _Sn_DPORTR_ before @ref Sn_CR_OPEN is performed.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_PORTR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_,
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_PORTR(), setSn_PORTR(), getSn_DIPR(), setSn_DIPR(),
S *     getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR()
S */
S#define Sn_CR_OPEN           (0x01)
S
S/**
S * @brief Wait a connection request in <b>TCP SERVER</b> mode
S * @details SOCKETn operates as a <b>TCP SERVER</b> and waits for a connection-request (SYN packet) \n
S *          with corresponding @ref _Sn_PORTR_ port number from any <b>TCP CLIENT</b> \n
S *          The @ref _Sn_SR_ is changed from @ref SOCK_INIT to @ref SOCK_LISTEN. \n
S *          When a <b>TCP CLIENT</b> connection request is successfully accepted,\n
S *          the @ref _Sn_SR_ is changed from @ref SOCK_LISTEN to @ref SOCK_ESTABLISHED \n
S *          and the @ref Sn_IR_CON is set.\n
S *          But when a <b>TCP CLIENT</b> connection request is failed, \n
S *          @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to SOCK_CLOSED.
S * @note This is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_PORTR_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_PORTR(), setSn_PORTR()
S */
S#define Sn_CR_LISTEN         (0x02)
S
S/**
S * @brief Send a connection request in <b>TCP CLIENT</b> mode
S * @details To establish a connection, a connect-request (SYN packet) is sent to <b>TCP SERVER</b> set by @ref _Sn_DIPR_ & @ref _Sn_DPORTR_.\n
S *          If the connect-request is successful accepted by a <b>TCP SERVER</b>, \n
S *          the @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and the @ref Sn_IR_CON is set. \n
S *          The connect-request fails in the following three cases, \n
S *          and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n\n
S *  1. Until a ARP timeout is occurred (@ref Sn_IR_TIMEOUT = 1), a destination hardware address can not be acquired through the ARP-process.\n
S *  2. Until a TCP tmeout occurred (@ref Sn_IR_TIMEOUT = 1), a SYN/ACK packet is not received from the server\n
S *  3. When a RST packet is received instead of a SYN/ACK packet \n
S *
S * @note This is valid only in TCP mode such as @ref Sn_MR_TCP4 and @ref Sn_MR_TCPD. 
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_DIPR_, _Sn_DPORTR_, Sn_CR_CONNECT6, _Sn_IR_, _Sn_IRCLR_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIPR(), setSn_DIPR(), getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR()
S */
S#define Sn_CR_CONNECT        (0x04)
S
S/**
S * @brief Send connection request in <b>TCP CLIENT</b> mode
S * @details To establish a connection, a connect-request (SYN packet) is sent to <b>TCP SERVER</b> set by @ref _Sn_DIP6R_ & @ref _Sn_DPORTR_.\n
S *          If the connect-request is successful accepted by a <b>TCP SERVER</b>, \n
S *          the @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and the @ref Sn_IR_CON is set. \n
S *          The connect-request fails in the following three cases, and @ref _Sn_SR_ is changed @ref SOCK_CLOSED.\n
S *   1. Until a ARP timeout is occurred (@ref Sn_IR_TIMEOUT = 1), a destination hardware address can not be acquired through the ARP-process.\n
S *   2. Until a TCP tmeout occurred (@ref Sn_IR_TIMEOUT = 1), a @b SYN/ACK packet is not received from the server\n
S *   3. When a RST packet is received instead of a @b SYN/ACK packet \n
S *
S * @note This is valid only in TCP mode such as @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD. 
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_DIP6R_, _Sn_DPORTR_, Sn_CR_CONNECT, _Sn_IR_, _Sn_IRCLR_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR()
S */
S#define Sn_CR_CONNECT6       (0x84)
S
S/**
S * @brief Send a disconnect request in TCP mode
S * @details Regardless of <b>TCP SERVER</b> or <b>TCP CLIENT</b>, \n
S *          @ref Sn_CR_DISCON processes the disconnect-process (Active or Passive close).\n
S *          When the disconnect-process is successful (that is, FIN/ACK packet is received successfully from/to each other),\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n
S *          Otherwise, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S *   - Active close 
S *     It transmits first a disconnect-request(FIN packet) to the connected peer, and waits to receive two FIN/ACK and FIN packet from the peer. \n
S *     If two FIN/ACK and FIN packet is received successfully, @ref Sn_IR_DISCON is set and @ref _Sn_SR_ is changed @ref SOCK_CLOSED.
S *   - Passive close
S *     When a FIN packet is first received from the peer, the FIN/ACK packet is replied back to the peer and @ref Sn_IR_DISCON is set.\n
S *     And then, a FIN packet is sent by @ref Sn_CR_DISCON to the peer, and waits to receive the FIN/ACK packet from the peer. \n
S *     If the FIN/ACK packet is received successfully from the peer, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S *
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_DISCON, Sn_IR_TIMEOUT
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_IR(), setSn_IRCLR()
S */
S#define Sn_CR_DISCON         (0x08)
S
S/**
S * @brief Release or Close SOCKETn
S * @details In TCP mode, @ref Sn_CR_CLOSE force to close a SOCKETn without the disconnect-process.\n
S *          In other SOCKETn mode, @ref Sn_CR_CLOSE just closes a SOCKET.\n
S * @note @ref _Sn_SR_ can be changed from any status to @ref SOCK_CLOSED by @ref Sn_CR_CLOSE.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, Sn_CR_DISCON
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR()
S */
S#define Sn_CR_CLOSE          (0x10)
S
S/**
S * @brief Send Data  
S * @details @ref Sn_CR_SEND send the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX buffer \n
S *          to the destination specified by @ref _Sn_DIPR_ or @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_.\n
S *   - TCP mode(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6,  @ref Sn_MR_TCPD)
S *     If it starts to be sent the data by @ref Sn_CR_SEND, @ref Sn_IR_SENDOK is set. \n 
S *     And after sending the data, if the ACK to the sent data can not be received during @ref _Sn_RTR_, \n
S *     the sent data can be retransmitted as many as @ref _Sn_RCR_. \n
S *     During the retransmission, \n
S *     If the ACK is received, @ref _Sn_TX_FSR_ is increased as many as the sent data size, \n
S *     Otherwise, @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S *   - UDP mode(@ref Sn_MR_UDP4, @ref Sn_MR_UDPD) & IPRAW mode(@ref Sn_MR_IPRAW4)
S *     It first sends a ARP-request to a destination specified with @ref _Sn_DIPR_ before it starts to be sent data by @ref Sn_CR_SEND. \n
S *     If the ARP-reply can not be received during @ref _Sn_RTR_, the ARP-request can be retransmitted as many as @ref _Sn_RCR_. \n
S *     During the retransmission, \n
S *     If the ARP-reply is received and @ref Sn_IR_SENDOK is set, it starts to send data and then @ref _Sn_TX_FSR_ is increased as many as the sent data size. \n
S *     Otherwise, @ref Sn_IR_TIMEOUT is set but @ref _Sn_SR_ is not changed.
S *   - MACRAW mode(@ref Sn_MR_MACRAW)
S *     It just start to send data and @ref Sn_IR_SENDOK is set.
S *
S * @note Data size to be sent is calculated by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_. \n
S *       In TCP or UDP mode, It can not be sent bigger data than @ref _Sn_TX_FSR_.\n
S *       In IPRAW or Macraw case, it can not be sent bigger data than MTU(Maximum Transmit Unit).
S * @note In TCP or MACRAW mode, It can send data to a destination address whether IPv4 or IPv6. \n
S *       In UDP or IPRAW mode, It can send data only to a destination IPv4 address. \n
S *       For Sending to IPv6 address, It can be used with @ref Sn_CR_SEND6.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_, _Sn_IR_, _Sn_IRCLR_, _Sn_TX_FSR_, _Sn_TX_WR_, _Sn_TX_RD_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), \n
S *     getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR(), getSn_TX_FSR(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD()
S */
S#define Sn_CR_SEND           (0x20)
S
S/**
S * @brief Send Data       
S * @details @ref Sn_CR_SEND6 sends the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX buffer \n
S *          to the destination specified by @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_.\n
S *   - TCP mode(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6,  @ref Sn_MR_TCPD) & MACRAW mode(@ref Sn_MR_MACRAW)
S *     @ref Sn_CR_SEND6 is not recommended. In this case, Use @ref Sn_CR_SEND.
S *   - UDP mode(@ref Sn_MR_UDP6, @ref Sn_MR_UDPD) & IPRAW mode(@ref Sn_MR_IPRAW6)
S *     It first send a neighbor solicitation NS) of ICMPv6 to a destination specified with @ref _Sn_DIP6R_ \n
S *     before it starts to be sent data by @ref Sn_CR_SEND. \n
S *     If the neighbor advertisement(NA) of ICMPv6 can not be received during @ref _Sn_RTR_, \n
S *     the NS can be retransmitted as many as @ref _Sn_RCR_. \n
S *     During the retransmission, \n
S *     If the NA is received and @ref Sn_IR_SENDOK is set, \n
S *     it starts to send data and then @ref _Sn_TX_FSR_ is increased as many as the sent data size. \n
S *     Otherwise, @ref Sn_IR_TIMEOUT is set but @ref _Sn_SR_ is not changed.
S *
S * @note Data size to be sent is calculated by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_. \n
S *       In TCP or UDP mode, It can not be sent bigger data than @ref _Sn_TX_FSR_.\n
S *       In IPRAW or Macraw case, it can not be sent bigger data than MTU(Maximum Transmit Unit).
S * @note In UDP or IPRAW mode, It can send data only to a destination IPv6 address. \n
S *       For Sending to IPv4 address, It can be sent by @ref Sn_CR_SEND.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_DIP6R_, _Sn_DPORTR_, _Sn_IR_, _Sn_IRCLR_, _Sn_TX_FSR_, _Sn_TX_WR_, _Sn_TX_RD_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR(), \n
S *     getSn_IR(), setSn_IRCLR(), getSn_TX_FSR(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD()
S */
S #define Sn_CR_SEND6         (0xA0)
S
S/**
S * @brief Send keep alive message
S * @details @ref Sn_CR_SEND_KEEP checks whether the connection is established or not by sending 1 byte KA(Keep Alive) packet.\n
S *          If the destination can not respond to the KA packet during the time set by @ref _Sn_RTR_ and @ref _Sn_RCR_, \n
S *          the connection is terminated, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed @ref SOCK_CLOSED.
S * @note It is valid only after sending data over 1 byte in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_IR_, _Sn_IRCLR_, _Sn_RTR_, _Sn_RCR_, _Sn_KPALVTR_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_IR(), setSn_IRCLR(), \n
S *        getSn_RTR(), setSn_RTR(), getSn_RCR(), setSn_RCR(), getSn_KPALVTR(), getSn_KPALVTR()
S */
S#define Sn_CR_SEND_KEEP      (0x22)
S
S/**
S * @brief Receive data
S * @details @ref Sn_CR_RECV reads the saved from @ref _Sn_RX_RD_ to @ref _Sn_RX_WR_ data in SOCKETn RX buffer.\n
S *          When a data is saved in the SOCKETn RX buffer, \n
S *          @ref Sn_IR_RECV is set and @ref _Sn_RX_RSR_ is increased as many as the saved data size.\n
S *          The total size of saved data is calculated by the absolute difference between @ref _Sn_RX_WR_ and @ref _Sn_RX_RD_,\n
S *          and it can be checked thru @ref _Sn_RX_RSR_.\n
S *          After reading data, @ref _Sn_RX_RD_ should be increased as many as the read size before @ref Sn_CR_RECV is performed.\n
S *          After @ref Sn_CR_RECV, @ref _Sn_RX_RSR_ is decreased as many as the read size.\n
S *          If @ref _Sn_RX_RSR_ is remained still at none-zero, @ref Sn_IR_RECV is set again.
S * @sa _Sn_CR_, _Sn_MR_, _Sn_IR_, _Sn_IRCLR_, _Sn_RX_RD_, _Sn_RX_WR_, _Sn_RX_RSR_
S * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_IR(), getSn_IRCLR(), \n
S *     getSn_RX_RD(), setSn_RX_RD(), getSn_RX_TX(), getSn_RX_RSR()
S */
S#define Sn_CR_RECV           (0x40)
S
S
S/* Sn_IR values */
S/**
S * @brief SEND OK Interrupt
S * @details @ref Sn_IR_SENDOK is set when it is started to be sent data by @ref Sn_CR_SEND. 
S * @note Even though @ref Sn_IR_SENDOK is set, it does not means that the destination receives data successfully.\n
S *         - In TCP mode, The sent data maybe still transmitting or retransmitting. \n
S *         - In other modes, The sent data maybe lost by media collision or an other reason such as network traffic.
S * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_SEND
S * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
S */
S#define Sn_IR_SENDOK         (0x10)
S
S/**
S * @brief TIMEOUT Interrupt
S * @details @ref Sn_IR_TIMEOUT is set when a timeout occurs in ARP and ND process or TCP retransmission.
S * @note In TCP mode, If it is set, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED. \n
S *       In other modes, _Sn_SR_ is still remained at the previous status.
S * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_CONNECT, Sn_CR_CONNECT6, Sn_CR_SEND
S * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
S */
S#define Sn_IR_TIMEOUT        (0x08)
S
S/**
S * @brief RECV Interrupt
S * @details @ref Sn_IR_RECV is set whenever data is received from a peer, \n
S *          or if @ref _Sn_RX_RSR_ is still at none-zero whenever @ref Sn_CR_RECV is performed.
S * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_RECV
S * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
S */
S#define Sn_IR_RECV           (0x04)
S
S/**
S * @brief DISCON Interrupt
S * @details @ref Sn_IR_DISCON is set when a FIN or FIN/ACK packet is received from the connected peer.
S * @note When first a FIN packet is received from the connected peer and @ref _Sn_SR_ is changed to SOCK_CLOSE_WAIT, \n
S *       you should perform @ref Sn_CR_DISCON for a successful disconnect. \n
S *       If the disconnect-process is completed or failed, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valild only in TCP mode such as @ref Sn_MR_TCP4, @ ref Sn_MR_TCP6 and @ref Sn_MR_TCPD.
S * @sa _Sn_IR_, _Sn_IRCLR_, Sn_IR_DISCON, _Sn_SR_
S * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR(), getSn_SR()
S */
S#define Sn_IR_DISCON         (0x02)
S
S/**
S * @brief CONNECT Interrupt
S * @details @ref Sn_IR_CON is set once the connection with a peer is established and @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ ref Sn_MR_TCP6 adn @ref Sn_MR_TCPD.
S * @sa _Sn_IR_, _Sn_IRCLR_, _Sn_SR_
S * @sa getSn_IR(), setSn_IRCLR(), getSn_SR()
S */
S#define Sn_IR_CON            (0x01)
S
S/* Sn_SR values */
S/**
S * @brief SOCKETn Closed status
S * @details @ref SOCK_CLOSED indicates that SOCKETn is closed and released.\n
S *          It is set when @ref Sn_CR_DISCON , @ref Sn_CR_CLOSE is performed, or when @ref Sn_IR_TIMEOUT is set.\n
S *          It can be changed to @ref SOCK_CLOSED regardless of previous status.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
S * @sa getSn_SR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR()
S */
S#define SOCK_CLOSED          (0x00)
S
S/**
S * @brief TCP SOCKETn initialized status
S * @details @ref SOCK_INIT indicates SOCKETn is opened with TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.\n
S *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT when @ref Sn_CR_OPEN is performed in TCP mode.\n
S *          In @ref SOCK_INIT status, @ref Sn_CR_LISTEN for operating a <b>TCP SERVER</b> \n
S *          or @ref Sn_CR_CONNECT / @ref Sn_CR_CONNECT6 for operating a <b>TCP CLIENT</b> can be performed.
S * @note It is valid only in TCP mode.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_MR_
S * @sa getSn_SR, getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_INIT            (0x13)
S
S/**
S * @brief TCP SOCKETn Listen status
S * @details @ref SOCK_LISTEN indicates SOCKETn is operating as <b>TCP SERVER</b> mode \n
S *          and waiting for connection-request (SYN packet) from a peer (<b>TCP CLIENT</b>).\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_SYNRECV when the connection-request(SYN packet) is successfully accepted \n
S *          and It is changed from @ref SOCK_SYNRECV to @ref SOCK_ESTABLISHED \n
S *          when the SYN/ACK packet is sent successfully to the peer and then the ACK packet of SYN/ACK is received successfully.\n
S *          Otherwise, it is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_ 
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_LISTEN          (0x14)
S
S/**
S * @brief TCP Connection Request status
S * @details @ref SOCK_SYNSENT indicates TCP SOCKETn sent the connect-request packet(SYN packet)\n
S *          to the peer specified by @ref _Sn_DIPR_ / @ref _Sn_DIP6R_ and @ref _Sn_DPORTR_.\n
S *          It is temporarily shown when @ref _Sn_SR_ is changing from @ref SOCK_INIT to @ref SOCK_ESTABLISHED by @ref Sn_CR_CONNECT or @ref Sn_CR_CONNECT6.\n
S *          When the connect-accept packet (SYN/ACK packet) is received from the peer at @ref SOCK_SYNSENT and the ACK packet of SYN/ACK is sent successfully, \n
S *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED.\n
S *          Otherwise, it is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_  
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_SYNSENT         (0x15)
S
S/**
S * @brief TCP Connection Accept status
S * @details @ref SOCK_SYNRECV indicates TCP SOCKETn is successfully received the connect-request packet (SYN packet) from a peer.\n
S *          It is temporarily shown when @ref _Sn_SR_ is changing from @ref SOCK_LISTEN to @ref SOCK_ESTABLISHED by the SYN packet\n
S *          If SOCKETn sends the response (SYN/ACK  packet) to the peer successfully and the ACK packet of SYS/ACK is received successfully,\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED. \n
S *          Otherwise, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_SYNRECV         (0x16)
S
S/**
S * @brief TCP SOCKETn Established status
S * @details @ref SOCK_ESTABLISHED indicates TCP SOCKETn is connected successfully with a peer.\n
S *          when the <b>TCP SERVER</b> processes the SYN packet from the <b>TCP CLIENT</b> during @ref SOCK_LISTEN or \n
S *          when the <b>TCP CLIENT</b> performs successfully @ref Sn_CR_CONNECT or @ref Sn_CR_CONNECT6,\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and @ref Sn_IR_CON is set. \n
S *          During @ref SOCK_ESTABLISHED, a DATA packet can be sent to or received from the peer by @ref Sn_CR_SEND or @ref Sn_CR_RECV.  \n
S *          If the DATA/ACK packet is not received from the peer during data re-transmission, @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n
S *          Otherwise, @ref _Sn_SR_ is still at @ref SOCK_ESTABLISHED.
S * @note In <b>TCP SERVER</b>, \n
S *       You can check the IPv4/IPv6 address and port number of connected peer thru @ref _Sn_DIPR_, @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_ respectively.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
S *     getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR().
S */
S#define SOCK_ESTABLISHED     (0x17)
S
S/**
S * @brief TCP SOCKETn Closing status
S * @details @ref SOCK_FIN_WAIT indicates TCP mode SOCKETn waits until the disconnect-process is completed. \n
S *          It is temporarily shown in disconnect-process such as active-close. \n
S *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_TIME_WAIT, SOCK_LAST_ACK
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S *
S */
S#define SOCK_FIN_WAIT        (0x18)
S
S/**
S * @brief TCP SOCKETn Closing status
S * @details @ref SOCK_TIME_WAIT indicates TCP SOCKETn waits until the disconnect-process is completed.\n
S *          It is temporarily shown in disconnect-process such as active-close. \n
S *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_FIN_WAIT, SOCK_LAST_ACK 
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_TIME_WAIT       (0x1B)
S
S/**
S * @brief TCP SOCKETn Half Closing staus
S * @details @ref SOCK_CLOSE_WAIT indicates TCP SOCKETn receives the disconnect-request (FIN packet) from the connected peer.\n
S *          It is a half-closing status, and a DATA packet can be still sent or received by @ref Sn_CR_SEND or @ref Sn_CR_RECV.\n
S *          If you do not have any more need to send or received a DATA packet, You can perform @ref Sn_CR_DISCON for a full-closing.
S * @note If you have no need the successful closing, You maybe perform @ref Sn_CR_CLOSE.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_ 
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_CLOSE_WAIT      (0x1C)
S
S/**
S * @brief TCP SOCKETn Closing status
S * @details @ref SOCK_LAST_ACK indicates TCP SOCKETn waits until the disconnect-process is completed.\n
S *          It is temporarily shown in disconnect-process such as active-close and passive-close.\n
S *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
S *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_FIN_WAIT, SOCK_TIME_WAIT 
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
S */
S#define SOCK_LAST_ACK        (0x1D)
S
S/**
S * @brief UDP SOCKETn status
S * @details @ref SOCK_UDP indicates SOCKETn is opened in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.\n
S *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT when @ref Sn_CR_OPEN is performed in UDP mode.\n
S *          Unlike TCP mode, during @ref SOCK_UDP, \n
S *          a DATA packet can be sent to or received from a peer by @ref Sn_CR_SEND / @ref Sn_CR_SEND6 or @ref Sn_CR_RECV without a connect-process.\n
S *          Before a DATA packet is sent by @ref Sn_CR_SEND / @ref Sn_CR_SEND6,\n
S *          the ARP is requested to the peer specified by @ref _Sn_DIPR_ / @ref _Sn_DIP6R_.\n
S *          In ARP processing, @ref _Sn_SR_ is stll at @ref SOCK_UDP even if @ref Sn_IR_TIMEOUT is set.\n
S *          If you do not have any more need to send or received a DATA packet, \n
S *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
S *     getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R()
S */
S#define SOCK_UDP             (0x22)
S
S/**
S * @brief IPRAW4 SOCKETn mode
S * @details @ref SOCK_IPRAW4(= @ref SOCK_IPRAW) SOCKETn indicates SOCKETn is opened as IPv4 RAW mode.\n
S *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW4 when @ref Sn_CR_OPEN is performed with @ref Sn_MR_IPRAW4. \n
S *          A DATA packet can be send to or received from a peer without a connection like as @ref SOCK_UDP. \n
S *          Before a DATA packet is sent by @ref Sn_CR_SEND, \n
S *          the ARP is requested to the peer specified by @ref _Sn_DIPR_.\n
S *          In ARP processing, @ref _Sn_SR_ is still at @ref SOCK_IPRAW4 even if @ref Sn_IR_TIMEOUT is set.\n
S *          IPRAW4 SOCKETn can receive only the packet specified by @ref _Sn_PNR_, and it discards the others packets.\n
S *          If you do not have any more need to send or received a DATA packet, \n
S *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in IPRAW4 mode such as @ref Sn_MR_IPRAW4.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_PNR_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
S *     getSn_DIPR(), setSn_DIPR(), getSn_PNR(), setSn_PNR() 
S */
S#define SOCK_IPRAW4          (0x32)
S#define SOCK_IPRAW           (SOCK_IPRAW4)   ///< Refer to @ref SOCK_IPRAW4.
S
S/**
S * @brief IPRAW6 SOCKETn mode
S * @details @ref SOCK_IPRAW6 SOCKETn indicates SOCKETn is opened as IPv6 RAW mode.\n
S *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW6 when @ref Sn_CR_OPEN is performed with @ref Sn_MR_IPRAW6. \n
S *          A DATA packet can be send to or received from a peer without a connection like as @ref SOCK_UDP.\n
S *          Before a DATA packet is sent by @ref Sn_CR_SEND6, \n
S *          the ICMPv6 NS is requested to the peer specified by @ref _Sn_DIPR_ or @ref _Sn_DIP6R_.\n
S *          In ND(Neighbor Discovery) is processing,\n
S *          @ref _Sn_SR_ is still at @ref SOCK_IPRAW6 even if @ref Sn_IR_TIMEOUT is set.\n
S *          IPRAW6 SOCKETn can receive only the packet specified by @ref _Sn_PNR_, and it discards the others packets.\n
S *          If you do not have any more need to send or received a DATA packet, \n
S *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
S * @note It is valid only in IPRAW6 mode such as @ref Sn_MR_IPRAW6.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIP6R_, _Sn_PNR_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
S *     getSn_DIP6R(), setSn_DIP6R(), getSn_PNR(), setSn_PNR() 
S */
S#define SOCK_IPRAW6          (0x33)
S
S/**
S * @brief MACRAW SOCKETn mode
S * @details @ref SOCK_MACRAW indicates SOCKET0 is opened as MACRAW mode.\n
S *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_MACRAW when @ref Sn_CR_OPEN command is ordered with @ref Sn_MR_MACRAW.\n
S *          MACRAW SOCKET0 can be sent or received a pure Ethernet frame packet to/from any peer.
S * @note  It is valid only in SOCKET0.
S * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
S * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
S */
S#define SOCK_MACRAW          (0x42)
S
S/* Sn_ESR values */
S/**
S * @brief SOCKETn Extended Status : TCP Mode
S * @details @ref Sn_ESR_TCPM masks the TCPM bit of @ref _Sn_ESR_. \n
S *          The masked bit values are as following. \n
S *          - @ref Sn_ESR_TCPM_IPV4
S *          - @ref Sn_ESR_TCPM_IPV6
S * @note It is useful to know the destination IP version when TCPD(@ref Sn_MR_TCPD) mode SOCKETn is operated as <b>TCP SERVER</b>.
S * @sa _Sn_ESR_
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPM          (1<<2)
S
S/**
S * @brief TCP SOCKETn IP version - IPv4
S * @details @ref Sn_ESR_TCPM_IPV4 indicates TCP SOCKETn is operated on IPv4 .
S * @sa _Sn_ESR_, Sn_ESR_TCPM_IPV6
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPM_IPV4     (0<<2)
S
S/**
S * @brief TCP SOCKETn IP version - IPv6
S * @details @ref Sn_ESR_TCPM_IPV6 indicates TCP SOCKETn is operated on IPv6 .
S * @sa _Sn_ESR_, Sn_ESR_TCPM_IPV4
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPM_IPV6     (1<<2)
S
S/**
S * @brief SOCKETn Extended Status : TCP Operation Mode
S * @details @ref Sn_ESR_TCPOP masks the TCPOP bit of @ref _Sn_ESR_. The masked bit values are as following. \n
S *            - @ref Sn_ESR_TCPOP_SVR
S *            - @ref Sn_ESR_TCPOP_CLT
S * @note It is useful to check TCP mode SOCKETn is operated as whether <b>TCP SERVER</b> or <b>TCP CLIENT</b>.
S * @sa _Sn_ESR_
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPOP         (1<<1)
S
S/**
S * @brief TCP SOCKETn Operation Mode - <b>TCP SERVER</b>
S * @details @ref Sn_ESR_TCPOP_SVR indicates TCP mode SOCKET n is operated as <b>TCP SERVER</b>
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_ESR_, Sn_ESR_TCPOP_CLT
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPOP_SVR     (0<<1)
S
S/**
S * @brief TCP SOCKETn Operation Mode - <b>TCP CLIENT</b>
S * @details @ref Sn_ESR_TCPOP_SVR indicates TCP mode SOCKET n is operated as <b>TCP CLIENT</b>
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_ESR_, Sn_ESR_TCPOP_SVR
S * @sa getSn_ESR()
S */
S#define Sn_ESR_TCPOP_CLT     (1<<1)
S
S/**
S * @brief SOCKETn Extended Status : Source IPv6 Address Type
S * @details @ref Sn_ESR_IP6T masks the IP6T bit of @ref _Sn_ESR_. \n
S *          The masked bit values are as following. \n
S *            - @ref Sn_ESR_IP6T_LLA
S *            - @ref Sn_ESR_IP6T_GUA
S * @note It is useful to check whether the connected peer IP address is LLA or GUA.
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD.
S * @sa _Sn_ESR_
S * @sa getSn_ESR()
S */
S#define Sn_ESR_IP6T          (1<<0)
S
S/**
S * @brief Source IPv6 Address Type - LLA
S * @details @ref Sn_ESR_IP6T_LLA indicates the source IPv6 Address is used as @ref _LLAR_
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_ESR_, Sn_ESR_IP6T_GUA, _LLAR_
S * @sa getSn_ESR(), getLLAR(), setLLAR()
S */
S#define Sn_ESR_IP6T_LLA      (0<<0)
S
S/**
S * @brief Source IPv6 Address Type - LLA
S * @details @ref Sn_ESR_IP6T_GUA indicates the source IPv6 Address is used as @ref _GUAR_
S * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
S * @sa _Sn_ESR_, Sn_ESR_IP6T_LLA, _GUAR_
S * @sa getSn_ESR(), getGUAR(), setGUAR()
S */
S#define Sn_ESR_IP6T_GUA      (1<<0)
S
S/* Sn_MR2 values */
S/**
S * @brief Destination Hardware Address Mode 
S * @details @ref Sn_MR2_DHAM masks the DHAM bit of @ref _Sn_MR2_.\n
S *          The masked bit values are as following.
S *            - @ref Sn_MR2_DHAM_AUTO
S *            - @ref Sn_MR2_DHAM_MANUAL
S * @sa _Sn_MR2_
S * @sa getSn_MR2(), setSn_MR2()
S */
S#define Sn_MR2_DHAM          (1<<1)
S
S/**
S * @brief Destination Hardware Address Mode - AUTO
S * @details @ref Sn_MR2_DHAM_AUTO sets the destination hardware address as the address acquired by ARP-process.
S * @sa _Sn_MR2_, Sn_MR_DHAM_MANUAL, NETMR_DHAS
S * @sa getSn_MR2(), setSn_MR2(), getNETMR(), setNETMR()
S */
S#define Sn_MR2_DHAM_AUTO     (0<<1)
S
S/**
S * @brief Destination Hardware Address Mode - MANUAL
S * @details @ref Sn_MR2_DHAM_MANUAL sets the destination hardware address as @ref _Sn_DHAR_.
S * @sa _Sn_MR2_, Sn_MR_DHAM_MANUAL, NETMR_DHAS
S * @sa getSn_MR2(), setSn_MR2(), getNETMR(), setNETMR()
S */
S#define Sn_MR2_DHAM_MANUAL   (1<<1)
S
S/**
S * @brief Force ARP
S * @details @ref Sn_MR2_FARP force to perform the ARP-process for acquiring the destination hardware address, before data communication\n
S *          0 : Normal \n
S *          1 : Force ARP
S *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
S *     If SOCKETn is operated as <b>TCP SERVER</b>, It sets the destination hardware address as the address 
S *     acquired by the forced ARP-process before sending SYN/ACK packet.
S *   - In UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD 
S *     It sets the destination hardware address as the address acquired by the forced ARP-process whenever @ref Sn_CR_SEND or @ref Sn_CR_SEND6.
S * @note When @ref Sn_MR2_DHAM_MANUAL and @ref Sn_MR2_FARP = '1', It sets the destination hardware address as @ref _Sn_DHAR_ even if the ARP-process is forced.
S */
S#define Sn_MR2_FARP          (1<<0)
S
S
S/*----------------------------For PHY Control-------------------------------*/
S
S/**
S * @ingroup Common_register_group_W6100
S * @brief Basic Mode Control Register of Ethernet PHY [RW][0x3100]
S * @details @ref PHYRAR_BMCR can be controlled by MDC/MDIO controller of @ref _WIZCHIP_. \n
S *          Each bit of @ref PHYRAR_BMCR is defined as the following.
S * <table>
S *    <tr> <td>15</td>  <td>14</td> <td>13</td>  <td>12 </td>  <td>11</td>  <td>10  </td> <td>9  </td> <td>8  </td> <td>7   </td>  <td>6 ~ 0  </td> </tr>
S *    <tr> <td>RST</td> <td>LB</td> <td>SPD</td> <td>ANE</td> <td>PWDN</td> <td>ISOL</td> <td>RAN</td> <td>DPX</td> <td>COLT</td> <td>Reserved</td> </tr>
S * </table>
S *   - @ref BMCR_RST
S *   - @ref BMCR_LB
S *   - @ref BMCR_SPD
S *   - @ref BMCR_ANE
S *   - @ref BMCR_PWDN
S *   - @ref BMCR_ISOL : Not supported.
S *   - @ref BMCR_REAN
S *   - @ref BMCR_DPX
S *   - @ref BMCR_COLT
S *
S * @note Its some bits have the same function as @ref _PHYCR0_ and @ref _PHYCR1_.\n
S *       It can control the Ethernet PHY with software, while @ref _PHYCR0_ \n
S *       and @ref _PHYCR1_ can control the Ethernet PHY with hardware.
S *       
S * @sa PHYRAR_BMSR, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYCR0_, _PHYCR1_
S * @sa getPHYRAR(), setPHYRAR(), wiz_mdio_read(), wiz_mdio_write()
S */
S#define PHYRAR_BMCR          (0x00)
S
S//Basic mode status register, basic register
S/**
S * @ingroup Common_register_group_W6100
S * @brief Basic Mode Status Register of Ethernet PHY [RO][0x7809]
S * @details @ref PHYRAR_BMSR gets the status of Ethernet PHY through MDC/MDIO controller of @ref _WIZCHIP_. \n
S *          Each bit of @ref PHYRAR_BMSR is defined as the following.
S * <table>
S *    <tr> <td>15</td> <td>14</td> <td>13</td> <td>12</td> <td>11</td> <td>10~7</td> 
S *         <td>6 </td> <td>5 </td> <td>4 </td> <td>3 </td> <td>2 </td> <td>1   </td> <td>0</td> </tr>
S *    <tr> <td>100_T4  </td> <td>100_FDX     </td> <td>100_HDX    </td> <td>10_FDX     </td> <td>10_HDX       </td> <td>Reserved</td> <td>MF_SUP</td> 
S *         <td>ANG_COMP</td> <td>REMOTE_FAULT</td> <td>ANG_ABILITY</td> <td>LINK_STATUS</td> <td>JABBER_DETECT</td> <td>EXT_CAPA</td> </tr>
S * </table>
S *   - @ref BMSR_100_T4        : Not supported. Always 0
S *   - @ref BMSR_100_FDX
S *   - @ref BMSR_100_HDX
S *   - @ref BMSR_10_FDX
S *   - @ref BMSR_10_HDX
S *   - @ref BMSR_MF_SUP        : Not supported. Always 0.
S *   - @ref BMSR_AN_COMP
S *   - @ref BMSR_REMOTE_FAULT  : Not supported. Always 0.
S *   - @ref BMSR_AN_ABILITY
S *   - @ref BMSR_LINK_STATUS
S *   - @ref BMSR_JABBER_DETECT
S *   - @ref BMSR_EXT_CAPA      : Always 1. If you need a extended register information, send e-mail to support@wiznet.io
S *
S * @note Its some bits have the same function as @ref _PHYSR_.
S * @sa PHYRAR_BMCR, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYCR0_, _PHYCR1_
S * @sa getPHYRAR(), setPHYRAR(), wiz_mdio_read(), wiz_mdio_write()
S */
S#define PHYRAR_BMSR          (0x01)
S
S
S/********************/
S/* BMCR & BMSR Bit definitions  */
S/********************/
S
S/*For BMCR register*/
S/**
S * @brief Ethernet PHY S/W Reset.
S * @details 0 - Normal operation \n
S *          1 - Software reset
S * @sa PHYRAR_BMCR, PHYCR1_RST
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define BMCR_RST             (1<<15)
S
S/**
S * @brief Ethernet PHY Loopback.
S * @details 0 - Normal Operation \n
S *          1 - Loopback Enable
S * @sa PHYRAR_BMCR
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define BMCR_LB              (1<<14)  ///< Loopback. 0 - Noraml operation, 1 - Loopback enabled
S
S/**
S * @brief Ethernet PHY Speed 
S * @details 0 - 10  Mbps \n
S *          1 - 100 Mbps
S * @sa PHYCR_BMCR, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
S */
S#define BMCR_SPD             (1<<13)
S
S/**
S * @brief Ethernet PHY Auto-Negotiation
S * @details 0 - Disable \n
S *          1 - Enable
S * @note When it is set, @ref BMCR_SPD and @ref BMCR_DPX is ignored
S * @sa PHYCR_BMCR, PHYCR0_AUTO
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
S */
S#define BMCR_ANE             (1<<12)
S
S/**
S * @brief Ethernet PHY Power Down Mode
S * @details 0 - Normal Operation \n
S *          1 - Power Down mode
S * @sa PHYCR_BMCR, PHYCR0_PWDN
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
S */
S#define BMCR_PWDN            (1<<11)  ///< Power-down mode
S
S/**
S * @brief Ethernet PHY Isolation Mode
S * @details 0 - Normal Operation \n
S *          1 - Isolation Mode
S * @ Don't set it to '1'. It is not supported.
S * @sa PHYCR_BMCR
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define BMCR_ISOL            (1<<10)
S
S/**
S * @brief Ethernet PHY Restart Auto-Negotiation
S * @details 0 - Normal Operation \n
S *          1 - Restart Auto-Negotiation
S * @sa PHYCR_BMCR
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define BMCR_REAN            (1<<9)
S
S/**
S * @brief Ethernet PHY Duplex 
S * @details 0 - Half-Duplex \n
S *          1 - Full-Duplex
S * @sa PHYCR_BMCR, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
S */
S#define BMCR_DPX             (1<<8)
S
S/**
S * @brief Ethernet PHY Collision Test
S * @details 0 - Normal Operation \n
S *          1 - Collision Test
S * @sa PHYCR_BMCR
S * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
S */
S#define BMCR_COLT            (1<<7)
S
S/*For BMSR register*/
S
S/**
S * @brief Ethernet PHY 100 Base-T4 capable
S * @details @ref BMSR_100_T4 is always 0.
S * @note It is not supported. 
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_100_T4          (1<<15)
S
S/**
S * @brief Ethernet PHY 100 Base-TX Full-Duplex capable
S * @details @ref BMSR_100_FDX is always 1.
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_100_FDX         (1<<14)
S
S/**
S * @brief Ethernet PHY 100 Base-TX Half-Duplex capable
S * @details @ref BMSR_100_HDX is always 1.
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_100_HDX         (1<<13)
S
S/**
S * @brief Ethernet PHY 10 Base-T Full-Duplex capable
S * @details @ref BMSR_10_FDX is always 1.
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_10_FDX          (1<<12)
S
S/**
S * @brief Ethernet PHY 10 Base-T Half-Duplex capable
S * @details @ref BMSR_10_HDX is always 1.
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_10_HDX          (1<<11)
S
S/**
S * @brief Ethernet PHY Management Frame preamble suppression
S * @details @ref BMSR_MF_SUP is always 0.
S * @note It is not supported 
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_MF_SUP          (1<<6)
S
S/**
S * @brief Ethernet PHY Auto-Negotiation Complete
S * @details @ref BMSR_MF_SUP indicates the status of auto-negotiation. \n
S *          0 - Auto-negotiation process is not completed \n
S *          1 - Auto-negotiation process is completed
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_AN_COMP         (1<<5)
S
S/**
S * @brief Ethernet PHY Remote Fault
S * @details @ref BMSR_REMOTE_FAULT is always 0.
S * @note It is not supported 
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_REMOTE_FAULT    (1<<4)
S
S/**
S * @brief Ethernet PHY Auto-Negotiation Ability
S * @details @ref BMSR_AN_ABILITY is always 1.
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_AN_ABILITY      (1<<3)
S
S/**
S * @brief Ethernet PHY Link Status
S * @details @ref BMSR_LINK_STATUS indicates the status of link. \n
S *          0 - Link is not established
S *          1 - Valid link is established
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_LINK_STATUS     (1<<2)
S
S/**
S * @brief Ethernet PHY Jabber Detect
S * @details @ref BMSR_JABBER_DETECT indicates the status of auto-negotiation. \n
S *          0 - Jabber condition is not detected\n
S *          1 - Jabber condition is detected
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_JABBER_DETECT   (1<<1)
S
S/**
S * @brief Ethernet PHY Extended capability
S * @details @ref BMSR_EXT_CAPA indicates the extended register capability. \n
S *          0 - Only basic registers are capable\n
S *          1 - Extended registers are capable
S * @sa PHYCR_BMSR
S * @sa getPHYRAR_BMSR()
S */
S#define BMSR_EXT_CAPA        (1<<0)
S
S
S/**
S * @brief Enter a critical section
S * @details It is provided to protect your shared code and hardware resources against interference. \n
S *   - Non-OS environment
S *     It can be just implemented by disabling whole interrupt.
S *   - OS environment
S *     You can replace it to critical section API supported by OS.
S *
S * @note It is callback function that can be replaced it with your code, by calling @ref reg_wizchip_cris_cbfunc(). 
S * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
S * @sa WIZCHIP_CRITICAL_EXIT(), reg_wizchip_cris_cbfunc()
S */
S#define WIZCHIP_CRITICAL_ENTER()       WIZCHIP.CRIS._e_n_t_e_r_()
S
S
S/**
S * @brief Enter a critical section
S * @details It exits the protected code and hardware resources against interference. \n
S *   - Non-OS environment
S *     It can be just implemented by enabling whole interrupt.\n
S *   - OS environment
S *     You can replace it to critical section API supported by OS.
S *
S * @note It is callback function that can be replaced it with your code, by calling @ref reg_wizchip_cris_cbfunc(). 
S * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
S * @sa WIZCHIP_CRITICAL_EXIT(), reg_wizchip_cris_cbfunc()
S */
S#define WIZCHIP_CRITICAL_EXIT()        WIZCHIP.CRIS._e_x_i_t_()
S
S
S
S////////////////////////
S// Basic I/O Function //
S////////////////////////
S//
S//
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It reads 1 byte value from a register.
S * @param AddrSel Register address
S * @return The value of register
S * @sa WIZCHIP_READ_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_WRITE()
S */
Suint8_t WIZCHIP_READ(uint32_t AddrSel);
S
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It writes 1 byte value to a register.
S * @param AddrSel Register address
S * @param wb Write data
S * @return void
S * @sa WIZCHIP_WRITE_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_READ()
S */
Svoid WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb );
S
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It reads sequentail data from registers.
S * @param AddrSel Register address
S * @param pBuf Pointer buffer to read data
S * @param len Data length
S * @return void
S * @sa WIZCHIP_WRITE_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_READ()
S */
Svoid WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, datasize_t len);
S
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It writes sequential data to registers.
S * @param AddrSel Register address
S * @param pBuf Pointer buffer to write data
S * @param len Data length
S * @return void
S * @sa WIZCHIP_READ_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_WRITE()
S */
Svoid WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, datasize_t len);
S
S
S
S/////////////////////////////////
S// Common Register IO function //
S/////////////////////////////////
S/**
S * @addtogroup Common_register_access_function_W6100
S * @{
S */
S#define getCIDR() \
S        ((((uint16_t)WIZCHIP_READ(_CIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_CIDR_,1)))
X#define getCIDR()         ((((uint16_t)WIZCHIP_READ(_CIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_CIDR_,1)))
S
S#define getVER() \
S        ((((uint16_t)WIZCHIP_READ(_VER_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VER_,1)))
X#define getVER()         ((((uint16_t)WIZCHIP_READ(_VER_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VER_,1)))
S
S#define getSYSR() \
S        WIZCHIP_READ(_SYSR_)
X#define getSYSR()         WIZCHIP_READ(_SYSR_)
S
S#define getSYCR0() \
S        WIZCHIP_READ(_SYCR0_)
X#define getSYCR0()         WIZCHIP_READ(_SYCR0_)
S
S#define setSYCR0(sycr0) \
S        WIZCHIP_WRITE(_SYCR0_, (sycr0))
X#define setSYCR0(sycr0)         WIZCHIP_WRITE(_SYCR0_, (sycr0))
S
S#define getSYCR1() \
S        WIZCHIP_READ(_SYCR1_)
X#define getSYCR1()         WIZCHIP_READ(_SYCR1_)
S                  
S#define setSYCR1(sycr1) \
S        WIZCHIP_WRITE(_SYCR1_, (sycr1))
X#define setSYCR1(sycr1)         WIZCHIP_WRITE(_SYCR1_, (sycr1))
S
S#define getTCNTR() \
S        ((((uint16_t)WIZCHIP_READ(_TCNTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_TCNTR_,1)))
X#define getTCNTR()         ((((uint16_t)WIZCHIP_READ(_TCNTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_TCNTR_,1)))
S
S#define setTCNTRCLR(tcntrclr) \
S        WIZCHIP_WRITE(_TCNTRCLR_,(tcntrclr))
X#define setTCNTRCLR(tcntrclr)         WIZCHIP_WRITE(_TCNTRCLR_,(tcntrclr))
S
S#define getIR() \
S        WIZCHIP_READ(_IR_)
X#define getIR()         WIZCHIP_READ(_IR_)
S
S#define getSIR() \
S        WIZCHIP_READ(_SIR_)
X#define getSIR()         WIZCHIP_READ(_SIR_)
S
S#define getSLIR() \
S        WIZCHIP_READ(_SLIR_)
X#define getSLIR()         WIZCHIP_READ(_SLIR_)
S
S#define setIMR(imr) \
S        WIZCHIP_WRITE(_IMR_,(imr))
X#define setIMR(imr)         WIZCHIP_WRITE(_IMR_,(imr))
S
S#define getIMR() \
S        WIZCHIP_READ(_IMR_)
X#define getIMR()         WIZCHIP_READ(_IMR_)
S
S#define setIRCLR(irclr) \
S        WIZCHIP_WRITE(_IRCLR_,(irclr))
X#define setIRCLR(irclr)         WIZCHIP_WRITE(_IRCLR_,(irclr))
S#define setIR(ir)                setIRCLR(ir)
S
S#define setSIMR(simr) \
S        WIZCHIP_WRITE(_SIMR_,(simr))
X#define setSIMR(simr)         WIZCHIP_WRITE(_SIMR_,(simr))
S
S#define getSIMR() \
S        WIZCHIP_READ(_SIMR_)
X#define getSIMR()         WIZCHIP_READ(_SIMR_)
S
S#define setSLIMR(slimr) \
S        WIZCHIP_WRITE(_SLIMR_,(slimr))
X#define setSLIMR(slimr)         WIZCHIP_WRITE(_SLIMR_,(slimr))
S
S#define getSLIMR() \
S        WIZCHIP_READ(_SLIMR_)
X#define getSLIMR()         WIZCHIP_READ(_SLIMR_)
S
S#define setSLIRCLR(slirclr) \
S        WIZCHIP_WRITE(_SLIRCLR_,(slirclr))
X#define setSLIRCLR(slirclr)         WIZCHIP_WRITE(_SLIRCLR_,(slirclr))
S#define setSLIR(slir)            setSLIRCLR(slir)
S
S#define setSLPSR(slpsr) \
S        WIZCHIP_WRITE(_SLPSR_,(slpsr))
X#define setSLPSR(slpsr)         WIZCHIP_WRITE(_SLPSR_,(slpsr))
S
S#define getSLPSR() \
S        WIZCHIP_READ(_SLPSR_)
X#define getSLPSR()         WIZCHIP_READ(_SLPSR_)
S
S#define setSLCR(slcr) \
S        WIZCHIP_WRITE(_SLCR_,(slcr))
X#define setSLCR(slcr)         WIZCHIP_WRITE(_SLCR_,(slcr))
S                  
S#define getSLCR()      \
S        WIZCHIP_READ(_SLCR_)
X#define getSLCR()              WIZCHIP_READ(_SLCR_)
S
S#define getPHYSR() \
S        WIZCHIP_READ(_PHYSR_)
X#define getPHYSR()         WIZCHIP_READ(_PHYSR_)
S
S#define setPHYRAR(phyrar) \
S        WIZCHIP_WRITE(_PHYRAR_,(phyrar))
X#define setPHYRAR(phyrar)         WIZCHIP_WRITE(_PHYRAR_,(phyrar))
S
S#define getPHYRAR() \
S        WIZCHIP_READ(_PHYRAR_)
X#define getPHYRAR()         WIZCHIP_READ(_PHYRAR_)
S
S#define setPHYDIR(phydir)  \
S        do{                                                                       \
S           WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PHYDIR_,1), (uint8_t)((phydir)>>8)); \
S           WIZCHIP_WRITE(_PHYDIR_, (uint8_t)(phydir));                            \
S        }while(0);
X#define setPHYDIR(phydir)          do{                                                                                  WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PHYDIR_,1), (uint8_t)((phydir)>>8));            WIZCHIP_WRITE(_PHYDIR_, (uint8_t)(phydir));                                    }while(0);
S
S#define getPHYDOR() \
S        ((((uint16_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PHYDOR_,1))) << 8) + WIZCHIP_READ(_PHYDOR_))
X#define getPHYDOR()         ((((uint16_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PHYDOR_,1))) << 8) + WIZCHIP_READ(_PHYDOR_))
S
S#define setPHYACR(phyacr) \
S        WIZCHIP_WRITE(_PHYACR_,(phyacr))
X#define setPHYACR(phyacr)         WIZCHIP_WRITE(_PHYACR_,(phyacr))
S
S#define getPHYACR() \
S        WIZCHIP_READ(_PHYACR_)
X#define getPHYACR()         WIZCHIP_READ(_PHYACR_)
S
S#define setPHYDIVR(phydivr) \
S        WIZCHIP_WRITE(_PHYDIVR_,(phydivr))
X#define setPHYDIVR(phydivr)         WIZCHIP_WRITE(_PHYDIVR_,(phydivr))
S
S#define getPHYDIVR() \
S        WIZCHIP_READ(_PHYDIVR_)
X#define getPHYDIVR()         WIZCHIP_READ(_PHYDIVR_)
S
S#define setPHYCR0(phycr0) \
S        WIZCHIP_WRITE(_PHYCR0_,(phycr0))
X#define setPHYCR0(phycr0)         WIZCHIP_WRITE(_PHYCR0_,(phycr0))
S
S#define setPHYCR1(phycr1) \
S        WIZCHIP_WRITE(_PHYCR1_,(phycr1))
X#define setPHYCR1(phycr1)         WIZCHIP_WRITE(_PHYCR1_,(phycr1))
S
S#define getPHYCR1() \
S        WIZCHIP_READ(_PHYCR1_)
X#define getPHYCR1()         WIZCHIP_READ(_PHYCR1_)
S
S#define setNET4MR(net4mr) \
S        WIZCHIP_WRITE(_NET4MR_,(net4mr))
X#define setNET4MR(net4mr)         WIZCHIP_WRITE(_NET4MR_,(net4mr))
S
S#define setNET6MR(net6mr) \
S        WIZCHIP_WRITE(_NET6MR_,(net6mr))
X#define setNET6MR(net6mr)         WIZCHIP_WRITE(_NET6MR_,(net6mr))
S
S#define setNETMR(netmr) \
S        WIZCHIP_WRITE(_NETMR_,(netmr))
X#define setNETMR(netmr)         WIZCHIP_WRITE(_NETMR_,(netmr))
S
S#define setNETMR2(netmr2) \
S        WIZCHIP_WRITE(_NETMR2_,(netmr2))
X#define setNETMR2(netmr2)         WIZCHIP_WRITE(_NETMR2_,(netmr2))
S
S#define getNET4MR() \
S        WIZCHIP_READ(_NET4MR_)
X#define getNET4MR()         WIZCHIP_READ(_NET4MR_)
S
S#define getNET6MR() \
S        WIZCHIP_READ(_NET6MR_)
X#define getNET6MR()         WIZCHIP_READ(_NET6MR_)
S
S#define getNETMR() \
S        WIZCHIP_READ(_NETMR_)
X#define getNETMR()         WIZCHIP_READ(_NETMR_)
S
S#define getNETMR2() \
S        WIZCHIP_READ(_NETMR2_)
X#define getNETMR2()         WIZCHIP_READ(_NETMR2_)
S
S#define setPTMR(ptmr) \
S        WIZCHIP_WRITE(_PTMR_, (ptmr))
X#define setPTMR(ptmr)         WIZCHIP_WRITE(_PTMR_, (ptmr))
S
S#define getPTMR() \
S        WIZCHIP_READ(_PTMR_)
X#define getPTMR()         WIZCHIP_READ(_PTMR_)
S
S#define setPMNR(pmnr) \
S        WIZCHIP_WRITE(_PMNR_, (pmnr))
X#define setPMNR(pmnr)         WIZCHIP_WRITE(_PMNR_, (pmnr))
S
S#define getPMNR() \
S        WIZCHIP_READ(_PMNR_)
X#define getPMNR()         WIZCHIP_READ(_PMNR_)
S
S#define setPHAR(phar) \
S        WIZCHIP_WRITE_BUF(_PHAR_,(phar),6)
X#define setPHAR(phar)         WIZCHIP_WRITE_BUF(_PHAR_,(phar),6)
S
S#define getPHAR(phar) \
S        WIZCHIP_READ_BUF(_PHAR_,(phar),6)
X#define getPHAR(phar)         WIZCHIP_READ_BUF(_PHAR_,(phar),6)
S
S#define setPSIDR(psidr) \
S        do{                                                                \
S            WIZCHIP_WRITE(_PSIDR_,(uint8_t)((psidr) >> 8));                \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PSIDR_,1),(uint8_t)(psidr)); \
S        }while(0);
X#define setPSIDR(psidr)         do{                                                                            WIZCHIP_WRITE(_PSIDR_,(uint8_t)((psidr) >> 8));                            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PSIDR_,1),(uint8_t)(psidr));         }while(0);
S
S#define getPSIDR() \
S        ((((uint16_t)WIZCHIP_READ(_PSIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PSIDR_,1)))
X#define getPSIDR()         ((((uint16_t)WIZCHIP_READ(_PSIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PSIDR_,1)))
S
S#define setPMRUR(pmrur) \
S        do{                                                                \
S            WIZCHIP_WRITE(_PMRUR_,(uint8_t)((pmrur) >> 8));                \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PMRUR_,1),(uint8_t)(pmrur)); \
S        }while(0);
X#define setPMRUR(pmrur)         do{                                                                            WIZCHIP_WRITE(_PMRUR_,(uint8_t)((pmrur) >> 8));                            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PMRUR_,1),(uint8_t)(pmrur));         }while(0);
S
S#define getPMRUR() \
S        ((((uint16_t)WIZCHIP_READ(_PMRUR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PMRUR_,1)))
X#define getPMRUR()         ((((uint16_t)WIZCHIP_READ(_PMRUR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PMRUR_,1)))
S
S#define setSHAR(shar) \
S        WIZCHIP_WRITE_BUF(_SHAR_,(shar),6)
X#define setSHAR(shar)         WIZCHIP_WRITE_BUF(_SHAR_,(shar),6)
S
S#define getSHAR(shar) \
S        WIZCHIP_READ_BUF(_SHAR_,(shar),6)
X#define getSHAR(shar)         WIZCHIP_READ_BUF(_SHAR_,(shar),6)
S
S#define setGAR(gar) \
S        WIZCHIP_WRITE_BUF(_GAR_,(gar),4)
X#define setGAR(gar)         WIZCHIP_WRITE_BUF(_GAR_,(gar),4)
S
S#define getGAR(gar) \
S        WIZCHIP_READ_BUF(_GAR_,(gar),4)
X#define getGAR(gar)         WIZCHIP_READ_BUF(_GAR_,(gar),4)
S
S#define setGA4R(ga4r)            setGAR(ga4r)
S#define getGA4R(ga4r)            getGAR(ga4r)
S
S#define setSUBR(subr) \
S        WIZCHIP_WRITE_BUF(_SUBR_,(subr),4)
X#define setSUBR(subr)         WIZCHIP_WRITE_BUF(_SUBR_,(subr),4)
S
S#define getSUBR(subr) \
S        WIZCHIP_READ_BUF(_SUBR_,(subr),4)
X#define getSUBR(subr)         WIZCHIP_READ_BUF(_SUBR_,(subr),4)
S
S#define setSUB4R(sub4r)          setSUBR(sub4r)
S#define getSUB4R(sub4r)          getSUBR(sub4r)
S
S#define setSIPR(sipr) \
S        WIZCHIP_WRITE_BUF(_SIPR_,(sipr),4)
X#define setSIPR(sipr)         WIZCHIP_WRITE_BUF(_SIPR_,(sipr),4)
S
S#define getSIPR(sipr) \
S        WIZCHIP_READ_BUF(_SIPR_,(sipr),4)
X#define getSIPR(sipr)         WIZCHIP_READ_BUF(_SIPR_,(sipr),4)
S
S#define setLLAR(llar) \
S        WIZCHIP_WRITE_BUF(_LLAR_,(llar),16)
X#define setLLAR(llar)         WIZCHIP_WRITE_BUF(_LLAR_,(llar),16)
S
S#define getLLAR(llar) \
S        WIZCHIP_READ_BUF(_LLAR_,(llar),16)
X#define getLLAR(llar)         WIZCHIP_READ_BUF(_LLAR_,(llar),16)
S
S#define setGUAR(guar) \
S        WIZCHIP_WRITE_BUF(_GUAR_,(guar),16)
X#define setGUAR(guar)         WIZCHIP_WRITE_BUF(_GUAR_,(guar),16)
S
S#define getGUAR(guar) \
S        WIZCHIP_READ_BUF(_GUAR_,(guar),16)
X#define getGUAR(guar)         WIZCHIP_READ_BUF(_GUAR_,(guar),16)
S
S#define setSUB6R(sub6r) \
S        WIZCHIP_WRITE_BUF(_SUB6R_,(sub6r),16)
X#define setSUB6R(sub6r)         WIZCHIP_WRITE_BUF(_SUB6R_,(sub6r),16)
S
S#define getSUB6R(sub6r) \
S        WIZCHIP_READ_BUF(_SUB6R_,(sub6r),16)
X#define getSUB6R(sub6r)         WIZCHIP_READ_BUF(_SUB6R_,(sub6r),16)
S
S#define setGA6R(ga6r) \
S        WIZCHIP_WRITE_BUF(_GA6R_,(ga6r),16)
X#define setGA6R(ga6r)         WIZCHIP_WRITE_BUF(_GA6R_,(ga6r),16)
S
S#define getGA6R(ga6r) \
S        WIZCHIP_READ_BUF(_GA6R_,(ga6r),16)
X#define getGA6R(ga6r)         WIZCHIP_READ_BUF(_GA6R_,(ga6r),16)
S
S#define setSLDIPR(sldipr) \
S        WIZCHIP_WRITE_BUF(_SLDIPR_,(sldipr),4)
X#define setSLDIPR(sldipr)         WIZCHIP_WRITE_BUF(_SLDIPR_,(sldipr),4)
S#define setSLDIP4R(sldip4r)      setSLDIPR((sldip4r))
S
S#define getSLDIPR(sldipr) \
S        WIZCHIP_READ_BUF(_SLDIPR_,(sldipr),4)
X#define getSLDIPR(sldipr)         WIZCHIP_READ_BUF(_SLDIPR_,(sldipr),4)
S#define getSLDIP4R(sldip4r)      getSLDIPR((sldip4r))
S
S#define setSLDIP6R(sldip6r) \
S        WIZCHIP_WRITE_BUF(_SLDIP6R_, (sldip6r),16)
X#define setSLDIP6R(sldip6r)         WIZCHIP_WRITE_BUF(_SLDIP6R_, (sldip6r),16)
S
S#define getSLDIP6R(sldip6r) \
S        WIZCHIP_READ_BUF(_SLDIP6R_,(sldip6r),16)
X#define getSLDIP6R(sldip6r)         WIZCHIP_READ_BUF(_SLDIP6R_,(sldip6r),16)
S
S#define getSLDHAR(sldhar) \
S        WIZCHIP_READ_BUF(_SLDHAR_,(sldhar),6)
X#define getSLDHAR(sldhar)         WIZCHIP_READ_BUF(_SLDHAR_,(sldhar),6)
S
S#define setPINGIDR(pingidr) \
S        do{                                                                    \
S            WIZCHIP_WRITE(_PINGIDR_,(uint8_t)((pingidr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGIDR_,1),(uint8_t)(pingidr)); \
S        }while(0);
X#define setPINGIDR(pingidr)         do{                                                                                WIZCHIP_WRITE(_PINGIDR_,(uint8_t)((pingidr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGIDR_,1),(uint8_t)(pingidr));         }while(0);
S
S#define getPINGIDR() \
S        (((int16_t)(WIZCHIP_READ(_PINGIDR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGIDR_,1)))
X#define getPINGIDR()         (((int16_t)(WIZCHIP_READ(_PINGIDR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGIDR_,1)))
S
S#define setPINGSEQR(pingseqr) \
S        do{                                                                      \
S            WIZCHIP_WRITE(_PINGSEQR_,(uint8_t)((pingseqr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGSEQR_,1),(uint8_t)(pingseqr)); \
S        }while(0);
X#define setPINGSEQR(pingseqr)         do{                                                                                  WIZCHIP_WRITE(_PINGSEQR_,(uint8_t)((pingseqr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGSEQR_,1),(uint8_t)(pingseqr));         }while(0);
S
S#define getPINGSEQR() \
S        (((int16_t)(WIZCHIP_READ(_PINGSEQR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGSEQR_,1)))
X#define getPINGSEQR()         (((int16_t)(WIZCHIP_READ(_PINGSEQR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGSEQR_,1)))
S
S#define getUIPR(uipr) \
S        WIZCHIP_READ_BUF(_UIPR_, (uipr), 4)
X#define getUIPR(uipr)         WIZCHIP_READ_BUF(_UIPR_, (uipr), 4)
S
S#define getUIP4R(uip4r)          getUIPR(uip4r)
S
S#define getUPORTR() \
S        ((((uint16_t)WIZCHIP_READ(_UPORTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORTR_,1)))
X#define getUPORTR()         ((((uint16_t)WIZCHIP_READ(_UPORTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORTR_,1)))
S
S#define getUPORT4R()             getUPORTR()
S
S#define getUIP6R(uip6r) \
S        WIZCHIP_READ_BUF(_UIP6R_,(uip6r),16)
X#define getUIP6R(uip6r)         WIZCHIP_READ_BUF(_UIP6R_,(uip6r),16)
S
S#define getUPORT6R(uport6r) \
S        ((((uint16_t)WIZCHIP_READ(_UPORT6R_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORT6R_,1)))
X#define getUPORT6R(uport6r)         ((((uint16_t)WIZCHIP_READ(_UPORT6R_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORT6R_,1)))
S
S#define setINTPTMR(intptmr) \
S        do{                                                                     \
S            WIZCHIP_WRITE(_INTPTMR_,(uint8_t)((intptmr) >> 8));                 \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_INTPTMR_,1),(uint8_t)(intptmr));  \
S       }while(0);
X#define setINTPTMR(intptmr)         do{                                                                                 WIZCHIP_WRITE(_INTPTMR_,(uint8_t)((intptmr) >> 8));                             WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_INTPTMR_,1),(uint8_t)(intptmr));         }while(0);
S
S#define getINTPTMR() \
S        ((((uint16_t)WIZCHIP_READ(_INTPTMR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_INTPTMR_,1)))
X#define getINTPTMR()         ((((uint16_t)WIZCHIP_READ(_INTPTMR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_INTPTMR_,1)))
S
S#define getPLR() \
S        WIZCHIP_READ(_PLR_)
X#define getPLR()         WIZCHIP_READ(_PLR_)
S
S#define getPFR() \
S        WIZCHIP_READ(_PFR_)
X#define getPFR()         WIZCHIP_READ(_PFR_)
S
S#define getVLTR() \
S        ( (((uint32_t)WIZCHIP_READ(_VLTR_)) << 24) +                       \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,1))) << 16) + \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,2))) << 16) + \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,3))) << 16) )
X#define getVLTR()         ( (((uint32_t)WIZCHIP_READ(_VLTR_)) << 24) +                                 (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,1))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,2))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,3))) << 16) )
S
S#define getPLTR() \
S        ( (((uint32_t)WIZCHIP_READ(_PLTR_)) << 24) +                       \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,1))) << 16) + \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,2))) << 16) + \
S          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,3))) << 16) )
X#define getPLTR()         ( (((uint32_t)WIZCHIP_READ(_PLTR_)) << 24) +                                 (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,1))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,2))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,3))) << 16) )
S
S#define getPAR(par) \
S        WIZCHIP_READ_BUF(_PAR_, (par), 16)
X#define getPAR(par)         WIZCHIP_READ_BUF(_PAR_, (par), 16)
S
S#define setICMP6BLKR(icmp6blkr) \
S        WIZCHIP_WRITE(_ICMP6BLKR_,(icmp6blkr))
X#define setICMP6BLKR(icmp6blkr)         WIZCHIP_WRITE(_ICMP6BLKR_,(icmp6blkr))
S
S#define getICMP6BLKR() \
S        WIZCHIP_READ(_ICMP6BLKR_)
X#define getICMP6BLKR()         WIZCHIP_READ(_ICMP6BLKR_)
S
S#define setCHPLCKR(chplckr) \
S        WIZCHIP_WRITE(_CHPLCKR_, (chplckr))
X#define setCHPLCKR(chplckr)         WIZCHIP_WRITE(_CHPLCKR_, (chplckr))
S
S#define getCHPLCKR() \
S        ((getSYSR() & SYSR_CHPL) >> 7)
X#define getCHPLCKR()         ((getSYSR() & SYSR_CHPL) >> 7)
S
S#define CHIPLOCK()      setCHPLCKR(0xFF)
S#define CHIPUNLOCK()    setCHPLCKR(0xCE)
S
S#define setNETLCKR(netlckr) \
S        WIZCHIP_WRITE(_NETLCKR_, (netlckr))
X#define setNETLCKR(netlckr)         WIZCHIP_WRITE(_NETLCKR_, (netlckr))
S
S#define getNETLCKR() \
S        ((getSYSR() & SYSR_NETL) >> 6)
X#define getNETLCKR()         ((getSYSR() & SYSR_NETL) >> 6)
S
S#define NETLOCK()      setNETLCKR(0xC5)
S#define NETUNLOCK()    setNETLCKR(0x3A)
S
S#define setPHYLCKR(phylckr) \
S        WIZCHIP_WRITE(_PHYLCKR_,(phylckr))
X#define setPHYLCKR(phylckr)         WIZCHIP_WRITE(_PHYLCKR_,(phylckr))
S
S#define getPHYLCKR() \
S        ((getSYSR() & SYSR_PHYL) >> 5)
X#define getPHYLCKR()         ((getSYSR() & SYSR_PHYL) >> 5)
S
S#define PHYLOCK()      setPHYLCKR(0xFF)
S#define PHYUNLOCK()    setPHYLCKR(0x53)
S
S#define setRTR(rtr) \
S        do{                                                            \
S            WIZCHIP_WRITE(_RTR_,(uint8_t)((rtr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_RTR_,1),(uint8_t)(rtr)); \
S        }while(0);
X#define setRTR(rtr)         do{                                                                        WIZCHIP_WRITE(_RTR_,(uint8_t)((rtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_RTR_,1),(uint8_t)(rtr));         }while(0);
S
S#define getRTR() \
S        ((((uint16_t)WIZCHIP_READ(_RTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_RTR_,1)))
X#define getRTR()         ((((uint16_t)WIZCHIP_READ(_RTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_RTR_,1)))
S
S#define setRCR(rcr) \
S        WIZCHIP_WRITE(_RCR_,(rcr))
X#define setRCR(rcr)         WIZCHIP_WRITE(_RCR_,(rcr))
S
S#define getRCR() \
S        WIZCHIP_READ(_RCR_)
X#define getRCR()         WIZCHIP_READ(_RCR_)
S
S#define setSLRTR(slrtr) \
S        do{                                                                \
S            WIZCHIP_WRITE(_SLRTR_,(uint8_t)((slrtr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_SLRTR_,1),(uint8_t)(slrtr)); \
S        }while(0);
X#define setSLRTR(slrtr)         do{                                                                            WIZCHIP_WRITE(_SLRTR_,(uint8_t)((slrtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_SLRTR_,1),(uint8_t)(slrtr));         }while(0);
S
S#define getSLRTR() \
S        ((((uint16_t)WIZCHIP_READ(_SLRTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_SLRTR_,1)))
X#define getSLRTR()         ((((uint16_t)WIZCHIP_READ(_SLRTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_SLRTR_,1)))
S
S#define setSLRCR(slrcr) \
S        WIZCHIP_WRITE(_SLRCR_,(slrcr))
X#define setSLRCR(slrcr)         WIZCHIP_WRITE(_SLRCR_,(slrcr))
S
S#define getSLRCR() \
S        WIZCHIP_READ(_SLRCR_)
X#define getSLRCR()         WIZCHIP_READ(_SLRCR_)
S
S#define setSLHOPR(slhopr) \
S        WIZCHIP_WRITE(_SLHOPR_,(slhopr))
X#define setSLHOPR(slhopr)         WIZCHIP_WRITE(_SLHOPR_,(slhopr))
S
S#define getSLHOPR() \
S        WIZCHIP_READ(_SLHOPR_)
X#define getSLHOPR()         WIZCHIP_READ(_SLHOPR_)
S/**
S * @}
S */
S
S
S////////////////////////////////////
S// SOCKETn  register I/O function //
S////////////////////////////////////
S/**
S * @addtogroup Socket_register_access_function_W6100
S * @{
S */
S#define setSn_MR(sn,mr) \
S        WIZCHIP_WRITE(_Sn_MR_(sn),(mr))
X#define setSn_MR(sn,mr)         WIZCHIP_WRITE(_Sn_MR_(sn),(mr))
S#define getSn_MR(sn) \
S        WIZCHIP_READ(_Sn_MR_(sn))
X#define getSn_MR(sn)         WIZCHIP_READ(_Sn_MR_(sn))
S
S#define setSn_PSR(sn,psr) \
S        WIZCHIP_WRITE(_Sn_PSR_(sn),(psr))
X#define setSn_PSR(sn,psr)         WIZCHIP_WRITE(_Sn_PSR_(sn),(psr))
S#define getSn_PSR(sn) \
S        WIZCHIP_READ(_Sn_PSR_(sn))
X#define getSn_PSR(sn)         WIZCHIP_READ(_Sn_PSR_(sn))
S
S#define setSn_CR(sn,cr) \
S        WIZCHIP_WRITE(_Sn_CR_(sn),(cr))
X#define setSn_CR(sn,cr)         WIZCHIP_WRITE(_Sn_CR_(sn),(cr))
S#define getSn_CR(sn) \
S        WIZCHIP_READ(_Sn_CR_(sn))
X#define getSn_CR(sn)         WIZCHIP_READ(_Sn_CR_(sn))
S
S#define getSn_IR(sn) \
S        WIZCHIP_READ(_Sn_IR_(sn))
X#define getSn_IR(sn)         WIZCHIP_READ(_Sn_IR_(sn))
S
S#define setSn_IMR(sn,imr) \
S        WIZCHIP_WRITE(_Sn_IMR_(sn),(imr))
X#define setSn_IMR(sn,imr)         WIZCHIP_WRITE(_Sn_IMR_(sn),(imr))
S#define getSn_IMR(sn) \
S        WIZCHIP_READ(_Sn_IMR_(sn))
X#define getSn_IMR(sn)         WIZCHIP_READ(_Sn_IMR_(sn))
S
S#define setSn_IRCLR(sn,irclr) \
S        WIZCHIP_WRITE(_Sn_IRCLR_(sn),(irclr))
X#define setSn_IRCLR(sn,irclr)         WIZCHIP_WRITE(_Sn_IRCLR_(sn),(irclr))
S#define setSn_IR(sn,ir)          setSn_IRCLR(sn,(ir))
S
S#define getSn_SR(sn) \
S        WIZCHIP_READ(_Sn_SR_(sn))
X#define getSn_SR(sn)         WIZCHIP_READ(_Sn_SR_(sn))
S
S#define getSn_ESR(sn) \
S        WIZCHIP_READ(_Sn_ESR_(sn))
X#define getSn_ESR(sn)         WIZCHIP_READ(_Sn_ESR_(sn))
S
S#define setSn_PNR(sn,pnr) \
S        WIZCHIP_WRITE(_Sn_PNR_(sn),(pnr))
X#define setSn_PNR(sn,pnr)         WIZCHIP_WRITE(_Sn_PNR_(sn),(pnr))
S#define setSn_NHR(sn,nhr)        setSn_PNR(_Sn_PNR_(sn),(nhr))
S
S#define getSn_PNR(sn) \
S        WIZCHIP_READ(_Sn_PNR_(sn))
X#define getSn_PNR(sn)         WIZCHIP_READ(_Sn_PNR_(sn))
S#define getSn_NHR(sn)            getSn_PNR(sn)
S
S#define setSn_TOSR(sn,tosr) \
S        WIZCHIP_WRITE(_Sn_TOSR_(sn),(tosr))
X#define setSn_TOSR(sn,tosr)         WIZCHIP_WRITE(_Sn_TOSR_(sn),(tosr))
S#define getSn_TOSR(sn) \
S        WIZCHIP_READ(_Sn_TOSR_(sn))
X#define getSn_TOSR(sn)         WIZCHIP_READ(_Sn_TOSR_(sn))
S
S#define setSn_TTLR(sn,ttlr) \
S        WIZCHIP_WRITE(_Sn_TTLR_(sn),(ttlr))
X#define setSn_TTLR(sn,ttlr)         WIZCHIP_WRITE(_Sn_TTLR_(sn),(ttlr))
S#define getSn_TTLR(sn) \
S        WIZCHIP_READ(_Sn_TTLR_(sn))
X#define getSn_TTLR(sn)         WIZCHIP_READ(_Sn_TTLR_(sn))
S
S#define setSn_HOPR(sn,hopr)      setSn_TTLR(sn),(ttlr))
S#define getSn_HOPR(sn)           getSn_TTLR(sn)
S
S#define setSn_FRGR(sn,frgr) \
S        do{                                                                      \
S            WIZCHIP_WRITE(_Sn_FRGR_(sn),(uint8_t)((frgr)>>8));                   \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1),(uint8_t)(frgr));  \
S        }while(0);
X#define setSn_FRGR(sn,frgr)         do{                                                                                  WIZCHIP_WRITE(_Sn_FRGR_(sn),(uint8_t)((frgr)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1),(uint8_t)(frgr));          }while(0);
S#define getSn_FRGR(sn,frgr) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_FRGR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1)))
X#define getSn_FRGR(sn,frgr)         ((((uint16_t)WIZCHIP_READ(_Sn_FRGR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1)))
S
S#define setSn_MSSR(sn,mssr) \
S        do{                                                                      \
S            WIZCHIP_WRITE(_Sn_MSSR_(sn),(uint8_t)((mssr)>>8));                   \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1),(uint8_t)(mssr));  \
S        }while(0);
X#define setSn_MSSR(sn,mssr)         do{                                                                                  WIZCHIP_WRITE(_Sn_MSSR_(sn),(uint8_t)((mssr)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1),(uint8_t)(mssr));          }while(0);
S#define getSn_MSSR(sn) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_MSSR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1)))
X#define getSn_MSSR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_MSSR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1)))
S
S#define setSn_PORTR(sn,portr) \
S        do{                                                                       \
S            WIZCHIP_WRITE(_Sn_PORTR_(sn),(uint8_t)((portr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1),(uint8_t)(portr)); \
S        }while(0);
X#define setSn_PORTR(sn,portr)         do{                                                                                   WIZCHIP_WRITE(_Sn_PORTR_(sn),(uint8_t)((portr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1),(uint8_t)(portr));         }while(0);
S#define getSn_PORTR(sn) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_PORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1)))
X#define getSn_PORTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_PORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1)))
S
S#define setSn_DHAR(sn,dhar) \
S        WIZCHIP_WRITE_BUF(_Sn_DHAR_(sn),(dhar),6)
X#define setSn_DHAR(sn,dhar)         WIZCHIP_WRITE_BUF(_Sn_DHAR_(sn),(dhar),6)
S#define getSn_DHAR(sn,dhar) \
S        WIZCHIP_READ_BUF(_Sn_DHAR_(sn),(dhar),6)
X#define getSn_DHAR(sn,dhar)         WIZCHIP_READ_BUF(_Sn_DHAR_(sn),(dhar),6)
S
S#define setSn_DIPR(sn,dipr) \
S        WIZCHIP_WRITE_BUF(_Sn_DIPR_(sn),(dipr),4)
X#define setSn_DIPR(sn,dipr)         WIZCHIP_WRITE_BUF(_Sn_DIPR_(sn),(dipr),4)
S#define getSn_DIPR(sn,dipr) \
S        WIZCHIP_READ_BUF(_Sn_DIPR_(sn),(dipr),4)
X#define getSn_DIPR(sn,dipr)         WIZCHIP_READ_BUF(_Sn_DIPR_(sn),(dipr),4)
S
S#define setSn_DIP4R(sn,dipr)      setSn_DIPR(sn,(dipr))
S#define getSn_DIP4R(sn,dipr)      getSn_DIPR(sn,(dipr))
S
S#define setSn_DIP6R(sn,dip6r) \
S        WIZCHIP_WRITE_BUF(_Sn_DIP6R_(sn),(dip6r),16)
X#define setSn_DIP6R(sn,dip6r)         WIZCHIP_WRITE_BUF(_Sn_DIP6R_(sn),(dip6r),16)
S#define getSn_DIP6R(sn,dip6r) \
S        WIZCHIP_READ_BUF(_Sn_DIP6R_(sn),(dip6r),16)
X#define getSn_DIP6R(sn,dip6r)         WIZCHIP_READ_BUF(_Sn_DIP6R_(sn),(dip6r),16)
S
S#define setSn_DPORTR(sn,dportr) \
S        do{                                                                         \
S            WIZCHIP_WRITE(_Sn_DPORTR_(sn),(uint8_t)((dportr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1),(uint8_t)(dportr)); \
S        }while(0);
X#define setSn_DPORTR(sn,dportr)         do{                                                                                     WIZCHIP_WRITE(_Sn_DPORTR_(sn),(uint8_t)((dportr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1),(uint8_t)(dportr));         }while(0);
S#define getSn_DPORTR(sn) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_DPORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1)))
X#define getSn_DPORTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_DPORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1)))
S
S#define setSn_MR2(sn,mr2) \
S        WIZCHIP_WRITE(_Sn_MR2_(sn),(mr2))
X#define setSn_MR2(sn,mr2)         WIZCHIP_WRITE(_Sn_MR2_(sn),(mr2))
S#define getSn_MR2(sn) \
S        WIZCHIP_READ(_Sn_MR2_(sn))
X#define getSn_MR2(sn)         WIZCHIP_READ(_Sn_MR2_(sn))
S
S#define setSn_RTR(sn,rtr) \
S        do{                                                                   \
S            WIZCHIP_WRITE(_Sn_RTR_(sn),(uint8_t)((rtr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1),(uint8_t)(rtr)); \
S        }while(0);
X#define setSn_RTR(sn,rtr)         do{                                                                               WIZCHIP_WRITE(_Sn_RTR_(sn),(uint8_t)((rtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1),(uint8_t)(rtr));         }while(0);
S#define getSn_RTR(sn) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_RTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1)))
X#define getSn_RTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_RTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1)))
S
S#define setSn_RCR(sn,rcr) \
S        WIZCHIP_WRITE(_Sn_RCR_(sn),(rcr))
X#define setSn_RCR(sn,rcr)         WIZCHIP_WRITE(_Sn_RCR_(sn),(rcr))
S#define getSn_RCR(sn) \
S        WIZCHIP_READ(_Sn_RCR_(sn))
X#define getSn_RCR(sn)         WIZCHIP_READ(_Sn_RCR_(sn))
S
S#define setSn_KPALVTR(sn,kpalvtr) \
S        WIZCHIP_WRITE(_Sn_KPALVTR_(sn),(kpalvtr))
X#define setSn_KPALVTR(sn,kpalvtr)         WIZCHIP_WRITE(_Sn_KPALVTR_(sn),(kpalvtr))
S#define getSn_KPALVTR(sn) \
S        WIZCHIP_READ(_Sn_KPALVTR_(sn))
X#define getSn_KPALVTR(sn)         WIZCHIP_READ(_Sn_KPALVTR_(sn))
S
S#define setSn_TX_BSR(sn, tmsr) \
S        WIZCHIP_WRITE(_Sn_TX_BSR_(sn),(tmsr))
X#define setSn_TX_BSR(sn, tmsr)         WIZCHIP_WRITE(_Sn_TX_BSR_(sn),(tmsr))
S#define setSn_TXBUF_SIZE(sn, tmsr)      setSn_TX_BSR(sn,(tmsr))
S
S#define getSn_TX_BSR(sn) \
S        WIZCHIP_READ(_Sn_TX_BSR_(sn))
X#define getSn_TX_BSR(sn)         WIZCHIP_READ(_Sn_TX_BSR_(sn))
S#define getSn_TXBUF_SIZE(sn)            getSn_TX_BSR(sn)
S              
S#define getSn_TxMAX(sn) \
S	  (getSn_TX_BSR(sn) << 10)
X#define getSn_TxMAX(sn) 	  (getSn_TX_BSR(sn) << 10)
S
Sdatasize_t getSn_TX_FSR(uint8_t sn);
S
S#define getSn_TX_RD(sn) \
S        ((((uint16_t)WIZCHIP_READ(_Sn_TX_RD_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_RD_(sn),1)))
X#define getSn_TX_RD(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_TX_RD_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_RD_(sn),1)))
S
S#define setSn_TX_WR(sn,txwr) \
S        do{                                                                       \
S            WIZCHIP_WRITE(_Sn_TX_WR_(sn), (uint8_t)((txwr)>>8));                  \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1), (uint8_t)(txwr)); \
S        }while(0);
X#define setSn_TX_WR(sn,txwr)         do{                                                                                   WIZCHIP_WRITE(_Sn_TX_WR_(sn), (uint8_t)((txwr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1), (uint8_t)(txwr));         }while(0);
S#define getSn_TX_WR(sn) \
S        (((uint16_t)WIZCHIP_READ(_Sn_TX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1)))
X#define getSn_TX_WR(sn)         (((uint16_t)WIZCHIP_READ(_Sn_TX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1)))
S
S#define setSn_RX_BSR(sn,rmsr) \
S        WIZCHIP_WRITE(_Sn_RX_BSR_(sn),(rmsr))
X#define setSn_RX_BSR(sn,rmsr)         WIZCHIP_WRITE(_Sn_RX_BSR_(sn),(rmsr))
S#define setSn_RXBUF_SIZE(sn,rmsr)      setSn_RX_BSR(sn,(rmsr))
S
S#define getSn_RX_BSR(sn) \
S        WIZCHIP_READ(_Sn_RX_BSR_(sn))
X#define getSn_RX_BSR(sn)         WIZCHIP_READ(_Sn_RX_BSR_(sn))
S#define getSn_RXBUF_SIZE(sn)           getSn_RX_BSR(sn)
S
S#define getSn_RxMAX(sn) \
S        (getSn_RX_BSR(sn) <<10)
X#define getSn_RxMAX(sn)         (getSn_RX_BSR(sn) <<10)
S
Sdatasize_t getSn_RX_RSR(uint8_t s);
S
S#define setSn_RX_RD(sn,rxrd) \
S        do{                                                                        \
S            WIZCHIP_WRITE(_Sn_RX_RD_(sn), (uint8_t)((rxrd)>>8));                   \
S            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1), (uint8_t)(rxrd)) ; \
S        }while(0);
X#define setSn_RX_RD(sn,rxrd)         do{                                                                                    WIZCHIP_WRITE(_Sn_RX_RD_(sn), (uint8_t)((rxrd)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1), (uint8_t)(rxrd)) ;         }while(0);
S
S#define getSn_RX_RD(sn) \
S        (((uint16_t)WIZCHIP_READ(_Sn_RX_RD_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1)))
X#define getSn_RX_RD(sn)         (((uint16_t)WIZCHIP_READ(_Sn_RX_RD_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1)))
S
S#define getSn_RX_WR(sn) \
S        (((uint16_t)WIZCHIP_READ(_Sn_RX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_WR_(sn),1)))
X#define getSn_RX_WR(sn)         (((uint16_t)WIZCHIP_READ(_Sn_RX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_WR_(sn),1)))
S/**
S * @}
S */
S                  
S
S/////////////////////////////////////
S// Sn_TXBUF & Sn_RXBUF IO function //
S/////////////////////////////////////
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It saves data to be sent in the SOCKETn TX buffer.
S * @details This function reads first @ref _Sn_TX_WR_ \n
S *          and starts to copy <i>wizdata</i> from @ref _Sn_TX_WR_ address of SOCKETn TX buffer as many as <i>len</i>.\n
S *          After it is completed to copy <i><wizdata</i>, \n
S *          It increases @ref _Sn_TX_WR_ as many as <i>len</i>.
S * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
S * @param wizdata Pointer buffer to write data
S * @param len Data length
S * @sa wiz_recv_data()
S */
Svoid wiz_send_data(uint8_t sn, uint8_t *wizdata, datasize_t len);
S
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It reads the received data from the SOCKETn RX buffer and copies the data to your system memory specified by <i>wizdata</i>.
S * @details This function reads first @ref _Sn_RX_RD_ \n
S *          and starts to copy the received data to <i>wizdata</i> as many as <i>len</i>.\n
S *          After it is completed to copy the received data, \n
S *          It increases @ref _Sn_RX_RD_ as many as <i>len</i>.
S * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
S * @param wizdata Pointer buffer to read data
S * @param len Data length
S * @sa wiz_send_data()
S */
Svoid wiz_recv_data(uint8_t sn, uint8_t *wizdata, datasize_t len);
S
S/**
S * @ingroup Basic_IO_function_W6100
S * @brief It discards the received data in the SOCKETn RX buffer.
S * @details This function discards the received data by increasing @ref _Sn_RX_RD_ as manay as <i>len</i> without coping the data.
S * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
S * @param len Data length
S */
Svoid wiz_recv_ignore(uint8_t sn, datasize_t len);
S
S/// @cond DOXY_APPLY_CODE
S#if (_PHY_IO_MODE_ == _PHY_IO_MODE_MII_)
S/// @endcond
S/**
S * @ingroup Special_function_W6100
S * @brief Write data to the PHY via MDC/MDIO interface.
S * @details Write command data to the PHY via MDC/MDIO interface.
S * @param phyregaddr Address of the PHY register. It should be @ref PHYRAR_BMCR, @ref PHYRAR_BMSR, and etc.
S * @param var Data to write to the PHY register. Please refer to the bit definitions of the BMCR and BMSR register.
S * @note In order to use it, You should define @ref _PHY_IO_MODE_ to @ref _PHY_IO_MODE_MII_.
S */
Svoid wiz_mdio_write(uint8_t phyregaddr, uint16_t var);
S
S/**
S * @ingroup Special_function_W6100
S * @brief Read data from the PHY via MDC/MDIO interface.
S * @details Read command or status data from the PHY via MDC/MDIO interface.
S * @param phyregaddr Address of the PHY register. It should be @ref PHYRAR_BMCR, @ref PHYRAR_BMSR, and etc.
S * @return The value of the PHY register
S * @note In order to use it, You should define @ref _PHY_IO_MODE_ to @ref _PHY_IO_MODE_MII_.
S */
Suint16_t wiz_mdio_read(uint8_t phyregaddr);
S/// @cond DOXY_APPLY_CODE
S#endif
S/// @endcond
S
S/// @cond DOXY_APPLY_CODE
S#endif  // _WIZCHIP_ == 6100
S/// @endcond
S
S
S#ifdef __cplusplus
S}
S#endif
S
S
N#endif //_W6100_H_
L 130 "..\..\Libraries\io6Library\Ethernet\wizchip_conf.h" 2
N   #include "../Application/Application.h"
L 1 "..\..\Libraries\io6Library\Ethernet\../Application/Application.h" 1
N#ifndef _APPLICATION_H_
N#define _APPLICATION_H_
N
N#include <stdint.h>
N
N
N#define SOCK_TCP4			 (Sn_MR_TCP)
N#define SOCK_TCP6			 (Sn_MR_TCP6)
N#define SOCK_TCPD			 (Sn_MR_TCPD)
N
N#define SOCK_UDP4			 (Sn_MR_UDP4)
N#define SOCK_UDP6			 (Sn_MR_UDP6)
N#define SOCK_UDPD			 (Sn_MR_UDPD)
N
N#define AS_IPV4 2
N#define AS_IPV6 23
N#define AS_IPDUAL 11
N#endif
L 131 "..\..\Libraries\io6Library\Ethernet\wizchip_conf.h" 2
N#else
S   #error "Unknown defined _WIZCHIP_. You should define 6100"
N#endif
N
N#ifndef _WIZCHIP_IO_MODE_
S   #error "Undefined _WIZCHIP_IO_MODE_. You should define it !!!"
N#endif
N
N/**
N * @brief Define I/O base address of @ref _WIZCHIP_.
N * @todo If you want to use @ref _WIZCHIP_IO_MODE_BUS_ such as @ref _WIZCHIP_IO_MODE_BUS_DIR_ and @ref _WIZCHIP_IO_MODE_BUS_INDIR_,\n
N *       You should redefine @ref _WIZCHIP_IO_BASE_ to a free address space of your system.\n
N *       ex> <code> #define _WIZCHIP_IO_BASE_      0x00008000 </code> \n\n
N *       Otherwise, No need to redefine it.
N */
N#if _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_
X#if (0x0100 + 2) & 0x0100
N   #define _WIZCHIP_IO_BASE_            0x60000000   // for W6100 BUS
N#elif _WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_
S   #define _WIZCHIP_IO_BASE_            0x00000000   // for W6100 SPI
S#else
S   #error "You should define _WIZCHIP_IO_BASE_ to fit your system memory map."
N#endif
N
N
N#define _WIZCHIP_SOCK_NUM_   8   ///< The count of independent SOCKET of @ref _WIZCHIP_
N
N
N/********************************************************
N* WIZCHIP BASIC IF functions for SPI, SDIO, I2C , ETC.
N*********************************************************/
N/**
N * @ingroup DATA_TYPE
N * @brief Callback function set for @ref _WIZCHIP_
N * @details @ref __WIZCHIP_T__ is a structure type to provide the callback function set \n
N * *        which is called instead of the default functions \n
N *          in order to your HOST dependent functions can access to @ref _WIZCHIP_.
N * @note If it is not registered, the default function is called.
N * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * @sa reg_wizchip_cris_cbfunc(), reg_wizchip_cs_cbfunc(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc()
N */
Ntypedef struct __WIZCHIP_T__
N{
N
N   uint16_t  if_mode;                     ///< HOST Interface Mode
N   uint8_t   id[6];                       ///< ID of CHIP such as W6100, and so on.
N
N   ///< The set of critical section callback function.
N   struct _CRIS
N   {
N      void (*_e_n_t_e_r_)  (void);        ///< critical section enter
N      void (*_e_x_i_t_) (void);           ///< critical section exit
N   }CRIS;  
N
N   ///< The set of @ref _WIZCHIP_ select control callback function.
N   struct _CS
N   {
N      void (*_s_e_l_e_c_t_)  (void);      ///< @ref _WIZCHIP_ selected
N      void (*_d_e_s_e_l_e_c_t_)(void);    ///< @ref _WIZCHIP_ deselected
N   }CS;  
N
N   ///< The set of interface IO callback function.
N   union _IF
N   {
N      ///< The callback function of @ref _WIZCHIP_IO_MODE_BUS_ such as @ref _WIZCHIP_IO_MODE_BUS_DIR_ and @ref _WIZCHIP_IO_MODE_BUS_INDIR_
N      struct _BUS
N      {
N         iodata_t  (*_read_data)      (uint32_t AddrSel);               ///< Read 1 @ref iodata_t from @ref _WIZCHIP_ through BUS
N         void      (*_write_data)     (uint32_t AddrSel, iodata_t wb);  ///< Write 1 @ref iodata_t to @ref _WIZCHIP_ through BUS
N         void      (*_read_data_buf)  (uint32_t AddrSel, iodata_t* pBuf, datasize_t len, uint8_t addrinc);  ///< Read @ref iodata_t as many as <i>len</i> from @ref _WIZCHIP_ through BUS
N         void      (*_write_data_buf) (uint32_t AddrSel, iodata_t* pBuf, datasize_t len, uint8_t addrinc);  ///< Write @ref iodata_t data as many as <i>len</i> to @ref _WIZCHIP_ through BUS
N      }BUS;
N
N      ///< The callback function of @ref _WIZCHIP_IO_MODE_SPI_ such as @ref _WIZCHIP_IO_MODE_SPI_VDM_ and @ref _WIZCHIP_IO_MODE_SPI_FDM_
N      struct _SPI
N      {
N         uint8_t   (*_read_byte)      (void);                           ///< Read 1 byte data from @ref _WIZCHIP_ through SPI
N         void      (*_write_byte)     (uint8_t wb);                     ///< Write 1 byte data to @ref _WIZCHIP_ through SPI
N         void      (*_read_byte_buf)  (uint8_t* pBuf, datasize_t len);  ///< Read byte data as many as <i>len</i> from @ref _WIZCHIP_ through SPI
N         void      (*_write_byte_buf) (uint8_t* pBuf, datasize_t len);  ///< Write byte data as many as <i>len</i> to @ref _WIZCHIP_ through SPI
N      }SPI;
N   }IF;    
N
N}_WIZCHIP_T_;
N
N
Nextern _WIZCHIP_T_  WIZCHIP;  ///< @ref WIZCHIP is instance of @ref _WIZCHIP_T_ to access @ref _WIZCHIP_.
N
N
N/**
N * @ingroup DATA_TYPE
N * @brief @ref _WIZCHIP_ Control Type Enumeration.
N * @details @ref ctlwizchip_type includes a general control function for @ref _WIZCHIP_ and the integrated Ethernet PHY.
N * @note If @ref _PHY_IO_MODE_ is @ref _PHY_IO_MODE_PHYCR_,\n
N *       the PHY control types such as following can configure the integrate PHY thru @ref _PHYCR0_ & @ref _PHYCR1_, or indicate thru or @ref _PHYSR_.\n
N *       - @ref CW_RESET_PHY      : It can configure the PHY only when @ref SYS_PHY_LOCK is unlock.
N *       - @ref CW_SET_PHYCONF    : It can configure the PHY only when @ref SYS_PHY_LOCK is unlock.
N *       - @ref CW_GET_PHYCONF    
N *       - @ref CW_GET_PHYSTATUS
N *       - @ref CW_SET_PHYPOWMODE : It can configure the PHY only when @ref SYS_PHY_LOCK is unlock.
N *       - @ref CW_GET_PHYPOWMODE
N *       - @ref CW_GET_PHYLINK
N *       Else if @ref _PHY_IO_MODE_ is @ref _PHY_IO_MODE_MII_, \n
N *       the PHY control types configure or indicate through two MDC/MDIO signal of MII \n
N *       regardless of @ref SYS_PHY_LOCK.
N * @sa ctlwizchip()
N */
Ntypedef enum
N{
N   CW_SYS_LOCK,           ///< Lock or Unlock @ref _WIZCHIP_ with @ref SYS_CHIP_LOCK, @ref SYS_PHY_LOCK, and @ref SYS_NET_LOCK
N   CW_SYS_UNLOCK,         ///< Lock or Unlock @ref _WIZCHIP_ with @ref SYS_CHIP_LOCK, @ref SYS_PHY_LOCK, and @ref SYS_NET_LOCK
N   CW_GET_SYSLOCK,        ///< Get the lock status of @ref _WIZCHIP_ with @ref SYS_CHIP_LOCK, @ref SYS_PHY_LOCK, and @ref SYS_NET_LOCK
N
N   CW_RESET_WIZCHIP,      ///< Reset @ref _WIZCHIP_ by software
N   CW_INIT_WIZCHIP,       ///< Initialize to SOCKETn buffer size with n byte array typed uint8_t
N   CW_GET_INTERRUPT,      ///< Get the interrupt status with @ref intr_kind 
N   CW_CLR_INTERRUPT,      ///< Clear the interrupt with @ref intr_kind
N   CW_SET_INTRMASK,       ///< Set the interrupt mask with @ref intr_kind
N   CW_GET_INTRMASK,       ///< Get the interrupt mask with @ref intr_kind
N   CW_SET_INTRTIME,       ///< Set the interrupt pending time 
N   CW_GET_INTRTIME,       ///< Get the interrupt pending time
N   CW_SET_IEN,            ///< Set the global interrupt enable only when @ref SYS_CHIP_LOCK is not set
N   CW_GET_IEN,            ///< Get the global interrupt enable 
N
N   CW_GET_ID,             ///< Get @ref _WIZCHIP_ name.
N   CW_GET_VER,            ///< Get the version of TCP/IP TOE engine
N
N   CW_SET_SYSCLK,         ///< Set the system clock with @ref SYSCLK_100MHZ or SYSCLK_10MHZ only when @ref SYS_CHIP_LOCK is unlock
N   CW_GET_SYSCLK,         ///< Get the system clock with @ref SYSCLK_100MHZ or SYSCLK_10MHZ 
N
N   CW_RESET_PHY,          ///< Reset PHY 
N   CW_SET_PHYCONF,        ///< Set PHY operation mode (Manual/Auto, 10/100, Half/Full) with @ref wiz_PhyConf
N   CW_GET_PHYCONF,        ///< Get PHY operation mode (Manual/Auto, 10/100, Half/Full) with @ref wiz_PhyConf
N   CW_GET_PHYSTATUS,      ///< Get real operation mode with @ref wiz_PhyConf when PHY is linked up.  
N   CW_SET_PHYPOWMODE,     ///< Set PHY power mode with @ref PHY_POWER_NORM or PHY_POWER_DOWN
N   CW_GET_PHYPOWMODE,     ///< Get PHY Power mode with @ref PHY_POWER_NORM or PHY_POWER_DOWN
N   CW_GET_PHYLINK         ///< Get PHY Link status with @ref PHY_LINK_ON or @ref PHY_LINK_OFF
N}ctlwizchip_type;
N
N
N/**
N * @ingroup DATA_TYPE
N * @brief  Network control type enumeration
N * @details @ref ctlnetwork_type includes a general network configuration function for @ref _WIZCHIP_.
N * @sa ctlnetwork().
N */
Ntypedef enum
N{
N   CN_SET_NETINFO,  ///< Set Network with @ref wiz_NetInfo
N   CN_GET_NETINFO,  ///< Get Network with @ref wiz_NetInfo
N   CN_SET_NETMODE,  ///< Set network mode with @ref netmode_type
N   CN_GET_NETMODE,  ///< Get network mode with @ref netmode_type
N   CN_SET_TIMEOUT,  ///< Set network timeout with @ref wiz_NetTimeout
N   CN_GET_TIMEOUT,  ///< Get network timeout with @ref wiz_NetTimeout
N   CN_SET_PREFER,   ///< Set the preferred source IPv6 address of @ref _SLCR_.\n Refer to @ref IPV6_ADDR_AUTO, @ref IPV6_ADDR_LLA, @ref IPV6_ADDR_GUA
N   CN_GET_PREFER,   ///< Get the preferred source IPv6 address of @ref _SLCR_.\n Refer to @ref IPV6_ADDR_AUTO, @ref IPV6_ADDR_LLA, @ref IPV6_ADDR_GUA
N}ctlnetwork_type;
N
N/**
N * @ingroup DATA_TYPE
N * @brief  Network Service Control Type enumeration
N * @details @ref ctlnetservice_type includes network management or monitor functions for @ref _WIZCHIP_.
N * @sa ctlnetservice(), wiz_IPAddress, wiz_Prefix
N */
Ntypedef enum
N{
N   CNS_ARP,            ///< ARP process with @ref wiz_IPAddress
N   CNS_PING,           ///< PING process with @ref wiz_IPAddress
N   CNS_DAD,            ///< Duplicated IPv6 Address Detection
N   /**
N    * @brief Stateless Address Auto-configuration(SLAAC) with @ref wiz_Prefix. 
N    * @details @ref CNS_SLAAC sends first RS message to all-router and then receives RA message from a router.
N    * @note It is valid only when the first received RA option is the source link-layer address(0x01) and the second is prefix information(0x03).\n
N    *       Refer to @ref SLIR_RS.
N    * @sa ctlnetservice()
N    * @sa CNS_GET_PREFIX
N    */
N   CNS_SLAAC,          
N   CNS_UNSOL_NA,       ///< Unsolicited Neighbor Advertisement for update @ref _WIZCHIP_ network information to neighbors
N   /**
N    * @brief Get prefix information with @ref wiz_Prefix.  
N    * @details @ref CNS_GET_PREFIX can get prefix information of RA message to be sent by a router without RS message.
N    * @note It is valid only when @ref IK_SOCKL_RA is set and the prefix information(0x03) of RA option is first received. 
N    * @sa ctlnetservice()
N    * @sa CNS_SLAAC
N    */
N   CNS_GET_PREFIX      
N}ctlnetservice_type;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Interrupt Kind
N * @details @ref intr_kind can be used as the interrupt bits of @ref _IR_, @ref _SIR_, and @ref _SLIR_,\n
N *          It can be used as the interrupt mask bits of @ref _IMR_, @ref _SIMR_, and @ref _SLIMR_,\n
N *          and also, It can be used as the interrupt clear bits of @ref _IRCLR_, @ref _Sn_IRCLR_, and @ref _SLIRCLR_.
N * @note It can be used with @b OR operation.
N * @sa ctlwizchip(), CW_GET_INTERRUPT, CW_CLR_INTERRUPT, CW_GET_INTRMASK, CW_SET_INTRMASK
N * @sa ctlnetservice(), ctlnetservice_type
N * @sa wizchip_getinterrupt(), wizchip_clrinterrupt(), wizchip_getinterruptmask(), wizchip_setinterruptmask()
N */
Ntypedef enum
N{
N   IK_PPPOE_TERMINATED = (1 << 0),     ///< PPPoE Termination Interrupt
N   IK_DEST_UNREACH     = (1 << 1),     ///< ICMPv4 Destination Unreachable Interrupt
N   IK_IP_CONFLICT      = (1 << 2),     ///< IPv4 Address Conflict Interrupt
N   IK_DEST_UNREACH6    = (1 << 4),     ///< ICMPv6 Destination Unreachable Interrupt
N   IK_WOL              = (1 << 7),     ///< WOL magic packet Interrupt
N   IK_NET_ALL          = (0x97),       ///< All Network Interrupt
N   
N   IK_SOCK_0           = (1 << 8),     ///< Socket 0 Interrupt
N   IK_SOCK_1           = (1 << 9),     ///< Socket 1 Interrupt
N   IK_SOCK_2           = (1 << 10),    ///< Socket 2 Interrupt
N   IK_SOCK_3           = (1 << 11),    ///< Socket 3 Interrupt
N   IK_SOCK_4           = (1 << 12),    ///< Socket 4 Interrupt
N   IK_SOCK_5           = (1 << 13),    ///< Socket 5 Interrupt
N   IK_SOCK_6           = (1 << 14),    ///< Socket 6 Interrupt
N   IK_SOCK_7           = (1 << 15),    ///< Socket 7 Interrupt
N   IK_SOCK_ALL         = (0xFF << 8),  ///< All Socket Interrupt
N
N   IK_SOCKL_TOUT       = (1 << 16),    ///< @ref _SLCR_ Timeout Interrupt.\n Refer to @ref ctlnetservice_type.
N   IK_SOCKL_ARP4       = (1 << 17),    ///< @ref _SLCR_ APR4 Interrupt.\n Refer to @ref CNS_ARP.
N   IK_SOCKL_PING4      = (1 << 18),    ///< @ref _SLCR_ PING4 Interrupt.\n Refer to @ref CNS_PING.
N   IK_SOCKL_ARP6       = (1 << 19),    ///< @ref _SLCR_ ARP6 Interrupt.\n Refer to @ref CNS_ARP.
N   IK_SOCKL_PING6      = (1 << 20),    ///< @ref _SLCR_ PING6 Interrupt.\n Refer to @ref CNS_PING.
N   IK_SOCKL_NS         = (1 << 21),    ///< @ref _SLCR_ NS Interrupt.\n Refer to @ref CNS_DAD.
N   IK_SOCKL_RS         = (1 << 22),    ///< @ref _SLCR_ RS Interrupt.\n Refer to @ref CNS_SLAAC.
N   IK_SOCKL_RA         = (1 << 23),    ///< @ref _SLCR_ RA Interrupt.\n Refer to @ref CNS_GET_PREFIX.
N   IK_SOCKL_ALL        = (0xFF << 16), ///< @ref _SLCR_ All Interrupt
N
N   IK_INT_ALL          = (0x00FFFF97)   ///< All Interrupt
N}intr_kind;
N
N
N
N#define SYS_CHIP_LOCK           (1<<2)   ///< CHIP LOCK. \n Refer to @ref CW_SYS_LOCK, @ref CW_SYS_UNLOCK, and @ref CW_GET_SYSLOCK.
N#define SYS_NET_LOCK            (1<<1)   ///< NETWORK Information LOCK. \n Refer to @ref CW_SYS_LOCK, @ref CW_SYS_UNLOCK, and @ref CW_GET_SYSLOCK.
N#define SYS_PHY_LOCK            (1<<0)   ///< PHY LOCK.\n Refer to @ref CW_SYS_LOCK, @ref CW_SYS_UNLOCK, and @ref CW_GET_SYSLOCK.
N
N#define SYSCLK_100MHZ            0       ///< System Clock 100MHz.\n Refer to Refer to @ref CW_SET_SYSCLK and  @ref CW_GET_SYSCLK.
N#define SYSCLK_25MHZ             1       ///< System Clock 25MHz.\n Refer to Refer to @ref CW_SET_SYSCLK and  @ref CW_GET_SYSCLK.
N
N#define PHY_MODE_MANUAL          0       ///< Configured PHY operation mode with user setting.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N#define PHY_MODE_AUTONEGO        1       ///< Configured PHY operation mode with auto-negotiation.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N/**
N * @brief Configured PHY operation mode with 10Base-Te.
N * @details It can be set or get through @ref ctlwizchip() with @ref CW_SET_PHYCONF or @ref CW_GET_PHYCONF.
N * @note It is controlled by @ref _PHYCR1_ regardless of @ref _PHY_IO_MODE_.
N * @note After 10Base-Te mode is set, Ethernet PHY should be reset by calling @ref ctlwizchip() with @ref CW_RESET_PHY
N */
N#define PHY_MODE_TE              2
N#define PHY_SPEED_10             0       ///< PHY Link Speed 10.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N#define PHY_SPEED_100            1       ///< PHY Link Speed 100.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N#define PHY_DUPLEX_HALF          0       ///< PHY Link Half-Duplex.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N#define PHY_DUPLEX_FULL          1       ///< PHY Link Full-Duplex.\n Refer to @ref CW_SET_PHYCONF and @ref CW_GET_PHYCONF.
N#define PHY_LINK_OFF             0       ///< PHY Link Off.\n Refer to @ref CW_GET_PHYLINK.
N#define PHY_LINK_ON              1       ///< PHY Link On.\n Refer to @ref CW_GET_PHYLINK.
N#define PHY_POWER_NORM           0       ///< PHY power normal mode.\n Refer to @ref CW_SET_PHYPOWMODE and @ref CW_GET_PHYPOWMODE
N#define PHY_POWER_DOWN           1       ///< PHY power down mode.\n Refer to @ref CW_SET_PHYPOWMODE and @ref CW_GET_PHYPOWMODE
N
N#define IPV6_ADDR_AUTO           0x00    ///< IPv6 Address Type : Auto.\n Refer to @ref CN_SET_PREFER, @ref CN_GET_PREFER.
N#define IPV6_ADDR_LLA            0x02    ///< IPv6 Address Type : LLA. \n Refer to @ref CN_SET_PREFER, @ref CN_GET_PREFER, @ref CNS_DAD.
N#define IPV6_ADDR_GUA            0x03    ///< IPv6 Address Type : GUA. \n Refer to @ref CN_SET_PREFER, @ref CN_GET_PREFER, @ref CNS_DAD.
N
N
N/**
N * @ingroup DATA_TYPE
N * @brief Ethernet PHY operation mode configuration
N * @details @ref wiz_PhyConf is a structure type to configure or \n
N *          indicate the PHY operation mode such as auto-negotiation, speed, and duplex.\n
N * @note If @ref _PHY_IO_MODE_ is defined with @ref _PHY_IO_MODE_PHYCR_,\n
N *       the PHY operation mode is configured by @ref _PHYCR0_ and is indicated by @ref _PHYSR_.\n
N *       Otherwise, the PHY operation mode is configured or indicated by two MDC/MDIO signal of MII.
N * @note In order to apply @ref wiz_PhyConf to the integrated Ethernet PHY, \n
N *       It needs to reset the PHY by calling @ref ctlwizchip(@ref CW_RESET_PHY)
N * @sa ctlwizchip(), CW_SET_PHYCONF, CW_GET_PHYCONF, CW_RESET_PHY
N * @sa wizphy_setphyconf(), wizphy_getphyconf(), wizphy_reset()
N */
Ntypedef struct wiz_PhyConf_t
N{
N      uint8_t mode;     ///< set by @ref PHY_MODE_MANUAL ,@ref PHY_MODE_AUTONEGO, or @ref PHY_MODE_TE
N      uint8_t speed;    ///< set by @ref PHY_SPEED_10 or @ref PHY_SPEED_100
N      uint8_t duplex;   ///< set by @ref PHY_DUPLEX_HALF @ref PHY_DUPLEX_FULL 
N}wiz_PhyConf;
N
N/**
N * @ingroup DATA_TYPE
N * @brief IP Address Configuration Mode
N * @details @ref ipconf_mode can be used to save the DHCP mode running on your system.
N * @sa ctlnetwork(), CN_SET_NETINFO, CN_GET_NETINFO
N * @sa wizchip_setnetinfo(), wizchip_getnetinfo(), wiz_NetInfo
N */
Ntypedef enum
N{
N   NETINFO_NONE       = 0x00,    ///< No use DHCP
N   NETINFO_STATIC_V4  = 0x01,    ///< Static IPv4 configuration by manually.
N   NETINFO_STATIC_V6  = 0x02,    ///< Static IPv6 configuration by manually.
N   NETINFO_STATIC_ALL = 0x03,    ///< Static IPv4 and IPv6 configuration by manually.
N   NETINFO_SLAAC_V6   = 0x04,    ///< Stateless Adders Auto Configuration for IPv6
N   NETINFO_DHCP_V4    = 0x10,    ///< Dynamic IPv4 configuration from a DHCP sever
N   NETINFO_DHCP_V6    = 0x20,    ///< Dynamic IPv6 configuration from a DHCP sever
N   NETINFO_DHCP_ALL   = 0x30     ///< Dynamic IPv4 and IPv6 configuration from a DHCP sever
N}ipconf_mode;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Network Information for @ref _WIZCHIP_
N * @details @ref wiz_NetInfo is a structure type to configure or indicate the network information of @ref _WIZCHIP_.
N * @sa ctlnetwork(), CN_SET_NETINFO, CN_GET_NETINFO
N * @sa wizchip_setnetinfo(), wizchip_getnetinfo()
N */
Ntypedef struct wiz_NetInfo_t
N{
N   uint8_t     mac[6];    ///< Source Hardware Address
N   uint8_t     ip[4];     ///< Source IPv4 Address
N   uint8_t     sn[4];     ///< Subnet Mask value
N   uint8_t     gw[4];     ///< Gateway IPv4 Address
N   uint8_t     lla[16];   ///< Source Link Local Address
N   uint8_t     gua[16];   ///< Source Global Unicast Address
N   uint8_t     sn6[16];   ///< IPv6 Prefix
N   uint8_t     gw6[16];   ///< Gateway IPv6 Address
N   uint8_t     dns[4];    ///< DNS server IPv4 Address
N   uint8_t     dns6[16];  ///< DNS server IPv6 Address
N   ipconf_mode ipmode;    ///< IP Configuration Mode
N}wiz_NetInfo;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Network mode Configuration
N * @details @ref netmode_type includes the network mode control function such as ping, TCP/RST block and etc.
N * @sa ctlnetwork(), CN_SET_NETMODE, CN_GET_NETMODE
N */
Ntypedef enum
N{
N   // NETMR Bit Values
N   NM_IPB_V4            = (1 << 0),      ///< IPv4 Packet Block
N   NM_IPB_V6            = (1 << 1),      ///< IPv6 Packet Block
N   NM_WOL               = (1 << 2),      ///< Wake On Lan(WOL) Mode
N   NM_PB6_MULTI         = (1 << 4),      ///< PING6 request from multicasting group address Block
N   NM_PB6_ALLNODE       = (1 << 5),      ///< PING6 request from all-node multicasting address Block
N   NM_MR_MASK           = (0x37),        ///< @ref _NETMR_ Mask value
N
N   // NETMR2 Bit Values
N   NM_PPPoE             = (1 << 8),      ///< PPPoE Mode
N   NM_DHA_SELECT        = (1 << 15),     ///< Destination Hardware Address Select
N   NM_MR2_MASK          = (0x09<<8),     ///< @ref _NETMR2_ Mask value
N
N  //NET4MR Bit Values
N   NM_PB4_ALL           = (1 << 16),     ///< All PING4 request Block
N   NM_TRSTB_V4          = (1 << 17),     ///< TCP RST packet for IPv4 Send Block
N   NM_PARP_V4           = (1 << 18),     ///< ARP request for IPv4 before PINGv4 Replay
N   NM_UNRB_V4           = (1 << 19),     ///< Unreachable Destination for IPv4 Block
N   NM_NET4_MASK         = (0x0F << 16),  ///< @ref _NET4MR_ Mask value
N
N  //NET4MR Bit Values
N   NM_PB6_ALL           = (1 << 24),     ///< All PING6 request Block
N   NM_TRSTB_V6          = (1 << 25),     ///< TCP RST packet for IPv6 Send Block
N   NM_PARP_V6           = (1 << 26),     ///< ARP request for IPv6 before PINGv4 Replay
N   NM_UNRB_V6           = (1 << 27),     ///< Unreachable Destination for IPv6 Block
N   NM_NET6_MASK         = (0x0F << 24),  ///< @ref _NET6MR_ Mask value
N
N   NM_MASK_ALL          = (0x0F0F0937)   ///< @ref netmode_type all mask value
N}netmode_type;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Network Timeout for @ref _WIZCHIP_
N * @details @ref wiz_NetInfo is a structure type to configure or indicate the network timeout of @ref _WIZCHIP_.
N * @sa ctlnetwork(), CN_SET_TIMEOUT, CN_GET_TIMEOUT
N * @sa wizchip_settimeout(), wizchip_gettimeout()
N */
Ntypedef struct wiz_NetTimeout_t
N{
N   uint8_t  s_retry_cnt;         ///< The default retry count of SOCKETn
N   uint16_t s_time_100us;        ///< The retransmission time of SOCKETn (unit 100us)
N   uint8_t  sl_retry_cnt;        ///< The retry count of SOCKET-less
N   uint16_t sl_time_100us;       ///< The retransmission time of SOCKET-less (unit 100us)
N}wiz_NetTimeout;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Destination Information for Network Service of @ref _WIZCHIP_
N * @details @ref wiz_NetInfo is a structure type to configure or indicate a destination information of network service.
N * @sa ctlnetservice(), CNS_ARP, CNS_PING
N * @sa IK_SOCKL_TOUT, IK_SOCKL_ARP4, IK_SOCKL_ARP6, IK_SOCKL_PING4, IK_SOCKL_PING6
N */
Ntypedef struct wiz_IPAddress_t
N{
N   uint8_t ip[16];               ///< Destination IP Address. \n IPv4 index : 0 to 3, IPv6 index : 0 to 15
N   uint8_t len;                  ///< Destination IP Address Length.\n IPv4 : 4, IPv6 : 16.
N}wiz_IPAddress;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Prefix Information
N * @details @ref wiz_Prefix is a structure type to indicate a prefix information(0x03) of received RA message from a router.
N * @sa ctlnetservice(), CNS_SLAAC, IK_SOCKL_RS
N * @sa IK_SOCKL_TOUT, IK_SOCKL_RA, CNS_GET_PREFIX
N */
Ntypedef struct wiz_Prefix_t
N{
N   uint8_t  len;                 ///< Prefix Length. \n It is used to set @ref _SUB6R_ to 1 as many as <i>len</i> from LSB bit.
N   uint8_t  flag;                ///< Prefix Flag
N   uint32_t valid_lifetime;      ///< Valid Lifetime
N   uint32_t preferred_lifetime;  ///< Preferred Lifetime
N   uint8_t  prefix[16];          ///< Prefix
N}wiz_Prefix;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Destination Information & Destination Hardware Address for @ref CNS_ARP
N * @details @ref wiz_ARP is a structure type to set a destination IP address for ARP-request or \n
N *          indicate a destination hardware address in APR-reply.
N * @sa ctlnetservice(), CNS_ARP
N * @sa IK_SOCKL_TOUT, IK_SOCKL_ARP4, IK_SOCKL_ARP6
N */
Ntypedef struct wiz_ARP_t
N{
N   wiz_IPAddress destinfo;       ///< Destination IP address for ARP-request
N   uint8_t dha[6];               ///< Destination Hardware Address when ARP-reply is received from the destination.
N}wiz_ARP;
N
N/**
N * @ingroup DATA_TYPE
N * @brief Destination Information & Destination Hardware Address for @ref CNS_ARP
N * @details @ref wiz_PING is a structure type to set a ID, sequence number, destination IP address for PING-request.
N * @sa ctlnetservice(), CNS_PING
N * @sa IK_SOCKL_TOUT, IK_SOCKL_PING4, IK_SOCKL_PING6
N */
Ntypedef struct wiz_PING_t
N{
N   uint16_t id;
N   uint16_t seq;
N   wiz_IPAddress destinfo;
N}wiz_PING;
N
N/**
N * @brief Registers call back functions for critical section.
N * @details @ref reg_wizchip_cris_cbfunc() is for basic I/O functions \n
N *           such as @ref WIZCHIP_READ(), @ref WIZCHIP_WRITE(), @ref WIZCHIP_READ_BUF() and @ref WIZCHIP_WRITE_BUF().
N * @param cris_en : callback function for critical section enter.
N * @param cris_ex : callback function for critical section exit.
N * @todo Register your functions for critical session.
N * @note If you do not register it, the @b empty default functions are called.\n
N *       @ref wizchip_cris_enter(), @ref wizchip_cris_exit()
N */
Nvoid reg_wizchip_cris_cbfunc(void(*cris_en)(void), void(*cris_ex)(void));
N
N
N/**
N * @brief Registers call back functions for @ref _WIZCHIP_ select & deselect.
N * @details @ref reg_wizchip_cs_cbfunc() registers your functions to select & deselect @ref _WIZCHIP_
N * @param cs_sel : callback function to select @ref _WIZCHIP_
N * @param cs_desel : callback function to deselect @ref _WIZCHIP_
N * @todo Register your functions to select or deselect @ref _WIZCHIP_.
N * @note If you do not register it, the @b empty default functions are called. \n
N *       @ref wizchip_cs_select(), @ref wizchip_cs_deselect()
N */
Nvoid reg_wizchip_cs_cbfunc(void(*cs_sel)(void), void(*cs_desel)(void));
N
N/// @cond DOXY_APPLY_CODE
N#if (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_BUS_)
X#if ((0x0100 + 2) & 0x0100)
N/// @endcond
N/**
N * @brief Registers call back functions for BUS interface.
N * @details @ref reg_wizchip_bus_cbfunc() is for basic I/O functions \n
N *          such as @ref WIZCHIP_READ(), @ref WIZCHIP_WRITE(), @ref WIZCHIP_READ_BUF() and @ref WIZCHIP_WRITE_BUF().
N * @param bus_rd   : callback function to read 1 @ref iodata_t data 
N * @param bus_wd   : callback function to write 1 @ref iodata_t data
N * @param bus_rbuf : callback function to read @ref iodata_t data buf as many as <i>len</i>
N * @param bus_wbuf : callback function to write @ref iodata_t data buf as many as <i>len</i>
N * @todo Register your functions for data read & write through BUS interface.
N * @note If you do not register it,the default functions are called. \n
N *       @ref wizchip_bus_read(), @ref wizchip_bus_write(), @ref wizchip_bus_read_buf(), @ref wizchip_bus_write_buf().
N */
Nvoid reg_wizchip_bus_cbfunc(iodata_t (*bus_rd)(uint32_t addr), 
N                            void (*bus_wd)(uint32_t addr, iodata_t wb),
N                            void (*bus_rbuf)(uint32_t addr, iodata_t* buf, datasize_t len, uint8_t inc),
N                            void (*bus_wbuf)(uint32_t addr, iodata_t* buf, datasize_t len, uint8_t inc) );
N/// @cond DOXY_APPLY_CODE
N#endif
N/// @endcond
N
N/// @cond DOXY_APPLY_CODE
N#if (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
X#if ((0x0100 + 2) & 0x0200)
S/// @endcond
S/**
S * @brief Registers call back functions for SPI interface.
S * @details @ref reg_wizchip_spi_cbfunc() is for for basic I/O functions \n
S * *        such as @ref WIZCHIP_READ(), @ref WIZCHIP_WRITE(), @ref WIZCHIP_READ_BUF() and @ref WIZCHIP_WRITE_BUF().
S * @param spi_rb : callback function to read 1 byte data using SPI
S * @param spi_wb : callback function to write 1 byte data using SPI
S * @param spi_rbuf : callback function to read byte data buf as many as <i>len</i>
S * @param spi_rbuf : callback function to write byte data buf as many as <i>len</i>
S * @todo Should register your functions for data read/write through SPI interface.
S * @note If you do not register it, the empty default function are called but these function are all null function.\n
S *        So, You should overwrite them or register your functions for replacing them.\n\n
S *        The empty default functions are @ref wizchip_spi_read(), @ref wizchip_spi_write(),@ref wizchip_spi_read_buf(), and @ref wizchip_spi_write_buf().
S */
Svoid reg_wizchip_spi_cbfunc(uint8_t (*spi_rb)(void), 
S                            void (*spi_wb)(uint8_t wb),
S                            void (*spi_rbuf)(uint8_t* buf, datasize_t len),
S                            void (*spi_wbuf)(uint8_t* buf, datasize_t len) );
S/// @cond DOXY_APPLY_CODE
N#endif
N/// @endcond
N
N
N/**
N * @ingroup extra_functions
N * @brief Control @ref _WIZCHIP_.
N * @details @ref ctlwizchip() resets @ref _WIZCHIP_ & integrated Ethernet PHY,\n
N *          configures PHY mode, monitors PHY(Link,Speed,Half/Full/Auto), controls interrupt & mask and so on.
N * @param cwtype : Decides to the control type
N * @param arg : arg type is dependent on cwtype.
N * @return  0 : Success \n
N *         -1 : Fail because of invalid @ref ctlwizchip_type or unsupported @ref ctlwizchip_type
N * @note When you define @ref _PHY_IO_MODE_ to @ref _PHY_IO_MODE_PHYCR_,\n
N *       If you call @ref ctlwizchip(@ref CW_RESET_PHY), you should wait for stable reset time.\n\n
N *       ex> W6100 case \n
N *          <code>
N *            ctlwizchip(CW_RESET_PHY); \n
N *            // Need to wait stable reset time 60.3ms\n
N *            your_delay_function(60300);
N *          </code>
N */          
Nint8_t ctlwizchip(ctlwizchip_type cwtype, void* arg);
N
N/**
N * @ingroup extra_functions
N * @brief Controls to network.
N * @details @ref ctlnetwork() controls to network environment, mode, timeout and so on.
N * @param cntype : Decides to the control type
N * @param arg : arg type is dependent on cntype.
N * @return -1 : Fail because of invalid @ref ctlnetwork_type or unsupported @ref ctlnetwork_type \n
N *          0 : Success      
N */          
Nint8_t ctlnetwork(ctlnetwork_type cntype, void* arg);
N
N
N/**
N * @ingroup extra_functions
N * @brief Controls to network service.
N * @details Controls to network environment, mode, timeout and so on.
N * @param cnstype : Decides to the control type
N * @param arg : arg type is dependent on cnstype.
N * @return -1 : Fail because of invalid @ref ctlnetwork_type or unsupported @ref ctlnetwork_type \n
N *          0 : Success      
N */          
Nint8_t ctlnetservice(ctlnetservice_type cnstype, void* arg);
N
N
N/* 
N * The following functions are implemented for internal use. 
N * but You can call these functions for code size reduction instead of ctlwizchip() and ctlnetwork().
N */
N 
N/**
N * @ingroup extra_functions
N * @brief Soft Reset @ref _WIZCHIP_.
N * @note It backs up the network information before reset, and restores after reset.
N * @sa ctlwizchip(), CW_RESET_WIZCHIP
N * @sa SYCR0_RST
N */ 
Nvoid   wizchip_sw_reset(void);
N
N/**
N * @ingroup extra_functions
N * @brief Initializes SOCKETn TX/RX buffer size
N * @param txsize SOCKETn TX buffer sizes.\n If it is null, SOCKETn TX buffer is initialized as the default size 2KB.
N * @param rxsize SOCKETn RX buffer sizes.\n If it is null, SOCKETn RX buffer is initialized as the default size 2KB.
N * @return 0 : Success \n
N *        -1 : Fail. Invalid buffer size
N * @sa ctlwizchip(), CW_INIT_WIZCHIP
N * @sa _Sn_TX_BSR_, _Sn_RX_BSR_
N */
Nint8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize);
N
N/**  
N * @ingroup extra_functions
N * @brief Clear Interrupt of @ref _WIZCHIP_.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint32_t.
N * @sa ctlwizchip(), CW_CLR_INTERRUPT, CW_GET_INTERRUPT, CW_SET_INTRMASK, CW_GET_INTRMASK
N * @sa wizchip_getintrerupt(), wizchip_setinterruptmask(), wizchip_getinterruptmask()
N */
Nvoid wizchip_clrinterrupt(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt of @ref _WIZCHIP_.
N * @return @ref intr_kind value operated OR. It can type-cast to uint32_t.
N * @sa ctlwizchip(), CW_GET_INTERRUPT, CW_CLR_INTERRUPT, CW_SET_INTRMASK, CW_GET_INTRMASK
N * @sa wizchip_clrinterrupt(), wizchip_setinterruptmask(), wizchip_getinterruptmask()
N */
Nintr_kind wizchip_getinterrupt(void);
N
N/** 
N * @ingroup extra_functions
N * @brief Mask or Unmask Interrupt of @ref _WIZCHIP_.
N * @param intr : @ref intr_kind value operated OR. It can type-cast to uint32_t.
N * @sa ctlwizchip(), CW_SET_INTRMASK, CW_GET_INTRMASK, CW_CLR_INTERRUPT, CW_GET_INTERRUPT
N * @sa wizchip_getinterruptmask(), wizchip_clrinterrupt(), wizchip_getinterrupt()
N */
Nvoid wizchip_setinterruptmask(intr_kind intr);
N
N/** 
N * @ingroup extra_functions
N * @brief Get Interrupt mask of @ref _WIZCHIP_.
N * @return The operated OR value of @ref intr_kind. It can type-cast to uint32_t.
N * @sa ctlwizchip(), CW_GET_INTRMASK, CW_SET_INTRMASK, CW_CLR_INTERRUPT, CW_GET_INTERRUPT
N * @sa wizchip_setinterruptmask(), wizchip_clrinterrupt(), wizchip_getinterrupt()
N */
Nintr_kind wizchip_getinterruptmask(void);
N
N/** 
N * @ingroup extra_functions
N * @brief Get the Link status of integrated PHY.
N * @details @ref wizphy_getphylink() gets the link status of the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_. \n
N * @return : @ref PHY_LINK_ON or @ref PHY_LINK_OFF.
N * @sa ctlwizchip(), CW_GET_PHYLINK
N * @sa _PHY_IO_MODE_
N */
Nint8_t wizphy_getphylink(void);            ///< get the link status of phy in WIZCHIP. No use in W5100
N
N/** 
N * @ingroup extra_functions
N * @brief Reset the integrated PHY.
N * @details @ref wizphy_reset() resets the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_. \n
N * @note In @ref _PHY_IO_MODE_PHYCR_, It needs a stable reset time. \n
N *       So you need to wait for the stable reset time.\n
N *       The stable reset time for each @ref _WIZCHIP_ maybe different.
N * @sa ctlwizchip(), CW_RESET_PHY
N * @sa _PHY_IO_MODE_
N */
Nvoid wizphy_reset(void);                   ///< Reset phy. Vailid only in W5500
N
N/**
N * @ingroup extra_functions
N * @details @ref wizphy_setphyconf() set a operation mode of the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_.\n
N * @param phyconf : @ref wiz_PhyConf
N * @note The operation mode can be applied to Ethernet PHY after the Ethernet PHY is reset by @ref wizphy_reset().
N * @sa ctlwizchip(), CW_SET_PHYCONF, CW_GET_PHYCONF, CW_GET_PHYSTATUS, CW_RESET_PHY
N * @sa _PHY_IO_MODE_, wizphy_getphyconf(), wizphy_getphystatus(), wizphy_reset()
N */
Nvoid wizphy_setphyconf(wiz_PhyConf* phyconf);  
N
N/**
N * @ingroup extra_functions
N * @brief Get the integrated Ethernet PHY operation mode.
N * @details @ref wizphy_getphyconf() gets a operation mode of the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_.\n
N * @param phyconf : @ref wiz_PhyConf
N * @note It gets just the configured value for PHY operation, not real PHY operation.\n
N *       To get real PHY operation, you can call @ref wizphy_getphystatus()
N * @sa ctlwizchip(), CW_GET_PHYCONF, CW_SET_PHYCONF, CW_GET_PHYSTATUS
N * @sa _PHY_IO_MODE_, wizphy_setphyconf(), wizphy_getphystatus()
N */
Nvoid wizphy_getphyconf(wiz_PhyConf* phyconf); 
N
N/**
N * @ingroup extra_functions
N * @brief Get the real PHY operation status when link is established.
N * @details @ref wizphy_getphystatus() gets a operation mode of the integrated Ethernet PHY. \n
N * @param phyconf : @ref wiz_PhyConf
N * @sa ctlwizchip(), CW_GET_PHYSTATUS, CW_GET_PHYCONF, CW_SET_PHYCONF 
N * @sa wizphy_setphyconf(), wizphy_getphyconf() 
N */ 
Nvoid wizphy_getphystatus(wiz_PhyConf* phyconf);
N 
N/**
N * @ingroup extra_functions
N * @brief Set the power mode of integrated Ethernet PHY.
N * @details @ref wizphy_setphypmode() sets a power mode of the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_.\n
N * @param pmode @ref PHY_POWER_NORM or @ref PHY_POWER_DOWN
N * @note When the integrated Ethernet PHY enters in power down mode, \n
N *       the system clock of @ref _WIZCHIP_ is changed to the lowest speed. \n
N *       So, you should adjust the access time of @ref _WIZCHIP_ to the changed system clock.
N * @sa ctlwizchip(), CW_SET_PHYPOWMODE, CW_GET_PHYPOWMODE
N * @sa _PHY_IO_MODE_, wizphy_setphypmode(), wizphy_getphypmode()
N */   
Nvoid wizphy_setphypmode(uint8_t pmode);    
N
N/**
N * @ingroup extra_functions
N * @brief get the power mode of integrated Ethernet PHY.
N * @details @ref wizphy_getphypmode() gets a power mode of the integrated Ethernet PHY \n
N *          through @ref _PHY_IO_MODE_PHYCR_ or @ref _PHY_IO_MODE_MII_.\n
N * @return @ref PHY_POWER_NORM or @ref PHY_POWER_DOWN
N * @note When the integrated Ethernet PHY enters in power down mode,\n
N *       the system clock of @ref _WIZCHIP_ is changed to the lowest speed. \n
N *       So, you should adjust the access time of @ref _WIZCHIP_ to the changed system clock.
N * @sa ctlwizchip(), CW_SET_PHYPOWMODE, CW_GET_PHYPOWMODE
N * @sa _PHY_IO_MODE_, wizphy_setphypmode(), wizphy_getphypmode()
N */   
Nint8_t wizphy_getphypmode(void);
N
N/**
N * @ingroup extra_functions
N * @brief Set the network information for @ref _WIZCHIP_
N * @param pnetinfo : @ref wiz_NetInfo
N * @sa ctlnetwork(), CN_SET_NETINFO, CN_GET_NETINFO
N * @sa wizchip_getnetinfo()
N */
Nvoid wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network information of @ref _WIZCHIP_
N * @param pnetinfo : @ref wiz_NetInfo
N * @sa ctlnetwork(), CN_GET_NETINFO, CN_SET_NETINFO
N * @sa wizchip_setnetinfo()
N */
Nvoid wizchip_getnetinfo(wiz_NetInfo* pnetinfo);
N
N/**
N * @ingroup extra_functions
N * @brief Set the network mode such as WOL, PPPoE, PING Block, and etc. 
N * @param netmode : @ref netmode_type.
N * @sa ctlnetwork(), CN_SET_NETMODE, CN_GET_NETMODE
N * @sa wizchip_getnetmode()
N */
Nvoid wizchip_setnetmode(netmode_type netmode);
N
N/**
N * @ingroup extra_functions
N * @brief Get the network mode such as WOL, PPPoE, PING Block, and etc. 
N * @return @ref netmode_type.
N * @sa ctlnetwork(), CN_GET_NETMODE, CN_SET_NETMODE
N * @sa wizchip_setnetmode()
N */
Nnetmode_type wizchip_getnetmode(void);
N
N/**
N * @ingroup extra_functions
N * @brief Set retransmission time values and retry counts.
N * @param nettime : @ref wiz_NetTimeout. 
N * @sa ctlnetwork(), CN_SET_TIMEOUT, CN_GET_TIMEOUT
N * @sa wizchip_gettimeout()
N */
Nvoid wizchip_settimeout(wiz_NetTimeout* nettime);
N
N/**
N * @ingroup extra_functions
N * @brief Get retransmission time values and retry counts.
N * @param nettime : @ref wiz_NetTimeout. 
N * @sa ctlnetwork(), CN_GET_TIMEOUT, CN_SET_TIMEOUT
N * @sa wizchip_settimeout()
N */
Nvoid wizchip_gettimeout(wiz_NetTimeout* nettime);
N
N/**
N * @ingroup extra_functions
N * @brief ARP process.
N * @details @ref wizchip_arp() processes ARP. \n
N *          It sends the APR-request to destination and waits to receive the ARP-reply.
N * @param arp @ref wiz_ARP.\n
N *            It sets a destination IP address and indicates the destination hardware address.
N * @return 0 : success, destination hardware address is valid.\n
N *         -1 : fail. destination hardware address is invalid because timeout is occurred.\n
N * @sa ctlnetservice(), CNS_ARP
N */
Nint8_t wizchip_arp(wiz_ARP* arp);
N
N/**
N * @ingroup extra_functions
N * @brief PING process.
N * @details @ref wizchip_ping() processes PING. \n
N *          It sends the PING-request to destination and waits to receive the PING-reply.
N * @param ping @ref wiz_PING, It sets a destination IP address, ID, SEQ of PING-request message
N * @return 0 : success, PING-reply is successfully received.\n
N *         -1 : fail. Timeout is occurred.\n
N * @sa ctlnetservice(), CNS_PING
N */
Nint8_t wizchip_ping(wiz_PING* ping);
N
N/**
N * @ingroup extra_functions
N * @brief DAD(Duplcated Address Detection) process.
N * @details @ref wizchip_dad() detects the duplication of source IPv6 address.\n
N *          It sends a NA message for DAD to all-node multicasting address(FF02::01).
N * @param ipv6 : IPv6 address to be detected the duplication.
N * @return 0 : success, There is no duplicated address. \n
N *         -1 : fail. @ref _WIZCHIP_ source IP address to use is duplicated with a neighbor's one.
N * @sa ctlnetservice(), CNS_DAD
N */
Nint8_t wizchip_dad(uint8_t* ipv6);
N
N/**
N * @ingroup extra_functions
N * @brief Stateless Address Auto Configuration(SLAAC) process.
N * @details @ref wizchip_slaac() get a prefix information from a router for SLAAC.\n
N *          It sends first a RS message to all-router and waits to receive a RS message with prefix information option from a router.
N * @param prefix @ref wiz_Prefix
N * @return 0 : success, RA message is successfully received, and <i>prefix</i> is valid.  \n
N *         -1 : fail. Timeout is occurred.
N * @note It is valid only when the prefix information type(0x03) of RA option received first.\n
N *       The prefix option should be in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address. \n
N *       For more detail, Refer to @ref SLIR_RS.
N * @sa ctlnetservice(), CNS_SLAAC
N */
Nint8_t wizchip_slaac(wiz_Prefix* prefix);
N
N/**
N * @ingroup extra_functions
N * @brief Unsolicited NA process.
N * @details @ref wizchip_unsolicited() updates the network information of @ref _WIZCHIP_ to neighbors.\n
N *          It sends a unsolicited NA message with @ref _LLAR_ or @ref _GUAR_ to neighbors \n
N *          in order to update the network information of @ref _WIZCHIP_.\n
N *          Because the unsolicited NA message have no reply, timeout is always occurred.
N * @return always 0. Timeout is occurred.
N * @sa ctlnetservice(), CNS_UNSOL
N */
Nint8_t wizchip_unsolicited(void);
N
N/**
N * @ingroup extra_functions
N * @brief Get a prefix information of RA message from a router.
N * @details @ref wizchip_getprefix() get a prefix information of RA is periodically sent by a router. \n
N * @return 0 : success, a RS message is successfully received from a router.
N *         -1 : fail, a RS message is not received from a router yet.
N * @note It is valid only when the prefix information type(0x03) of RA option received first.\n
N *       The prefix option should be in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address. \n
N *       For more detail, Refer to @ref SLIR_RS.
N * @sa ctlnetservice(), CNS_GET_PREFIX
N */
Nint8_t wizchip_getprefix(wiz_Prefix * prefix);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif   // _WIZCHIP_CONF_H_
L 39 "..\..\Libraries\io6Library\Ethernet\W6100\w6100.h" 2
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/// @cond DOXY_APPLY_CODE
N#if      (_WIZCHIP_ == W6100)
X#if      (6100 == 6100)
N/// @endcond
N
N#define _W6100_SPI_READ_                  (0x00 << 2)        ///< SPI interface Read operation in Control Phase
N#define _W6100_SPI_WRITE_                 (0x01 << 2)        ///< SPI interface Write operation in Control Phase
N
N#define WIZCHIP_CREG_BLOCK                (0x00   <<3)       ///< Common register block
N#define WIZCHIP_SREG_BLOCK(N)             ((1+4*N)<<3)       ///< SOCKETn register block
N#define WIZCHIP_TXBUF_BLOCK(N)            ((2+4*N)<<3)       ///< SOCKETn Tx buffer address block
N#define WIZCHIP_RXBUF_BLOCK(N)            ((3+4*N)<<3)       ///< SOCKETn Rx buffer address block
N
N#define WIZCHIP_OFFSET_INC(ADDR, N) (ADDR + (N<<8)) ///< Increase offset address
N
N#if (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_)      
X#if ((0x0100 + 2) == (0x0100 + 2))      
N   #define IDM_AR0                        ((_WIZCHIP_IO_BASE_ + 0x0000))      ///< Indirect High Address Register
N   #define IDM_AR1                        ((_WIZCHIP_IO_BASE_ + 0x0001))      ///< Indirect Low Address Register
N   #define IDM_BSR                        ((_WIZCHIP_IO_BASE_ + 0x0002))      ///< Block Select Register
N   #define IDM_DR                         ((_WIZCHIP_IO_BASE_ + 0x0003))      ///< Indirect Data Register
N   #define _W6100_IO_BASE_       _WIZCHIP_IO_BASE_
N#elif (_WIZCHIP_IO_MODE_ & _WIZCHIP_IO_MODE_SPI_)
S   #define _W6100_IO_BASE_       0x00000000
N#endif
N
N
N//-----------       defgroup --------------------------------
N
N/**
N * @defgroup W6100 W6100
N * @brief @ref _WIZCHIP_ register defines and I/O functions
N * @details
N *   - @ref WIZCHIP_register_W6100 : @ref Common_register_group_W6100, @ref Socket_register_group_W6100
N *   - @ref WIZCHIP_IO_Functions_W6100 : @ref Basic_IO_function_W6100, @ref Common_register_access_function_W6100, @ref Socket_register_access_function_W6100
N */
N
N /**
N * @defgroup WIZCHIP_register_W6100 WIZCHIP register
N * @ingroup W6100
N * @brief @ref WIZCHIP_register_W6100 defines register group of @b W6100.
N * @details
N *   - @ref Common_register_group_W6100 : Common register group W6100
N *   - @ref Socket_register_group_W6100 : SOCKET n register group W6100
N */
N
N/**
N * @defgroup Basic_IO_function_W6100 Basic I/O function
N * @ingroup WIZCHIP_IO_Functions_W6100
N * @brief These are basic input/output functions to read values from register or write values to register.
N */
N
N/**
N * @defgroup Common_register_access_function_W6100 Common register access functions
N * @ingroup WIZCHIP_IO_Functions_W6100
N * @brief These are functions to access @ref Common_register_group_W6100.
N */
N
N/**
N * @defgroup Socket_register_access_function_W6100 Socket register access functions
N * @ingroup WIZCHIP_IO_Functions_W6100
N * @brief These are functions to access @ref Socket_register_group_W6100.
N */
N
N/**
N * @defgroup WIZCHIP_IO_Functions_W6100 WIZCHIP I/O functions
N * @ingroup W6100
N * @brief @ref WIZCHIP_IO_Functions_W6100 supports the basic I/O functions for @ref WIZCHIP_register_W6100.
N * @details
N *   - @ref WIZCHIP_IO_Functions_W6100 \n
N *     WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N *   - @ref Common_register_access_function_W6100 \n
N *     - @ref _WIZCHIP_ Mode \n
N *       getCIDR(), getVER() \n
N *       getSYSR()  \n
N *       setCHPLCKR(), setNETLCKR(), setPHYLCKR() \n
N *       setSYCR0(), getSYCR1(), setSYCR1()
N *     - Network Mode \n
N *       getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR(), getNETMR(), setNETMR(), getNETMR2(), setNETMR2()
N *     - Interrupt \n
N *       getIR(), setIRCLR(), getIMR(), setIMR() \n
N *       getSIR(), getSIMR(), setSIMR() \n
N *       getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR() \n
N *       getINTPTMR(), setINTPTMR()
N *     - Network Information \n
N *       NETLOCK(), NETUNLOCK() \n
N *       getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), setSUBR(), getSIPR(), setSIPR() \n
N *       getLLAR(), setLLAR(), getGUAR(), setGUAR(), getGA6R(), setGA6R(), getSUB6R(), setSUB6R() \n
N *       getPLR(), getPFR(), getVLTR(), getPLTR(), getPAR() \n
N *     - SOCKET-less Commands for PING, ARP and IPv6 Auto-Configuration \n
N *       getSLCR(), setSLCR() \n
N *       getPINGIDR(), setPINGIDR(), getPINGSEQR(), setPINGSEQR() \n
N *       getSLDHAR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLHOPR(), setSLHOPR() \n
N *     - Retransmission  \n
N *       getRCR(), setRCR() \n
N *       getSLRCR(), setSLRCR(), getSLRTR(), setSLRTR() \n
N *     - ICMP \n
N *       getUIPR(), getUIP6R(), getUPORTR(), getUPORT6R() \n
N *       getICMP6BLKR(), setICMP6BLKR() \n
N *     - PPPoE \n
N *       getPTMR(), setPTMR(), getPMNR(), getPMNR() \n
N *       getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR()
N *     - PHY Configuration \n
N *       getPHYSR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK() \n
N *       setPHYCR0(), getPHYCR1(), setPHYCR1() \n
N *       getPHYRAR(), setPHYRAR(), setPHYDIR(), getPHYDOR(), getPHYACR(), setPHYACR(), getPHYDIVR(), setPHYDIVR()
N *     - etc \n
N *       getTCNTR(), setTCNTRCLR()
N *   - @ref Socket_register_access_function_W6100 \n
N *     - SOCKET control \n
N *       getSn_MR(), setSn_MR(), getSn_MR2(), setSn_MR2(), getSn_PSR(), setSn_PSR(), getSn_CR(), setSn_CR() \n
N *       getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR()  \n
N *       getSn_RTR(), setSn_RTR(), getSn_RCR(), setSn_RCR(), getSn_KPALVTR(), setSn_KPALVTR()
N *     - SOCKET information \n
N *       getSn_SR(), getSn_ESR() \n
N *       getSn_DHAR(), setSn_DHAR(),  getSn_PORTR(), setSn_PORTR(), getSn_DPORTR(), setSn_DPORTR() \n
N *       getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R() \n
N *       getSn_MSSR(), setSn_MSSR()
N *     - SOCKET communication \n
N *       getSn_RX_BSR(), setSn_RX_BSR(), getSn_TX_BSR(), setSn_TX_BSR() \n
N *       getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR() \n
N *       getSn_RX_RD(), setSn_RX_RD(), getSn_RX_WR() \n
N *       getSn_TX_FSR(), getSn_RX_RSR()
N *     - IP header field \n
N *       getSn_FRGR(), setSn_FRGR(),  getSn_TOSR(), setSn_TOSR() \n
N *       getSn_TTLR(), setSn_TTLR()
N */
N
N/**
N * @defgroup Common_register_group_W6100 Common register
N * @ingroup WIZCHIP_register_W6100
N * @brief Common register group \n
N * @details It set the general configuration such as interrupt, network information, ICMP, and etc.
N * @sa
N * <table width=0>
N *    <tr><td> @ref _WIZCHIP_ Information   </td><td>: _CIDR_, _VER_                                                                   </td></tr>
N *    <tr><td> @ref _WIZCHIP_ Mode          </td><td>: _SYSR_, _SYCR0_, _SYCR1_, _CHPLCKR_, _NETLCKR_, _PHYLCKR_                       </td></tr>
N *    <tr><td> Network Mode                 </td><td>: _NET4MR_, _NET6MR_, _NETMR_, _NETMR2_                                           </td></tr>
N *    <tr><td> Network Information          </td><td>: _GAR_, _SUBR_, _SHAR_, _SIPR_, _GA6R_, _LLAR_, _GUAR_, _SUB6R_                  </td></tr>
N *    <tr><td> Interrupt                    </td><td>: _IR_, _IRCLR_, _IMR_, _SIR_, _SIMR_, _SLIR_, _SLIMR_, _SLIRCLR_, _INTPTMR_      </td></tr>
N *    <tr><td> Data retransmission          </td><td>: _RTR_, _RCR_, _SLRTR_, _SLRCR_, _SLHOPR_                                        </td></tr>
N *    <tr><td> PPPoE                        </td><td>: _PHAR_, _PSIDR_, _PMRUR_, _PTMR_, _PMNR_                                        </td></tr>
N *    <tr><td> SOCKET-less command          </td><td>: _SLCR_, _SLIR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _PINGIDR_, _PINGSEQR_ </td></tr>
N *    <tr><td> ICMP v4 & v6                 </td><td>: _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_, _ICMP6BLKR_                               </td></tr>
N *    <tr><td> IPv6 Auto-configuration      </td><td>: _PLR_, _PFR_, _VLTR_, _PAR_                                                     </td></tr>
N *    <tr><td> PHY Configuration            </td><td>: _PHYSR_, _PHYCR0_, _PHYCR1_, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYDIVR_  </td></tr>
N * </table>
N */
N 
N
N/**
N * @defgroup Socket_register_group_W6100 Socket register
N * @ingroup WIZCHIP_register_W6100
N * @brief Socket register group\n
N * @details
N * SOCKETn registers configure and control SOCKETn which is necessary to data communication.
N * @sa
N * <table width=0>
N *    <tr><td> SOCKETn Control       </td><td>: _Sn_MR_, _Sn_MR2_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, _Sn_PSR_                                </td></tr>
N *    <tr><td> SOCKETn Information   </td><td>: _Sn_SR_, _Sn_ESR_, _Sn_PORTR_, _Sn_DHAR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_                       </td></tr>
N *    <tr><td> SOCKETn Retransmission </td><td>: _Sn_RTR_, _Sn_RCR_                                                                                 </td></tr>
N *    <tr><td> Internet protocol     </td><td>: _Sn_MSSR_, _Sn_TOSR_, _Sn_TTLR_, _Sn_FRGR_                                                         </td></tr>
N *    <tr><td> Data communication    </td><td>: _Sn_RX_BSR_, _Sn_TX_BSR_, _Sn_TX_FSR_, _Sn_TX_RD_, _Sn_TX_WR_, _Sn_RX_RSR_, _Sn_RX_RD_, _Sn_RX_WR_ </td></tr>
N * </table>
N */
N
N//-----------------------------------------------------------------------------------
N
N//----------------------------- W6100 Common Registers IOMAP -----------------------------
N
N/**
N * @addtogroup Common_register_group_W6100
N * @{
N */
N
N/**
N * @brief Chip Identification Register address [RO] [0x6100]
N * @sa getCIDR()
N */
N#define _CIDR_               (_W6100_IO_BASE_ + (0x0000 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Chip Version Register address [RO] [0x4661]
N * @sa getVER()
N */
N#define _VER_                (_W6100_IO_BASE_ + (0x0002 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief System Status Register address [RO] [0xEU]
N * @details @ref _SYSR_ shows the information such as CHIP, NET, PHY Locking and Host I/F
N * <table>
N *    <tr> <td>7   </td> <td>6   </td> <td>5   </td> <td>4 ~ 2   </td> <td>1  </td> <td>0  </td> </tr>
N *    <tr> <td>CHPL</td> <td>NETL</td> <td>PHYL</td> <td>Reserved</td> <td>IND</td> <td>SPI</td> </tr>
N * </table>
N *  - @ref SYSR_CHPL 
N *  - @ref SYSR_NETL 
N *  - @ref SYSR_PHYL 
N *  - @ref SYSR_IND  : HOST use Parallel BUS Interface(Indirect Bus Mode)
N *  - @ref SYSR_SPI  : HOST use SPI Interface
N *
N * @sa _CHPLCKR_, _NETLCKR_, _PHYLCKR_, 
N * @sa getSYSR(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK() \n
N *        setPHYLCKR(), getPHYLCKR(), PHYLOCK(), PHYUNLOCK()
N */
N#define _SYSR_               (_W6100_IO_BASE_ + (0x2000 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief System Config Register 0 address [WO][0x80] 
N * @details @ref _SYCR0_ softly reset to _WIZCHIP_.
N * <table>
N *    <tr> <td>7  </td> <td>6 ~ 0   </td> </tr>
N *    <tr> <td>RST</td> <td>Reserved</td> </tr>
N * </table>
N *   - @ref SYCR0_RST : Software Reset.
N *
N * @note It can be accessed only when @ref SYSR_CHPL = 1.
N * @sa _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa setSYCR0(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SYCR0_              (_W6100_IO_BASE_ + (0x2004 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief System Config Register 1 address [R=W][0x80] 
N * @details @ref _SYCR1_ controls the global interrupt enable, and selects the system clock.
N * <table>
N *    <tr> <td>7  </td> <td>6 ~ 1   </td> <td>0     </td> </tr>
N *    <tr> <td>IEN</td> <td>Reserved</td> <td>CLKSEL</td> </tr>
N * </table>
N *   - @ref SYCR1_IEN
N *   - @ref SYCR1_CLKSEL
N *
N * @note SYCR1_CLKSEL bit can be accessed only when @ref SYSR_CHPL = 1.
N * @sa _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSYCR1(), setSYCR1(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SYCR1_              (WIZCHIP_OFFSET_INC(_SYCR0_,1))
N
N/**
N * @brief Ticker Counter Register address [RO][0x0000]
N * @details @ref _TCNTR_ increase by 1 every 100us after _WIZCHIP_ reset.
N * @sa _TCNTRCLR_
N * @sa getTCNTR(), setTCNTRCLR() 
N */
N#define _TCNTR_              (_W6100_IO_BASE_ + (0x2016 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Ticker Counter Clear Register address [RO][0x00]
N * @details @ref _TCNTRCLR_ clear @ref _TCNTR_.
N * @sa setTCNTRCLR(), getTCNTR()
N */
N#define _TCNTRCLR_           (_W6100_IO_BASE_ + (0x2020 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Interrupt Register address [RO][0x00]
N * @details @ref _IR_ indicates the interrupt status.
N *          If @ref _IR_ is not equal to x00 INTn PIN is asserted to low until it is x00.
N * 
N * <table>
N *    <tr> <td>7  </td> <td>6 ~ 5   </td> <td>4   </td> <td>3       </td> <td>2     </td> <td>1   </td> <td>0    </td> </tr>
N *    <tr> <td>WOL</td> <td>Reserved</td> <td>UNR6</td> <td>Reserved</td> <td>IPCONF</td> <td>UNR4</td> <td>PTERM</td> </tr>
N * </table>
N *  - @ref IR_WOL    : Wake On LAN
N *  - @ref IR_UNR6   : Destination Port Unreachable for IPv6
N *  - @ref IR_IPCONF : @ref _SIPR_ is Conflict
N *  - @ref IR_UNR4   : Destination Port Unreachable for IPv4
N *  - @ref IR_PTERM  : PPPoE Terminated
N *
N * @sa _IMR_, _IRCLR_, SYCR1_IEN, _CHIPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getIR(), setIRCLR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR() 
N */
N#define _IR_                 (_W6100_IO_BASE_ + (0x2100 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET Interrupt Register address [RO][0x00]
N * @details @ref _SIR_ indicates whether a socket interrupt is occurred or not.\n
N *          Each bit of @ref _SIR_ be still until @ref _Sn_IR_ is cleared by @ref _Sn_IRCLR_
N * @sa _SIMR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, SYCR1_IEN , _CHIPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSIR(), getSn_IR(), setSn_IRCLR(), getSIMR(), setSIMR(), getSn_IMR(), setSn_IMR(), getSYCR1(), setSYCR1(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SIR_                (_W6100_IO_BASE_ + (0x2101 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Interrupt Register address [RO][0x00]
N * @details @ref _SLIR_ indicates the completion of @ref _SLCR_ or timeout.
N * <table>
N *    <tr> <td>7   </td> <td>6   </td> <td>5    </td> <td>4   </td> <td>3    </td> <td>2 </td> <td>1 </td> <td>0 </td> </tr>
N *    <tr> <td>TOUT</td> <td>ARP4</td> <td>PING4</td> <td>ARP6</td> <td>PING6</td> <td>NS</td> <td>RS</td> <td>RA</td> </tr>
N * </table>
N *  - @ref SLIR_TOUT  : The timeout occurrence after @ref _SLCR_ is performed
N *  - @ref SLIR_ARP4  : The completion of @ref SLCR_ARP4
N *  - @ref SLIR_PING4 : The completion of @ref SLCR_PING4
N *  - @ref SLIR_ARP6  : The completion f @ref SLCR_ARP6
N *  - @ref SLIR_PING6 : The completion of @ref SLCR_PING6
N *  - @ref SLIR_NS    : The completion of @ref SLCR_NS
N *  - @ref SLIR_RS    : The completion of @ref SLIR_RS
N *  - @ref SLIR_RA    : The reception from Router Advertisement
N *
N * @sa _SLIRCLR_, _SLIMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSLIR(), setSLIRCLR(),  getSLIR(), getSLIMR(), setSLIMR(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SLIR_               (_W6100_IO_BASE_ + (0x2102 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Interrupt Mask Register address [R=W][0x00]
N * @details @ref _IMR_ is used to mask interrupts of @ref _IR_.\n
N *          When a bit of @ref _IMR_ and the corresponding bit of @ref _IR_ is set, an interrupt will be issued.
N * @sa _IR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getIMR(), setIMR(),  getIR(), setIRCLR(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _IMR_                (_W6100_IO_BASE_ + (0x2104 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief @ref _IR_  Clear Register address [WO][0x00]
N * @details @ref _IRCLR_ clears @ref _IR_
N * @sa _IR_, _IMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa setIRCLR(), getIR(), getIMR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _IRCLR_              (_W6100_IO_BASE_ + (0x2108 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET Interrupt Mask Register address [R=W]][0x00]
N * @details @ref _SIMR_ is used to mask interrupts of @ref _SIR_.\n
N *          When a bit of @ref _SIMR_ and the corresponding bit of @ref _SIR_ is set, an interrupt will be issued.\n
N *          when @ref _Sn_IR_ is not 0,  The N-th bit of @ref _SIR_ is set. Otherwise, this bit is automatically clear.\n
N * @sa _SIR_, _Sn_IR_, _Sn_IRCLR_, _Sn_IMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSIMR(), setSIMR(), getSIR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SIMR_               (_W6100_IO_BASE_ + (0x2114 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Interrupt Mask Register address [R=W][0x00]
N * @details @ref _SLIMR_ is used to mask interrupts of @ref _SLIR_\n
N *          When a bit of @ref _SLIMR_ and the corresponding bit of @ref _SLIR_ is set, an interrupt will be issued.
N * @sa _SLIR_, _SLIRCLR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSLIMR(), setSLIMR(), getSLIR(), setSLIRCLR(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SLIMR_              (_W6100_IO_BASE_ + (0x2124 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Interrupt Clear Register address [WO][0x00]
N * @details @ref _SLIRCLR_ clears @ref _SLIR_
N * @sa _SLIR_, _SLIRCLR_, _SLIMR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), \n
N *     getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SLIRCLR_            (_W6100_IO_BASE_ + (0x2128 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Prefer Source IPv6 Address Register address [R=W][0x00]
N * @details @ref _SLPSR_ select the Source IPv6 Address to transmit a packet by @ref _SLCR_.
N *   - @ref PSR_AUTO 
N *   - @ref PSR_LLA 
N *   - @ref PSR_GUA 
N * @sa _SLCR_, _Sn_PSR_
N * @sa getSLPSR(), setSLPSR(), getSLCR(), setSLCR(), getSn_PSR(), setSn_PSR()
N */
N#define _SLPSR_              (_W6100_IO_BASE_ + (0x212C << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Command Register address [RW,AC][0x00]
N * @details @ref _SLCR_ can be request a message such like as ARP, PING, and ICMPv6 without SOCKET.
N * <table>
N *    <tr> <td>7       </td> <td>6   </td> <td>5    </td> <td>4   </td> <td>3    </td> <td>2 </td> <td>1 </td> <td>0  </td> </tr>
N *    <tr> <td>Reserved</td> <td>ARP4</td> <td>PING4</td> <td>ARP6</td> <td>PING6</td> <td>NS</td> <td>RS</td> <td>UNA</td> </tr>
N * </table>
N *   - @ref SLCR_ARP4
N *   - @ref SLCR_PING4
N *   - @ref SLCR_ARP6
N *   - @ref SLCR_PING6
N *   - @ref SLCR_NS
N *   - @ref SLCR_RS
N *   - @ref SLCR_UNA
N *
N * @sa _SLIR_, _SLIMR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, SYCR1_IEN, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDIPR(),setSLDIPR(), getSLDIP4R(),setSLDIP4R(), 
N *     getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSYCR1(), setSYCR1(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _SLCR_               (_W6100_IO_BASE_ + (0x2130 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Status Register address [RO][0x00]
N * @details @ref _PHYSR_ shows the operation mode of PHY, the link status and etc.
N *   - @ref PHYSR_CAB  : @ref PHYSR_CAB_OFF, @ref PHYSR_CAB_ON
N *   - @ref PHYSR_MODE : @ref PHYSR_MODE_AUTO, @ref PHYSR_MODE_100F, @ref PHYSR_MODE_100H, @ref PHYSR_MODE_10F, @ref PHYSR_MODE_10H
N *   - @ref PHYSR_DPX  : @ref PHYSR_DPX_FULL, @ref PHYSR_DPX_HALF
N *   - @ref PHYSR_SPD  : @ref PHYSR_SPD_100M, @ref PHYSR_SPD_10M
N *   - @ref PHYSR_LNK  : @ref PHYSR_LNK_UP, @ref PHYSR_LNK_DOWN
N *
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL
N * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), getPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
N */
N#define _PHYSR_              (_W6100_IO_BASE_ + (0x3000 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Internal Register Address Register address(R/W)
N * @details @ref _PHYRAR_ specifies the address of register in the Ethernet PHY.
N *   - @ref PHYRAR_BMCR
N *   - @ref PHYRAR_BMSR
N * @sa _PHYACR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
N * @sa getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
N */
N#define _PHYRAR_             (_W6100_IO_BASE_ + (0x3008 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Data Input Register address [R=W][0x00]
N * @details @ref _PHYDIR_ specifies the value to write to the register in PHY
N * @sa _PHYRAR_, _PHYACR_, _PHYDOR_, _PHYDIVR_
N * @sa setPHYDIR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
N */
N#define _PHYDIR_             (_W6100_IO_BASE_ + (0x300C << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Data Output Register address [WO][0x00]
N * @details @ref _PHYDOR_ read the value from the register in PHY
N * @sa _PHYRAR_, _PHYACR_, _PHYDIR_, _PHYDIVR_
N * @sa getPHYDOR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
N */
N#define _PHYDOR_             (_W6100_IO_BASE_ + (0x3010 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Access Register address [RW,AC][0x00]
N * @details @ref _PHYACR_ write(read)  to(from) the value of register in the Ethernet PHY
N *   - @ref PHYACR_READ
N *   - @ref PHYACR_WRITE
N * @sa _PHYRAR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
N * @sa getPHYACR(), setPHYACR(), getPHYDOR(), getPHYRAR(), setPHYRAR(), setPHYDIR(), getPHYDIVR(), setPHYDIVR()
N */
N#define _PHYACR_             (_W6100_IO_BASE_ + (0x3014 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY's MDC Clock Division Register address [R=W][0x01]
N * @details @ref _PHYDIVR_ divides the system clock for the MDC clock of Ethernet PHY'
N *   - @ref PHYDIVR_32
N *   - @ref PHYDIVR_64
N *   - @ref PHYDIVR_128
N * @sa _PHYRAR_, _PHYACR_, _PHYDOR_, _PHYDIR_, _PHYDIVR_
N * @sa getPHYDIVR(), setPHYDIVR(), getPHYRAR(), setPHYRAR(), getPHYACR(), setPHYACR(), getPHYDOR(), setPHYDIR()
N */
N#define _PHYDIVR_            (_W6100_IO_BASE_ + (0x3018 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Control Register address [WO][0x00]
N * @details @ref _PHYCR0_ controls the operation mode of PHY.
N *          The result will be checked by @ref _PHYSR_ after PHY HW reset by @ref PHYCR1_RST.
N *   - @ref PHYCR0_AUTO
N *   - @ref PHYCR0_100F
N *   - @ref PHYCR0_100H
N *   - @ref PHYCR0_10F
N *   - @ref PHYCR0_10H
N *
N * @note It can be only accessed when @ref SYSR_PHYL is unlock.  
N * @sa _SYSR_, _PHYCR1_
N * @sa setPHYCR0(), getSYSR(), getPHYCR1(), setPHYCR1() 
N */
N#define _PHYCR0_             (_W6100_IO_BASE_ + (0x301C << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY Control Register address [R=W][0x40]
N * @details @ref _PHYCR1_ controls the Ethernet PHY function such as HW reset, Power down and etc.
N * <table>
N *    <tr> <td>7       </td> <td>6       </td> <td>5   </td> <td>4      </td> <td>3 </td> <td>2 ~ 1   </td> <td>0  </td> </tr>
N *    <tr> <td>Reserved</td> <td>Always 1</td> <td>PWDN</td> <td>Reseved</td> <td>TE</td> <td>Reserved</td> <td>RST</td> </tr>
N * </table>
N *   - @ref PHYCR1_PWDN
N *   - @ref PHYCR1_TE
N *   - @ref PHYCR1_RST
N *
N * @note It can be only accessed when @ref SYSR_PHYL is unlock.  
N * @sa _SYSR_, _PHYCR0_
N * @sa getPHYCR1(), setPHYCR1(), setPHYCR0(), getSYSR() 
N */
N#define _PHYCR1_             WIZCHIP_OFFSET_INC(_PHYCR0_,1)
N
N/**
N * @brief Network IPv4 Mode Register address [R=W][0x00]
N * @details @ref _NET4MR_ can block the transmission such like as unreachable message, TCP reset, and ping relay.\n
N *          It can ARP request before ping relpy.
N *
N * <table>
N *    <tr> <td>7 ~ 4   </td> <td>3   </td> <td>2   </td> <td>1   </td> <td>0 </td> </tr>
N *    <tr> <td>Reserved</td> <td>UNRB</td> <td>PARP</td> <td>RSTB</td> <td>PB</td> </tr>
N * </table>
N *   - @ref NETxMR_UNRB
N *   - @ref NETxMR_PARP
N *   - @ref NETxMR_RSTB
N *   - @ref NETxMR_PB
N * @sa _NET6MR_
N * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
N */
N#define _NET4MR_             (_W6100_IO_BASE_ + (0x4000 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Network IPv6 Mode Register address [R=W][0x00]
N * @details @ref _NET6MR_ can block the transmission such like as unreachable message, TCP reset, and ping relay.\n
N *          It can ARP request before ping reply.
N *
N * <table>
N *    <tr> <td>7 ~ 4   </td> <td>3   </td> <td>2   </td> <td>1   </td> <td>0 </td> </tr>
N *    <tr> <td>Reserved</td> <td>UNRB</td> <td>PARP</td> <td>RSTB</td> <td>PB</td> </tr>
N * </table>
N *   - @ref NETxMR_UNRB
N *   - @ref NETxMR_PARP
N *   - @ref NETxMR_RSTB
N *   - @ref NETxMR_PB
N * @sa _NET4MR_
N * @sa getNET6MR(), setNET6MR(), getNET4MR(), setNET4MR() 
N */
N#define _NET6MR_             (_W6100_IO_BASE_ + (0x4004 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Network Mode Register address [R=W][0x00]
N * @details @ref _NETMR_ set WOL(Wake On Lan) mode.\n
N *          It also can block a packet such as \n
N *          IPv6 PING request from an all-node broadcasting, \n
N *          IPv6 PING request from a solicited mulitcasting address,\n
N *          IPv4 packets, \n
N *          and IPv6 packets.
N * 
N * <table>
N *    <tr> <td>7 ~ 6   </td> <td>5  </td> <td>4  </td> <td>3       </td> <td>2  </td> <td>1   </td> <td>0  </td> </tr>
N *    <tr> <td>Reserved</td> <td>ANB</td> <td>M6B</td> <td>Always 0</td> <td>WOL</td> <td>IP6B</td> <td>IP4B</td> </tr> 
N * </table>
N * - @ref NETMR_ANB
N * - @ref NETMR_M6B
N * - @ref NETMR_WOL
N * - @ref NETMR_IP6B
N * - @ref NETMR_IP4B
N * @sa getNETMR(), setNETMR()
N *
N */
N#define _NETMR_              (_W6100_IO_BASE_ + (0x4008 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Network Mode Register 2 address [R=W][0x00]
N * @details @ref _NETMR2_ set PPPoE mode.\n
N *          It also can select the destination hardware address to either Ethernet frame MAC or target MAC in the ARP-reply message
N * <table>
N *    <tr> <td>7   </td> <td>6 ~ 1</td> <td>0    </td> </tr>
N *    <tr> <td>DHAS</td> <td>6 ~ 1</td> <td>PPPoE</td> </tr>
N * </table>
N *   - @ref NETMR2_DHAS : @ref NETMR2_DHAS_ARP, @ref NETMR2_DHAS_ETH
N *   - @ref NETMR2_PPPoE
N * @sa getNETMR2(), setNETMR2()
N */
N#define _NETMR2_             (_W6100_IO_BASE_ + (0x4009 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PPP LCP request Timer Register address [R=W][0x28]
N * @details @ref _PTMR_ sets the time for sending LCP echo request.\n
N *          The unit of time is 25ms.
N * @sa _PMNR_, _PHAR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
N * @sa getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
N */
N#define _PTMR_               (_W6100_IO_BASE_ + (0x4100 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PPP LCP Magic Number Register address [R=W][0x00]
N * @details @ref _PMNR_ sets the 4bytes magic number to be used in LCP negotiation.
N * @sa _PTMR_, _PHAR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
N * @sa getPMNR(), setPMNR(), getPTMR(), setPTMR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
N */
N#define _PMNR_               (_W6100_IO_BASE_ + (0x4104 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PPPoE Hardware Address Register address [R=W][0x00]
N * @details @ref _PHAR_ sets the PPPoE server hardware address that is acquired during PPPoE connection process.
N * @sa _PTMR_, _PMNR_, _PSIDR_, _PMRUR_, NETMR2_PPPoE
N * @sa getPHAR(), setPHAR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPSIDR(), setPSIDR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
N */
N#define _PHAR_               (_W6100_IO_BASE_ + (0x4108 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PPP Session ID Register address [R=W][0X0000]
N * @details @ref  _PSIDR_ sets the PPPoE sever session ID acquired during PPPoE connection process.
N * @sa _PTMR_, _PMNR_, _PHAR_, _PMRUR_, NETMR2_PPPoE
N * @sa getPSIDR(), setPSIDR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPMRUR(), setPMRUR(), getNETMR2(), setNETMR2()
N */
N#define _PSIDR_              (_W6100_IO_BASE_ + (0x4110 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PPP Maximum Receive Unit Register address [R=W][0xFFFF]
N * @details @ref _PMRUR_ sets the maximum receive unit of PPPoE.
N * @sa _PTMR_, _PMNR_, _PHAR_, _PSIDR_, NETMR2_PPPoE
N * @sa  getPMRUR(), setPMRUR(), getPTMR(), setPTMR(), getPMNR(), setPMNR(), getPHAR(), setPHAR(), getPSIDR(), setPSIDR(), getNETMR2(), setNETMR2()
N */
N#define _PMRUR_              (_W6100_IO_BASE_ + (0x4114 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Source Hardware Address Register address [R=W][00:00:00:00:00:00]
N * @details @ref _SHAR_ sets the source hardware address.
N * @note It can be accessed only when @ref SYSR_NETL is unlock.
N * @sa SYSR_NETL, _NETLCKR_
N * @sa getSHAR(), setSHAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK()
N */
N#define _SHAR_               (_W6100_IO_BASE_ + (0x4120 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv4 Gateway Address Register address [R=W][0.0.0.0]
N * @details @ref _GAR_ sets the default gateway IPv4 address.
N * @note It can be accessed only when @ref SYSR_NETL is unlock.
N * @sa SYSR_NETL, _NETLCKR_, _GA6R_
N * @sa getGAR(), setGAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getGA6R(), setGA6R()
N */
N#define _GAR_                (_W6100_IO_BASE_ + (0x4130 << 8) + WIZCHIP_CREG_BLOCK)
N#define _GA4R_               (_GAR_)      ///< Refer to @ref _GAR_
N/**
N * @brief IPv4 Subnet Mask Register address [R=W][0.0.0.0]
N * @details @ref _SUBR_ sets the default subnet mask address of IPv4.
N * @note It can be accessed only when @ref SYSR_NETL is unlock. 
N * @sa SYSR_NETL, _NETLCKR_, _SUB6R_
N * @sa getSUBR(), setSUBR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getSUB6R(), setSUB6R()
N */
N#define _SUBR_               (_W6100_IO_BASE_ + (0x4134 << 8) + WIZCHIP_CREG_BLOCK)
N#define _SUB4R_              (_SUBR_)      ///< Refer to @ref _SUBR_
N
N/**
N * @brief IPv4 Source IP Register address [R=W][0.0.0.0]
N * @details @ref _SIPR_ sets the source IPv4 address.
N * @note It can be accessed only when @ref SYSR_NETL is unlock. 
N * @sa SYSR_NETL, _NETLCKR_, _LLAR_, _GUAR_
N * @sa getSIPR(), setSIPR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getLLAR(), setLLAR(), getGUAR(),setGUAR()
N */
N#define _SIPR_               (_W6100_IO_BASE_ + (0x4138 << 8) + WIZCHIP_CREG_BLOCK)
N#define _SIP4R_              (_SIPR_)   ///< Refer to @ref _SIPR_.
N
N/**
N * @brief IPv6 LLA(Link Local Address) Register address [R=W][::]
N * @details @ref _LLAR_ sets the LLA address of IPv6.
N * @note It can be accessed only when @ref SYSR_NETL is unlock. 
N * @sa SYSR_NETL, _NETLCKR_, _GUAR_, _SIPR_
N * @sa getLLAR(), setLLAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getGUAR(),setGUAR(), getSIPR(), setSIPR()
N */
N#define _LLAR_               (_W6100_IO_BASE_ + (0x4140 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv6 GUA(Global Unicast Address) Register address [R=W][::]
N * @details @ref _GUAR_ sets the GUA address of IPv6.
N * @note It can be accessed only when @ref SYSR_NETL is unlock.  
N * @sa SYSR_NETL, _NETLCKR_, _LLAR_, _SIPR_
N * @sa getGUAR(), setGUAR(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getLLAR(),setLLAR(), getSIPR(), setSIPR()
N */
N#define _GUAR_               (_W6100_IO_BASE_ + (0x4150 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv6 Subnet Mask Register address [R=W][]
N * @details @ref _SUB6R_ sets the default subnet mask address of IPv6.
N * @note It can be accessed only when @ref SYSR_NETL is unlock. 
N * @sa SYSR_NETL, _NETLCKR_, _SUBR_
N * @sa getSUB6R(), setSUB6R(), getSYSR(), setNETLCKR(), getNETLCKR(), NETLOCK(), NETUNLOCK(), getSUBR(), setSUBR()
N */
N#define _SUB6R_              (_W6100_IO_BASE_ + (0x4160 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv6 Gateway Address Register address [R/W][::]
N * @details @ref _GA6R_ sets the default gateway IPv6 address.
N * @sa _GAR_
N * @sa getGA6R(), setGA6R(), getGAR(), setGAR()
N */
N#define _GA6R_               (_W6100_IO_BASE_ + (0x4170 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Peer IPv6 Register address [R=W][::]
N * @details @ref _SLDIP6R_ sets the destination IP address of @ref _SLCR_.
N * @sa _SLDIP6R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_, _SLDHAR_, _SLDIPR_, _SLDIP4R_
N * @sa getSLDIP6R(), setSLDIP6R(), getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDHAR(),
N *     getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R()
N */
N#define _SLDIP6R_            (_W6100_IO_BASE_ + (0x4180 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Peer IPv6 Register address [R=W][0.0.0.0]
N * @details @ref _SLDIPR_(= @ref _SLDIP4R_) sets the destination IPv4 address of @ref _SLCR_.
N * @sa _SLDIP4R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_, _SLDHAR_, _SLDIP6R_
N * @sa getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLCR(), setSLCR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSLDHAR(),
N *     getSLDIP6R(), setSLDIP6R()
N */
N#define _SLDIPR_             (_W6100_IO_BASE_ + (0x418C << 8) + WIZCHIP_CREG_BLOCK)
N#define _SLDIP4R_            (_SLDIPR_)            ///< Refer to @ref _SLDIPR_.
N
N
N/**
N * @brief SOCKET-less Peer Hardware Address Register address [RO][00:00:00:00:00:00]
N * @details @ref _SLDHAR_ gets the destination hardware address acquired by of @ref SLCR_ARP4, SLCR_ARP6, SLCR_PING4, and SLCR_PING6.
N * @sa _SLDIP4R_, _SLDIP6R_, _SLCR_, _SLIR_, _SLIRCLR_, _SLIMR_
N * @sa getSLDHAR(), getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLCR(), setSLCR(), \n
N *     getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR() 
N */
N#define _SLDHAR_             (_W6100_IO_BASE_ + (0x4190 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Ping ID Register address [R=W][0x00]
N * @details @ref _PINGIDR_ sets the PING-request ID to be sent by @ref SLCR_PING4 or @ref SLCR_PING6.
N * @sa _SLCR_, _PINGSEQR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLIMR_
N * @sa getPINGIDR(), setPINGIDR(), getSLCR(), setSLCR(), getPINGSEQR(), setPINGSEQR(), getSLDIPR(), setSLDIPR(), 
N *     getSLDIP4R(), setSLDIP4R(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR()
N */
N#define _PINGIDR_            (_W6100_IO_BASE_ + (0x4198 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less ping Sequence number Register address [R=W][0x0000]
N * @details @ref _PINGIDR_ sets the PING-request sequence number to be sent by @ref SLCR_PING4 or @ref SLCR_PING6.
N * @sa _SLCR_, _PINGIDR_, _SLDIPR_, _SLDIP4R_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLIMR_
N * @sa getPINGSEQR(), setPINGSEQR(), getSLCR(), setSLCR(), getPINGIDR(), setPINGIDR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(),
N *     getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR()
N */
N#define _PINGSEQR_           (_W6100_IO_BASE_ + (0x419C << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv4 Unreachable Address Register address [RO][0.0.0.0]
N * @details @ref _UIPR_ is set when a unreachable ICMPv4 message is received.
N * @sa _UPORTR_, _UIP6R_, _UPORT6R_
N * @sa getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUIPR6(), setUIPR6(), getUPORT6R(), setUPORT6R()
N */
N#define _UIPR_               (_W6100_IO_BASE_ + (0x41A0 << 8) + WIZCHIP_CREG_BLOCK)
N#define _UIP4R_              (_UIPR_)   ///< Refer to @ref _UPORTR_
N
N/**
N * @brief IPv4 Unreachable Port number Register address [RO][0x0000]
N * @details @ref _UPORTR_ is set when a unreachable ICMPv4 message is received.
N * @sa _UIPR_, _UIP6R_, _UPORT6R_
N * @sa getUPORTR(), setUPORTR(), getUIPR(), setUIPR(), getUIPR6(), setUIPR6(), getUPORT6R(), setUPORT6R()
N */
N#define _UPORTR_             (_W6100_IO_BASE_ + (0x41A4 << 8) + WIZCHIP_CREG_BLOCK)
N#define _UPORT4R_            (_UPORTR_)   ///< Refer to @ref _UPORTR_
N/**
N * @brief IPv6 Unreachable IP Address Register address [RO][::]
N * @details @ref _UIP6R_ is set when a unreachable ICMPv6 message is received.
N * @sa _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_
N * @sa getUIPR6(), setUIPR6(), getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUPORT6R(), setUPORT6R()
N */
N#define _UIP6R_              (_W6100_IO_BASE_ + (0x41B0 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief IPv6 Unreachable Port number Register address [RO][0x0000]
N * @details @ref _UIP6R_ is set when a unreachable ICMPv6 message is received.
N * @sa _UIPR_, _UPORTR_, _UIP6R_, _UPORT6R_
N * @sa getUIPR6(), setUIPR6(), getUIPR(), setUIPR(), getUPORTR(), setUPORTR(), getUPORT6R(), setUPORT6R()
N */
N#define _UPORT6R_            (_W6100_IO_BASE_ + (0x41C0 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Interrupt Pending Time Register address [R=w][0x0000]
N * @details @ref _INTPTMR_ pends the next interrupt issued by the INTn pin of @ref _WIZCHIP_.\n
N *          It is decreased 1 every 4 SYS_CLK. \n
N *          If it is zero and some interrupt is still remained, the INTn pin is issued.
N * @sa _IR_, _IRCLR_, _IMR_, _SIR_, _Sn_IRCLR_, _SIMR_, _SLIR_, _SLIRCLR_, _SLIMR_, SYCR_IEN
N * @sa getINTPTMR(), setINTPTMR(), getIR(), setIRCLR(), getIMR(), setIMR(), getSIR(), setSn_IRCLR(), getSIMR(), setSIMR(), \n
N *     getSLIR(), setSLIRCLR(), getSLIMR(), setSLIMR(), getSYCR1(), setSYCR1()
N */
N#define _INTPTMR_            (_W6100_IO_BASE_ + (0x41C5 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief RA Prefix Length Register address [RO][0x00]
N * @details @ref _PLR_ is set when RA packet is received from a router.
N * @sa SLIR_RA, _SLIRCLR_, _PFR_, _VLTR_, _PLTR_, _PAR_
N * @sa getPLR(), getSLIR(), setSLIRCLR(), getPFR(), getVLTR(), getPLTR(), getPAR()
N */
N#define _PLR_                (_W6100_IO_BASE_ + (0x41D0 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief RA Prefix Flag Register address [RO][0x00]
N * @details @ref _PFR_ is set when RA packet is received from a router.
N * @sa SLIR_RA, _SLIRCLR_, _PLR_, _VLTR_, _PLTR_, _PAR_
N * @sa getPFR(), getSLIR(), setSLIRCLR(), getPLR(), getVLTR(), getPLTR(), getPAR()
N */
N#define _PFR_                (_W6100_IO_BASE_ + (0x41D4 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief RA Valid Life Time Register address [RO][0x00000000]
N * @details @ref _VLTR_ is set when RA packet is received from a router.
N * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _PLTR_, _PAR_
N * @sa getVLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(),  getPLTR(), getPAR()
N */
N#define _VLTR_               (_W6100_IO_BASE_ + (0x41D8 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief RA Prefered Life Time Register address [RO][0x00000000]
N * @details @ref _PLTR_ is set when RA packet is received from a router.
N * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _PLTR_, _PAR_
N * @sa getPLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(), getVLTR(), getPAR()
N */
N#define _PLTR_               (_W6100_IO_BASE_ + (0x41DC << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief RA Prefix Address Register address[RO][::]
N * @details @ref _PAR_ is set when RA packet is received from a router.
N * @sa SLIR_RA, _SLIRCLR_, _PLR_, _PFR_, _VLTR_, _PLTR_, _PAR_
N * @sa getPAR(), getPLTR(), getSLIR(), setSLIRCLR(), getPLR(), getPFR(), getVLTR() 
N */
N#define _PAR_                (_W6100_IO_BASE_ + (0x41E0 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief ICMPv6 Block Register address [R=W][0x00]
N * @details @ref _ICMP6BLKR_ can block ICMPv6 message such like as PING, MLD, RA, NS and NA.\n
N *          In this blocked case, @ref Sn_MR_IPRAW6 SOCKET can receive it.
N * <table>
N *    <tr> <td>7 ~ 5</td> <td>4    </td> <td>3  </td> <td>2 </td> <td>1 </td> <td>0 </td> </tr>
N *    <tr> <td>7 ~ 5</td> <td>PING6</td> <td>MLD</td> <td>RA</td> <td>NA</td> <td>NS</td> </tr>
N * </table>
N *   - @ref ICMP6BLKR_PING6 : The same as @ref NETxMR_PB
N *   - @ref ICMP6BLKR_MLD
N *   - @ref ICMP6BLKR_RA
N *   - @ref ICMP6BLKR_NA
N *   - @ref ICMP6BLKR_NS
N *
N * @note The blocked message can be accepted by SOCKETn opened with @ref Sn_MR_IPRAW6.
N * @sa NETxMR_PB
N * @sa getICMP6BLKR(), setICMP6BLKR(), getNET6MR(), setNET6MR()
N */
N#define _ICMP6BLKR_          (_W6100_IO_BASE_ + (0x41F0 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Chip configuration Lock Register address [WO][0x00]
N * @details @ref _CHPLCKR_ can lock or unlock to access @ref _SYCR0_ and @ref _SYCR1_.\n
N *          The lock state can be checked from @ref SYSR_CHPL.
N * @sa _SYCR0_, _SYCR1_, _SYSR_, SYSR_CHPL
N * @sa getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define _CHPLCKR_            (_W6100_IO_BASE_ + (0x41F4 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Network configuration Lock Register address [WO][0x00]
N * @details @ref _NETLCKR_ can lock or unlock to access the network information register such as @ref _SIPR_, @ref _LLAR_, and etc.\n
N *          The lock state can be checked from @ SYSR_NETL.
N * @sa _SHAR_, _SIPR_, _SUBR_, _GAR_, _LLAR_, _GUAR_, _SUB6R_, _SYSR_, SYSR_NETL
N * @sa getNETLCKR(), setNETLCKR(), NETLOCK(), NETUNLOCK(), getSHAR(), setSHAR(), getSIPR(), getSIPR(), getSUBR(), setSUBR(), \n
N *     getGAR(), setGAR(), getLLAR(), setLLAR(), getGUAR(), setGUAR(), getSUB6R(), setSUB6R(), getSYSR()
N */
N#define _NETLCKR_            (_W6100_IO_BASE_ + (0x41F5 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief PHY configuration Lock Register address [WO][0x00]
N * @details @ref _PHYLCKR_ can lock or unlock to access @ref _PHYCR0_ and @ref _PHYCR1_.\n
N *          The lock state can be checked from @ref SYSR_PHYL.
N * @sa _PHYCR0_, _PHYCR1_, _SYSR_, SYSR_PHYL.
N * @sa getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), setPHYCR0(), getPHYCR1(), setPHYCR1(), getSYSR()
N */
N#define _PHYLCKR_            (_W6100_IO_BASE_ + (0x41F6 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Retransmission Time Register address [R=W][0x07D0]
N * @details @ref _RTR_ sets the default timeout value of @ref _Sn_RTR_.\n
N *          When @ref _Sn_RTR_ is 0, @ref _Sn_RTR_ is reset to @ref _RTR_ after @ref Sn_CR_OPEN.
N * @sa _Sn_RTR_, _RCR_, _Sn_RCR_, _Sn_CR_, Sn_CR_OPEN, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
N * @sa getRTR(), setRTR(), getSn_RTR(), setSn_RTR(), getRCR(), setRCR(), getSn_RCR(), setSn_RCR(),  \n
N *     getSn_CR(), getSn_CR(), getSn_IR(), setSn_IRCLR()
N */
N#define _RTR_                (_W6100_IO_BASE_ + (0x4200 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief Retransmission Counter Register address [R=W][0x08]
N * @details @ref _RCR_ sets the default retransmission count of @ref _Sn_RCR_.\n
N *          When @ref _Sn_RCR_ is 0, @ref _Sn_RCR_ is initialized as @ref _Sn_RTR_ after @ref Sn_CR_OPEN.
N * @sa _Sn_RCR_, _RTR_, _Sn_RTR_, _Sn_CR_, Sn_CR_OPEN, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
N * @sa getRCR(), setRCR(), getSn_RCR(), setSn_RCR(), getRTR(), setRTR(), getSn_RTR(), setSn_RTR(), \n 
N *     getSn_CR(), getSn_CR(), getSn_IR(), setSn_IRCLR()
N */
N#define _RCR_                (_W6100_IO_BASE_ + (0x4204 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Retransmission Time Register address [R=W][0x07D0]
N * @details @ref _SLRTR_ sets the timeout value of packet to be retransmitted by @ref _SLCR_.
N * @sa _SLRCR_, _SLIR_, _SLIRCLR_, SLIR_TOUT
N * @sa getSLRTR(), setSLRTR(), getSLRCR(), setSLRCR(), getSLIR(), setSLIRCLR() 
N */
N#define _SLRTR_              (_W6100_IO_BASE_ + (0x4208 << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Retransmission Count Register address [R=W][0x00]
N * @details @ref _SLRCR_ sets the retry counter of packet to be retransmitted by @ref _SLCR_.
N * @sa _SLRTR_, _SLIR_, _SLIRCLR_, SLIR_TOUT
N * @sa getSLRCR(), setSLRCR(), getSLRTR(), setSLRTR(), setSLIRCLR(), getSLIR(), setSLIRCLR(),
N */
N#define _SLRCR_              (_W6100_IO_BASE_ + (0x420C << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @brief SOCKET-less Hop Limit Register address [R=W][0x80]
N * @details @ref _SLHOPR_ sets the hop limit value of packet to be transmitted by @ref _SLCR_.
N * @sa _SLCR_
N * @sa getSLHOPR(), setSLHOPR(), getSLCR(), setSLCR()
N */
N#define _SLHOPR_             (_W6100_IO_BASE_ + (0x420F << 8) + WIZCHIP_CREG_BLOCK)
N
N/**
N * @}
N */
N
N//----------------------------- W6100 Socket Registers -----------------------------
N/**
N * @addtogroup Socket_register_group_W6100
N * @{
N */
N/**
N * @brief Socket Mode Register Address [R=W][0x00]
N * @details @ref _Sn_MR_ sets the option or protocol type of SOCKETn before @ref Sn_CR_OPEN is performed.\n\n
N *          Each bit of @ref _Sn_MR_ is defined as the following.
N * <table>
N *    <tr> <td>7       </td> <td>6        </td> <td>5            </td> <td>4        </td> <td>3 ~ 0 </td> </tr>
N *    <tr> <td>MULTI/MF</td> <td>BRDB/FPSH</td> <td>ND/MC/SMB/MMB</td> <td>UNIB/MMB6</td> <td>P[3:0]</td> </tr>
N * </table>
N *   - @ref Sn_MR_MULTI : Support UDP Multicasting
N *   - @ref Sn_MR_MF    : Support MAC Filter Enable
N *   - @ref Sn_MR_BRDB  : Broadcast Block
N *   - @ref Sn_MR_FPSH  : Force PSH flag
N *   - @ref Sn_MR_ND    : No Delay ACK flag
N *   - @ref Sn_MR_MC    : IGMP ver2, ver1
N *   - @ref Sn_MR_SMB   : Solicited Multicast Block
N *   - @ref Sn_MR_MMB   : IPv4 Multicast block
N *   - @ref Sn_MR_UNIB  : Unicast Block
N *   - @ref Sn_MR_MMB6  : IPv6 UDP Multicast Block
N *   - <b>P[3:0]</b>
N * <table>
N *    <tr> <td> P[3:0] </td> <td> Protocol Mode  </td> </tr>
N *    <tr> <td> 0000   </td> <td> SOCKET Closed  </td> </tr>
N *    <tr> <td> 0001   </td> <td> TCP4           </td> </tr>
N *    <tr> <td> 0010   </td> <td> UDP4           </td> </tr>
N *    <tr> <td> 0011   </td> <td> IPRAW4         </td> </tr>
N *    <tr> <td> 0100   </tr> <td> MACRAW         </td> </tr>
N *    <tr> <td> 1001   </td> <td> TCP6           </td> </tr>
N *    <tr> <td> 1010   </td> <td> UDP6           </td> </tr>
N *    <tr> <td> 1100   </td> <td> IPRAW6         </td> </tr>
N *    <tr> <td> 1101   </td> <td> TCP Dual(TCPD) </td> </tr>
N *    <tr> <td> 1110   </td> <td> UDP Dual (UDPD)</td> </tr>
N * </table>
N *   - @ref Sn_MR_CLOSE                      : SOCKET Closed
N *   - @ref Sn_MR_TCP4(= @ref Sn_MR_TCP)     : TCP4 mode
N *   - @ref Sn_MR_UDP4(= @ref Sn_MR_UDP)     : UDP4 mode
N *   - @ref Sn_MR_IPRAW4(= @ref Sn_MR_IPRAW) : IPRAW4 mode
N *   - @ref Sn_MR_MACRAW                     : MACRAW mode
N *   - @ref Sn_MR_TCP6                       : TCP6 mode
N *   - @ref Sn_MR_UDP6                       : UDP6 mode
N *   - @ref Sn_MR_IPRAW6                     : IPRAW6 mode
N *   - @ref Sn_MR_TCPD                       : TCP Dual (TCPD) mode
N *   - @ref Sn_MR_UDPD                       : UDP Dual (UDPD) mode
N *
N * @note MACRAW mode should be only used in Socket 0.
N * @sa _Sn_CR_, Sn_CR_OPEN, _Sn_SR_, _Sn_MR2_
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR(), getSn_MR2(), setSn_MR2()
N */
N#define _Sn_MR_(N)           (_W6100_IO_BASE_ + (0x0000 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKET n Prefer Source IPv6 Address Register Address [R=W][0x00]
N * @details @ref _Sn_PSR_ select the Source IPv6 Address to transmit a packet by @ref _Sn_CR_.
N * This function is same as @ref _SLPSR_.
N *   - @ref PSR_AUTO 
N *   - @ref PSR_LLA 
N *   - @ref PSR_GUA 
N * @sa _Sn_CR_, _Sn_PSR_, _SLPSR_
N * @sa getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSLPSR(), setSLPSR(), 
N */
N #define _Sn_PSR_(N)         (_W6100_IO_BASE_ + (0x0004 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief Socket Command Register Address [RW,AC][0x00]
N * @details @ref _Sn_CR_ is used to set the command for SOCKET n such as OPEN, CLOSE, CONNECT, LISTEN, SEND, and RECEIVE.\n
N *          It is automatically cleared to 0x00 after the command is recognized by @ref _WIZCHIP_.\n
N *          Even though @ref _Sn_CR_ is cleared to 0x00, the command is still being processed.\n
N *          To check whether the command is completed or not, please check the @ref _Sn_IR_ or @ref _Sn_SR_.
N *   - @ref Sn_CR_OPEN            : Initialize or open socket.
N *   - @ref Sn_CR_LISTEN       : Wait connection request on TCP4/TCP6/TCPD mode(<b>Server mode</b>)
N *   - @ref Sn_CR_CONNECT      : Send connection request on TCP4/TCPD mode(<b>Client mode</b>)
N *   - @ref Sn_CR_CONNECT6  : Send connection request on TCP6/TCPD mode(<b>Client mode</b>):nohl
N *   - @ref Sn_CR_DISCON       : Send closing request on TCP/TCP6/TCPD mode.
N *   - @ref Sn_CR_CLOSE        : Close socket.
N *   - @ref Sn_CR_SEND            : Update TX buffer pointer and send data in IPv4 socket.
N *   - @ref Sn_CR_SEND6        : Update TX buffer pointer and send data in IPv6 socket.
N *   - @ref Sn_CR_SEND_KEEP : Send keep alive message.
N *   - @ref Sn_CR_RECV            : Update RX buffer pointer and receive data.
N *
N * @note These commands should be exclusive executed.\n That is, the other command can not executed when one command is not cleared yet.
N * @sa _Sn_IR_, _Sn_IRCLR_, Sn_IMR_, _SIR_, _Sn_SR_
N * @sa getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), getSIR(), getSn_SR()
N */
N#define _Sn_CR_(N)           (_W6100_IO_BASE_ + (0x0010 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Interrupt Register Address [RO][0x00]
N * @details @ref _Sn_IR_ gets the status of SOCKETn interrupt such as establishment, termination, receiving data, timeout.\n
N *          If SOCKETn interrupt occurs and the n-th bit of @ref _SIMR_ is set, then @ref SIR_INT(n) is set.\n
N *          In order to clear the @ref _Sn_IR_ bit, Set the corresponding bit of _Sn_IRCLR_ to 1.\n
N *          If all @ref _Sn_IR_ bits are cleared, the @ref SIR_INT(n) is automatically cleared.
N * <table>
N *     <tr> <td>7 ~ 5   </td> <td>4     </td> <td>3      </td> <td>2   </td> <td>1     </td> <td>0  </td> </tr>
N *     <tr> <td>Reserved</td> <td>SENDOK</td> <td>TIMEOUT</td> <td>RECV</td> <td>DISCON</td> <td>CON</td> </tr>
N * </table>
N *   - @ref Sn_IR_SENDOK 
N *   - @ref Sn_IR_TIMEOUT 
N *   - @ref Sn_IR_RECV 
N *   - @ref Sn_IR_DISCON 
N *   - @ref Sn_IR_CON 
N *  
N * @sa _Sn_IRCLR_, _Sn_IMR_, _SIR_, _SIMR_
N * @sa getSn_IR(), setSn_IRCLR(), getSn_IMR(), setSn_IMR(), getSIR(), getSIMR(), setSIMR()
N */
N#define _Sn_IR_(N)           (_W6100_IO_BASE_ + (0x0020 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Interrupt Mask Register Address [R=W][0xFF]
N * @details @ref _Sn_IMR_ is used to mask interrupts of @ref _Sn_IR_.
N * @sa _Sn_IR_, _Sn_IRCR_, _SIR_, _SIMR_
N * @sa getSn_IMR(), setSn_IMR(), getSn_IR(), setSn_IRCLR(), getSIR(), getSIMR(), setSIMR()
N */
N#define _Sn_IMR_(N)          (_W6100_IO_BASE_ + (0x0024 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Interrupt Clear Register Address [WO][0x00]
N * @details @ref _Sn_IRCLR_ clears @ref _Sn_IR_
N * @sa _Sn_IR_, _SIR_, _SIMR_
N * @sa setSn_IRCLR(), getSn_IR(), getSIR(), getSIMR(), setSIMR()
N */
N#define _Sn_IRCLR_(N)        (_W6100_IO_BASE_ + (0x0028 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N
N
N/**
N * @brief SOCKETn Status Register Address [RO][0x00]
N * @details @ref _Sn_SR_ indicates the status of SOCKETn.\n
N *          The status of SOCKETn can be changed by @ref _Sn_CR_, some TCP packets such as SYN, FIN, RST packet, or @ref Sn_IR_TIMEOUT.
N *  - Normal status
N *    - @ref SOCK_CLOSED      : Closed
N *    - @ref SOCK_INIT        : Initiate state
N *    - @ref SOCK_LISTEN      : Listen state
N *    - @ref SOCK_ESTABLISHED : Success to connect
N *    - @ref SOCK_CLOSE_WAIT  : Closing state
N *    - @ref SOCK_UDP         : UDP socket
N *    - @ref SOCK_IPRAW       : IPRAW socket
N *    - @ref SOCK_IPRAW6      : IPv6 IPRAW socket
N *    - @ref SOCK_MACRAW      : MAC raw mode socket
N *  - Temporary status during changing the status of SOCKETn .
N *    - @ref SOCK_SYNSENT     : This indicates SOCKETn  sent the connect-request packet (SYN packet) to a peer.
N *    - @ref SOCK_SYNRECV     : It indicates SOCKETn  successfully received the connect-request packet (SYN packet) from a peer.
N *    - @ref SOCK_FIN_WAIT    : Connection state
N *    - @ref SOCK_TIME_WAIT   : Closing state
N *    - @ref SOCK_LAST_ACK    : Closing state
N *
N * @sa _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT 
N * @sa getSn_SR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR()
N * 
N *  <table width=0 >
N *     <tr> <td>@image html SocketStatus.png "<SOCKETn Status Transition>"</td> </tr>
N *  </table>
N *
N */
N#define _Sn_SR_(N)           (_W6100_IO_BASE_ + (0x0030 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Extension Status Register Address [RO][0x00]
N * @details @ref _Sn_ESR_ indicates the connected client IP address information such as IP version, IPv6 address type(LLA or GUA), \n
N *          and TCP operation mode such as <b>TCP SERVER</b> and <b>TCP CLIENT</b>
N * <table>
N *    <tr> <td> 7 ~ 3   </td> <td>2   </td> <td>1    </td> <td>0   </td> </tr> 
N *    <tr> <td> Reserved</td> <td>TCPM</td> <td>TCPOP</td> <td>IP6T</td> </tr> 
N * </table>
N * - @ref Sn_ESR_TCPM  : @ref Sn_ESR_TCPM_IPV4, @ref Sn_ESR_TCPM_IPV6
N * - @ref Sn_ESR_TCPOP : @ref Sn_ESR_TCPOP_SVR, @ref Sn_ESR_TCPOP_CLT
N * - @ref Sn_ESR_IP6T  : @ref Sn_ESR_IP6T_LLA,  @ref Sn_ESR_IP6T_GUA
N * 
N * @note It is valid only on TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_MR_, _Sn_PSR_
N * @sa getSn_ESR(), getSn_MR(), setSn_MR(), getSn_PSR(), setSn_PSR()
N */
N#define _Sn_ESR_(N)          (_W6100_IO_BASE_ + (0x0031 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn IP Protocol Number(PN) Register Address [R/W][0x0000]
N * @details \ref _Sn_PNR_ that sets the protocol number/next header field of the IPv4/IPv6 header at the IP layer.
N * @note It is valid only in IPRAW mode such as @ref Sn_MR_IPRAW4 and @ref Sn_MR_IPRAW6.
N * @note It is set before @ref Sn_CR_OPEN is performed.
N * @sa _Sn_NHR_, _Sn_MR_, Sn_CR_OPEN
N * @sa getSn_PNR(), setSn_PNR(), getSn_NHR(), setSn_NHR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
N */
N#define _Sn_PNR_(N)          (_W6100_IO_BASE_ + (0x0100 << 8) + WIZCHIP_SREG_BLOCK(N))
N#define _Sn_NHR_(N)          (_Sn_PNR_(N))      ///< Refer to @ref _Sn_PNR_.
N
N/**
N * @brief SOCKETn IPv4 Type of Service(TOS) Register Address [R=W][0x00]
N * @details @ref _Sn_TOSR_ sets the TOS(Type Of Service) field in IPv4 Header.
N * @sa getSn_TOSR(), setSn_TOSR()
N */
N#define _Sn_TOSR_(N)         (_W6100_IO_BASE_ + (0x0104 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn IP Time to live(TTL) Register Address [R=W][0x80]
N * @details @ref _Sn_TTLR_ sets the TTL(Time To Live)/HOP(Hop Limit) field in IPv4/IPv6 header at the IP layer.
N * @sa _Sn_HOPR_
N * @sa getSn_TTLR(), setSn_TTLR(), getSn_HOPR(), setSn_HOPR()
N */
N#define _Sn_TTLR_(N)         (_W6100_IO_BASE_ + (0x0108 << 8) + WIZCHIP_SREG_BLOCK(N))
N#define _Sn_HOPR_(N)         (_Sn_TTLR_(N))   ///< Refer to @ref _Sn_TTLR_.
N
N/**
N * @brief SOCKETn Fragment Register Address [R=W][0x4000]
N * @details @ref _Sn_FRGR_ sets the fragment flag & offset in IPv4 header.
N * @note @ref _WIZCHIP_ can not support IP fragment & re-assembly.\n So It is not recommended to set @ref _Sn_FRGR_ to any other value.
N * @sa getSn_FRGR(), setSn_FRGR()
N */
N#define _Sn_FRGR_(N)         (_W6100_IO_BASE_ + (0x010C << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Maximum Segment Size(MSS) Register Address [RW][0x0000]
N * @details @ref _Sn_MSSR_ sets or gets the MTU(Maximum Transfer Unit) of SOCKETn. \n
N *          The MTU of each protocol is as following.
N * <table>
N *    <tr> <td> @ref _Sn_MR_[3:0] </td> <td>@ref NETMR2_PPPoE = 0 </td> <td>@ref NETMR2_PPPoE = '1'</td> </tr>
N *    <tr> <td> @ref Sn_MR_TCP4   </td> <td> 1 ~ 1460             </td> <td> 1 ~ 1452              </td> </tr>
N *    <tr> <td> @ref Sn_MR_TCP6   </td> <td> 1 ~ 1440             </td> <td> 1 ~ 1432              </td> </tr>
N *    <tr> <td> @ref Sn_MR_UDP4   </td> <td> 1 ~ 1472             </td> <td> 1 ~ 1464              </td> </tr>
N *    <tr> <td> @ref Sn_MR_UDP6   </td> <td> 1 ~ 1452             </td> <td> 1 ~ 1444              </td> </tr>
N *    <tr> <td> @ref Sn_MR_IPRAW4 </td> <td> 1 ~ 1480             </td> <td> 1 ~ 1472              </td> </tr>
N *    <tr> <td> @ref Sn_MR_IPRAW6 </td> <td> 1 ~ 1460             </td> <td> 1 ~ 1452              </td> </tr>
N *    <tr> <td> @ref Sn_MR_MACRAW </td> <td colspan = "2">      1 ~ 1514                                              </td> </tr>
N * </table>
N *
N * @note It is not set exceeding the MTU for each protocol of SOCKETn even if _Sn_MSSR_ is set over the MTU.
N * @sa _Sn_MR_, NETMR2_PPPoE
N * @sa getSn_MSSR(), setSn_MSSR(), getSn_MR(), setSn_MR(), getNETMR2(), setNETMR2()
N */
N#define _Sn_MSSR_(N)         (_W6100_IO_BASE_ + (0x0110 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Source Port Register Address [R=W][0x0000]
N * @details @ref _Sn_PORTR_ sets the source port number of SOCKETn .
N * @note It is valid in TCP(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6, @ref Sn_MR_TCPD) and UDP(@ref Sn_MR_UDP4, @ref Sn_MR_UDP6, @ref Sn_MR_UDPD) mode.
N * @note It should be set before @ref Sn_CR_OPEN is performed.
N * @sa _Sn_MR_, Sn_CR_OPEN
N * @sa getSn_PORTR(), getSn_PORTR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
N*/
N#define _Sn_PORTR_(N)        (_W6100_IO_BASE_ + (0x0114 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Destination Hardware Address Register Address [RW][00:00:00:00:00:00]
N * @details @ref _Sn_DHAR_ sets or gets the destination hardware address of SOCKETn.\n
N *   - When @ref Sn_MR2_DHAM = 1 and @ref _Sn_MR_[3:0] != @ref Sn_MR_MACRAW
N *     The destination hardware address is set by @ref _Sn_DHAR_ without ARP processed by @ref Sn_CR_CONNECT, @ref Sn_CR_CONNECT6, @ref Sn_CR_SEND, and @ref Sn_CR_SEND6.\n
N *     Also, when SOCKETn is opened with @ref Sn_MR_UDP4 or @ref Sn_MR_UDP6 and @ref Sn_MR_MULTI is set, @ref _Sn_DHAR_ sets the Multicast Group Hardware address.
N *   - Others
N *     In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD, \n
N *     @ref _Sn_DHAR_ gets the destination hardware address when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
N * @sa _Sn_MR_, _Sn_MR2_, _Sn_CR_, _Sn_SR_
N * @sa getSn_DHAR(), setSn_DHAR(), getSn_MR(), setSn_MR(), getSn_MR2(), setSn_MR2(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define _Sn_DHAR_(N)         (_W6100_IO_BASE_ + (0x0118 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Destination IPv4 Address Register Address [RW][0.0.0.0]
N * @details @ref _Sn_DIPR_(= @ref _Sn_DIP4R_) sets or gets the destination IPv4 address of SOCKETn. \n
N *   - In TCP mode such as @ref Sn_MR_TCP4, and @ref Sn_MR_TCPD
N *      - <b>TCP CLIENT</b> mode : It sets the IPv4 address of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT is performed. 
N *      - <b>TCP SERVER</b> mode : It gets the IPv4 address of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
N *   - In UDP(@ref Sn_MR_UDP4, @ref Sn_MR_UDPD) mode & IPRAW4(@ref Sn_MR_IPRAW4) mode
N *     It sets the destination IPv4 address before @ref Sn_CR_SEND is performed. \n
N *     When Sn_MR_MULTI = 1, It sets the multicast group IPv4 address.
N * @sa _Sn_DIP4R_, _Sn_MR_, _Sn_CR_, _Sn_SR_ 
N * @sa getSn_DIPR(), getSn_DIPR(), getSn_DIP4R(), getSn_DIP4R(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define _Sn_DIPR_(N)         (_W6100_IO_BASE_ + (0x0120 << 8) + WIZCHIP_SREG_BLOCK(N))
N#define _Sn_DIP4R_(N)        (_Sn_DIPR_(N))            ///< Refer to @ref _Sn_DIPR_.
N
N/**
N * @brief SOCKETn Destination IPv6 Address Register Address [RW][::]
N * @details @ref _Sn_DIP6R_ sets or gets the destination IPv6 address of SOCKETn.
N *   - In TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
N *      - <b>TCP CLIENT</b> mode : It sets the IPv6 address of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT6 is performed. 
N *      - <b>TCP SERVER</b> mode : It gets the IPv6 address of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
N *   - In UDP(@ref Sn_MR_UDP6, @ref Sn_MR_UDPD) mode & IPRAW4(@ref Sn_MR_IPRAW6) mode
N *     It sets the destination IPv6 address before @ref Sn_CR_SEND6 is performed.\n
N *     When Sn_MR_MULTI = 1, It sets the multicast group IPv6 address.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
N * @sa getSn_DIP6R(), setSn_DIP6R(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define _Sn_DIP6R_(N)        (_W6100_IO_BASE_ + (0x0130 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Destination Port Register Address [RW][0x0000]
N * @details @ref _Sn_DPORTR_ sets or gets the destination port number of SOCKETn.
N *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
N *      - <b>TCP CLIENT</b> mode : It sets the port number of <b>TCP SERVER</b> before @ref Sn_CR_CONNECT is performed.
N *      - <b>TCP SERVER</b> mode : It gets the port number of <b>TCP CLIENT</b> when @ref _Sn_SR_ is @ref SOCK_ESTABLISHED.
N *   - In UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD
N *     It sets the destination port number before @ref Sn_CR_SEND is performed. \n
N *     When Sn_MR_MULTI = 1, It sets the multicast group group port number.
N *
N * @note It is valid SOCKETn is opened with @ref Sn_MR_TCP4,  @ref Sn_MR_TCP6, @ref Sn_MR_TCPD, @ref Sn_MR_UDP4, @ref Sn_MR_UDP4, and @ref Sn_MR_UDPD.
N * @note It should be set before OPEN command is ordered.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_ 
N * @sa getSn_DPORTR(), getSn_DPORTR(), getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define _Sn_DPORTR_(N)       (_W6100_IO_BASE_ + (0x0140 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Mode Register 2 Address [R=W][0x00]
N * @details @ref _Sn_MR2_ sets the option of SOCKETn with @ref _Sn_MR_, before @ref Sn_CR_OPEN is performed.\n
N *          Each bit of @ref _Sn_MR2_ is defined as the following.
N * <table>
N *    <tr> <td>7 ~ 2   </td> <td>1   </td> <td>0   </td> </tr>
N *    <tr> <td>Reserved</td> <td>DHAM</td> <td>FARP</td> </tr>
N * </table>
N *   - @ref Sn_MR2_DHAM : @ref Sn_MR2_DHAM_AUTO, @ref Sn_MR2_DHAM_MANUAL
N *   - @ref Sn_MR2_FARP
N * @sa _Sn_MR_, _Sn_CR_
N * @sa getSn_MR2(), setSn_MR2(), getSn_MR(), getSn_MR(), getSn_CR()
N */
N#define _Sn_MR2_(N)          (_W6100_IO_BASE_ + (0x0144 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N
N/**
N * @brief SOCKETn Retransmission Time Register Address [R=W][0x0000]
N * @details @ref _Sn_RTR_ sets the timeout value of packet to be retransmitted by @ref _SLCR_.\n
N * @note It should be set before @ref Sn_CR_OPEN is performed.\n
N *       It is initialized as @ref _RTR_ if you do not set it to none-zero value.
N * @sa _RTR_, _Sn_CR_
N * @sa getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
N */
N#define _Sn_RTR_(N)          (_W6100_IO_BASE_ + (0x0180 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Retransmission Count Register Address [R=W][0x00]
N * @details @ref _Sn_RCR_ sets the retry count value of packet to be retransmitted by @ref _SLCR_.\n
N * @note It should be set before @ref Sn_CR_OPEN is performed.\n
N *       It is initialized as @ref _RTR_ if you do not set it to any none-zero value.
N * @sa _RTR_, _Sn_CR_
N * @sa getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
N */
N#define _Sn_RCR_(N)          (_W6100_IO_BASE_ + (0x0184 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn Keep Alive Time Register Address [R=W][0x00]
N * @details @ref _Sn_KPALVTR_ sets the auto-retransmission time of KA(Keep Alive) packet. \n
N *          If the destination can not respond to the KA packet during the time set by @ref _Sn_KPALVTR_,\n
N *          the connection is terminated, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed @ref SOCK_CLOSED.\n
N *          Before the time is expierd, if the destination sends a KA/ACK packet or any packet, the connection is still valid,\n
N *          @ref _Sn_SR_ remained at @ref SOCK_ESTABLISHED.
N * @note It is valid only after sending data over 1 byte in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @note If it is set to 0, KA packet can be sent by @ref Sn_CR_SEND_KEEP.
N * @sa Sn_CR_SEND_KEEP, Sn_IR_TIMEOUT, Sn_IRCLR, Sn_SR, Sn_MR
N * @sa getSn_KPALVTR(), setSn_KPALVTR(), getSn_IR(), setSn_IRCLR(), getSn_SR(), getSn_MR(), setSn_MR()
N */
N#define _Sn_KPALVTR_(N)      (_W6100_IO_BASE_ + (0x0188 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn TX Buffer Size Register Address [R=W][0x02]
N * @details @ref _Sn_TX_BSR_ sets the TX buffer size of SOCKETn in the 16KB TX memory.\n
N *          It can be set only with 0,1,2,4,8, and 16K bytes.
N * @note The 16KB TX memory is allocated as many as @ref _Sn_TX_BSR_ sequentially from SOCKET0 to SOCKETn(Here, 0 <= n <= @ref _WIZCHIP_SOCK_NUM_ - 1).\n
N *       The total sum of Sn_TX_BSR can not be exceed 16KB of TX memory. \n
N *       If the total size is exceeded, SOCKETn can't be normally sent data to a destination.
N * @sa _Sn_RX_BSR_
N * @sa getSn_TX_BSR(), setSn_TX_BSR(), getSn_TXBUF_SIZE(), setSn_TXBUF_SIZE(), getSn_TxMAX(), setSn_TX_BSR(), getSn_RX_BSR(), setSn_RX_BSR()
N */
N#define _Sn_TX_BSR_(N)       (_W6100_IO_BASE_ + (0x0200 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn TX Free Buffer Size Register Address [RO][0x0800]
N * @details @ref _Sn_TX_FSR_ gets the transmittable free size of SOCKETn TX buffer.
N * @note Data should not be saved bigger than it because the data overwrites the previous saved data not to be sent yet.\n
N *       Therefore, Check it before saving the data to the SOCKETn TX buffer. \n
N *       If the data size is equal or smaller than it, transmit the data with @ref Sn_CR_SEND / @ref Sn_CR_SEND6 after saving the data in SOCKETn TX buffer.\n
N *       If the data size is greater than it, transmit the data after dividing into it and saving in the SOCKETn TX buffer.
N * @note \n
N *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD, \n
N *     It is automatically increased by the absolute difference between @ref _Sn_TX_WR_ and interanl TX ACK pointer.
N *   - In other mode \n
N *     It is automatically increased by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_.
N * @sa _Sn_RX_RSR_, _Sn_TX_WR_, _Sn_TX_RD_, _Sn_CR_
N * @sa getSn_TX_FSR(), getSn_TX_WR(), getSn_TX_WR(), getSn_TX_RD(), getSn_CR(), setSn_CR()
N */
N#define _Sn_TX_FSR_(N)       (_W6100_IO_BASE_ + (0x0204 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKET TX Memory Read Pointer Register Address[R][0x0000]
N * @details @ref _Sn_TX_RD_ gets the start pointer of data to be sent by @ref Sn_CR_SEND. \n
N *          @ref Sn_CR_SEND / @ref Sn_CR_SEND6 starts to transmit the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX Buffer,\n
N *          and when @ref Sn_IR_SENDOK is set, It is automatically increased to equal @ref _Sn_TX_WR_.
N * @note It is initialized by @ref Sn_CR_OPEN, But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
N *       it is re-initialized when the TCP connection is completed.
N * @note If it exceeds the maximum value 0xFFFF, (that is, it is greater than 0x10000 and the carry bit occurs),\n
N *       then the carry bit is ignored and it automatically is updated with its the lower 16bits value.
N * @sa _Sn_TX_WR_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
N * @sa getSn_TX_RD(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
N */
N#define _Sn_TX_RD_(N)        (_W6100_IO_BASE_ + (0x0208 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N
N/**
N * @brief SOCKETn TX Memory Write Pointer Register Address [RW][0x0000]
N * @details @ref _Sn_TX_WR_ gets the start pointer of data to be saved in the SOCKETn TX buffer, \n
N *          or sets the end pointer of data to be sent by @ref Sn_CR_SEND. \n
N *          If you have completed to save the data to be sent in the SOCKETn TX buffer,
N *          increase it as many as the saved size of data before @ref Sn_CR_SEND is performed.\n
N *          @ref Sn_CR_SEND starts to transmit the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX Buffer, \n
N *          and when @ref Sn_IR_SENDOK is set, @ref _Sn_TX_RD_ is automatically increased to equal it.
N * @note It is initialized by @ref Sn_CR_OPEN.\n
N *       But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
N *       it is re-initialized when the TCP connection is completed.
N * @note The size of data to be saved can't exceed @ref _Sn_TX_FSR_.
N * @note If it exceeds the maximum value 0xFFFF(that is, it is greater than 0x10000 and the carry bit occurs),\n
N *       then ignore the carry bit and update it with its lower 16bits value.
N * @sa _Sn_TX_RD_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
N * @sa getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
N */
N#define _Sn_TX_WR_(N)        (_W6100_IO_BASE_ + (0x020C << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn RX Buffer Size Register Address [R=W][0x02]
N * @details @ref _Sn_RX_BSR_ sets the RX buffer size of SOCKETn in the 16KB RX memory.\n
N *          It can be set only with 0,1,2,4,8, and 16K bytes.
N * @note The 16KB RX memory is allocated as many as @ref _Sn_RX_BSR_ sequentially from SOCKET0 to SOCKETn(Here, 0 <= n <= @ref _WIZCHIP_SOCK_NUM_ - 1).\n
N *       The total sum of @ref _Sn_RX_BSR_ can not be exceed 16KB of RX memory. \n
N *       If the total size is exceeded, SOCKETn can't be normally received data from a destination.
N * @sa _Sn_RX_BSR_
N * @sa getSn_TX_BSR(), setSn_TX_BSR(), getSn_RXBUF_SIZE(), setSn_RXBUF_SIZE(), getSn_RxMAX(), getSn_RX_BSR(), setSn_RX_BSR()
N */
N#define _Sn_RX_BSR_(N)       (_W6100_IO_BASE_ + (0x0220 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn RX Received Size Register Address [RO][0x0000]
N * @details @ref _Sn_RX_RSR_ gets the received data size of SOCKETn RX buffer.
N * @note The real received data size maybe smaller than it, \n
N *       because it maybe included the size of 'PACKET NFO' such like as \n
N *       the destination IP address, destination port number and data size of the received DATA PACKET.
N * @note Do not read bigger data than @ref _Sn_RX_RSR_.
N * @note It is automatically increased by the absolute difference between @ref _Sn_RX_WR_ and @ref _Sn_RX_RD_ \n
N *       after @ref Sn_CR_RECV is performed.
N * @sa _Sn_RX_RSR_, _Sn_TX_WR_, _Sn_TX_RD_, _Sn_CR_, _Sn_TX_FSR_
N * @sa getSn_RX_RSR(), getSn_TX_WR(), getSn_TX_WR(), getSn_CR(), setSn_CR(), getSn_TX_FSR()
N */
N#define _Sn_RX_RSR_(N)       (_W6100_IO_BASE_ + (0x0224 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKET RX Memory Read Pointer Register Address[R][0x0000]
N * @details @ref _Sn_RX_RD_ gets the start pointer of the received data in the SOCKETn RX buffer,\n
N *          or sets the end data pointer of the read completed data by @ref Sn_CR_RECV. \n
N *          You can read the received data from it to @ref _Sn_RX_WR_ in the SOCKET RX buffer.\n
N *          After completing to read data, you should increase it as many as the read size before @ref Sn_CR_RECV is performed.
N * @note It is initialized by @ref Sn_CR_OPEN, But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
N *       it is re-initialized when the TCP connection is completed.
N * @note If it exceeds the maximum value 0xFFFF, (that is, it is greater than 0x10000 and the carry bit occurs),\n
N *       Ignore the carry bit and update with its the lower 16bits value.
N * @sa _Sn_RX_WR_, _Sn_RX_RSR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
N * @sa getSn_RX_WR(), setSn_RX_RD(), getSn_RX_WR(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
N */
N#define _Sn_RX_RD_(N)        (_W6100_IO_BASE_ + (0x0228 << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @brief SOCKETn TX Memory Write Pointer Register Address [RW][0x0000]
N * @details @ref _Sn_TX_WR_ gets the end pointer of the data that has been completely received in the SOCKETn RX buffer. \n
N *          Whenever a data has been completely received from a destination, \n
N *          It is automatically increased as many as the sum size of the received data and the 'PACKET INFO'. \n
N *          You can read the recevied data from @ref _Sn_RX_RD_ to it in the SOCKET RX buffer.
N * @note It is initialized by @ref Sn_CR_OPEN. But, In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD,\n
N *       it is re-initialized when the TCP connection is completed.
N * @note If it exceeds the maximum value 0xFFFF(that is, it is greater than 0x10000 and the carry bit occurs),\n
N *       then ignore the carry bit and update it with its lower 16bits value.
N * @sa _Sn_TX_RD_, _Sn_TX_FSR_, _Sn_CR_, _Sn_IR_, Sn_IRCLR_, _Sn_MR_
N * @sa getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD(), getSn_TX_FSR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR(), getSn_MR(), setSn_MR()
N */
N#define _Sn_RX_WR_(N)        (_W6100_IO_BASE_ + (0x022C << 8) + WIZCHIP_SREG_BLOCK(N))
N
N/**
N * @}
N */
N
N/*----------------------------- W6100 Register values  -----------------------------*/
N
N/* System Status Register Bit Definition */
N/**
N * @brief CHIP Lock staus bit of @ref _SYSR_.
N * @details @ref SYSR_CHPL indicates the lock status of @ref _SYCR0_ and @ref _SYCR1_.\n
N *          1 : Lock \n
N *          0 : unlock 
N * @note It is set by only @ref _CHPLCKR_.
N * @sa _SYSR_, _CHPLCKR_, _SYCR0_, _SYCR1_
N * @sa getSYSR(), getCHPLCKR(), setCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), setSYCR0(), setSYCR1()
N */
N#define SYSR_CHPL            (1 << 7)
N
N/**
N * @brief NET Lock status bit of @ref _SYSR_.
N * @details @ref SYSR_NETL indicates the lock of network information registers such as 
N *          @ref _SHAR_, @ref _GAR_, @ref _SUBR_, @ref _SIPR_, @ref _LLAR_, @ref _GUAR_, and @ref _SUB6R_. \n
N *          1 : Lock \n
N *          0 : unlock 
N * @note It is set by only @ref _NETLCKR_.
N * @note @ref _GA6R_ can be accessed regardless of @ref SYSR_NETL.
N * @sa _SYSR_, _NETLCKR_, _SHAR_, _GAR_, _SUBR_, _SIPR_, _LLAR_, _GUAR_, _SUB6R_
N * @sa getSYSR(), getNETLCKR(), setNETLCKR(), NETLOCK(), NETUNLOCK(),\n
N *     getSHAR(), setSHAR(), getGAR(), setGAR(), getSUBR(), getSIR(), setSIPR(), \n
N *     getLLAR(), setLLAR(), getGUAR(),setGUAR(), getSUB6R(), setSUB6R()
N */
N#define SYSR_NETL            (1 << 6)
N
N/**
N * @brief PHY Lock status bit of @ref _SYSR_. Refer to @ref _PHYLCKR_.
N * @details @ref SYSR_PHYL indicates the lock status of @ref _PHYCR0_ and _PHYCR1_.\n
N *          1 : Lock \n
N *          0 : unlock
N * @note It is set by only @ref _PHYLCKR_.
N * @sa _SYSR_, _PHYCLKR_, _PHYCR0_, _PHYCR1_
N * @sa getSYSR(), getPHYLCKR(), setPHYLCKR(), setPHYCR0(), getPHYCR1(), setPHYCR1()
N */
N#define SYSR_PHYL            (1 << 5)
N
N/**
N * @brief Parallel Bus Mode bit of @ref _SYSR_
N * @details @ref SYSR_IND is set when @ref _WIZCHIP_ PIN MODE[3:0] == "010X".
N *          It indicates to use the parallel BUS mode. 
N * @sa _SYSR_, _WIZCHIP_IO_MODE_BUS_
N * @sa getSYSR()
N */
N#define SYSR_IND             (1 << 5)
N
N/**
N * @brief SPI I/F Mode bit of @ref _SYSR_.
N * @details @ref SYSR_SPI is set when @ref _WIZCHIP_ PIN MODE[3:0] == "000X".
N *          It indicates to use the SPI mode.
N * @sa _SYSR_, _WIZCHIP_IO_MODE_SPI_
N * @sa getSYSR()
N */
N#define SYSR_SPI             (1 << 0)
N
N
N/* System Config Register Bit Definition */
N/**
N * @brief RST bit of @ref _SYCR0_
N * @details @ref SYCR0_RST resets to @ref _WIZCHIP_ softly. \n
N *          0 : Soft reset \n
N *          1 : Normal operation
N * @note It can be set only when @ref SYSR_CHPL = 1.
N * @sa _SYSR0_, _CHPLCKR_, _SYSR_, SYSR_CHPL
N * @sa setSYCR0(), setCHPLCKR(), getCHPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getSYSR()
N */
N#define SYCR0_RST            (0x00)
N
N/**
N * @brief IEN bit of @ref _SYCR1_.
N * @details @ref SYCR1_IEN is globally enable or disable the interrupt of @ref _WIZCHIP_,\n
N *          regardless of the related interrupt mask registers such as @ref _IMR_, @ref _SIMR_, @ref _SLIMR_, and @ref _Sn_IMR_.\n
N *          1 : Enable  \n
N *          0 : Disable
N * @sa _SYCR1_, _IR_, _SIR_, _SLIR_, _Sn_IR_, _IRCLR_,  _SLIRCLR_, _Sn_IRCLR_
N * @sa getSYCR1(), setSYCR1(), getIR(), getSIR(), getSLIR(), getSn_IR(), setIRCLR(), setSLIRCLR(), setSn_IRCLR()
N */
N#define SYCR1_IEN            (1 << 7)
N
N/**
N * @brief System Clock select mask bit of @ref _SYCR1_.
N * @details @ref SYCR1_CLKSEL selects a system clock to 100MHz or 25MHz. \n
N *          The masked bit values are as following.
N *            - @ref SYCR1_CLKSEL_25M
N *            - @ref SYCR1_CLKSEL_100M
N * @note It can be set only when @ref SYSR_CHPL = 1.
N * @note The system clock is automatically changed to 25MHz while the reset of @ref _WIZCHIP_ H/W reset, the Ethernet PHY H/W reset and power down. \n
N *       On the other hand, the system clock is set by @ref SYCR1_CLKSEL during normal operating.
N * @sa _SYCR1_, _SYSR_, _CHPLCKR_, SYSL_CHPL, PHYCR1_RST, PHYCR1_PWDN
N * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK(), getPHYCR1(), setPHYCR1()
N */
N#define SYCR1_CLKSEL         (1 << 0)
N
N/**
N * @brief System Clock - 25MHz
N * @details @ref SYCR1_CLKSEL_25M selects a system clock to 25MHz.
N * @note It can be set only when @ref SYSR_CHPL = 1.
N * @sa _SYCR1_, SYCR1_CLKSEL, SYCR1_CLKSEL_100M
N * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK()
N */
N#define SYCR1_CLKSEL_25M     1
N
N/**
N * @brief System Clock - 100MHz
N * @details @ref SYCR1_CLKSEL_100M selects a system clock to 100MHz.
N * @note It can be set only when @ref SYSR_CHPL = 1.
N * @sa _SYCR1_, SYCR1_CLKSEL, SYCR1_CLKSEL_25M
N * @sa getSYCR1(), setSYCR1(), getSYSR(), getCHPLCKR(), setCHIPLCKR(), CHIPLOCK(), CHIPUNLOCK()
N */
N#define SYCR1_CLKSEL_100M    0
N
N
N/* Interrupt Register Bit Definition */
N/**
N * @brief WOL bit of @ref _IR_
N * @details @ref IR_WOL is set when @ref _WIZCHIP_ receives a magic packet of WOL.
N * @sa _IR_, _IRCLR_, _IMR_ 
N * @sa getIR(), setIRCLR(), getIMR(), setIMR()
N */
N#define IR_WOL               (1<<7) 
N
N/**
N * @brief UNR6 bit of @ref _IR_
N * @details @ref IR_UNR6 is set when @ref _WIZCHIP_ receives the unreachable message of ICMPv6.
N * @sa _IR_, _IRCLR_, _IMR_
N * @sa getIR(), setIRCLR(), getIMR(), setIMR()
N */
N#define IR_UNR6              (1<<4)
N
N/**
N * @brief IPCONF bit of @ref _IR_
N * @details @ref IR_IPCONF is set when @ref _WIZCHIP_ receives a ARP reply with the same IPv4 address as @ref _SIPR_.
N * @sa _IR_, _IRCLR_, _IMR_
N * @sa getIR(), setIRCLR(), getIMR(), setIMR()
N */
N#define IR_IPCONF            (1<<2)
N
N/**
N * @brief UNR4 bit of @ref _IR_
N * @details @ref IR_UNR4 is set when @ref _WIZCHIP_ receives the unreachable message of ICMPv4.
N * @sa _IR_, _IRCLR_, _IMR_
N * @sa getIR(), setIRCLR(), getIMR(), setIMR()
N */
N#define IR_UNR4              (1<<1)
N
N/**
N * @brief PTERM bit of @ref _IR_
N * @details @ref IR_PTERM is set when @ref _WIZCHIP_ receives the PPP termination packet
N * @sa _IR_, _IRCLR_, _IMR_
N * @sa getIR(), setIRCLR(), getIMR(), setIMR()
N */
N#define IR_PTERM             (1<<0) 
N
N
N/* SOCKET Interrupt Register Bit Definition */
N/**
N * @brief N-th INT bit of @@ref _SIR_
N * @details @ref SIR_INT(N) is set when @ref _Sn_IR_(N) is not equal to zero.
N * @sa _SIR_, _Sn_IRCLR_, _SIMR_
N * @sa getSIR(), setSn_IRCLR(), getSIMR()
N */
N#define SIR_INT(N)           (1<<N)
N
N
N/* SOCKET-less Interrupt Register Bit Definition */
N/**
N * @brief TOUT bit of @ref _SLIR_
N * @details @ref SLIR_TOUT is set when the timeout is occurred after @ref _SLCR_ is performed.
N * @sa _SLIR_, _SLIRCLR_, _SLCR_
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR()
N */
N#define SLIR_TOUT            (1<<7)
N
N/**
N * @brief ARP4 bit of @ref _SLIR_
N * @details @ref SLIR_ARP4 is set when the ARP-relay is received successfully after @ref SLCR_ARP4 is performed \n
N *          and the destination hardware address can be checked by @ref _SLDHAR_. \n
N *          Otherwise, @ref SLIR_TOUT is set.
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, SLIR_TOUT
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR() 
N */
N#define SLIR_ARP4            (1<<6)
N
N/**
N * @brief PING4 bit of @ref _SLIR_
N * @details @ref SLIR_PING4 is set when the PING-relay is received successfully after @ref SLCR_PING4 is performed \n
N *          and the destination hardware address can be checked by @ref _SLDHAR_ like as @ref SLIR_ARP4.\n
N *          Otherwise, @ref SLIR_TOUT is set. 
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, SLIR_TOUT
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR() 
N */
N#define SLIR_PING4           (1<<5)
N
N/**
N * @brief ARP6 bit of @ref _SLIR_
N * @details @ref SLIR_ARP6 is set when the ARP6-relay is received successfully after @ref SLCR_ARP6 is performed \n
N *          and the destination hardware address can be checked by @ref _SLDHAR_. \n
N *          Otherwise, @ref SLIR_TOUT is set.
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, _SLDHAR_, SLIR_TOUT
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR() 
N */
N#define SLIR_ARP6            (1<<4)
N
N/**
N * @brief PING6 bit of @ref _SLIR_
N * @details @ref SLIR_PING6 is set when the PING-relay is received successfully after @ref SLCR_PING6 is performed \n
N *          and the destination hardware address can be checked by @ref _SLDHAR_ like as @ref SLIR_ARP6. \n
N *          Otherwise, @ref SLIR_TOUT is set.
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, _SLDHAR_, SLIR_TOUT
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR() 
N */
N#define SLIR_PING6           (1<<3)
N
N/**
N * @brief NS bit of @ref _SLIR_
N * @details @ref SLIR_NS is set when the ICMPv6 NA is received after @ref SLCR_NS is performed. \n
N *          Its set means IPv6 address such like as @ref _LLAR_ or @ref _GUAR_ is conflict. \n
N *          If @ref SLIR_TOUT is set, You can use @ref _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_.
N * @note It is used for IPv6 state-less address auto-configuration(SLAAC).
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, _SLDIP6R_, SLIR_TOUT, _LLAR_, _GUAR_
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getLLAR(), setLLAR(), getGAUR(), setGUAR()
N */
N#define SLIR_NS              (1<<2) 
N
N/**
N * @brief RS bit of @ref _SLIR_
N * @details @ref SLIR_RS is set when the ICMPv6 RA is received successfully after @ref SLCR_RS is performed \n
N *          and the prefix length, the prefix flag, the valid life time, the preferred life time and the prefix address of RA option message \n
N *          can be checked by @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_, respectively.\n
N *          Otherwise, @ref SLIR_TOUT is set.
N * @bug Only when the first received RA option is the source link-layer address(0x01) and the second is prefix information(0x03),\n
N *      and the prefix information is in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address,\n
N *      @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_ is correctly set.\n
N *      Other case, these registers are not valid.\n\n
N *      To solve this errata,\n
N *      You should use a IPRAW6 mode SOCKETn opened with Sn_MR_IPRAW6 and set the @ref _Sn_PNR_ to ICMPv6 number 58.\n
N *      This SOCKETn can be received a RA message or other ICMPv6 message, and a ICMPv6 message can be selectively filtered out by @ref _ICMP6BLKR_.\n
N *      For more details, Refer to "IPv6 Auto-configuration" document.
N *
N * @sa _SLIR_, _SLIRCLR_, _SLCR_, SLIR_TOUT
N * @sa getSLIR(), setSLIRCLR(), getSLCR(), setSLCR()
N */
N#define SLIR_RS              (1<<1)
N
N/**
N * @brief ICMPv6 RA Received Interrupt
N * @details @ref SLIR_RA is set when a RA is received from a router without @ref SLCR_RS.\n
N *          Like as @ref SLIR_RS, a RA option message can be checked by @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_.\n
N * @bug Only when RA options are received in the order of prefix length, prefix flag, valid lifetime, default lifetime and prefix address,\n
N *      @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_ and @ref _PAR_ is correctly set. \n
N *      Other case, these registers are not valid.\n\n
N *      To solve this errata, You should use a IPRAW6 mode SOCKETn opened with @ref Sn_MR_IPRAW6 and set the @ref _Sn_PNR_ to ICMPv6 number 58.\n
N *      This SOCKETn can be received a RA message or other ICMPv6 message, and a ICMPv6 message can be selectively filtered out by @ref _ICMP6BLKR_.\n
N *      For more details, Refer to "IPv6 Auto-configuration" document.
N *
N * @sa _SLIR_, _SLIRCLR_ 
N * @sa getSLIR(), setSLIRCLR(), 
N  */
N#define SLIR_RA              (1<<0)
N
N
N/* SOCKET-less & SOCKETn  Prefer Source IPv6 Address Register Bit Definition */
N/**
N * @brief Select the source IPv6 address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to AUTO
N * @details The source IPv6 address depends on IPv6 address type of @ref _SLDIP6R_ or @ref _Sn_DIP6R_.\n
N *          If @ref _Sn_DIP6R_ is a link-local, the source IPv6 address is selected to @ref _LLAR_.\n
N *          Otherwise, the source IPv6 address is selected to @ref _GUAR_.
N * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDI6PR_, _Sn_DIP6R_, _LLAR_, _GUAR_
N * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
N *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
N */
N#define PSR_AUTO             (0x00)
N
N/**
N * @brief Select the source IP address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to @ref _LLAR_
N * @details Regardless of the destination IPv6 address type of @ref _SLDIP6R_ or @ref _Sn_DIP6R_, the source IP is selected to @ref _LLAR_.
N * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDIP6R_, _Sn_DIP6R_, _LLAR_, _GUAR_
N * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
N *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
N */
N#define PSR_LLA              (0x02)
N
N/**
N * @brief Select the source IP address of the packet sent by @ref _SLCR_ or @ref _Sn_CR_ to @ref _GUAR_
N * @details Regardless of the destination IPv6 address type of @ref _SLDIP6R_, or @ref _Sn_DIP6R_, the source IP is selected to @ref _GUAR_.
N * @sa _SLPSR_, _Sn_PSR_, _SLCR_, _Sn_CR_, _SLDIP6R_, _Sn_DIP6R_, _LLAR_, _GUAR_
N * @sa getSLPSR(), setSLPSR(), getSn_PSR(), setSn_PSR(), getSLCR(), setSLCR(), getSn_CR(), setSn_CR(), \n
N *     getSLDIP6R(), setSLDIP6R(), getSn_DIP6R(), setSn_DIP6R(), getLLAR(), setLLAR(), getGUAR(), setGUAR()
N */
N#define PSR_GUA              (0x03)
N
N
N/* SOCKET-less Command Register Bit Definition */
N/**
N * @brief IPv4 ARP Command
N * @details It sends a IPv4 ARP request message to @ref _SLDIP4R_ without SOCKETn. \n
N *          The results can be ether @ref SLIR_TOUT or @ref SLIR_ARP4.\n
N *          If the result is @ref SLIR_ARP4, It is success to receive the reply from @ref _SLDIP4R_. \n
N *          You can check the destination hardware address thru @ref _SLDHAR_. \n
N *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP4R_ \n
N *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
N * @sa _SLCR_, _SLDIPR_, _SLDIP4R_ _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
N * @sa getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
N */
N#define SLCR_ARP4            (1<<6)
N
N/**
N * @brief IPv4 PING Command
N * @details It sends a IPv4 PING request message to @ref _SLDIP4R_ without SOCKETn.\n
N *          The results can be ether @ref SLIR_TOUT or @ref SLIR_PING4.\n
N *          If the result is @ref SLIR_PING4, It is success to receive the reply from @ref _SLDIP4R_. \n
N *          Also such like as @ref SLCR_ARP4, You can check the destination hardware address thru @ref _SLDHAR_.\n
N *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP4R_ \n
N *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
N * @sa _SLCR_, _SLDIPR_, _SLDIP4R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
N * @sa getSLCR(), setSLCR(), getSLDIPR(), setSLDIPR(), getSLDIP4R(), setSLDIP4R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
N */
N#define SLCR_PING4           (1<<5)
N
N/**
N * @brief IPv6 ARP Command
N * @details It sends a IPv6 ARP request message to @ref _SLDIP6R_ without SOCKETn. \n
N *          The results can be either @ref SLIR_TOUT or @ref SLIR_ARP6.
N *          If the result is @ref SLIR_ARP6, It is success to receive the reply from @ref _SLDIP6R_. \n
N *          You can check the destination hardware address thru @ref _SLDHAR_.\n
N *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP6R_
N *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
N * @sa _SLCR_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
N * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
N */
N#define SLCR_ARP6            (1<<4)
N
N/**
N * @brief IPv6 PING Command
N * @details It sends a IPv6 PING request message to @ref _SLDIP6R_ without SOCKET. \n
N *          The results can be either @ref SLIR_TOUT or @ref SLIR_PING6.\n
N *          If the result is @ref SLIR_PING6, It is success to receive the reply from @ref _SLDIP6R_.\n
N *          Also such like as @ref SLCR_ARP6, You can check the destination hardware address thru @ref _SLDHAR_.\n
N *          @ref SLIR_TOUT is set when it is no reply from @ref _SLDIP6R_ \n
N *          while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
N * @sa _SLCR_, _SLDIP6R_, _SLDHAR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_
N * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLDHAR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR()
N */
N#define SLCR_PING6           (1<<3)
N
N/**
N * @brief IPv6 DAD(Duplicate Address Detection) NS Command
N * @details It sends NS message for DAD to @ref _SLDIP6R_ that is set the address to be used as as @ref _LLAR_ or @ref _GUAR_, without SOCKET.\n
N *          The result can be ether @ref SLIR_TOUT and @ref SLIR_NS.\n
N *          If @ref SLIR_TOUT is set then you can use @ref _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_,\n
N *          else if @ref SLIR_NS is set then you can not use _SLDIP6R_ to @ref _LLAR_ or @ref _GUAR_.\n
N *          That means the IPv6 Address are Conflict.
N * @sa _SLCR_, _SLDIP6R_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_, _LLAR_, _GUAR_
N * @sa getSLCR(), setSLCR(), getSLDIP6R(), setSLDIP6R(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR(), \n
N *        getLLAR(), setLLAR(), getGUAR(), setGUAR()
N */
N#define SLCR_NS              (1<<2) 
N
N/**
N * @brief IPv6 Auto-configuration RS Command
N * @details It sends RS message to All-router for IPv6 Auto-configuration without SOCKET.\n
N *         The result can be ether @ref SLIR_RS or @ref SLIR_TOUT. \n
N *         If the result is @ref SLIR_RS, You can some information of router such as a prefix length, a Prefix flag, a valid life time, \n
N *         a preferred life time, and a prefix address respectively thru @ref _PLR_, @ref _PFR_, @ref _VLTR_, @ref _PLTR_, and @ref _PAR_.\n
N *         @ref SLIR_TOUT is set when it is no reply from a IPv6 router \n
N *         while both the time set by @ref _SLRTR_ and the retry count set by @ref _SLRCR_ are expired.
N * @sa _SLCR_, _SLIR_, _SLIRCLR_, _SLRTR_, _SLRCR_, _PLR_, _PFR_, _VLTR_, _PLTR_, _PAR_.
N * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCR(), getSLRTR(), setSLRTR(), getSLRCR(), setSLRTR(), \n
N *        getPLR(), getPFR(), getVLTR(), getPLTR(), getPAR().
N */
N#define SLCR_RS              (1<<1)
N
N/**
N * @brief IPv6 Unsolicited NA Command
N * @details It sends the IPv6 unsolicited NA message for updating the network information such as @ref _LLAR_, @ref _GUAR_, and @ref _SHAR_.\n
N *          The result is none.\n
N *          When @ref _SLPSR_ = @ref PSR_GUA, It can send the GUA unsolicited NA message.\n
N *          When @ref _SLPSR_ = Others, It can send the LLA unsolicited NA message.
N * @sa _SLCR_, _SLIR_, _SLIRCLR_, _SLPSR_
N * @sa getSLCR(), setSLCR(), getSLIR(), setSLIRCR(), getSLPFR(), setSLPFR()
N */
N#define SLCR_UNA             (1<<0)
N
N
N
N/* PHY Status Register Bit Definition */
N/**
N * @brief CAB mask bit
N * @details @ref PHYSR_CAB masks the CAB bit of @ref _PHYSR_.\n
N *          The masked bit values are as following. \n
N * - @ref PHYSR_CAB_OFF
N * - @ref PHYSR_CAB_ON
N * @sa getPHYSR()
N */
N#define PHYSR_CAB            (1<<7)
N
N/* PHY Status Register Bit Definition */
N/**
N * @brief Ethernet Cable Off
N * @details @ref PHYSR_CAB_OFF indicates the cable is off the Ethernet PHY.
N * @sa _PHYSR_, PHYSR_CAB, PHYSR_CAB_ON
N * @sa getPHYSR()
N */
N#define PHYSR_CAB_OFF        (1<<7)
N
N/**
N * @brief Ethernet PHY Cable On
N * @details @ref PHYSR_CAB_OFF indicates the cable is on the Ethernet PHY.
N * @sa _PHYSR_, PHYSR_CAB, PHYSR_CAB_OFF
N * @sa getPHYSR()
N */
N#define PHYSR_CAB_ON         (0<<7)
N
N/**
N * @brief Mask bits of @ref _PHYSR_
N * @details @ref PHYSR_MODE masks the MODE bits of @ref _PHYSR_.\n
N *          The masked bits values are as following. \n
N *            - @ref PHYSR_MODE_AUTO
N *            - @ref PHYSR_MODE_100F
N *            - @ref PHYSR_MODE_100H
N *            - @ref PHYSR_MODE_10F
N *            - @ref PHYSR_MODE_10H
N * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
N * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
N */
N#define PHYSR_MODE           (7<<3)
N
N/**
N * @brief PHY Mode - AUTO
N * @details @ref PHYSR_MODE_AUTO indicates the Ethernet PHY is operated as auto-negotiation mode.
N * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10F, PHYSR_MODE_10H
N * @sa getPHYSR()
N */
N#define PHYSR_MODE_AUTO      (0<<3)
N
N/**
N * @brief PHY Mode - 100F
N * @details @ref PHYSR_MODE_100F indicates the Ethernet PHY is operated as 100M full-duplex mode.
N * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100H, PHYSR_MODE_10F, PHYSR_MODE_10H
N * @sa getPHYSR()
N */
N#define PHYSR_MODE_100F      (4<<3)
N
N/**
N * @brief PHY Mode - 100H
N * @details @ref PHYSR_MODE_100H indicates the Ethernet PHY is operated as 100M half-duplex mode.
N * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_10F, PHYSR_MODE_10H
N * @sa getPHYSR()
N */
N#define PHYSR_MODE_100H      (5<<3)
N
N/**
N * @brief PHY Mode - 10F
N * @details @ref PHYSR_MODE_10F indicates the Ethernet PHY is operated as 10M full-duplex mode.
N * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10H
N * @sa getPHYSR()
N */
N#define PHYSR_MODE_10F       (6<<3)
N
N/**
N * @brief PHY Mode - 10H
N * @details @ref PHYSR_MODE_10H indicates the Ethernet PHY is operated as 10M half-duplex mode.
N * @sa _PHYSR_, PHYSR_MODE, PHYSR_MODE_AUTO, PHYSR_MODE_100F, PHYSR_MODE_100H, PHYSR_MODE_10F
N * @sa getPHYSR() 
N */
N#define PHYSR_MODE_10H       (7<<3)
N
N/**
N * @brief DPX mask bit of @ref _PHYSR_
N * @details @ref PHYSR_DPX masks the DPX bit of @ref _PHYSR_. \n
N *          The masked bit values are as following. \n
N *            - @ref PHYSR_DPX_HALF
N *            - @ref PHYSR_DPX_FULL
N * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
N * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
N */
N#define PHYSR_DPX            (1<<2)
N
N/**
N * @brief PHY Duplex - HALF
N * @details @ref PHYSR_DPX_HALF indicates the Ethernet PHY is operated as half-duplex mode.
N * @sa _PHYSR_, PHYSR_DPX_FULL
N * @sa getPHYSR()
N */
N#define PHYSR_DPX_HALF       (1<<2)
N
N/**
N * @brief PHY Duplex - FULL
N * @details @ref PHYSR_DPX_FULL indicates the Ethernet PHY is operated as full-duplex mode.
N * @sa _PHYSR_, PHYSR_DPX_HALF
N * @sa getPHYSR()
N */
N#define PHYSR_DPX_FULL       (0<<2)
N
N/**
N * @brief SPD mask bit of @ref _PHYSR_
N * @details @ref PHYSR_SPD masks the SPD bit of @ref _PHYSR_. The masked bit values are as following. \n
N *   - @ref PHYSR_SPD_10M
N *   - @ref PHYSR_SPD_100M
N * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
N * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
N */
N#define PHYSR_SPD            (1<<1)
N
N /**
N * @brief PHY Speed - 10M
N * @details @ref PHYSR_SPD_10M indicates the Ethernet PHY is operated as 10Mbps speed.
N * @sa _PHYSR_, PHYSR_SPD_100M
N * @sa getPHYSR()
N */
N#define PHYSR_SPD_10M        (1<<1)
N
N /**
N * @brief PHY Speed - 100M
N * @details @ref PHYSR_SPD_100M indicates the Ethernet PHY is operated as 100Mbps speed.
N * @sa _PHYSR_, PHYSR_SPD_10M
N * @sa getPHYSR()
N */
N#define PHYSR_SPD_100M       (0<<1)
N
N/**
N * @brief LNK mask bit of @ref _PHYSR_
N * @details @ref PHYSR_LNK masks the LNK bit of @ref _PHYSR_. The masked bit values are as following. \n
N *   - @ref PHYSR_LNK_DOWN
N *   - @ref PHYSR_LNK_UP
N * @sa _PHYSR_, _PHYCR0_, _PHYCLKR_, _SYSR_, SYSR_NETL
N * @sa getPHYSR(), setPHYCR0(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR() 
N */
N#define PHYSR_LNK            (1<<0)
N
N/**
N * @brief PHY Link - Up
N * @details @ref PHYSR_LNK_UP indicates the link of Ethernet PHY is successfully established .\n
N * @sa _PHYSR_, PHYSR_LNK_DOWN
N * @sa getPHYSR()
N */
N#define PHYSR_LNK_UP         (1<<0)
N
N/**
N * @brief PHY Link - Down
N * @details @ref PHYSR_LNK_DOWN indicates the link of Ethernet PHY is not established yet.\n
N * @sa _PHYSR_, PHYSR_LNK_UP
N * @sa getPHYSR()
N */
N#define PHYSR_LNK_DOWN       (0<<0)
N
N/**
N * @brief Read a value  from the Ethernet PHY register specified by @ref _PHYRAR_.\n
N *        The read value can be checked by _PHYDOR_.
N * @sa _PHYACR_, _PHYDOR_, _PHYRAR_, _PHYDIR_, PHYACR_WRITE
N * @sa getPHYACR(), setPHYACR(), getPHYDOR(), getPHYRAR(), setPHYRAR(), setPHYDIR()
N */
N#define PHYACR_READ          (0x02)
N
N/**
N * @brief Write @ref _PHYDIR_ to the Ethernet PHY register specified by @ref _PHYRAR_.
N * @sa _PHYACR_, _PHYDIR_, _PHYRAR_, _PHYDOR_, PHYACR_READ
N * @sa getPHYACR(), setPHYACR(), setPHYDIR(), getPHYRAR(), setPHYRAR(), getPHYDOR()
N */
N#define PHYACR_WRITE         (0x01)
N
N/**
N * @brief PHY's MDC clock is the divided the system clock by 32
N * @sa _PHYDIVR_
N * @sa getPHYDIVR(), setPHYDIVR()
N */
N#define PHYDIVR_32           (0x00)
N
N/**
N * @brief PHY's MDC clock is the divided system clock by 64
N * @sa _PHYDIVR_
N * @sa getPHYDIVR(), setPHYDIVR()
N */
N#define PHYDIVR_64           (0x01)
N
N/**
N * @brief PHY's MDC clock is the divided system clock by 128
N * @sa _PHYDIVR_
N * @sa getPHYDIVR(), setPHYDIVR()
N */
N#define PHYDIVR_128          (0xFF)
N
N
N/* PHY Command Register Bit Definition */
N/**
N * @brief PHY Operation Mode - Auto Negotiation
N * @details @ref PHYCR0_AUTO sets the Ethernet PHY to operate on auto-negotiation mode.\n
N *          The Ethernet PHY can operate on auto-negotiation after @ref PHYCR1_RST is performed, \n
N *          and the result of @ref PHYCR0_AUTO can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H, BMCR_ANE 
N * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()  
N */
N#define PHYCR0_AUTO          (0x00)
N
N/**
N * @brief PHY Operation Mode - 100F 
N * @details @ref PHYCR0_100F sets the Ethernet PHY to operate on 100F\n
N *          The Ethernet PHY can operate on 100F after @ref PHYCR1_RST is performed,\n
N *          and the result of @ref PHYCR0_100F can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, BMCR_SPD, BMCR_DPX
N * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR0_100F          (0x04)
N
N/**
N * @brief PHY Operation Mode - 100H 
N * @details @ref PHYCR0_100H sets the Ethernet PHY to operate on 100H \n
N *          The Ethernet PHY can operate 100H after @ref PHYCR1_RST is performed, \n
N *          and the result of @ref PHYCR0_100H can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H, BMCR_SPD, BMCR_DPX
N * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR0_100H          (0x05)
N
N/**
N * @brief PHY Operation Mode - 10F 
N * @details @ref PHYCR0_10F sets the Ethernet PHY to operate on 10F \n
N *          The Ethernet PHY can operate 10H after @ref PHYCR1_RST is performed, \n
N *          and the result of @ref PHYCR0_10F can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100F, PHYCR0_100H, PHYCR0_10H, BMCR_SPD, BMCR_DPX
N * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR0_10F           (0x06)
N
N/**
N * @brief PHY Operation Mode - 10H 
N * @details @ref PHYCR0_10H sets the Ethernet PHY to operate on 10H \n
N *          The Ethernet PHY can operate 10H after @ref PHYCR1_RST is performed,  \n
N *          and the result of @ref PHYCR0_10H can be checked by @ref PHYSR_SPD, @ref PHYSR_DPX, and @ref PHYSR_LNK.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR0_, _PHYLCKR_, _SYSR_, SYSR_PHYL, _PHYSR_, PHYCR0_AUTO, PHYCR0_100F, PHYCR0_100H, PHYCR0_10H, BMCR_SPD, BMCR_DPX
N * @sa setPHYCR0(), getPHYLCKR(), setPHYLCKR(), PHYLOCK(), PHYUNLOCK(), getSYSR(), getPHYSR(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR0_10H           (0x07)
N
N
N/**
N * @brief PHY function - Power Down
N * @details @ref PHYCR1_PWDN enters the Ethernet PHY in power down mode. \n
N *          0 : Normal mode \n
N *          1 : Power down mode
N * @note The system clock changes to 25MHz in power down mode, and depends on @ref SYCR1_CLKSEL in normal mode.
N * @note It can be set only when @ref SYSR_PHYL = 1.
N * @sa _PHYCR1_, SYCR1_CLKSEL, BMCR_PWDN
N * @sa getPHYCR1(), setPHYCR1(), getSYCR1(), setSYCR1(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR1_PWDN          (1<<5)
N
N/**
N * @brief PHY function - 10Base-TE Mode
N * @details @ref PHYCR1_TE sets the operation of Ethernet PHY to 10base-Te.
N * @note It is valid only when @ref PHYSR_MODE = @ref PHYSR_MODE_AUTO.
N * @note It can be set only when @ref SYSR_PHYL = 1. 
N * @sa _PHYCR1_
N * @sa getPHYCR1(), setPHYCR1()
N */
N#define PHYCR1_TE            (1<<3)
N
N/**
N * @brief PHY function - HW Reset
N * @details @ref PHYCR1_RST resets the Ethernet PHY in hardware, \n
N *          and it is automatically cleared after the H/W reset and it takes 60.3ms to stabilize.\n
N *          0 : Normal mode \n  
N *          1 : H/W Reset \n
N * @note The system clock changes to 25MHz in H/W reset time, and depends on @ref SYCR1_CLKSEL in normal mode.
N * @note It can be set only when @ref SYSR_PHYL = 1. 
N * @sa _PHYCR1_, BMCR_RST
N * @sa getPHYCR1(), setPHYCR1(), getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define PHYCR1_RST           (1<<0)
N
N
N
N/* IPv4 Network Mode Register Bit Definition */
N/**
N * @brief UDP Unreachable Packet Block
N * @details @ref NETxMR_UNRB can block sending a ICMPv or ICMPv6 unreachable message to a peer.
N * @sa _NET4MR_, _NET6MR_
N * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
N */
N#define NETxMR_UNRB          (1<<3) 
N
N/**
N * @brief PING ARP Request
N * @details @ref NETxMR_PARP can send a ARP request before sending a ICMPv4 or ICMPv6 PING reply.
N * @sa _NET4MR_, _NET6MR_
N * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
N */
N#define NETxMR_PARP          (1<<2)
N
N/**
N * @brief TCP Reset Packet Block
N * @details @ref NETxMR_RSTB can block sending a TCP RST packet based on IPv4 or IPv6 \n
N *          when there is no SOCKET n opened with a listen port.
N * @sa _NET4MR_, _NET6MR_
N * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
N */
N#define NETxMR_RSTB          (1<<1)
N
N/**
N * @brief PING Reply Block
N * @details @ref NETxMR_PB can block sending a ICMPv4 or ICMPv6 PING reply to a peer.
N * @sa _NET4MR_, _NET6MR_
N * @sa getNET4MR(), setNET4MR(), getNET6MR(), setNET6MR()
N */
N#define NETxMR_PB            (1<<0)
N
N
N/* Network Mode Register Bit Definition */
N/**
N * @brief All-node Multicating PING Reply Block
N * @details @ref NETMR_ANB can block sending a IPv6 PING reply to the peer ping requested to all-node multicast address.
N * @sa _NETMR_
N * @sa getNETMR(), setNETMR()
N */
N#define NETMR_ANB            (1<<5)
N
N/**
N * @brief Solicited Multicasting PING Reply Block
N * @details @ref NETMR_M6B can block sending a IPv6 PING reply to the peer ping requested to the own solicited multicast address.
N * @sa _NETMR_
N * @sa getNETMR(), setNETMR()
N */
N#define NETMR_M6B            (1<<4)
N
N/**
N * @brief Wake On LAN mode
N * @details @ref NETMR_WOL can receive a magic packet of WOL.
N * @sa _NETMR_
N * @sa getNETMR(), setNETMR()
N */
N#define NETMR_WOL            (1<<2)
N
N/**
N * @brief IPv6 Packet Block
N * @details @ref NETMR_IP6B can block receiving all IPv6 packets.
N * @sa _NETMR_
N * @sa getNETMR(), setNETMR()
N */
N#define NETMR_IP6B           (1<<1)
N
N/**
N * @brief IPv4 Packet Block
N * @details @ref NETMR_IP4B can block receiving all IPv4 packets.
N * @sa _NETMR_
N * @sa getNETMR(), setNETMR()
N */
N#define NETMR_IP4B           (1<<0)
N
N
N/**
N * @brief Destination Hardware Address Select
N * @details @ref NETMR2_DHAS masks the DHAS bit of @ref _NETMR2_. \n
N *          The masked bit values are as following.
N *            - @ref NETMR2_DHAS_ARP
N *            - @ref NETMR2_DHAS_ETH
N *
N * @note It is useful when the destination hardware address of Ethernet frame is different from the target address of ARP.
N * @sa _NETMR2_
N * @sa getNETMR2(), setNETMR2()
N */
N#define NETMR2_DHAS          (1<<7)
N
N/**
N * @brief Destination Hardware Address Select - ARP
N * @details @ref NETMR2_DHAS_ARP select the target address of ARP-replay packet to the destination hardware address.
N * @sa _NETMR2_, NETMR2_DHAS_ETH
N * @sa getNETMR2(), setNETMR2()
N */
N#define NETMR2_DHAS_ARP      (1<<7)
N
N/**
N * @brief Destination Hardware Address Select - Ethernet Frame
N * @details @ref NETMR2_DHAS_ETH select the destination address of Ethernet frame to the destination hardware address.
N * @sa _NETMR2_, NETMR2_DHAS_ARP
N * @sa getNETMR2(), setNETMR2()
N */
N#define NETMR2_DHAS_ETH      (0<<7)
N
N/**
N * @brief PPPoE Mode
N * @details @ref NETMR2_PPPoE enables PPPoE mode \n
N *          0 : Disable \n
N *          1 : Enable
N * @note For enabling a PPPoE mode, some information such like as _PTMR_, _PHAR_, _PSIDR_, and _PMRUR_ are needed. \n
N *       To get these information, You can use a SOCKET0 opened with @ref Sn_MR_MACRAW. 
N * @sa _NETMR2_, _PTMR_, _PHAR_, _PSIDR_, _PMRUR_, Sn_MR_MACRAW
N * @sa getNETMR2(), setNETMR2()
N */
N#define NETMR2_PPPoE         (1<<0)
N
N/* ICMPv6 Block Register Bit Definition */
N/**
N * @brief ICMPv6 PING Block
N * @details @ref ICMP6BLKR_PING6 can block a ping request from a peer
N * @sa _IMCP6BLKR_, NETxMR_PB
N * @sa getICMP6BLKR(), setICMP6BLKR(), getNET6MR(), setNET6MR()
N */
N#define ICMP6BLKR_PING6      (1<<4)
N
N/**
N * @brief ICMPv6 MLD Block
N * @details @ref ICMP6BLKR_MLD can block a multicast listener discovery(MLD) query.
N * @sa _ICMP6BLKR_
N * @sa getICMP6BLKR(), setICMP6BLKR()
N */
N#define ICMP6BLKR_MLD        (1<<3)
N
N/**
N * @brief ICMPv6 RA Block
N * @details @ref ICMP6BLKR_RA can block a RA packet from a router
N * @sa _ICMP6BLKR_
N * @sa getICMP6BLKR(), setICMP6BLKR()
N */
N#define ICMP6BLKR_RA         (1<<2)
N
N/**
N * @brief ICMPv6 NA Block
N * @details @ref ICMP6BLKR_NA can block a Neighbor Advertisement(NA) from a peer
N * @sa _ICMP6BLKR_
N * @sa getICMP6BLKR(), setICMP6BLKR()
N */
N#define ICMP6BLKR_NA         (1<<1)
N
N/**
N * @brief ICMPv6 NS Block
N * @details @ref ICMP6BLKR_NS can block a Neighbor Solicitation(NS) from a peer
N * @sa _ICMP6BLKR_
N * @sa getICMP6BLKR(), setICMP6BLKR()
N */
N#define ICMP6BLKR_NS         (1<<0)
N
N
N/* Sn_MR values */
N/**
N * @brief UDP Multicasting 
N * @details  @ref Sn_MR_MULTI enables to a multicast packet from a multicast group in UDP mode SOCKETn. \n
N *            To use multicasting, @ref _Sn_DIPR_, @ref _Sn_DIP6R_, & @ref _Sn_DPORTR_ should be respectively set with \n
N *            the multicast group IPv4, IPv6 address & port number before @ref Sn_CR_OPEN. \n
N *            0 : Disable Multicasting \n
N *            1 : Enable Multicasting \n
N * @note It is valid only in UDP mode such like as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
N * @sa _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_
N * @sa getSn_MR(), setSn_MR(), getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR().
N */
N#define Sn_MR_MULTI          (1<<7)
N
N/**
N * @brief MAC Filter 
N * @details @ref Sn_MR_MF filters other packets except broadcasting, multicasting, and packets sent to your own.\n
N *          0 : Disable MAC Filtering \n
N *          1 : Enable MAC Filtering \n
N * @note It is valid only in MACRAW SOCKET0 opened with @ref Sn_MR_MACRAW \n
N * @note If you want to implement a hybrid TCP/IP stack, \n
N *       It is recommended that @ref Sn_MR_MF enable for reducing host overhead to process the all received packets.
N * @sa _Sn_MR_, Sn_MR_MULTI
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_MF             (1<<7)
N
N/**
N * @brief Broadcasting packet block
N * @details @ref Sn_MR_BRDB can block a broadcasting packet in MACRAW SOCKET0 or UDP mode SOCKETn. \n
N *          0 : Disable Broadcast Blocking \n
N *          1 : Enable Broadcast Blocking \n
N * @note It is valid only in MACRAW mode such as @ref Sn_MR_MACRAW, or in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
N * @sa _Sn_MR_, Sn_MR_FPSH 
N * @sa getSn_MR(), setSn_MR()
N */
N #define Sn_MR_BRDB          (1<<6)
N
N/**
N * @brief Force PUSH flag
N * @details When @ref Sn_MR_FPSH is set, all TCP DATA packets with PSH flag set can be transmitted by @ref Sn_CR_SEND. \n
N *          When @ref Sn_MR_FPSH is not set, the PSH flag is set only in the last DATA packet among the DATA packets transmitted by @ref Sn_CR_SEND. \n
N *          0 : No Force PSH flag \n
N *          1 : Force PSH flag \n
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_MR_, Sn_CR_SEND, Sn_MR_BRDB
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR()
N */
N#define Sn_MR_FPSH           (1<<6)
N
N/**
N * @brief No Delayed Ack
N * @details When @ref Sn_MR_FPSH is set, It sends the ACK packet without delay as soon as a DATA packet is received from a peer.\n
N *          Otherwise, It sends the ACK packet after waiting the time set by @ref _Sn_RTR_. \n
N *          0 : Delayed ACK \n
N *          1 : No Delayed ACK \n
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.
N * @note Regardless of @ref Sn_MR_ND, It sends the ACK packet when SOCKETn window size is less than MSS after @ref Sn_CR_RECV.
N * @sa _Sn_MR_, _Sn_RTR_, Sn_CR_RECV, Sn_MR_MC, Sn_MR_SMB, Sn_MR_MMB
N * @sa getSn_MR(), setSn_MR(), getSn_RTR(), setSn_RTR(), getSn_CR(), setSn_CR()
N */
N #define Sn_MR_ND            (1<<5)
N
N/**
N * @brief IGMP version for IPv4 Multicasting
N * @details @ref Sn_MR_MC decides IGMP version. \n
N *          0 : IGMPv2 \n
N *          1 : IGMPv1 \n
N * @note It is valid only when @ref Sn_MR_MULTI = '1' and UDP mode is @ref Sn_MR_UDP4.
N * @note IGMP packet can be automatically sent to the multicast group by @ref Sn_CR_OPEN.
N * @note @ref _WIZCHIP_ doesn't not support IGMP version 3.
N * @sa _Sn_MR_, Sn_MR_MULTI, Sn_MR_ND, Sn_MR_SMB, Sn_MR_MMB
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_MC             (1<<5)
N
N/**
N * @brief Solicited Mulitcast Block
N * @details @ref Sn_MR_SMB can block a received packet that have your own solicited multicast address. \n
N *          0 : Unblock a solicited multicast packet \n
N *          1 : Block a solicited multicast packet \n
N * @note It is valid only when UDP mode is @ref Sn_MR_UDP6 or @ref Sn_MR_UDPD.
N * @sa _Sn_MR_,  Sn_MR_ND, Sn_MR_MC, Sn_MR_MMB
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_SMB            (1<<5)
N
N/**
N * @brief UDP4 Multicast Block
N * @details @ref Sn_MR_MMB can block the UDP4 multicast packet when SOCKET0 is opend with @ref Sn_MR_MACRAW and @ref Sn_MR_MF is set.\n
N *          0 : Unblock a UDP multicast packet with IPv4 address \n
N *          1 : Block a UDP multicast packet with IPv4 address \n
N * @note It is valid only in MACRAW SOCKET0 with Sn_MR_MF = '1'.
N * @sa _Sn_MR_, Sn_MR_MMB6, Sn_MR_ND, Sn_MR_MC, Sn_MR_SMB
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_MMB            (1<<5)
N#define Sn_MR_MMB4           (Sn_MR_MMB)  /// Refer to @ref Sn_MR_MMB.
N
N/**
N * @brief Unicast Block
N * @details @ref Sn_MR_UNIB can block a unicast packet. \n
N *          0 : Unblock a UDP unicast packet \n
N *          1 : Block a UDP unicast packet \n
N * @note It is valid only when SOCKETn is opened with UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6 and @ref Sn_MR_UDPD, and @ref Sn_MR_MULTI is set.
N * @sa _Sn_MR_, Sn_MR_MULTIL, Sn_MR_MMB6
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_UNIB           (1<<4)
N
N/**
N * @brief UDP6 Multicast Block
N * @details @ref Sn_MR_MMB6 can block the UDP6 multicast packet. \n
N *          0 : Unblock a UDP multicast packet with IPv6 address \n
N *          1 : Block a UDP multicast packet with IPv6 address \n
N * @note  It is valid only when SOCKET0 is opend with @ref Sn_MR_MACRAW and @ref Sn_MR_MF is set.
N * @sa _Sn_MR_, Sn_MR_MMB
N * @sa getSn_MR(), setSn_MR()
N */
N#define Sn_MR_MMB6           (1<<4)
N
N/**
N * @brief SOCKETn Closed
N * @details @ref Sn_MR_CLOSE is not opened yet.\n
N *          It is the default mode when @ref _WIZCHIP_ is reset.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_CLOSE          (0x00)
N
N/**
N * @brief IPv4 TCP mode 
N * @details @ref Sn_MR_TCP(= @ref Sn_MR_TCP4) sets SOCKETn to TCP4 mode. \n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opend as TCP4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.
N * @note In oder to connect a peer, You should use @ref Sn_CR_CONNECT as command and @ref _Sn_DIPR_ as destination.
N * @note In order to send data, You should use @ref Sn_CR_SEND.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_TCP6, Sn_MR_TCPD
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_TCP            (0x01)
N#define Sn_MR_TCP4           (Sn_MR_TCP)   ///< Refer to @ref Sn_MR_TCP.
N
N/**
N * @brief IPv4 UDP mode
N * @details @ref Sn_MR_UDP(= @ref Sn_MR_UDP4) sets SOCKETn to UDP4 mode.\n
N *          It should be set before @ref Sn_CR_OPEN is performed. \n
N *          After @ref Sn_CR_OPEN, SOCKETn is opend as UDP4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
N * @note In order to send data, You should use @ref Sn_CR_SEND as command and @ref _Sn_DIPR_ as destination.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP6, Sn_MR_UDPD
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_UDP            (0x02)
N#define Sn_MR_UDP4           (Sn_MR_UDP)   ///< Refer to @ref Sn_MR_UDP
N
N/**
N * @brief IPv4 RAW mode
N * @details @ref Sn_MR_IPRAW(= @ref Sn_MR_IPRAW4) sets SOCKETn to IPRAW4 mode. \n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opend as IPRAW4 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW(= @ref SOCK_IPRAW4).
N * @note In order to send data, You should use @ref Sn_CR_SEND as command and @ref _Sn_DIPR_ as destination.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_IPRAW6
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_IPRAW          (0x03)
N#define Sn_MR_IPRAW4         (Sn_MR_IPRAW)   ///< Refer to @ref Sn_MR_IPRAW.   
N
N/**
N * @brief MACRAW mode
N * @details @ref Sn_MR_MACRAW sets only SOCKET0 to MACRAW mode.\n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKET0 is opend as MACRAW mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_MACRAW.
N * @note In order to send data, You should use @ref Sn_CR_SEND.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_MACRAW         (0x07)
N
N/**
N * @brief IPv6 TCP mode 
N * @details @ref Sn_MR_TCP6 sets SOCKETn to TCP6 mode. \n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opend as TCP6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.
N * @note In oder to connect a peer, You should use @ref Sn_CR_CONNECT6 as command and @ref _Sn_DIP6R_ as destination.
N * @note In order to send data, You should use @ref Sn_CR_SEND, not @ref Sn_CR_SEND6.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_TCP4, Sn_MR_TCPD
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_TCP6           (0x09)
N
N/**
N * @brief IPv6 UDP mode
N * @details @ref Sn_MR_UDP6 sets SOCKETn to UDP6 mode.\n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opend as UDP6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
N * @note In order to send data, You should use @ref Sn_CR_SEND6 as command and @ref _Sn_DIP6R_ as destination.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP4, Sn_MR_UDPD
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_UDP6           (0x0A)
N
N/**
N * @brief IPv6 RAW mode
N * @details @ref Sn_MR_IPRAW6 sets SOCKETn to IPRAW6 mode.\n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opened as IPRAW6 mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW6.
N * @note In order to send data, You should use @ref Sn_CR_SEND6 as command and @ref _Sn_DIP6R_ as destination.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_IPRAW4
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_IPRAW6         (0x0B)
N
N/**
N * @brief Both IPv4 & IPv6 TCP mode (TCP dual mode)
N * @details @ref Sn_MR_TCPD sets SOCKETn to both TCP4 & TCP6 mode. \n
N *          It should be set before @ref Sn_CR_OPEN is performed.\n
N *          After @ref Sn_CR_OPEN, SOCKETn is opened as TCP Dual mode and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT.\n
N *          The real mode of TCP dual SOCKETn is decided when the connection with a peer is established.\n
N *   - In SOCKETn is operated as <b>TCP SERVER</b> mode 
N *     If the connection request client have a IPv4 address, \n
N *     TCP dual SOCKETn is changed to TCP4 mode and a destination IP address can be checked thru @ref _Sn_DIPR_, \n
N *     else if the client have a IPv6 address, \n
N *     TCP dual SOCKETn is changed to IPv6 mode and destination IP address can be checked by thru @ref _Sn_DIP6R_.
N *   - In SOCKETn is operated as <b>TCP CLIENT</b> mode, 
N *     If the IP address type of destination to connect is IPv4, \n
N *     the destination IP address should be set to @ref _Sn_DIPR_ and try to connect by @ref Sn_CR_CONNECT, \n
N *     else if the type is IPv6, \n
N *     the destination IP address should be set to @ref _Sn_DIP6R_ and try to connect by @ref Sn_CR_CONNECT6. \n
N *           
N * @note In <b>TCP SERVER</b> mode, You can check the IP type of the client with @ref Sn_ESR_TCPM.
N * @note If the connected client have a IPv6 address, You can check whether the address is LLA or GAU, thru @ref Sn_ESR_IP6T
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, _Sn_ESR_TCPM_, Sn_MR_TCP4, Sn_MR_TCP6
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR(), getSn_ESR()
N */
N#define Sn_MR_TCPD           (0x0D)
N
N/**
N * @brief UDP Dual mode
N * @details @ref Sn_MR_UDPD sets SOCKETn to both UDP4 & UDP6 mode. \n
N *          It should be set before @ref Sn_CR_OPEN is performed. \n
N *          After @ref Sn_CR_OPEN, SOCKETn is opened as UDP dual mode \n
N *          and @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_UDP.
N * @note In order to send data, \n
N *       You can use both @ref Sn_CR_SEND and @ref Sn_CR_SEND6 as command and both @ref _Sn_DIPR_ and @ref _Sn_DIP6R_ as destination.
N * @note You can know the destination IP address type is whether IPv6 or IPv4 thru @ref getsockopt() with @ref SO_PACKINFO.
N * @sa _Sn_MR_, _Sn_CR_, _Sn_SR_, Sn_MR_UDP6, Sn_MR_UDP4
N * @sa getSn_MR(), setSn_MR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_MR_UDPD           (0x0E)
N
N/* SOCKETn  Command Register BIt Definition */
N/**
N * @brief Initialize or Open SOCKETn.
N * @details SOCKETn is initialized and opened according to the protocol mode selected by @ref _Sn_MR_ and with a source port set by @ref _Sn_PORTR_. \n
N *                   The table shows @ref _Sn_SR_ is changed according to @ref _Sn_MR_.\n
N * <table>
N *    <tr> <td> <b>@ref _Sn_MR_</b> (P[3:0])                      </td> <td><b>@ref _Sn_SR_</b> </td> </tr>
N *    <tr> <td> @ref Sn_MR_CLOSE                                  </td> <td> @ref SOCK_CLOSED   </td> </tr>
N *    <tr> <td> @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, @ref Sn_MR_TCPD </td> <td> @ref SOCK_INIT     </td> </tr>
N *    <tr> <td> @ref Sn_MR_UDP, @ref Sn_MR_UDP6, @ref Sn_MR_UDPD  </td> <td> @ref SOCK_UDP      </td> </tr>
N *    <tr> <td> @ref Sn_MR_IPRAW4                                 </td> <td> @ref SOCK_IPRAW4   </td> </tr>
N *    <tr> <td> @ref Sn_MR_IPRAW6                                 </td> <td> @ref SOCK_IPRAW6   </td> </tr>
N *    <tr> <td> @ref Sn_MR_MACRAW                                 </td> <td> @ref SOCK_MACRAW   </td> </tr>
N * </table>
N *
N * @note If you want to use a SOCKETn option such as Sn_MR_MF, Sn_MR_ND, Sn_MR_MUTIL and etc, \n
N *       these options should be set before @ref Sn_CR_OPEN is performed.
N * @note If you want to open a multicast UDP mode SOCKETn, \n
N *       You should set the multicast group with @ref _Sn_DIPR_ or @ref _Sn_DIP6R_ and @ref _Sn_DPORTR_ before @ref Sn_CR_OPEN is performed.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_PORTR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_,
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_PORTR(), setSn_PORTR(), getSn_DIPR(), setSn_DIPR(),
N *     getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR()
N */
N#define Sn_CR_OPEN           (0x01)
N
N/**
N * @brief Wait a connection request in <b>TCP SERVER</b> mode
N * @details SOCKETn operates as a <b>TCP SERVER</b> and waits for a connection-request (SYN packet) \n
N *          with corresponding @ref _Sn_PORTR_ port number from any <b>TCP CLIENT</b> \n
N *          The @ref _Sn_SR_ is changed from @ref SOCK_INIT to @ref SOCK_LISTEN. \n
N *          When a <b>TCP CLIENT</b> connection request is successfully accepted,\n
N *          the @ref _Sn_SR_ is changed from @ref SOCK_LISTEN to @ref SOCK_ESTABLISHED \n
N *          and the @ref Sn_IR_CON is set.\n
N *          But when a <b>TCP CLIENT</b> connection request is failed, \n
N *          @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to SOCK_CLOSED.
N * @note This is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_PORTR_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_PORTR(), setSn_PORTR()
N */
N#define Sn_CR_LISTEN         (0x02)
N
N/**
N * @brief Send a connection request in <b>TCP CLIENT</b> mode
N * @details To establish a connection, a connect-request (SYN packet) is sent to <b>TCP SERVER</b> set by @ref _Sn_DIPR_ & @ref _Sn_DPORTR_.\n
N *          If the connect-request is successful accepted by a <b>TCP SERVER</b>, \n
N *          the @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and the @ref Sn_IR_CON is set. \n
N *          The connect-request fails in the following three cases, \n
N *          and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n\n
N *  1. Until a ARP timeout is occurred (@ref Sn_IR_TIMEOUT = 1), a destination hardware address can not be acquired through the ARP-process.\n
N *  2. Until a TCP tmeout occurred (@ref Sn_IR_TIMEOUT = 1), a SYN/ACK packet is not received from the server\n
N *  3. When a RST packet is received instead of a SYN/ACK packet \n
N *
N * @note This is valid only in TCP mode such as @ref Sn_MR_TCP4 and @ref Sn_MR_TCPD. 
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_DIPR_, _Sn_DPORTR_, Sn_CR_CONNECT6, _Sn_IR_, _Sn_IRCLR_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIPR(), setSn_DIPR(), getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR()
N */
N#define Sn_CR_CONNECT        (0x04)
N
N/**
N * @brief Send connection request in <b>TCP CLIENT</b> mode
N * @details To establish a connection, a connect-request (SYN packet) is sent to <b>TCP SERVER</b> set by @ref _Sn_DIP6R_ & @ref _Sn_DPORTR_.\n
N *          If the connect-request is successful accepted by a <b>TCP SERVER</b>, \n
N *          the @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and the @ref Sn_IR_CON is set. \n
N *          The connect-request fails in the following three cases, and @ref _Sn_SR_ is changed @ref SOCK_CLOSED.\n
N *   1. Until a ARP timeout is occurred (@ref Sn_IR_TIMEOUT = 1), a destination hardware address can not be acquired through the ARP-process.\n
N *   2. Until a TCP tmeout occurred (@ref Sn_IR_TIMEOUT = 1), a @b SYN/ACK packet is not received from the server\n
N *   3. When a RST packet is received instead of a @b SYN/ACK packet \n
N *
N * @note This is valid only in TCP mode such as @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD. 
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_DIP6R_, _Sn_DPORTR_, Sn_CR_CONNECT, _Sn_IR_, _Sn_IRCLR_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR()
N */
N#define Sn_CR_CONNECT6       (0x84)
N
N/**
N * @brief Send a disconnect request in TCP mode
N * @details Regardless of <b>TCP SERVER</b> or <b>TCP CLIENT</b>, \n
N *          @ref Sn_CR_DISCON processes the disconnect-process (Active or Passive close).\n
N *          When the disconnect-process is successful (that is, FIN/ACK packet is received successfully from/to each other),\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n
N *          Otherwise, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N *   - Active close 
N *     It transmits first a disconnect-request(FIN packet) to the connected peer, and waits to receive two FIN/ACK and FIN packet from the peer. \n
N *     If two FIN/ACK and FIN packet is received successfully, @ref Sn_IR_DISCON is set and @ref _Sn_SR_ is changed @ref SOCK_CLOSED.
N *   - Passive close
N *     When a FIN packet is first received from the peer, the FIN/ACK packet is replied back to the peer and @ref Sn_IR_DISCON is set.\n
N *     And then, a FIN packet is sent by @ref Sn_CR_DISCON to the peer, and waits to receive the FIN/ACK packet from the peer. \n
N *     If the FIN/ACK packet is received successfully from the peer, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N *
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_DISCON, Sn_IR_TIMEOUT
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_IR(), setSn_IRCLR()
N */
N#define Sn_CR_DISCON         (0x08)
N
N/**
N * @brief Release or Close SOCKETn
N * @details In TCP mode, @ref Sn_CR_CLOSE force to close a SOCKETn without the disconnect-process.\n
N *          In other SOCKETn mode, @ref Sn_CR_CLOSE just closes a SOCKET.\n
N * @note @ref _Sn_SR_ can be changed from any status to @ref SOCK_CLOSED by @ref Sn_CR_CLOSE.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, Sn_CR_DISCON
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR()
N */
N#define Sn_CR_CLOSE          (0x10)
N
N/**
N * @brief Send Data  
N * @details @ref Sn_CR_SEND send the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX buffer \n
N *          to the destination specified by @ref _Sn_DIPR_ or @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_.\n
N *   - TCP mode(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6,  @ref Sn_MR_TCPD)
N *     If it starts to be sent the data by @ref Sn_CR_SEND, @ref Sn_IR_SENDOK is set. \n 
N *     And after sending the data, if the ACK to the sent data can not be received during @ref _Sn_RTR_, \n
N *     the sent data can be retransmitted as many as @ref _Sn_RCR_. \n
N *     During the retransmission, \n
N *     If the ACK is received, @ref _Sn_TX_FSR_ is increased as many as the sent data size, \n
N *     Otherwise, @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N *   - UDP mode(@ref Sn_MR_UDP4, @ref Sn_MR_UDPD) & IPRAW mode(@ref Sn_MR_IPRAW4)
N *     It first sends a ARP-request to a destination specified with @ref _Sn_DIPR_ before it starts to be sent data by @ref Sn_CR_SEND. \n
N *     If the ARP-reply can not be received during @ref _Sn_RTR_, the ARP-request can be retransmitted as many as @ref _Sn_RCR_. \n
N *     During the retransmission, \n
N *     If the ARP-reply is received and @ref Sn_IR_SENDOK is set, it starts to send data and then @ref _Sn_TX_FSR_ is increased as many as the sent data size. \n
N *     Otherwise, @ref Sn_IR_TIMEOUT is set but @ref _Sn_SR_ is not changed.
N *   - MACRAW mode(@ref Sn_MR_MACRAW)
N *     It just start to send data and @ref Sn_IR_SENDOK is set.
N *
N * @note Data size to be sent is calculated by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_. \n
N *       In TCP or UDP mode, It can not be sent bigger data than @ref _Sn_TX_FSR_.\n
N *       In IPRAW or Macraw case, it can not be sent bigger data than MTU(Maximum Transmit Unit).
N * @note In TCP or MACRAW mode, It can send data to a destination address whether IPv4 or IPv6. \n
N *       In UDP or IPRAW mode, It can send data only to a destination IPv4 address. \n
N *       For Sending to IPv6 address, It can be used with @ref Sn_CR_SEND6.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_, _Sn_IR_, _Sn_IRCLR_, _Sn_TX_FSR_, _Sn_TX_WR_, _Sn_TX_RD_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), \n
N *     getSn_DPORTR(), setSn_DPORTR(), getSn_IR(), setSn_IRCLR(), getSn_TX_FSR(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD()
N */
N#define Sn_CR_SEND           (0x20)
N
N/**
N * @brief Send Data       
N * @details @ref Sn_CR_SEND6 sends the saved data from @ref _Sn_TX_RD_ to @ref _Sn_TX_WR_ in the SOCKETn TX buffer \n
N *          to the destination specified by @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_.\n
N *   - TCP mode(@ref Sn_MR_TCP4, @ref Sn_MR_TCP6,  @ref Sn_MR_TCPD) & MACRAW mode(@ref Sn_MR_MACRAW)
N *     @ref Sn_CR_SEND6 is not recommended. In this case, Use @ref Sn_CR_SEND.
N *   - UDP mode(@ref Sn_MR_UDP6, @ref Sn_MR_UDPD) & IPRAW mode(@ref Sn_MR_IPRAW6)
N *     It first send a neighbor solicitation NS) of ICMPv6 to a destination specified with @ref _Sn_DIP6R_ \n
N *     before it starts to be sent data by @ref Sn_CR_SEND. \n
N *     If the neighbor advertisement(NA) of ICMPv6 can not be received during @ref _Sn_RTR_, \n
N *     the NS can be retransmitted as many as @ref _Sn_RCR_. \n
N *     During the retransmission, \n
N *     If the NA is received and @ref Sn_IR_SENDOK is set, \n
N *     it starts to send data and then @ref _Sn_TX_FSR_ is increased as many as the sent data size. \n
N *     Otherwise, @ref Sn_IR_TIMEOUT is set but @ref _Sn_SR_ is not changed.
N *
N * @note Data size to be sent is calculated by the absolute difference between @ref _Sn_TX_WR_ and @ref _Sn_TX_RD_. \n
N *       In TCP or UDP mode, It can not be sent bigger data than @ref _Sn_TX_FSR_.\n
N *       In IPRAW or Macraw case, it can not be sent bigger data than MTU(Maximum Transmit Unit).
N * @note In UDP or IPRAW mode, It can send data only to a destination IPv6 address. \n
N *       For Sending to IPv4 address, It can be sent by @ref Sn_CR_SEND.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_DIP6R_, _Sn_DPORTR_, _Sn_IR_, _Sn_IRCLR_, _Sn_TX_FSR_, _Sn_TX_WR_, _Sn_TX_RD_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR(), \n
N *     getSn_IR(), setSn_IRCLR(), getSn_TX_FSR(), getSn_TX_WR(), setSn_TX_WR(), getSn_TX_RD()
N */
N #define Sn_CR_SEND6         (0xA0)
N
N/**
N * @brief Send keep alive message
N * @details @ref Sn_CR_SEND_KEEP checks whether the connection is established or not by sending 1 byte KA(Keep Alive) packet.\n
N *          If the destination can not respond to the KA packet during the time set by @ref _Sn_RTR_ and @ref _Sn_RCR_, \n
N *          the connection is terminated, @ref Sn_IR_TIMEOUT is set and then @ref _Sn_SR_ is changed @ref SOCK_CLOSED.
N * @note It is valid only after sending data over 1 byte in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_SR_, _Sn_IR_, _Sn_IRCLR_, _Sn_RTR_, _Sn_RCR_, _Sn_KPALVTR_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_SR(), getSn_IR(), setSn_IRCLR(), \n
N *        getSn_RTR(), setSn_RTR(), getSn_RCR(), setSn_RCR(), getSn_KPALVTR(), getSn_KPALVTR()
N */
N#define Sn_CR_SEND_KEEP      (0x22)
N
N/**
N * @brief Receive data
N * @details @ref Sn_CR_RECV reads the saved from @ref _Sn_RX_RD_ to @ref _Sn_RX_WR_ data in SOCKETn RX buffer.\n
N *          When a data is saved in the SOCKETn RX buffer, \n
N *          @ref Sn_IR_RECV is set and @ref _Sn_RX_RSR_ is increased as many as the saved data size.\n
N *          The total size of saved data is calculated by the absolute difference between @ref _Sn_RX_WR_ and @ref _Sn_RX_RD_,\n
N *          and it can be checked thru @ref _Sn_RX_RSR_.\n
N *          After reading data, @ref _Sn_RX_RD_ should be increased as many as the read size before @ref Sn_CR_RECV is performed.\n
N *          After @ref Sn_CR_RECV, @ref _Sn_RX_RSR_ is decreased as many as the read size.\n
N *          If @ref _Sn_RX_RSR_ is remained still at none-zero, @ref Sn_IR_RECV is set again.
N * @sa _Sn_CR_, _Sn_MR_, _Sn_IR_, _Sn_IRCLR_, _Sn_RX_RD_, _Sn_RX_WR_, _Sn_RX_RSR_
N * @sa getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR(), getSn_IR(), getSn_IRCLR(), \n
N *     getSn_RX_RD(), setSn_RX_RD(), getSn_RX_TX(), getSn_RX_RSR()
N */
N#define Sn_CR_RECV           (0x40)
N
N
N/* Sn_IR values */
N/**
N * @brief SEND OK Interrupt
N * @details @ref Sn_IR_SENDOK is set when it is started to be sent data by @ref Sn_CR_SEND. 
N * @note Even though @ref Sn_IR_SENDOK is set, it does not means that the destination receives data successfully.\n
N *         - In TCP mode, The sent data maybe still transmitting or retransmitting. \n
N *         - In other modes, The sent data maybe lost by media collision or an other reason such as network traffic.
N * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_SEND
N * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
N */
N#define Sn_IR_SENDOK         (0x10)
N
N/**
N * @brief TIMEOUT Interrupt
N * @details @ref Sn_IR_TIMEOUT is set when a timeout occurs in ARP and ND process or TCP retransmission.
N * @note In TCP mode, If it is set, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED. \n
N *       In other modes, _Sn_SR_ is still remained at the previous status.
N * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_CONNECT, Sn_CR_CONNECT6, Sn_CR_SEND
N * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
N */
N#define Sn_IR_TIMEOUT        (0x08)
N
N/**
N * @brief RECV Interrupt
N * @details @ref Sn_IR_RECV is set whenever data is received from a peer, \n
N *          or if @ref _Sn_RX_RSR_ is still at none-zero whenever @ref Sn_CR_RECV is performed.
N * @sa _Sn_IR_, _Sn_IRCLR_, Sn_CR_RECV
N * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR()
N */
N#define Sn_IR_RECV           (0x04)
N
N/**
N * @brief DISCON Interrupt
N * @details @ref Sn_IR_DISCON is set when a FIN or FIN/ACK packet is received from the connected peer.
N * @note When first a FIN packet is received from the connected peer and @ref _Sn_SR_ is changed to SOCK_CLOSE_WAIT, \n
N *       you should perform @ref Sn_CR_DISCON for a successful disconnect. \n
N *       If the disconnect-process is completed or failed, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valild only in TCP mode such as @ref Sn_MR_TCP4, @ ref Sn_MR_TCP6 and @ref Sn_MR_TCPD.
N * @sa _Sn_IR_, _Sn_IRCLR_, Sn_IR_DISCON, _Sn_SR_
N * @sa getSn_IR(), setSn_IRCLR(), getSn_CR(), setSn_CR(), getSn_SR()
N */
N#define Sn_IR_DISCON         (0x02)
N
N/**
N * @brief CONNECT Interrupt
N * @details @ref Sn_IR_CON is set once the connection with a peer is established and @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ ref Sn_MR_TCP6 adn @ref Sn_MR_TCPD.
N * @sa _Sn_IR_, _Sn_IRCLR_, _Sn_SR_
N * @sa getSn_IR(), setSn_IRCLR(), getSn_SR()
N */
N#define Sn_IR_CON            (0x01)
N
N/* Sn_SR values */
N/**
N * @brief SOCKETn Closed status
N * @details @ref SOCK_CLOSED indicates that SOCKETn is closed and released.\n
N *          It is set when @ref Sn_CR_DISCON , @ref Sn_CR_CLOSE is performed, or when @ref Sn_IR_TIMEOUT is set.\n
N *          It can be changed to @ref SOCK_CLOSED regardless of previous status.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, Sn_IR_TIMEOUT
N * @sa getSn_SR(), getSn_CR(), setSn_CR(), getSn_IR(), setSn_IRCLR()
N */
N#define SOCK_CLOSED          (0x00)
N
N/**
N * @brief TCP SOCKETn initialized status
N * @details @ref SOCK_INIT indicates SOCKETn is opened with TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.\n
N *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT when @ref Sn_CR_OPEN is performed in TCP mode.\n
N *          In @ref SOCK_INIT status, @ref Sn_CR_LISTEN for operating a <b>TCP SERVER</b> \n
N *          or @ref Sn_CR_CONNECT / @ref Sn_CR_CONNECT6 for operating a <b>TCP CLIENT</b> can be performed.
N * @note It is valid only in TCP mode.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_MR_
N * @sa getSn_SR, getSn_CR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_INIT            (0x13)
N
N/**
N * @brief TCP SOCKETn Listen status
N * @details @ref SOCK_LISTEN indicates SOCKETn is operating as <b>TCP SERVER</b> mode \n
N *          and waiting for connection-request (SYN packet) from a peer (<b>TCP CLIENT</b>).\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_SYNRECV when the connection-request(SYN packet) is successfully accepted \n
N *          and It is changed from @ref SOCK_SYNRECV to @ref SOCK_ESTABLISHED \n
N *          when the SYN/ACK packet is sent successfully to the peer and then the ACK packet of SYN/ACK is received successfully.\n
N *          Otherwise, it is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_ 
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_LISTEN          (0x14)
N
N/**
N * @brief TCP Connection Request status
N * @details @ref SOCK_SYNSENT indicates TCP SOCKETn sent the connect-request packet(SYN packet)\n
N *          to the peer specified by @ref _Sn_DIPR_ / @ref _Sn_DIP6R_ and @ref _Sn_DPORTR_.\n
N *          It is temporarily shown when @ref _Sn_SR_ is changing from @ref SOCK_INIT to @ref SOCK_ESTABLISHED by @ref Sn_CR_CONNECT or @ref Sn_CR_CONNECT6.\n
N *          When the connect-accept packet (SYN/ACK packet) is received from the peer at @ref SOCK_SYNSENT and the ACK packet of SYN/ACK is sent successfully, \n
N *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED.\n
N *          Otherwise, it is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_  
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_SYNSENT         (0x15)
N
N/**
N * @brief TCP Connection Accept status
N * @details @ref SOCK_SYNRECV indicates TCP SOCKETn is successfully received the connect-request packet (SYN packet) from a peer.\n
N *          It is temporarily shown when @ref _Sn_SR_ is changing from @ref SOCK_LISTEN to @ref SOCK_ESTABLISHED by the SYN packet\n
N *          If SOCKETn sends the response (SYN/ACK  packet) to the peer successfully and the ACK packet of SYS/ACK is received successfully,\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED. \n
N *          Otherwise, @ref _Sn_SR_ is changed to @ref SOCK_CLOSED and @ref Sn_IR_TIMEOUT is set.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6..
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_SYNRECV         (0x16)
N
N/**
N * @brief TCP SOCKETn Established status
N * @details @ref SOCK_ESTABLISHED indicates TCP SOCKETn is connected successfully with a peer.\n
N *          when the <b>TCP SERVER</b> processes the SYN packet from the <b>TCP CLIENT</b> during @ref SOCK_LISTEN or \n
N *          when the <b>TCP CLIENT</b> performs successfully @ref Sn_CR_CONNECT or @ref Sn_CR_CONNECT6,\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_ESTABLISHED and @ref Sn_IR_CON is set. \n
N *          During @ref SOCK_ESTABLISHED, a DATA packet can be sent to or received from the peer by @ref Sn_CR_SEND or @ref Sn_CR_RECV.  \n
N *          If the DATA/ACK packet is not received from the peer during data re-transmission, @ref Sn_IR_TIMEOUT is set and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.\n
N *          Otherwise, @ref _Sn_SR_ is still at @ref SOCK_ESTABLISHED.
N * @note In <b>TCP SERVER</b>, \n
N *       You can check the IPv4/IPv6 address and port number of connected peer thru @ref _Sn_DIPR_, @ref _Sn_DIP6R_, and @ref _Sn_DPORTR_ respectively.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCP6.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_, _Sn_DPORTR_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
N *     getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R(), getSn_DPORTR(), setSn_DPORTR().
N */
N#define SOCK_ESTABLISHED     (0x17)
N
N/**
N * @brief TCP SOCKETn Closing status
N * @details @ref SOCK_FIN_WAIT indicates TCP mode SOCKETn waits until the disconnect-process is completed. \n
N *          It is temporarily shown in disconnect-process such as active-close. \n
N *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_TIME_WAIT, SOCK_LAST_ACK
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N *
N */
N#define SOCK_FIN_WAIT        (0x18)
N
N/**
N * @brief TCP SOCKETn Closing status
N * @details @ref SOCK_TIME_WAIT indicates TCP SOCKETn waits until the disconnect-process is completed.\n
N *          It is temporarily shown in disconnect-process such as active-close. \n
N *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_FIN_WAIT, SOCK_LAST_ACK 
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_TIME_WAIT       (0x1B)
N
N/**
N * @brief TCP SOCKETn Half Closing staus
N * @details @ref SOCK_CLOSE_WAIT indicates TCP SOCKETn receives the disconnect-request (FIN packet) from the connected peer.\n
N *          It is a half-closing status, and a DATA packet can be still sent or received by @ref Sn_CR_SEND or @ref Sn_CR_RECV.\n
N *          If you do not have any more need to send or received a DATA packet, You can perform @ref Sn_CR_DISCON for a full-closing.
N * @note If you have no need the successful closing, You maybe perform @ref Sn_CR_CLOSE.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_ 
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_CLOSE_WAIT      (0x1C)
N
N/**
N * @brief TCP SOCKETn Closing status
N * @details @ref SOCK_LAST_ACK indicates TCP SOCKETn waits until the disconnect-process is completed.\n
N *          It is temporarily shown in disconnect-process such as active-close and passive-close.\n
N *          When the disconnect-process is successfully completed or when @ref Sn_IR_TIMEOUT is set,\n
N *          @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, SOCK_FIN_WAIT, SOCK_TIME_WAIT 
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR()
N */
N#define SOCK_LAST_ACK        (0x1D)
N
N/**
N * @brief UDP SOCKETn status
N * @details @ref SOCK_UDP indicates SOCKETn is opened in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.\n
N *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_INIT when @ref Sn_CR_OPEN is performed in UDP mode.\n
N *          Unlike TCP mode, during @ref SOCK_UDP, \n
N *          a DATA packet can be sent to or received from a peer by @ref Sn_CR_SEND / @ref Sn_CR_SEND6 or @ref Sn_CR_RECV without a connect-process.\n
N *          Before a DATA packet is sent by @ref Sn_CR_SEND / @ref Sn_CR_SEND6,\n
N *          the ARP is requested to the peer specified by @ref _Sn_DIPR_ / @ref _Sn_DIP6R_.\n
N *          In ARP processing, @ref _Sn_SR_ is stll at @ref SOCK_UDP even if @ref Sn_IR_TIMEOUT is set.\n
N *          If you do not have any more need to send or received a DATA packet, \n
N *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_DIP6R_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
N *     getSn_DIPR(), setSn_DIPR(), getSn_DIP6R(), setSn_DIP6R()
N */
N#define SOCK_UDP             (0x22)
N
N/**
N * @brief IPRAW4 SOCKETn mode
N * @details @ref SOCK_IPRAW4(= @ref SOCK_IPRAW) SOCKETn indicates SOCKETn is opened as IPv4 RAW mode.\n
N *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW4 when @ref Sn_CR_OPEN is performed with @ref Sn_MR_IPRAW4. \n
N *          A DATA packet can be send to or received from a peer without a connection like as @ref SOCK_UDP. \n
N *          Before a DATA packet is sent by @ref Sn_CR_SEND, \n
N *          the ARP is requested to the peer specified by @ref _Sn_DIPR_.\n
N *          In ARP processing, @ref _Sn_SR_ is still at @ref SOCK_IPRAW4 even if @ref Sn_IR_TIMEOUT is set.\n
N *          IPRAW4 SOCKETn can receive only the packet specified by @ref _Sn_PNR_, and it discards the others packets.\n
N *          If you do not have any more need to send or received a DATA packet, \n
N *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in IPRAW4 mode such as @ref Sn_MR_IPRAW4.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIPR_, _Sn_PNR_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
N *     getSn_DIPR(), setSn_DIPR(), getSn_PNR(), setSn_PNR() 
N */
N#define SOCK_IPRAW4          (0x32)
N#define SOCK_IPRAW           (SOCK_IPRAW4)   ///< Refer to @ref SOCK_IPRAW4.
N
N/**
N * @brief IPRAW6 SOCKETn mode
N * @details @ref SOCK_IPRAW6 SOCKETn indicates SOCKETn is opened as IPv6 RAW mode.\n
N *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_IPRAW6 when @ref Sn_CR_OPEN is performed with @ref Sn_MR_IPRAW6. \n
N *          A DATA packet can be send to or received from a peer without a connection like as @ref SOCK_UDP.\n
N *          Before a DATA packet is sent by @ref Sn_CR_SEND6, \n
N *          the ICMPv6 NS is requested to the peer specified by @ref _Sn_DIPR_ or @ref _Sn_DIP6R_.\n
N *          In ND(Neighbor Discovery) is processing,\n
N *          @ref _Sn_SR_ is still at @ref SOCK_IPRAW6 even if @ref Sn_IR_TIMEOUT is set.\n
N *          IPRAW6 SOCKETn can receive only the packet specified by @ref _Sn_PNR_, and it discards the others packets.\n
N *          If you do not have any more need to send or received a DATA packet, \n
N *          You can perform @ref Sn_CR_CLOSE and @ref _Sn_SR_ is changed to @ref SOCK_CLOSED.
N * @note It is valid only in IPRAW6 mode such as @ref Sn_MR_IPRAW6.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_, _Sn_DIP6R_, _Sn_PNR_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
N *     getSn_DIP6R(), setSn_DIP6R(), getSn_PNR(), setSn_PNR() 
N */
N#define SOCK_IPRAW6          (0x33)
N
N/**
N * @brief MACRAW SOCKETn mode
N * @details @ref SOCK_MACRAW indicates SOCKET0 is opened as MACRAW mode.\n
N *          @ref _Sn_SR_ is changed from @ref SOCK_CLOSED to @ref SOCK_MACRAW when @ref Sn_CR_OPEN command is ordered with @ref Sn_MR_MACRAW.\n
N *          MACRAW SOCKET0 can be sent or received a pure Ethernet frame packet to/from any peer.
N * @note  It is valid only in SOCKET0.
N * @sa _Sn_SR_, _Sn_CR_, _Sn_IR_, _Sn_IRCLR_, _Sn_MR_
N * @sa getSn_SR, getSn_CR(), getSn_IR(), setSn_IRCLR(), setSn_CR(), getSn_MR(), setSn_MR(),
N */
N#define SOCK_MACRAW          (0x42)
N
N/* Sn_ESR values */
N/**
N * @brief SOCKETn Extended Status : TCP Mode
N * @details @ref Sn_ESR_TCPM masks the TCPM bit of @ref _Sn_ESR_. \n
N *          The masked bit values are as following. \n
N *          - @ref Sn_ESR_TCPM_IPV4
N *          - @ref Sn_ESR_TCPM_IPV6
N * @note It is useful to know the destination IP version when TCPD(@ref Sn_MR_TCPD) mode SOCKETn is operated as <b>TCP SERVER</b>.
N * @sa _Sn_ESR_
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPM          (1<<2)
N
N/**
N * @brief TCP SOCKETn IP version - IPv4
N * @details @ref Sn_ESR_TCPM_IPV4 indicates TCP SOCKETn is operated on IPv4 .
N * @sa _Sn_ESR_, Sn_ESR_TCPM_IPV6
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPM_IPV4     (0<<2)
N
N/**
N * @brief TCP SOCKETn IP version - IPv6
N * @details @ref Sn_ESR_TCPM_IPV6 indicates TCP SOCKETn is operated on IPv6 .
N * @sa _Sn_ESR_, Sn_ESR_TCPM_IPV4
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPM_IPV6     (1<<2)
N
N/**
N * @brief SOCKETn Extended Status : TCP Operation Mode
N * @details @ref Sn_ESR_TCPOP masks the TCPOP bit of @ref _Sn_ESR_. The masked bit values are as following. \n
N *            - @ref Sn_ESR_TCPOP_SVR
N *            - @ref Sn_ESR_TCPOP_CLT
N * @note It is useful to check TCP mode SOCKETn is operated as whether <b>TCP SERVER</b> or <b>TCP CLIENT</b>.
N * @sa _Sn_ESR_
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPOP         (1<<1)
N
N/**
N * @brief TCP SOCKETn Operation Mode - <b>TCP SERVER</b>
N * @details @ref Sn_ESR_TCPOP_SVR indicates TCP mode SOCKET n is operated as <b>TCP SERVER</b>
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_ESR_, Sn_ESR_TCPOP_CLT
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPOP_SVR     (0<<1)
N
N/**
N * @brief TCP SOCKETn Operation Mode - <b>TCP CLIENT</b>
N * @details @ref Sn_ESR_TCPOP_SVR indicates TCP mode SOCKET n is operated as <b>TCP CLIENT</b>
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_ESR_, Sn_ESR_TCPOP_SVR
N * @sa getSn_ESR()
N */
N#define Sn_ESR_TCPOP_CLT     (1<<1)
N
N/**
N * @brief SOCKETn Extended Status : Source IPv6 Address Type
N * @details @ref Sn_ESR_IP6T masks the IP6T bit of @ref _Sn_ESR_. \n
N *          The masked bit values are as following. \n
N *            - @ref Sn_ESR_IP6T_LLA
N *            - @ref Sn_ESR_IP6T_GUA
N * @note It is useful to check whether the connected peer IP address is LLA or GUA.
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6 and @ref Sn_MR_TCPD.
N * @sa _Sn_ESR_
N * @sa getSn_ESR()
N */
N#define Sn_ESR_IP6T          (1<<0)
N
N/**
N * @brief Source IPv6 Address Type - LLA
N * @details @ref Sn_ESR_IP6T_LLA indicates the source IPv6 Address is used as @ref _LLAR_
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_ESR_, Sn_ESR_IP6T_GUA, _LLAR_
N * @sa getSn_ESR(), getLLAR(), setLLAR()
N */
N#define Sn_ESR_IP6T_LLA      (0<<0)
N
N/**
N * @brief Source IPv6 Address Type - LLA
N * @details @ref Sn_ESR_IP6T_GUA indicates the source IPv6 Address is used as @ref _GUAR_
N * @note It is valid only in TCP mode such as @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD.
N * @sa _Sn_ESR_, Sn_ESR_IP6T_LLA, _GUAR_
N * @sa getSn_ESR(), getGUAR(), setGUAR()
N */
N#define Sn_ESR_IP6T_GUA      (1<<0)
N
N/* Sn_MR2 values */
N/**
N * @brief Destination Hardware Address Mode 
N * @details @ref Sn_MR2_DHAM masks the DHAM bit of @ref _Sn_MR2_.\n
N *          The masked bit values are as following.
N *            - @ref Sn_MR2_DHAM_AUTO
N *            - @ref Sn_MR2_DHAM_MANUAL
N * @sa _Sn_MR2_
N * @sa getSn_MR2(), setSn_MR2()
N */
N#define Sn_MR2_DHAM          (1<<1)
N
N/**
N * @brief Destination Hardware Address Mode - AUTO
N * @details @ref Sn_MR2_DHAM_AUTO sets the destination hardware address as the address acquired by ARP-process.
N * @sa _Sn_MR2_, Sn_MR_DHAM_MANUAL, NETMR_DHAS
N * @sa getSn_MR2(), setSn_MR2(), getNETMR(), setNETMR()
N */
N#define Sn_MR2_DHAM_AUTO     (0<<1)
N
N/**
N * @brief Destination Hardware Address Mode - MANUAL
N * @details @ref Sn_MR2_DHAM_MANUAL sets the destination hardware address as @ref _Sn_DHAR_.
N * @sa _Sn_MR2_, Sn_MR_DHAM_MANUAL, NETMR_DHAS
N * @sa getSn_MR2(), setSn_MR2(), getNETMR(), setNETMR()
N */
N#define Sn_MR2_DHAM_MANUAL   (1<<1)
N
N/**
N * @brief Force ARP
N * @details @ref Sn_MR2_FARP force to perform the ARP-process for acquiring the destination hardware address, before data communication\n
N *          0 : Normal \n
N *          1 : Force ARP
N *   - In TCP mode such as @ref Sn_MR_TCP4, @ref Sn_MR_TCP6, and @ref Sn_MR_TCPD
N *     If SOCKETn is operated as <b>TCP SERVER</b>, It sets the destination hardware address as the address 
N *     acquired by the forced ARP-process before sending SYN/ACK packet.
N *   - In UDP mode such as @ref Sn_MR_UDP4, @ref Sn_MR_UDP6, and @ref Sn_MR_UDPD 
N *     It sets the destination hardware address as the address acquired by the forced ARP-process whenever @ref Sn_CR_SEND or @ref Sn_CR_SEND6.
N * @note When @ref Sn_MR2_DHAM_MANUAL and @ref Sn_MR2_FARP = '1', It sets the destination hardware address as @ref _Sn_DHAR_ even if the ARP-process is forced.
N */
N#define Sn_MR2_FARP          (1<<0)
N
N
N/*----------------------------For PHY Control-------------------------------*/
N
N/**
N * @ingroup Common_register_group_W6100
N * @brief Basic Mode Control Register of Ethernet PHY [RW][0x3100]
N * @details @ref PHYRAR_BMCR can be controlled by MDC/MDIO controller of @ref _WIZCHIP_. \n
N *          Each bit of @ref PHYRAR_BMCR is defined as the following.
N * <table>
N *    <tr> <td>15</td>  <td>14</td> <td>13</td>  <td>12 </td>  <td>11</td>  <td>10  </td> <td>9  </td> <td>8  </td> <td>7   </td>  <td>6 ~ 0  </td> </tr>
N *    <tr> <td>RST</td> <td>LB</td> <td>SPD</td> <td>ANE</td> <td>PWDN</td> <td>ISOL</td> <td>RAN</td> <td>DPX</td> <td>COLT</td> <td>Reserved</td> </tr>
N * </table>
N *   - @ref BMCR_RST
N *   - @ref BMCR_LB
N *   - @ref BMCR_SPD
N *   - @ref BMCR_ANE
N *   - @ref BMCR_PWDN
N *   - @ref BMCR_ISOL : Not supported.
N *   - @ref BMCR_REAN
N *   - @ref BMCR_DPX
N *   - @ref BMCR_COLT
N *
N * @note Its some bits have the same function as @ref _PHYCR0_ and @ref _PHYCR1_.\n
N *       It can control the Ethernet PHY with software, while @ref _PHYCR0_ \n
N *       and @ref _PHYCR1_ can control the Ethernet PHY with hardware.
N *       
N * @sa PHYRAR_BMSR, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYCR0_, _PHYCR1_
N * @sa getPHYRAR(), setPHYRAR(), wiz_mdio_read(), wiz_mdio_write()
N */
N#define PHYRAR_BMCR          (0x00)
N
N//Basic mode status register, basic register
N/**
N * @ingroup Common_register_group_W6100
N * @brief Basic Mode Status Register of Ethernet PHY [RO][0x7809]
N * @details @ref PHYRAR_BMSR gets the status of Ethernet PHY through MDC/MDIO controller of @ref _WIZCHIP_. \n
N *          Each bit of @ref PHYRAR_BMSR is defined as the following.
N * <table>
N *    <tr> <td>15</td> <td>14</td> <td>13</td> <td>12</td> <td>11</td> <td>10~7</td> 
N *         <td>6 </td> <td>5 </td> <td>4 </td> <td>3 </td> <td>2 </td> <td>1   </td> <td>0</td> </tr>
N *    <tr> <td>100_T4  </td> <td>100_FDX     </td> <td>100_HDX    </td> <td>10_FDX     </td> <td>10_HDX       </td> <td>Reserved</td> <td>MF_SUP</td> 
N *         <td>ANG_COMP</td> <td>REMOTE_FAULT</td> <td>ANG_ABILITY</td> <td>LINK_STATUS</td> <td>JABBER_DETECT</td> <td>EXT_CAPA</td> </tr>
N * </table>
N *   - @ref BMSR_100_T4        : Not supported. Always 0
N *   - @ref BMSR_100_FDX
N *   - @ref BMSR_100_HDX
N *   - @ref BMSR_10_FDX
N *   - @ref BMSR_10_HDX
N *   - @ref BMSR_MF_SUP        : Not supported. Always 0.
N *   - @ref BMSR_AN_COMP
N *   - @ref BMSR_REMOTE_FAULT  : Not supported. Always 0.
N *   - @ref BMSR_AN_ABILITY
N *   - @ref BMSR_LINK_STATUS
N *   - @ref BMSR_JABBER_DETECT
N *   - @ref BMSR_EXT_CAPA      : Always 1. If you need a extended register information, send e-mail to support@wiznet.io
N *
N * @note Its some bits have the same function as @ref _PHYSR_.
N * @sa PHYRAR_BMCR, _PHYRAR_, _PHYDIR_, _PHYDOR_, _PHYACR_, _PHYCR0_, _PHYCR1_
N * @sa getPHYRAR(), setPHYRAR(), wiz_mdio_read(), wiz_mdio_write()
N */
N#define PHYRAR_BMSR          (0x01)
N
N
N/********************/
N/* BMCR & BMSR Bit definitions  */
N/********************/
N
N/*For BMCR register*/
N/**
N * @brief Ethernet PHY S/W Reset.
N * @details 0 - Normal operation \n
N *          1 - Software reset
N * @sa PHYRAR_BMCR, PHYCR1_RST
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define BMCR_RST             (1<<15)
N
N/**
N * @brief Ethernet PHY Loopback.
N * @details 0 - Normal Operation \n
N *          1 - Loopback Enable
N * @sa PHYRAR_BMCR
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define BMCR_LB              (1<<14)  ///< Loopback. 0 - Noraml operation, 1 - Loopback enabled
N
N/**
N * @brief Ethernet PHY Speed 
N * @details 0 - 10  Mbps \n
N *          1 - 100 Mbps
N * @sa PHYCR_BMCR, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
N */
N#define BMCR_SPD             (1<<13)
N
N/**
N * @brief Ethernet PHY Auto-Negotiation
N * @details 0 - Disable \n
N *          1 - Enable
N * @note When it is set, @ref BMCR_SPD and @ref BMCR_DPX is ignored
N * @sa PHYCR_BMCR, PHYCR0_AUTO
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
N */
N#define BMCR_ANE             (1<<12)
N
N/**
N * @brief Ethernet PHY Power Down Mode
N * @details 0 - Normal Operation \n
N *          1 - Power Down mode
N * @sa PHYCR_BMCR, PHYCR0_PWDN
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
N */
N#define BMCR_PWDN            (1<<11)  ///< Power-down mode
N
N/**
N * @brief Ethernet PHY Isolation Mode
N * @details 0 - Normal Operation \n
N *          1 - Isolation Mode
N * @ Don't set it to '1'. It is not supported.
N * @sa PHYCR_BMCR
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define BMCR_ISOL            (1<<10)
N
N/**
N * @brief Ethernet PHY Restart Auto-Negotiation
N * @details 0 - Normal Operation \n
N *          1 - Restart Auto-Negotiation
N * @sa PHYCR_BMCR
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define BMCR_REAN            (1<<9)
N
N/**
N * @brief Ethernet PHY Duplex 
N * @details 0 - Half-Duplex \n
N *          1 - Full-Duplex
N * @sa PHYCR_BMCR, PHYCR0_100F, PHYCR0_100H, PHYCR0_10F, PHYCR0_10H
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR(), setPHYCR0()
N */
N#define BMCR_DPX             (1<<8)
N
N/**
N * @brief Ethernet PHY Collision Test
N * @details 0 - Normal Operation \n
N *          1 - Collision Test
N * @sa PHYCR_BMCR
N * @sa getPHYRAR_BMCR(), setPHYRAR_BMCR()
N */
N#define BMCR_COLT            (1<<7)
N
N/*For BMSR register*/
N
N/**
N * @brief Ethernet PHY 100 Base-T4 capable
N * @details @ref BMSR_100_T4 is always 0.
N * @note It is not supported. 
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_100_T4          (1<<15)
N
N/**
N * @brief Ethernet PHY 100 Base-TX Full-Duplex capable
N * @details @ref BMSR_100_FDX is always 1.
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_100_FDX         (1<<14)
N
N/**
N * @brief Ethernet PHY 100 Base-TX Half-Duplex capable
N * @details @ref BMSR_100_HDX is always 1.
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_100_HDX         (1<<13)
N
N/**
N * @brief Ethernet PHY 10 Base-T Full-Duplex capable
N * @details @ref BMSR_10_FDX is always 1.
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_10_FDX          (1<<12)
N
N/**
N * @brief Ethernet PHY 10 Base-T Half-Duplex capable
N * @details @ref BMSR_10_HDX is always 1.
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_10_HDX          (1<<11)
N
N/**
N * @brief Ethernet PHY Management Frame preamble suppression
N * @details @ref BMSR_MF_SUP is always 0.
N * @note It is not supported 
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_MF_SUP          (1<<6)
N
N/**
N * @brief Ethernet PHY Auto-Negotiation Complete
N * @details @ref BMSR_MF_SUP indicates the status of auto-negotiation. \n
N *          0 - Auto-negotiation process is not completed \n
N *          1 - Auto-negotiation process is completed
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_AN_COMP         (1<<5)
N
N/**
N * @brief Ethernet PHY Remote Fault
N * @details @ref BMSR_REMOTE_FAULT is always 0.
N * @note It is not supported 
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_REMOTE_FAULT    (1<<4)
N
N/**
N * @brief Ethernet PHY Auto-Negotiation Ability
N * @details @ref BMSR_AN_ABILITY is always 1.
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_AN_ABILITY      (1<<3)
N
N/**
N * @brief Ethernet PHY Link Status
N * @details @ref BMSR_LINK_STATUS indicates the status of link. \n
N *          0 - Link is not established
N *          1 - Valid link is established
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_LINK_STATUS     (1<<2)
N
N/**
N * @brief Ethernet PHY Jabber Detect
N * @details @ref BMSR_JABBER_DETECT indicates the status of auto-negotiation. \n
N *          0 - Jabber condition is not detected\n
N *          1 - Jabber condition is detected
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_JABBER_DETECT   (1<<1)
N
N/**
N * @brief Ethernet PHY Extended capability
N * @details @ref BMSR_EXT_CAPA indicates the extended register capability. \n
N *          0 - Only basic registers are capable\n
N *          1 - Extended registers are capable
N * @sa PHYCR_BMSR
N * @sa getPHYRAR_BMSR()
N */
N#define BMSR_EXT_CAPA        (1<<0)
N
N
N/**
N * @brief Enter a critical section
N * @details It is provided to protect your shared code and hardware resources against interference. \n
N *   - Non-OS environment
N *     It can be just implemented by disabling whole interrupt.
N *   - OS environment
N *     You can replace it to critical section API supported by OS.
N *
N * @note It is callback function that can be replaced it with your code, by calling @ref reg_wizchip_cris_cbfunc(). 
N * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * @sa WIZCHIP_CRITICAL_EXIT(), reg_wizchip_cris_cbfunc()
N */
N#define WIZCHIP_CRITICAL_ENTER()       WIZCHIP.CRIS._e_n_t_e_r_()
N
N
N/**
N * @brief Enter a critical section
N * @details It exits the protected code and hardware resources against interference. \n
N *   - Non-OS environment
N *     It can be just implemented by enabling whole interrupt.\n
N *   - OS environment
N *     You can replace it to critical section API supported by OS.
N *
N * @note It is callback function that can be replaced it with your code, by calling @ref reg_wizchip_cris_cbfunc(). 
N * @sa WIZCHIP_READ(), WIZCHIP_WRITE(), WIZCHIP_READ_BUF(), WIZCHIP_WRITE_BUF()
N * @sa WIZCHIP_CRITICAL_EXIT(), reg_wizchip_cris_cbfunc()
N */
N#define WIZCHIP_CRITICAL_EXIT()        WIZCHIP.CRIS._e_x_i_t_()
N
N
N
N////////////////////////
N// Basic I/O Function //
N////////////////////////
N//
N//
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It reads 1 byte value from a register.
N * @param AddrSel Register address
N * @return The value of register
N * @sa WIZCHIP_READ_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_WRITE()
N */
Nuint8_t WIZCHIP_READ(uint32_t AddrSel);
N
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It writes 1 byte value to a register.
N * @param AddrSel Register address
N * @param wb Write data
N * @return void
N * @sa WIZCHIP_WRITE_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_READ()
N */
Nvoid WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb );
N
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It reads sequentail data from registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to read data
N * @param len Data length
N * @return void
N * @sa WIZCHIP_WRITE_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_READ()
N */
Nvoid WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, datasize_t len);
N
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It writes sequential data to registers.
N * @param AddrSel Register address
N * @param pBuf Pointer buffer to write data
N * @param len Data length
N * @return void
N * @sa WIZCHIP_READ_BUF(), reg_wizchip_bus_cbfunc(), reg_wizchip_spi_cbfunc(), WIZCHIP_WRITE()
N */
Nvoid WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, datasize_t len);
N
N
N
N/////////////////////////////////
N// Common Register IO function //
N/////////////////////////////////
N/**
N * @addtogroup Common_register_access_function_W6100
N * @{
N */
N#define getCIDR() \
N        ((((uint16_t)WIZCHIP_READ(_CIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_CIDR_,1)))
X#define getCIDR()         ((((uint16_t)WIZCHIP_READ(_CIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_CIDR_,1)))
N
N#define getVER() \
N        ((((uint16_t)WIZCHIP_READ(_VER_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VER_,1)))
X#define getVER()         ((((uint16_t)WIZCHIP_READ(_VER_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VER_,1)))
N
N#define getSYSR() \
N        WIZCHIP_READ(_SYSR_)
X#define getSYSR()         WIZCHIP_READ(_SYSR_)
N
N#define getSYCR0() \
N        WIZCHIP_READ(_SYCR0_)
X#define getSYCR0()         WIZCHIP_READ(_SYCR0_)
N
N#define setSYCR0(sycr0) \
N        WIZCHIP_WRITE(_SYCR0_, (sycr0))
X#define setSYCR0(sycr0)         WIZCHIP_WRITE(_SYCR0_, (sycr0))
N
N#define getSYCR1() \
N        WIZCHIP_READ(_SYCR1_)
X#define getSYCR1()         WIZCHIP_READ(_SYCR1_)
N                  
N#define setSYCR1(sycr1) \
N        WIZCHIP_WRITE(_SYCR1_, (sycr1))
X#define setSYCR1(sycr1)         WIZCHIP_WRITE(_SYCR1_, (sycr1))
N
N#define getTCNTR() \
N        ((((uint16_t)WIZCHIP_READ(_TCNTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_TCNTR_,1)))
X#define getTCNTR()         ((((uint16_t)WIZCHIP_READ(_TCNTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_TCNTR_,1)))
N
N#define setTCNTRCLR(tcntrclr) \
N        WIZCHIP_WRITE(_TCNTRCLR_,(tcntrclr))
X#define setTCNTRCLR(tcntrclr)         WIZCHIP_WRITE(_TCNTRCLR_,(tcntrclr))
N
N#define getIR() \
N        WIZCHIP_READ(_IR_)
X#define getIR()         WIZCHIP_READ(_IR_)
N
N#define getSIR() \
N        WIZCHIP_READ(_SIR_)
X#define getSIR()         WIZCHIP_READ(_SIR_)
N
N#define getSLIR() \
N        WIZCHIP_READ(_SLIR_)
X#define getSLIR()         WIZCHIP_READ(_SLIR_)
N
N#define setIMR(imr) \
N        WIZCHIP_WRITE(_IMR_,(imr))
X#define setIMR(imr)         WIZCHIP_WRITE(_IMR_,(imr))
N
N#define getIMR() \
N        WIZCHIP_READ(_IMR_)
X#define getIMR()         WIZCHIP_READ(_IMR_)
N
N#define setIRCLR(irclr) \
N        WIZCHIP_WRITE(_IRCLR_,(irclr))
X#define setIRCLR(irclr)         WIZCHIP_WRITE(_IRCLR_,(irclr))
N#define setIR(ir)                setIRCLR(ir)
N
N#define setSIMR(simr) \
N        WIZCHIP_WRITE(_SIMR_,(simr))
X#define setSIMR(simr)         WIZCHIP_WRITE(_SIMR_,(simr))
N
N#define getSIMR() \
N        WIZCHIP_READ(_SIMR_)
X#define getSIMR()         WIZCHIP_READ(_SIMR_)
N
N#define setSLIMR(slimr) \
N        WIZCHIP_WRITE(_SLIMR_,(slimr))
X#define setSLIMR(slimr)         WIZCHIP_WRITE(_SLIMR_,(slimr))
N
N#define getSLIMR() \
N        WIZCHIP_READ(_SLIMR_)
X#define getSLIMR()         WIZCHIP_READ(_SLIMR_)
N
N#define setSLIRCLR(slirclr) \
N        WIZCHIP_WRITE(_SLIRCLR_,(slirclr))
X#define setSLIRCLR(slirclr)         WIZCHIP_WRITE(_SLIRCLR_,(slirclr))
N#define setSLIR(slir)            setSLIRCLR(slir)
N
N#define setSLPSR(slpsr) \
N        WIZCHIP_WRITE(_SLPSR_,(slpsr))
X#define setSLPSR(slpsr)         WIZCHIP_WRITE(_SLPSR_,(slpsr))
N
N#define getSLPSR() \
N        WIZCHIP_READ(_SLPSR_)
X#define getSLPSR()         WIZCHIP_READ(_SLPSR_)
N
N#define setSLCR(slcr) \
N        WIZCHIP_WRITE(_SLCR_,(slcr))
X#define setSLCR(slcr)         WIZCHIP_WRITE(_SLCR_,(slcr))
N                  
N#define getSLCR()      \
N        WIZCHIP_READ(_SLCR_)
X#define getSLCR()              WIZCHIP_READ(_SLCR_)
N
N#define getPHYSR() \
N        WIZCHIP_READ(_PHYSR_)
X#define getPHYSR()         WIZCHIP_READ(_PHYSR_)
N
N#define setPHYRAR(phyrar) \
N        WIZCHIP_WRITE(_PHYRAR_,(phyrar))
X#define setPHYRAR(phyrar)         WIZCHIP_WRITE(_PHYRAR_,(phyrar))
N
N#define getPHYRAR() \
N        WIZCHIP_READ(_PHYRAR_)
X#define getPHYRAR()         WIZCHIP_READ(_PHYRAR_)
N
N#define setPHYDIR(phydir)  \
N        do{                                                                       \
N           WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PHYDIR_,1), (uint8_t)((phydir)>>8)); \
N           WIZCHIP_WRITE(_PHYDIR_, (uint8_t)(phydir));                            \
N        }while(0);
X#define setPHYDIR(phydir)          do{                                                                                  WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PHYDIR_,1), (uint8_t)((phydir)>>8));            WIZCHIP_WRITE(_PHYDIR_, (uint8_t)(phydir));                                    }while(0);
N
N#define getPHYDOR() \
N        ((((uint16_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PHYDOR_,1))) << 8) + WIZCHIP_READ(_PHYDOR_))
X#define getPHYDOR()         ((((uint16_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PHYDOR_,1))) << 8) + WIZCHIP_READ(_PHYDOR_))
N
N#define setPHYACR(phyacr) \
N        WIZCHIP_WRITE(_PHYACR_,(phyacr))
X#define setPHYACR(phyacr)         WIZCHIP_WRITE(_PHYACR_,(phyacr))
N
N#define getPHYACR() \
N        WIZCHIP_READ(_PHYACR_)
X#define getPHYACR()         WIZCHIP_READ(_PHYACR_)
N
N#define setPHYDIVR(phydivr) \
N        WIZCHIP_WRITE(_PHYDIVR_,(phydivr))
X#define setPHYDIVR(phydivr)         WIZCHIP_WRITE(_PHYDIVR_,(phydivr))
N
N#define getPHYDIVR() \
N        WIZCHIP_READ(_PHYDIVR_)
X#define getPHYDIVR()         WIZCHIP_READ(_PHYDIVR_)
N
N#define setPHYCR0(phycr0) \
N        WIZCHIP_WRITE(_PHYCR0_,(phycr0))
X#define setPHYCR0(phycr0)         WIZCHIP_WRITE(_PHYCR0_,(phycr0))
N
N#define setPHYCR1(phycr1) \
N        WIZCHIP_WRITE(_PHYCR1_,(phycr1))
X#define setPHYCR1(phycr1)         WIZCHIP_WRITE(_PHYCR1_,(phycr1))
N
N#define getPHYCR1() \
N        WIZCHIP_READ(_PHYCR1_)
X#define getPHYCR1()         WIZCHIP_READ(_PHYCR1_)
N
N#define setNET4MR(net4mr) \
N        WIZCHIP_WRITE(_NET4MR_,(net4mr))
X#define setNET4MR(net4mr)         WIZCHIP_WRITE(_NET4MR_,(net4mr))
N
N#define setNET6MR(net6mr) \
N        WIZCHIP_WRITE(_NET6MR_,(net6mr))
X#define setNET6MR(net6mr)         WIZCHIP_WRITE(_NET6MR_,(net6mr))
N
N#define setNETMR(netmr) \
N        WIZCHIP_WRITE(_NETMR_,(netmr))
X#define setNETMR(netmr)         WIZCHIP_WRITE(_NETMR_,(netmr))
N
N#define setNETMR2(netmr2) \
N        WIZCHIP_WRITE(_NETMR2_,(netmr2))
X#define setNETMR2(netmr2)         WIZCHIP_WRITE(_NETMR2_,(netmr2))
N
N#define getNET4MR() \
N        WIZCHIP_READ(_NET4MR_)
X#define getNET4MR()         WIZCHIP_READ(_NET4MR_)
N
N#define getNET6MR() \
N        WIZCHIP_READ(_NET6MR_)
X#define getNET6MR()         WIZCHIP_READ(_NET6MR_)
N
N#define getNETMR() \
N        WIZCHIP_READ(_NETMR_)
X#define getNETMR()         WIZCHIP_READ(_NETMR_)
N
N#define getNETMR2() \
N        WIZCHIP_READ(_NETMR2_)
X#define getNETMR2()         WIZCHIP_READ(_NETMR2_)
N
N#define setPTMR(ptmr) \
N        WIZCHIP_WRITE(_PTMR_, (ptmr))
X#define setPTMR(ptmr)         WIZCHIP_WRITE(_PTMR_, (ptmr))
N
N#define getPTMR() \
N        WIZCHIP_READ(_PTMR_)
X#define getPTMR()         WIZCHIP_READ(_PTMR_)
N
N#define setPMNR(pmnr) \
N        WIZCHIP_WRITE(_PMNR_, (pmnr))
X#define setPMNR(pmnr)         WIZCHIP_WRITE(_PMNR_, (pmnr))
N
N#define getPMNR() \
N        WIZCHIP_READ(_PMNR_)
X#define getPMNR()         WIZCHIP_READ(_PMNR_)
N
N#define setPHAR(phar) \
N        WIZCHIP_WRITE_BUF(_PHAR_,(phar),6)
X#define setPHAR(phar)         WIZCHIP_WRITE_BUF(_PHAR_,(phar),6)
N
N#define getPHAR(phar) \
N        WIZCHIP_READ_BUF(_PHAR_,(phar),6)
X#define getPHAR(phar)         WIZCHIP_READ_BUF(_PHAR_,(phar),6)
N
N#define setPSIDR(psidr) \
N        do{                                                                \
N            WIZCHIP_WRITE(_PSIDR_,(uint8_t)((psidr) >> 8));                \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PSIDR_,1),(uint8_t)(psidr)); \
N        }while(0);
X#define setPSIDR(psidr)         do{                                                                            WIZCHIP_WRITE(_PSIDR_,(uint8_t)((psidr) >> 8));                            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PSIDR_,1),(uint8_t)(psidr));         }while(0);
N
N#define getPSIDR() \
N        ((((uint16_t)WIZCHIP_READ(_PSIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PSIDR_,1)))
X#define getPSIDR()         ((((uint16_t)WIZCHIP_READ(_PSIDR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PSIDR_,1)))
N
N#define setPMRUR(pmrur) \
N        do{                                                                \
N            WIZCHIP_WRITE(_PMRUR_,(uint8_t)((pmrur) >> 8));                \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PMRUR_,1),(uint8_t)(pmrur)); \
N        }while(0);
X#define setPMRUR(pmrur)         do{                                                                            WIZCHIP_WRITE(_PMRUR_,(uint8_t)((pmrur) >> 8));                            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PMRUR_,1),(uint8_t)(pmrur));         }while(0);
N
N#define getPMRUR() \
N        ((((uint16_t)WIZCHIP_READ(_PMRUR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PMRUR_,1)))
X#define getPMRUR()         ((((uint16_t)WIZCHIP_READ(_PMRUR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PMRUR_,1)))
N
N#define setSHAR(shar) \
N        WIZCHIP_WRITE_BUF(_SHAR_,(shar),6)
X#define setSHAR(shar)         WIZCHIP_WRITE_BUF(_SHAR_,(shar),6)
N
N#define getSHAR(shar) \
N        WIZCHIP_READ_BUF(_SHAR_,(shar),6)
X#define getSHAR(shar)         WIZCHIP_READ_BUF(_SHAR_,(shar),6)
N
N#define setGAR(gar) \
N        WIZCHIP_WRITE_BUF(_GAR_,(gar),4)
X#define setGAR(gar)         WIZCHIP_WRITE_BUF(_GAR_,(gar),4)
N
N#define getGAR(gar) \
N        WIZCHIP_READ_BUF(_GAR_,(gar),4)
X#define getGAR(gar)         WIZCHIP_READ_BUF(_GAR_,(gar),4)
N
N#define setGA4R(ga4r)            setGAR(ga4r)
N#define getGA4R(ga4r)            getGAR(ga4r)
N
N#define setSUBR(subr) \
N        WIZCHIP_WRITE_BUF(_SUBR_,(subr),4)
X#define setSUBR(subr)         WIZCHIP_WRITE_BUF(_SUBR_,(subr),4)
N
N#define getSUBR(subr) \
N        WIZCHIP_READ_BUF(_SUBR_,(subr),4)
X#define getSUBR(subr)         WIZCHIP_READ_BUF(_SUBR_,(subr),4)
N
N#define setSUB4R(sub4r)          setSUBR(sub4r)
N#define getSUB4R(sub4r)          getSUBR(sub4r)
N
N#define setSIPR(sipr) \
N        WIZCHIP_WRITE_BUF(_SIPR_,(sipr),4)
X#define setSIPR(sipr)         WIZCHIP_WRITE_BUF(_SIPR_,(sipr),4)
N
N#define getSIPR(sipr) \
N        WIZCHIP_READ_BUF(_SIPR_,(sipr),4)
X#define getSIPR(sipr)         WIZCHIP_READ_BUF(_SIPR_,(sipr),4)
N
N#define setLLAR(llar) \
N        WIZCHIP_WRITE_BUF(_LLAR_,(llar),16)
X#define setLLAR(llar)         WIZCHIP_WRITE_BUF(_LLAR_,(llar),16)
N
N#define getLLAR(llar) \
N        WIZCHIP_READ_BUF(_LLAR_,(llar),16)
X#define getLLAR(llar)         WIZCHIP_READ_BUF(_LLAR_,(llar),16)
N
N#define setGUAR(guar) \
N        WIZCHIP_WRITE_BUF(_GUAR_,(guar),16)
X#define setGUAR(guar)         WIZCHIP_WRITE_BUF(_GUAR_,(guar),16)
N
N#define getGUAR(guar) \
N        WIZCHIP_READ_BUF(_GUAR_,(guar),16)
X#define getGUAR(guar)         WIZCHIP_READ_BUF(_GUAR_,(guar),16)
N
N#define setSUB6R(sub6r) \
N        WIZCHIP_WRITE_BUF(_SUB6R_,(sub6r),16)
X#define setSUB6R(sub6r)         WIZCHIP_WRITE_BUF(_SUB6R_,(sub6r),16)
N
N#define getSUB6R(sub6r) \
N        WIZCHIP_READ_BUF(_SUB6R_,(sub6r),16)
X#define getSUB6R(sub6r)         WIZCHIP_READ_BUF(_SUB6R_,(sub6r),16)
N
N#define setGA6R(ga6r) \
N        WIZCHIP_WRITE_BUF(_GA6R_,(ga6r),16)
X#define setGA6R(ga6r)         WIZCHIP_WRITE_BUF(_GA6R_,(ga6r),16)
N
N#define getGA6R(ga6r) \
N        WIZCHIP_READ_BUF(_GA6R_,(ga6r),16)
X#define getGA6R(ga6r)         WIZCHIP_READ_BUF(_GA6R_,(ga6r),16)
N
N#define setSLDIPR(sldipr) \
N        WIZCHIP_WRITE_BUF(_SLDIPR_,(sldipr),4)
X#define setSLDIPR(sldipr)         WIZCHIP_WRITE_BUF(_SLDIPR_,(sldipr),4)
N#define setSLDIP4R(sldip4r)      setSLDIPR((sldip4r))
N
N#define getSLDIPR(sldipr) \
N        WIZCHIP_READ_BUF(_SLDIPR_,(sldipr),4)
X#define getSLDIPR(sldipr)         WIZCHIP_READ_BUF(_SLDIPR_,(sldipr),4)
N#define getSLDIP4R(sldip4r)      getSLDIPR((sldip4r))
N
N#define setSLDIP6R(sldip6r) \
N        WIZCHIP_WRITE_BUF(_SLDIP6R_, (sldip6r),16)
X#define setSLDIP6R(sldip6r)         WIZCHIP_WRITE_BUF(_SLDIP6R_, (sldip6r),16)
N
N#define getSLDIP6R(sldip6r) \
N        WIZCHIP_READ_BUF(_SLDIP6R_,(sldip6r),16)
X#define getSLDIP6R(sldip6r)         WIZCHIP_READ_BUF(_SLDIP6R_,(sldip6r),16)
N
N#define getSLDHAR(sldhar) \
N        WIZCHIP_READ_BUF(_SLDHAR_,(sldhar),6)
X#define getSLDHAR(sldhar)         WIZCHIP_READ_BUF(_SLDHAR_,(sldhar),6)
N
N#define setPINGIDR(pingidr) \
N        do{                                                                    \
N            WIZCHIP_WRITE(_PINGIDR_,(uint8_t)((pingidr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGIDR_,1),(uint8_t)(pingidr)); \
N        }while(0);
X#define setPINGIDR(pingidr)         do{                                                                                WIZCHIP_WRITE(_PINGIDR_,(uint8_t)((pingidr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGIDR_,1),(uint8_t)(pingidr));         }while(0);
N
N#define getPINGIDR() \
N        (((int16_t)(WIZCHIP_READ(_PINGIDR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGIDR_,1)))
X#define getPINGIDR()         (((int16_t)(WIZCHIP_READ(_PINGIDR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGIDR_,1)))
N
N#define setPINGSEQR(pingseqr) \
N        do{                                                                      \
N            WIZCHIP_WRITE(_PINGSEQR_,(uint8_t)((pingseqr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGSEQR_,1),(uint8_t)(pingseqr)); \
N        }while(0);
X#define setPINGSEQR(pingseqr)         do{                                                                                  WIZCHIP_WRITE(_PINGSEQR_,(uint8_t)((pingseqr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_PINGSEQR_,1),(uint8_t)(pingseqr));         }while(0);
N
N#define getPINGSEQR() \
N        (((int16_t)(WIZCHIP_READ(_PINGSEQR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGSEQR_,1)))
X#define getPINGSEQR()         (((int16_t)(WIZCHIP_READ(_PINGSEQR_) << 8)) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PINGSEQR_,1)))
N
N#define getUIPR(uipr) \
N        WIZCHIP_READ_BUF(_UIPR_, (uipr), 4)
X#define getUIPR(uipr)         WIZCHIP_READ_BUF(_UIPR_, (uipr), 4)
N
N#define getUIP4R(uip4r)          getUIPR(uip4r)
N
N#define getUPORTR() \
N        ((((uint16_t)WIZCHIP_READ(_UPORTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORTR_,1)))
X#define getUPORTR()         ((((uint16_t)WIZCHIP_READ(_UPORTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORTR_,1)))
N
N#define getUPORT4R()             getUPORTR()
N
N#define getUIP6R(uip6r) \
N        WIZCHIP_READ_BUF(_UIP6R_,(uip6r),16)
X#define getUIP6R(uip6r)         WIZCHIP_READ_BUF(_UIP6R_,(uip6r),16)
N
N#define getUPORT6R(uport6r) \
N        ((((uint16_t)WIZCHIP_READ(_UPORT6R_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORT6R_,1)))
X#define getUPORT6R(uport6r)         ((((uint16_t)WIZCHIP_READ(_UPORT6R_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_UPORT6R_,1)))
N
N#define setINTPTMR(intptmr) \
N        do{                                                                     \
N            WIZCHIP_WRITE(_INTPTMR_,(uint8_t)((intptmr) >> 8));                 \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_INTPTMR_,1),(uint8_t)(intptmr));  \
N       }while(0);
X#define setINTPTMR(intptmr)         do{                                                                                 WIZCHIP_WRITE(_INTPTMR_,(uint8_t)((intptmr) >> 8));                             WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_INTPTMR_,1),(uint8_t)(intptmr));         }while(0);
N
N#define getINTPTMR() \
N        ((((uint16_t)WIZCHIP_READ(_INTPTMR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_INTPTMR_,1)))
X#define getINTPTMR()         ((((uint16_t)WIZCHIP_READ(_INTPTMR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_INTPTMR_,1)))
N
N#define getPLR() \
N        WIZCHIP_READ(_PLR_)
X#define getPLR()         WIZCHIP_READ(_PLR_)
N
N#define getPFR() \
N        WIZCHIP_READ(_PFR_)
X#define getPFR()         WIZCHIP_READ(_PFR_)
N
N#define getVLTR() \
N        ( (((uint32_t)WIZCHIP_READ(_VLTR_)) << 24) +                       \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,1))) << 16) + \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,2))) << 16) + \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,3))) << 16) )
X#define getVLTR()         ( (((uint32_t)WIZCHIP_READ(_VLTR_)) << 24) +                                 (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,1))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,2))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_VLTR_,3))) << 16) )
N
N#define getPLTR() \
N        ( (((uint32_t)WIZCHIP_READ(_PLTR_)) << 24) +                       \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,1))) << 16) + \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,2))) << 16) + \
N          (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,3))) << 16) )
X#define getPLTR()         ( (((uint32_t)WIZCHIP_READ(_PLTR_)) << 24) +                                 (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,1))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,2))) << 16) +           (((uint32_t)WIZCHIP_READ(WIZCHIP_OFFSET_INC(_PLTR_,3))) << 16) )
N
N#define getPAR(par) \
N        WIZCHIP_READ_BUF(_PAR_, (par), 16)
X#define getPAR(par)         WIZCHIP_READ_BUF(_PAR_, (par), 16)
N
N#define setICMP6BLKR(icmp6blkr) \
N        WIZCHIP_WRITE(_ICMP6BLKR_,(icmp6blkr))
X#define setICMP6BLKR(icmp6blkr)         WIZCHIP_WRITE(_ICMP6BLKR_,(icmp6blkr))
N
N#define getICMP6BLKR() \
N        WIZCHIP_READ(_ICMP6BLKR_)
X#define getICMP6BLKR()         WIZCHIP_READ(_ICMP6BLKR_)
N
N#define setCHPLCKR(chplckr) \
N        WIZCHIP_WRITE(_CHPLCKR_, (chplckr))
X#define setCHPLCKR(chplckr)         WIZCHIP_WRITE(_CHPLCKR_, (chplckr))
N
N#define getCHPLCKR() \
N        ((getSYSR() & SYSR_CHPL) >> 7)
X#define getCHPLCKR()         ((getSYSR() & SYSR_CHPL) >> 7)
N
N#define CHIPLOCK()      setCHPLCKR(0xFF)
N#define CHIPUNLOCK()    setCHPLCKR(0xCE)
N
N#define setNETLCKR(netlckr) \
N        WIZCHIP_WRITE(_NETLCKR_, (netlckr))
X#define setNETLCKR(netlckr)         WIZCHIP_WRITE(_NETLCKR_, (netlckr))
N
N#define getNETLCKR() \
N        ((getSYSR() & SYSR_NETL) >> 6)
X#define getNETLCKR()         ((getSYSR() & SYSR_NETL) >> 6)
N
N#define NETLOCK()      setNETLCKR(0xC5)
N#define NETUNLOCK()    setNETLCKR(0x3A)
N
N#define setPHYLCKR(phylckr) \
N        WIZCHIP_WRITE(_PHYLCKR_,(phylckr))
X#define setPHYLCKR(phylckr)         WIZCHIP_WRITE(_PHYLCKR_,(phylckr))
N
N#define getPHYLCKR() \
N        ((getSYSR() & SYSR_PHYL) >> 5)
X#define getPHYLCKR()         ((getSYSR() & SYSR_PHYL) >> 5)
N
N#define PHYLOCK()      setPHYLCKR(0xFF)
N#define PHYUNLOCK()    setPHYLCKR(0x53)
N
N#define setRTR(rtr) \
N        do{                                                            \
N            WIZCHIP_WRITE(_RTR_,(uint8_t)((rtr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_RTR_,1),(uint8_t)(rtr)); \
N        }while(0);
X#define setRTR(rtr)         do{                                                                        WIZCHIP_WRITE(_RTR_,(uint8_t)((rtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_RTR_,1),(uint8_t)(rtr));         }while(0);
N
N#define getRTR() \
N        ((((uint16_t)WIZCHIP_READ(_RTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_RTR_,1)))
X#define getRTR()         ((((uint16_t)WIZCHIP_READ(_RTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_RTR_,1)))
N
N#define setRCR(rcr) \
N        WIZCHIP_WRITE(_RCR_,(rcr))
X#define setRCR(rcr)         WIZCHIP_WRITE(_RCR_,(rcr))
N
N#define getRCR() \
N        WIZCHIP_READ(_RCR_)
X#define getRCR()         WIZCHIP_READ(_RCR_)
N
N#define setSLRTR(slrtr) \
N        do{                                                                \
N            WIZCHIP_WRITE(_SLRTR_,(uint8_t)((slrtr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_SLRTR_,1),(uint8_t)(slrtr)); \
N        }while(0);
X#define setSLRTR(slrtr)         do{                                                                            WIZCHIP_WRITE(_SLRTR_,(uint8_t)((slrtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_SLRTR_,1),(uint8_t)(slrtr));         }while(0);
N
N#define getSLRTR() \
N        ((((uint16_t)WIZCHIP_READ(_SLRTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_SLRTR_,1)))
X#define getSLRTR()         ((((uint16_t)WIZCHIP_READ(_SLRTR_)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_SLRTR_,1)))
N
N#define setSLRCR(slrcr) \
N        WIZCHIP_WRITE(_SLRCR_,(slrcr))
X#define setSLRCR(slrcr)         WIZCHIP_WRITE(_SLRCR_,(slrcr))
N
N#define getSLRCR() \
N        WIZCHIP_READ(_SLRCR_)
X#define getSLRCR()         WIZCHIP_READ(_SLRCR_)
N
N#define setSLHOPR(slhopr) \
N        WIZCHIP_WRITE(_SLHOPR_,(slhopr))
X#define setSLHOPR(slhopr)         WIZCHIP_WRITE(_SLHOPR_,(slhopr))
N
N#define getSLHOPR() \
N        WIZCHIP_READ(_SLHOPR_)
X#define getSLHOPR()         WIZCHIP_READ(_SLHOPR_)
N/**
N * @}
N */
N
N
N////////////////////////////////////
N// SOCKETn  register I/O function //
N////////////////////////////////////
N/**
N * @addtogroup Socket_register_access_function_W6100
N * @{
N */
N#define setSn_MR(sn,mr) \
N        WIZCHIP_WRITE(_Sn_MR_(sn),(mr))
X#define setSn_MR(sn,mr)         WIZCHIP_WRITE(_Sn_MR_(sn),(mr))
N#define getSn_MR(sn) \
N        WIZCHIP_READ(_Sn_MR_(sn))
X#define getSn_MR(sn)         WIZCHIP_READ(_Sn_MR_(sn))
N
N#define setSn_PSR(sn,psr) \
N        WIZCHIP_WRITE(_Sn_PSR_(sn),(psr))
X#define setSn_PSR(sn,psr)         WIZCHIP_WRITE(_Sn_PSR_(sn),(psr))
N#define getSn_PSR(sn) \
N        WIZCHIP_READ(_Sn_PSR_(sn))
X#define getSn_PSR(sn)         WIZCHIP_READ(_Sn_PSR_(sn))
N
N#define setSn_CR(sn,cr) \
N        WIZCHIP_WRITE(_Sn_CR_(sn),(cr))
X#define setSn_CR(sn,cr)         WIZCHIP_WRITE(_Sn_CR_(sn),(cr))
N#define getSn_CR(sn) \
N        WIZCHIP_READ(_Sn_CR_(sn))
X#define getSn_CR(sn)         WIZCHIP_READ(_Sn_CR_(sn))
N
N#define getSn_IR(sn) \
N        WIZCHIP_READ(_Sn_IR_(sn))
X#define getSn_IR(sn)         WIZCHIP_READ(_Sn_IR_(sn))
N
N#define setSn_IMR(sn,imr) \
N        WIZCHIP_WRITE(_Sn_IMR_(sn),(imr))
X#define setSn_IMR(sn,imr)         WIZCHIP_WRITE(_Sn_IMR_(sn),(imr))
N#define getSn_IMR(sn) \
N        WIZCHIP_READ(_Sn_IMR_(sn))
X#define getSn_IMR(sn)         WIZCHIP_READ(_Sn_IMR_(sn))
N
N#define setSn_IRCLR(sn,irclr) \
N        WIZCHIP_WRITE(_Sn_IRCLR_(sn),(irclr))
X#define setSn_IRCLR(sn,irclr)         WIZCHIP_WRITE(_Sn_IRCLR_(sn),(irclr))
N#define setSn_IR(sn,ir)          setSn_IRCLR(sn,(ir))
N
N#define getSn_SR(sn) \
N        WIZCHIP_READ(_Sn_SR_(sn))
X#define getSn_SR(sn)         WIZCHIP_READ(_Sn_SR_(sn))
N
N#define getSn_ESR(sn) \
N        WIZCHIP_READ(_Sn_ESR_(sn))
X#define getSn_ESR(sn)         WIZCHIP_READ(_Sn_ESR_(sn))
N
N#define setSn_PNR(sn,pnr) \
N        WIZCHIP_WRITE(_Sn_PNR_(sn),(pnr))
X#define setSn_PNR(sn,pnr)         WIZCHIP_WRITE(_Sn_PNR_(sn),(pnr))
N#define setSn_NHR(sn,nhr)        setSn_PNR(_Sn_PNR_(sn),(nhr))
N
N#define getSn_PNR(sn) \
N        WIZCHIP_READ(_Sn_PNR_(sn))
X#define getSn_PNR(sn)         WIZCHIP_READ(_Sn_PNR_(sn))
N#define getSn_NHR(sn)            getSn_PNR(sn)
N
N#define setSn_TOSR(sn,tosr) \
N        WIZCHIP_WRITE(_Sn_TOSR_(sn),(tosr))
X#define setSn_TOSR(sn,tosr)         WIZCHIP_WRITE(_Sn_TOSR_(sn),(tosr))
N#define getSn_TOSR(sn) \
N        WIZCHIP_READ(_Sn_TOSR_(sn))
X#define getSn_TOSR(sn)         WIZCHIP_READ(_Sn_TOSR_(sn))
N
N#define setSn_TTLR(sn,ttlr) \
N        WIZCHIP_WRITE(_Sn_TTLR_(sn),(ttlr))
X#define setSn_TTLR(sn,ttlr)         WIZCHIP_WRITE(_Sn_TTLR_(sn),(ttlr))
N#define getSn_TTLR(sn) \
N        WIZCHIP_READ(_Sn_TTLR_(sn))
X#define getSn_TTLR(sn)         WIZCHIP_READ(_Sn_TTLR_(sn))
N
N#define setSn_HOPR(sn,hopr)      setSn_TTLR(sn),(ttlr))
N#define getSn_HOPR(sn)           getSn_TTLR(sn)
N
N#define setSn_FRGR(sn,frgr) \
N        do{                                                                      \
N            WIZCHIP_WRITE(_Sn_FRGR_(sn),(uint8_t)((frgr)>>8));                   \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1),(uint8_t)(frgr));  \
N        }while(0);
X#define setSn_FRGR(sn,frgr)         do{                                                                                  WIZCHIP_WRITE(_Sn_FRGR_(sn),(uint8_t)((frgr)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1),(uint8_t)(frgr));          }while(0);
N#define getSn_FRGR(sn,frgr) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_FRGR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1)))
X#define getSn_FRGR(sn,frgr)         ((((uint16_t)WIZCHIP_READ(_Sn_FRGR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_FRGR_(sn),1)))
N
N#define setSn_MSSR(sn,mssr) \
N        do{                                                                      \
N            WIZCHIP_WRITE(_Sn_MSSR_(sn),(uint8_t)((mssr)>>8));                   \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1),(uint8_t)(mssr));  \
N        }while(0);
X#define setSn_MSSR(sn,mssr)         do{                                                                                  WIZCHIP_WRITE(_Sn_MSSR_(sn),(uint8_t)((mssr)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1),(uint8_t)(mssr));          }while(0);
N#define getSn_MSSR(sn) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_MSSR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1)))
X#define getSn_MSSR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_MSSR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_MSSR_(sn),1)))
N
N#define setSn_PORTR(sn,portr) \
N        do{                                                                       \
N            WIZCHIP_WRITE(_Sn_PORTR_(sn),(uint8_t)((portr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1),(uint8_t)(portr)); \
N        }while(0);
X#define setSn_PORTR(sn,portr)         do{                                                                                   WIZCHIP_WRITE(_Sn_PORTR_(sn),(uint8_t)((portr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1),(uint8_t)(portr));         }while(0);
N#define getSn_PORTR(sn) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_PORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1)))
X#define getSn_PORTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_PORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_PORTR_(sn),1)))
N
N#define setSn_DHAR(sn,dhar) \
N        WIZCHIP_WRITE_BUF(_Sn_DHAR_(sn),(dhar),6)
X#define setSn_DHAR(sn,dhar)         WIZCHIP_WRITE_BUF(_Sn_DHAR_(sn),(dhar),6)
N#define getSn_DHAR(sn,dhar) \
N        WIZCHIP_READ_BUF(_Sn_DHAR_(sn),(dhar),6)
X#define getSn_DHAR(sn,dhar)         WIZCHIP_READ_BUF(_Sn_DHAR_(sn),(dhar),6)
N
N#define setSn_DIPR(sn,dipr) \
N        WIZCHIP_WRITE_BUF(_Sn_DIPR_(sn),(dipr),4)
X#define setSn_DIPR(sn,dipr)         WIZCHIP_WRITE_BUF(_Sn_DIPR_(sn),(dipr),4)
N#define getSn_DIPR(sn,dipr) \
N        WIZCHIP_READ_BUF(_Sn_DIPR_(sn),(dipr),4)
X#define getSn_DIPR(sn,dipr)         WIZCHIP_READ_BUF(_Sn_DIPR_(sn),(dipr),4)
N
N#define setSn_DIP4R(sn,dipr)      setSn_DIPR(sn,(dipr))
N#define getSn_DIP4R(sn,dipr)      getSn_DIPR(sn,(dipr))
N
N#define setSn_DIP6R(sn,dip6r) \
N        WIZCHIP_WRITE_BUF(_Sn_DIP6R_(sn),(dip6r),16)
X#define setSn_DIP6R(sn,dip6r)         WIZCHIP_WRITE_BUF(_Sn_DIP6R_(sn),(dip6r),16)
N#define getSn_DIP6R(sn,dip6r) \
N        WIZCHIP_READ_BUF(_Sn_DIP6R_(sn),(dip6r),16)
X#define getSn_DIP6R(sn,dip6r)         WIZCHIP_READ_BUF(_Sn_DIP6R_(sn),(dip6r),16)
N
N#define setSn_DPORTR(sn,dportr) \
N        do{                                                                         \
N            WIZCHIP_WRITE(_Sn_DPORTR_(sn),(uint8_t)((dportr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1),(uint8_t)(dportr)); \
N        }while(0);
X#define setSn_DPORTR(sn,dportr)         do{                                                                                     WIZCHIP_WRITE(_Sn_DPORTR_(sn),(uint8_t)((dportr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1),(uint8_t)(dportr));         }while(0);
N#define getSn_DPORTR(sn) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_DPORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1)))
X#define getSn_DPORTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_DPORTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_DPORTR_(sn),1)))
N
N#define setSn_MR2(sn,mr2) \
N        WIZCHIP_WRITE(_Sn_MR2_(sn),(mr2))
X#define setSn_MR2(sn,mr2)         WIZCHIP_WRITE(_Sn_MR2_(sn),(mr2))
N#define getSn_MR2(sn) \
N        WIZCHIP_READ(_Sn_MR2_(sn))
X#define getSn_MR2(sn)         WIZCHIP_READ(_Sn_MR2_(sn))
N
N#define setSn_RTR(sn,rtr) \
N        do{                                                                   \
N            WIZCHIP_WRITE(_Sn_RTR_(sn),(uint8_t)((rtr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1),(uint8_t)(rtr)); \
N        }while(0);
X#define setSn_RTR(sn,rtr)         do{                                                                               WIZCHIP_WRITE(_Sn_RTR_(sn),(uint8_t)((rtr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1),(uint8_t)(rtr));         }while(0);
N#define getSn_RTR(sn) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_RTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1)))
X#define getSn_RTR(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_RTR_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RTR_(sn),1)))
N
N#define setSn_RCR(sn,rcr) \
N        WIZCHIP_WRITE(_Sn_RCR_(sn),(rcr))
X#define setSn_RCR(sn,rcr)         WIZCHIP_WRITE(_Sn_RCR_(sn),(rcr))
N#define getSn_RCR(sn) \
N        WIZCHIP_READ(_Sn_RCR_(sn))
X#define getSn_RCR(sn)         WIZCHIP_READ(_Sn_RCR_(sn))
N
N#define setSn_KPALVTR(sn,kpalvtr) \
N        WIZCHIP_WRITE(_Sn_KPALVTR_(sn),(kpalvtr))
X#define setSn_KPALVTR(sn,kpalvtr)         WIZCHIP_WRITE(_Sn_KPALVTR_(sn),(kpalvtr))
N#define getSn_KPALVTR(sn) \
N        WIZCHIP_READ(_Sn_KPALVTR_(sn))
X#define getSn_KPALVTR(sn)         WIZCHIP_READ(_Sn_KPALVTR_(sn))
N
N#define setSn_TX_BSR(sn, tmsr) \
N        WIZCHIP_WRITE(_Sn_TX_BSR_(sn),(tmsr))
X#define setSn_TX_BSR(sn, tmsr)         WIZCHIP_WRITE(_Sn_TX_BSR_(sn),(tmsr))
N#define setSn_TXBUF_SIZE(sn, tmsr)      setSn_TX_BSR(sn,(tmsr))
N
N#define getSn_TX_BSR(sn) \
N        WIZCHIP_READ(_Sn_TX_BSR_(sn))
X#define getSn_TX_BSR(sn)         WIZCHIP_READ(_Sn_TX_BSR_(sn))
N#define getSn_TXBUF_SIZE(sn)            getSn_TX_BSR(sn)
N              
N#define getSn_TxMAX(sn) \
N	  (getSn_TX_BSR(sn) << 10)
X#define getSn_TxMAX(sn) 	  (getSn_TX_BSR(sn) << 10)
N
Ndatasize_t getSn_TX_FSR(uint8_t sn);
N
N#define getSn_TX_RD(sn) \
N        ((((uint16_t)WIZCHIP_READ(_Sn_TX_RD_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_RD_(sn),1)))
X#define getSn_TX_RD(sn)         ((((uint16_t)WIZCHIP_READ(_Sn_TX_RD_(sn))) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_RD_(sn),1)))
N
N#define setSn_TX_WR(sn,txwr) \
N        do{                                                                       \
N            WIZCHIP_WRITE(_Sn_TX_WR_(sn), (uint8_t)((txwr)>>8));                  \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1), (uint8_t)(txwr)); \
N        }while(0);
X#define setSn_TX_WR(sn,txwr)         do{                                                                                   WIZCHIP_WRITE(_Sn_TX_WR_(sn), (uint8_t)((txwr)>>8));                              WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1), (uint8_t)(txwr));         }while(0);
N#define getSn_TX_WR(sn) \
N        (((uint16_t)WIZCHIP_READ(_Sn_TX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1)))
X#define getSn_TX_WR(sn)         (((uint16_t)WIZCHIP_READ(_Sn_TX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_WR_(sn),1)))
N
N#define setSn_RX_BSR(sn,rmsr) \
N        WIZCHIP_WRITE(_Sn_RX_BSR_(sn),(rmsr))
X#define setSn_RX_BSR(sn,rmsr)         WIZCHIP_WRITE(_Sn_RX_BSR_(sn),(rmsr))
N#define setSn_RXBUF_SIZE(sn,rmsr)      setSn_RX_BSR(sn,(rmsr))
N
N#define getSn_RX_BSR(sn) \
N        WIZCHIP_READ(_Sn_RX_BSR_(sn))
X#define getSn_RX_BSR(sn)         WIZCHIP_READ(_Sn_RX_BSR_(sn))
N#define getSn_RXBUF_SIZE(sn)           getSn_RX_BSR(sn)
N
N#define getSn_RxMAX(sn) \
N        (getSn_RX_BSR(sn) <<10)
X#define getSn_RxMAX(sn)         (getSn_RX_BSR(sn) <<10)
N
Ndatasize_t getSn_RX_RSR(uint8_t s);
N
N#define setSn_RX_RD(sn,rxrd) \
N        do{                                                                        \
N            WIZCHIP_WRITE(_Sn_RX_RD_(sn), (uint8_t)((rxrd)>>8));                   \
N            WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1), (uint8_t)(rxrd)) ; \
N        }while(0);
X#define setSn_RX_RD(sn,rxrd)         do{                                                                                    WIZCHIP_WRITE(_Sn_RX_RD_(sn), (uint8_t)((rxrd)>>8));                               WIZCHIP_WRITE(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1), (uint8_t)(rxrd)) ;         }while(0);
N
N#define getSn_RX_RD(sn) \
N        (((uint16_t)WIZCHIP_READ(_Sn_RX_RD_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1)))
X#define getSn_RX_RD(sn)         (((uint16_t)WIZCHIP_READ(_Sn_RX_RD_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_RD_(sn),1)))
N
N#define getSn_RX_WR(sn) \
N        (((uint16_t)WIZCHIP_READ(_Sn_RX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_WR_(sn),1)))
X#define getSn_RX_WR(sn)         (((uint16_t)WIZCHIP_READ(_Sn_RX_WR_(sn)) << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_WR_(sn),1)))
N/**
N * @}
N */
N                  
N
N/////////////////////////////////////
N// Sn_TXBUF & Sn_RXBUF IO function //
N/////////////////////////////////////
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It saves data to be sent in the SOCKETn TX buffer.
N * @details This function reads first @ref _Sn_TX_WR_ \n
N *          and starts to copy <i>wizdata</i> from @ref _Sn_TX_WR_ address of SOCKETn TX buffer as many as <i>len</i>.\n
N *          After it is completed to copy <i><wizdata</i>, \n
N *          It increases @ref _Sn_TX_WR_ as many as <i>len</i>.
N * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param wizdata Pointer buffer to write data
N * @param len Data length
N * @sa wiz_recv_data()
N */
Nvoid wiz_send_data(uint8_t sn, uint8_t *wizdata, datasize_t len);
N
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It reads the received data from the SOCKETn RX buffer and copies the data to your system memory specified by <i>wizdata</i>.
N * @details This function reads first @ref _Sn_RX_RD_ \n
N *          and starts to copy the received data to <i>wizdata</i> as many as <i>len</i>.\n
N *          After it is completed to copy the received data, \n
N *          It increases @ref _Sn_RX_RD_ as many as <i>len</i>.
N * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param wizdata Pointer buffer to read data
N * @param len Data length
N * @sa wiz_send_data()
N */
Nvoid wiz_recv_data(uint8_t sn, uint8_t *wizdata, datasize_t len);
N
N/**
N * @ingroup Basic_IO_function_W6100
N * @brief It discards the received data in the SOCKETn RX buffer.
N * @details This function discards the received data by increasing @ref _Sn_RX_RD_ as manay as <i>len</i> without coping the data.
N * @param sn SOCKETn. It should be <b>0 ~ @ref _WIZCHIP_SOCK_NUM_</b>.
N * @param len Data length
N */
Nvoid wiz_recv_ignore(uint8_t sn, datasize_t len);
N
N/// @cond DOXY_APPLY_CODE
N#if (_PHY_IO_MODE_ == _PHY_IO_MODE_MII_)
X#if (0x0000 == 0x0010)
S/// @endcond
S/**
S * @ingroup Special_function_W6100
S * @brief Write data to the PHY via MDC/MDIO interface.
S * @details Write command data to the PHY via MDC/MDIO interface.
S * @param phyregaddr Address of the PHY register. It should be @ref PHYRAR_BMCR, @ref PHYRAR_BMSR, and etc.
S * @param var Data to write to the PHY register. Please refer to the bit definitions of the BMCR and BMSR register.
S * @note In order to use it, You should define @ref _PHY_IO_MODE_ to @ref _PHY_IO_MODE_MII_.
S */
Svoid wiz_mdio_write(uint8_t phyregaddr, uint16_t var);
S
S/**
S * @ingroup Special_function_W6100
S * @brief Read data from the PHY via MDC/MDIO interface.
S * @details Read command or status data from the PHY via MDC/MDIO interface.
S * @param phyregaddr Address of the PHY register. It should be @ref PHYRAR_BMCR, @ref PHYRAR_BMSR, and etc.
S * @return The value of the PHY register
S * @note In order to use it, You should define @ref _PHY_IO_MODE_ to @ref _PHY_IO_MODE_MII_.
S */
Suint16_t wiz_mdio_read(uint8_t phyregaddr);
S/// @cond DOXY_APPLY_CODE
N#endif
N/// @endcond
N
N/// @cond DOXY_APPLY_CODE
N#endif  // _WIZCHIP_ == 6100
N/// @endcond
N
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif //_W6100_H_
L 35 "..\..\Libraries\io6Library\Ethernet\W6100\w6100.c" 2
N
N
N
N#define _WIZCHIP_SPI_VDM_OP_    0x00
N#define _WIZCHIP_SPI_FDM_LEN1_  0x01
N#define _WIZCHIP_SPI_FDM_LEN2_  0x02
N#define _WIZCHIP_SPI_FDM_LEN4_  0x03
N//
N// If you want to use SPI FDM mode, Feel free contact to WIZnet. 
N// http://forum.wiznet.io
N//
N
N#if _WIZCHIP_ == 6100
X#if 6100 == 6100
N////////////////////////////////////////////////////////////////////////////////////////
N
N
N#define _W6100_SPI_OP_          _WIZCHIP_SPI_VDM_OP_
N
N//////////////////////////////////////////////////
Nvoid WIZCHIP_WRITE(uint32_t AddrSel, uint8_t wb )
N{
N   uint8_t tAD[4];
N   tAD[0] = (uint8_t)((AddrSel & 0x00FF0000) >> 16);
N   tAD[1] = (uint8_t)((AddrSel & 0x0000FF00) >> 8);
N   tAD[2] = (uint8_t)(AddrSel & 0x000000ff);
N   tAD[3] = wb;
N
N   WIZCHIP_CRITICAL_ENTER();
X   WIZCHIP . CRIS . _e_n_t_e_r_();
N   WIZCHIP.CS._s_e_l_e_c_t_();
N
N#if( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_))
X#if( ((0x0100 + 2) == (0x0200 + 1)))
S   tAD[2] |= (_W6100_SPI_WRITE_ | _W6100_SPI_OP_);
S   WIZCHIP.IF.SPI._write_byte_buf(tAD, 4);
S
N#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
X#elif ( ((0x0100 + 2) == (0x0100 + 2)) )
N   WIZCHIP.IF.BUS._write_data_buf(IDM_AR0, tAD, 4, 1);
X   WIZCHIP.IF.BUS._write_data_buf(((0x60000000 + 0x0000)), tAD, 4, 1);
N#else
S   #error "Unknown _WIZCHIP_IO_MODE_ in W5100. !!!"
N#endif
N
N   WIZCHIP.CS._d_e_s_e_l_e_c_t_();
N   WIZCHIP_CRITICAL_EXIT();
X   WIZCHIP . CRIS . _e_x_i_t_();
N}
N
Nuint8_t  WIZCHIP_READ(uint32_t AddrSel)
N{
N   uint8_t ret;
N   uint8_t tAD[3];
N   tAD[0] = (uint8_t)((AddrSel & 0x00FF0000) >> 16);
N   tAD[1] = (uint8_t)((AddrSel & 0x0000FF00) >> 8);
N   tAD[2] = (uint8_t)(AddrSel & 0x000000ff);
N
N   WIZCHIP_CRITICAL_ENTER();
X   WIZCHIP . CRIS . _e_n_t_e_r_();
N   WIZCHIP.CS._s_e_l_e_c_t_();
N
N#if( (_WIZCHIP_IO_MODE_ ==  _WIZCHIP_IO_MODE_SPI_VDM_))
X#if( ((0x0100 + 2) ==  (0x0200 + 1)))
S   tAD[2] |= (_W6100_SPI_READ_ | _W6100_SPI_OP_);
S   WIZCHIP.IF.SPI._write_byte_buf(tAD, 3);
S   ret = WIZCHIP.IF.SPI._read_byte();
N#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
X#elif ( ((0x0100 + 2) == (0x0100 + 2)) )
N   WIZCHIP.IF.BUS._write_data_buf(IDM_AR0,tAD,3,1);
X   WIZCHIP.IF.BUS._write_data_buf(((0x60000000 + 0x0000)),tAD,3,1);
N   ret = WIZCHIP.IF.BUS._read_data(IDM_DR);
X   ret = WIZCHIP.IF.BUS._read_data(((0x60000000 + 0x0003)));
N#else
S   #error "Unknown _WIZCHIP_IO_MODE_ in W6100. !!!"   
N#endif
N
N   WIZCHIP.CS._d_e_s_e_l_e_c_t_();
N   WIZCHIP_CRITICAL_EXIT();
X   WIZCHIP . CRIS . _e_x_i_t_();
N   return ret;
N}
N
Nvoid WIZCHIP_WRITE_BUF(uint32_t AddrSel, uint8_t* pBuf, datasize_t len)
N{
N   uint8_t tAD[3];
N   tAD[0] = (uint8_t)((AddrSel & 0x00FF0000) >> 16);
N   tAD[1] = (uint8_t)((AddrSel & 0x0000FF00) >> 8);
N   tAD[2] = (uint8_t)(AddrSel & 0x000000ff);
N
N
N   WIZCHIP_CRITICAL_ENTER();
X   WIZCHIP . CRIS . _e_n_t_e_r_();
N   WIZCHIP.CS._s_e_l_e_c_t_();
N
N#if((_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_))
X#if(((0x0100 + 2) == (0x0200 + 1)))
S   tAD[2] |= (_W6100_SPI_WRITE_ | _W6100_SPI_OP_);
S
S   WIZCHIP.IF.SPI._write_byte_buf(tAD, 3);
S   WIZCHIP.IF.SPI._write_byte_buf(pBuf, len);
S
N#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
X#elif ( ((0x0100 + 2) == (0x0100 + 2)) )
N   WIZCHIP.IF.BUS._write_data_buf(IDM_AR0,tAD, 3, 1);
X   WIZCHIP.IF.BUS._write_data_buf(((0x60000000 + 0x0000)),tAD, 3, 1);
N   WIZCHIP.IF.BUS._write_data_buf(IDM_DR,pBuf,len, 0);
X   WIZCHIP.IF.BUS._write_data_buf(((0x60000000 + 0x0003)),pBuf,len, 0);
N#else
S   #error "Unknown _WIZCHIP_IO_MODE_ in W6100. !!!!"
N#endif
N
N   WIZCHIP.CS._d_e_s_e_l_e_c_t_();
N   WIZCHIP_CRITICAL_EXIT();
X   WIZCHIP . CRIS . _e_x_i_t_();
N}
N
Nvoid WIZCHIP_READ_BUF (uint32_t AddrSel, uint8_t* pBuf, datasize_t len)
N{
N   uint8_t tAD[3];
N   tAD[0] = (uint8_t)((AddrSel & 0x00FF0000) >> 16);
N   tAD[1] = (uint8_t)((AddrSel & 0x0000FF00) >> 8);
N   tAD[2] = (uint8_t)(AddrSel & 0x000000ff);
N
N   WIZCHIP_CRITICAL_ENTER();
X   WIZCHIP . CRIS . _e_n_t_e_r_();
N   WIZCHIP.CS._s_e_l_e_c_t_();
N
N#if((_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_SPI_VDM_))
X#if(((0x0100 + 2) == (0x0200 + 1)))
S   tAD[2] |= (_W6100_SPI_READ_ | _W6100_SPI_OP_);
S   WIZCHIP.IF.SPI._write_byte_buf(tAD,3);
S   WIZCHIP.IF.SPI._read_byte_buf(pBuf, len);
N#elif ( (_WIZCHIP_IO_MODE_ == _WIZCHIP_IO_MODE_BUS_INDIR_) )
X#elif ( ((0x0100 + 2) == (0x0100 + 2)) )
N   WIZCHIP.IF.BUS._write_data_buf(IDM_AR0,tAD,3,1);
X   WIZCHIP.IF.BUS._write_data_buf(((0x60000000 + 0x0000)),tAD,3,1);
N   WIZCHIP.IF.BUS._read_data_buf(IDM_DR,pBuf,len,0);
X   WIZCHIP.IF.BUS._read_data_buf(((0x60000000 + 0x0003)),pBuf,len,0);
N#else
S   #error "Unknown _WIZCHIP_IO_MODE_ in W6100. !!!!"
N#endif
N   WIZCHIP.CS._d_e_s_e_l_e_c_t_();
N   WIZCHIP_CRITICAL_EXIT();
X   WIZCHIP . CRIS . _e_x_i_t_();
N}
N
Ndatasize_t getSn_TX_FSR(uint8_t sn)
N{
N   datasize_t prev_val=-1,val=0;
N   do
N   {
N      prev_val = val;
N      val = WIZCHIP_READ(_Sn_TX_FSR_(sn));
X      val = WIZCHIP_READ((0x60000000 + (0x0204 << 8) + ((1+4*sn)<<3)));
N      val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_TX_FSR_(sn),1));
X      val = (val << 8) + WIZCHIP_READ(((0x60000000 + (0x0204 << 8) + ((1+4*sn)<<3)) + (1<<8)));
N   }while (val != prev_val);
N   return val;
N}
N
Ndatasize_t getSn_RX_RSR(uint8_t sn)
N{
N   datasize_t prev_val=-1,val=0;
N   do
N   {
N      prev_val = val;
N      val = WIZCHIP_READ(_Sn_RX_RSR_(sn));
X      val = WIZCHIP_READ((0x60000000 + (0x0224 << 8) + ((1+4*sn)<<3)));
N      val = (val << 8) + WIZCHIP_READ(WIZCHIP_OFFSET_INC(_Sn_RX_RSR_(sn),1));
X      val = (val << 8) + WIZCHIP_READ(((0x60000000 + (0x0224 << 8) + ((1+4*sn)<<3)) + (1<<8)));
N   }while (val != prev_val);
N   return val;
N}
N
Nvoid wiz_send_data(uint8_t sn, uint8_t *wizdata, datasize_t len)
N{
N   datasize_t ptr = 0;
N   uint32_t addrsel = 0;
N   ptr = getSn_TX_WR(sn);
X   ptr = (((uint16_t)WIZCHIP_READ((0x60000000 + (0x020C << 8) + ((1+4*sn)<<3))) << 8) + WIZCHIP_READ(((0x60000000 + (0x020C << 8) + ((1+4*sn)<<3)) + (1<<8))));
N   addrsel = ((uint32_t)ptr << 8) + WIZCHIP_TXBUF_BLOCK(sn);
X   addrsel = ((uint32_t)ptr << 8) + ((2+4*sn)<<3);
N   WIZCHIP_WRITE_BUF(addrsel,wizdata, len);
N   ptr += len;
N   setSn_TX_WR(sn,ptr);
X   do{ WIZCHIP_WRITE((0x60000000 + (0x020C << 8) + ((1+4*sn)<<3)), (uint8_t)((ptr)>>8)); WIZCHIP_WRITE(((0x60000000 + (0x020C << 8) + ((1+4*sn)<<3)) + (1<<8)), (uint8_t)(ptr)); }while(0);;
N}
N
Nvoid wiz_recv_data(uint8_t sn, uint8_t *wizdata, datasize_t len)
N{
N   datasize_t ptr = 0;
N   uint32_t addrsel = 0;
N   if(len == 0) return;
N   ptr = getSn_RX_RD(sn);
X   ptr = (((uint16_t)WIZCHIP_READ((0x60000000 + (0x0228 << 8) + ((1+4*sn)<<3))) << 8) + WIZCHIP_READ(((0x60000000 + (0x0228 << 8) + ((1+4*sn)<<3)) + (1<<8))));
N   addrsel = ((uint32_t)ptr << 8) + WIZCHIP_RXBUF_BLOCK(sn);
X   addrsel = ((uint32_t)ptr << 8) + ((3+4*sn)<<3);
N   WIZCHIP_READ_BUF(addrsel, wizdata, len);
N   ptr += len;
N   setSn_RX_RD(sn,ptr);
X   do{ WIZCHIP_WRITE((0x60000000 + (0x0228 << 8) + ((1+4*sn)<<3)), (uint8_t)((ptr)>>8)); WIZCHIP_WRITE(((0x60000000 + (0x0228 << 8) + ((1+4*sn)<<3)) + (1<<8)), (uint8_t)(ptr)) ; }while(0);;
N}
N
Nvoid wiz_recv_ignore(uint8_t sn, datasize_t len)
N{
N   setSn_RX_RD(sn,getSn_RX_RD(sn)+len);
X   do{ WIZCHIP_WRITE((0x60000000 + (0x0228 << 8) + ((1+4*sn)<<3)), (uint8_t)(((((uint16_t)WIZCHIP_READ((0x60000000 + (0x0228 << 8) + ((1+4*sn)<<3))) << 8) + WIZCHIP_READ(((0x60000000 + (0x0228 << 8) + ((1+4*sn)<<3)) + (1<<8))))+len)>>8)); WIZCHIP_WRITE(((0x60000000 + (0x0228 << 8) + ((1+4*sn)<<3)) + (1<<8)), (uint8_t)((((uint16_t)WIZCHIP_READ((0x60000000 + (0x0228 << 8) + ((1+4*sn)<<3))) << 8) + WIZCHIP_READ(((0x60000000 + (0x0228 << 8) + ((1+4*sn)<<3)) + (1<<8))))+len)) ; }while(0);;
N}
N
N
N/// @cond DOXY_APPLY_CODE
N#if (_PHY_IO_MODE_ == _PHY_IO_MODE_MII_)
X#if (0x0000 == 0x0010)
S/// @endcond
Svoid wiz_mdio_write(uint8_t phyregaddr, uint16_t var)
S{
S   setPHYRAR(phyregaddr);
S   setPHYDIR(var);
S   setPHYACR(PHYACR_WRITE);
S   while(getPHYACR());  //wait for command complete
S}
S
Suint16_t wiz_mdio_read(uint8_t phyregaddr)
S{
S   setPHYRAR(phyregaddr);
S   setPHYACR(PHYACR_READ);
S   while(getPHYACR());  //wait for command complete
S   return getPHYDOR();
S}
S/// @cond DOXY_APPLY_CODE
N#endif
N/// @endcond
N
N////////////////////////////////////////////////////////////////////////////////////////
N#endif
