; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\objects\stm32f4xx_pwr.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_pwr.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\test_[SLAAC-RDNSS] -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\io6Library\Application\loopback -I..\..\Libraries\io6Library\Ethernet -I..\..\Libraries\io6Library\Ethernet\W6100 -I..\..\Libraries\io6Library\Internet\DHCP -I..\..\Libraries\io6Library\Internet\DNS -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\io6Library\Internet\DHCP6 -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Ic:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F4XX -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f4xx_pwr.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_pwr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  PWR_DeInit PROC
;;;119      */
;;;120    void PWR_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;121    {
;;;122      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  070c              LSLS     r4,r1,#28
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;123      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;124    }
;;;125    
                          ENDP

                  PWR_BackupAccessCmd PROC
;;;134      */
;;;135    void PWR_BackupAccessCmd(FunctionalState NewState)
000018  492a              LDR      r1,|L1.196|
;;;136    {
;;;137      /* Check the parameters */
;;;138      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;139      
;;;140      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
00001a  6208              STR      r0,[r1,#0x20]
;;;141    }
00001c  4770              BX       lr
;;;142    
                          ENDP

                  PWR_PVDLevelConfig PROC
;;;180      */
;;;181    void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
00001e  4a2a              LDR      r2,|L1.200|
;;;182    {
;;;183      uint32_t tmpreg = 0;
;;;184      
;;;185      /* Check the parameters */
;;;186      assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
;;;187      
;;;188      tmpreg = PWR->CR;
000020  6811              LDR      r1,[r2,#0]
;;;189      
;;;190      /* Clear PLS[7:5] bits */
;;;191      tmpreg &= CR_PLS_MASK;
000022  f02101e0          BIC      r1,r1,#0xe0
;;;192      
;;;193      /* Set PLS[7:5] bits according to PWR_PVDLevel value */
;;;194      tmpreg |= PWR_PVDLevel;
000026  4301              ORRS     r1,r1,r0
;;;195      
;;;196      /* Store the new value */
;;;197      PWR->CR = tmpreg;
000028  6011              STR      r1,[r2,#0]
;;;198    }
00002a  4770              BX       lr
;;;199    
                          ENDP

                  PWR_PVDCmd PROC
;;;205      */
;;;206    void PWR_PVDCmd(FunctionalState NewState)
00002c  4925              LDR      r1,|L1.196|
;;;207    {
;;;208      /* Check the parameters */
;;;209      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;210      
;;;211      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
00002e  6108              STR      r0,[r1,#0x10]
;;;212    }
000030  4770              BX       lr
;;;213    
                          ENDP

                  PWR_WakeUpPinCmd PROC
;;;239      */
;;;240    void PWR_WakeUpPinCmd(FunctionalState NewState)
000032  4924              LDR      r1,|L1.196|
;;;241    {
;;;242      /* Check the parameters */  
;;;243      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;244    
;;;245      *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
000034  f8c100a0          STR      r0,[r1,#0xa0]
;;;246    }
000038  4770              BX       lr
;;;247    
                          ENDP

                  PWR_BackupRegulatorCmd PROC
;;;297      */
;;;298    void PWR_BackupRegulatorCmd(FunctionalState NewState)
00003a  4922              LDR      r1,|L1.196|
;;;299    {
;;;300      /* Check the parameters */
;;;301      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;302    
;;;303      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
00003c  f8c100a4          STR      r0,[r1,#0xa4]
;;;304    }
000040  4770              BX       lr
;;;305    
                          ENDP

                  PWR_MainRegulatorModeConfig PROC
;;;317      */
;;;318    void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
000042  4921              LDR      r1,|L1.200|
;;;319    {
;;;320      /* Check the parameters */
;;;321      assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));
;;;322    
;;;323      if (PWR_Regulator_Voltage == PWR_Regulator_Voltage_Scale2)
000044  2800              CMP      r0,#0
;;;324      {
;;;325        PWR->CR &= ~PWR_Regulator_Voltage_Scale1;
;;;326      }
;;;327      else
;;;328      {    
;;;329        PWR->CR |= PWR_Regulator_Voltage_Scale1;
000046  6808              LDR      r0,[r1,#0]
000048  d003              BEQ      |L1.82|
00004a  f4404080          ORR      r0,r0,#0x4000
                  |L1.78|
00004e  6008              STR      r0,[r1,#0]            ;325
;;;330      }
;;;331    }
000050  4770              BX       lr
                  |L1.82|
000052  f4204080          BIC      r0,r0,#0x4000         ;325
000056  e7fa              B        |L1.78|
;;;332    
                          ENDP

                  PWR_FlashPowerDownCmd PROC
;;;359      */
;;;360    void PWR_FlashPowerDownCmd(FunctionalState NewState)
000058  491a              LDR      r1,|L1.196|
;;;361    {
;;;362      /* Check the parameters */
;;;363      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;364    
;;;365      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
00005a  6248              STR      r0,[r1,#0x24]
;;;366    }
00005c  4770              BX       lr
;;;367    
                          ENDP

                  PWR_EnterSTOPMode PROC
;;;499      */
;;;500    void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
00005e  4b1a              LDR      r3,|L1.200|
;;;501    {
;;;502      uint32_t tmpreg = 0;
;;;503      
;;;504      /* Check the parameters */
;;;505      assert_param(IS_PWR_REGULATOR(PWR_Regulator));
;;;506      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
;;;507      
;;;508      /* Select the regulator state in STOP mode ---------------------------------*/
;;;509      tmpreg = PWR->CR;
000060  681a              LDR      r2,[r3,#0]
;;;510      /* Clear PDDS and LPDSR bits */
;;;511      tmpreg &= CR_DS_MASK;
000062  f0220203          BIC      r2,r2,#3
;;;512      
;;;513      /* Set LPDSR bit according to PWR_Regulator value */
;;;514      tmpreg |= PWR_Regulator;
000066  4302              ORRS     r2,r2,r0
;;;515      
;;;516      /* Store the new value */
;;;517      PWR->CR = tmpreg;
000068  601a              STR      r2,[r3,#0]
;;;518      
;;;519      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;520      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
00006a  4818              LDR      r0,|L1.204|
00006c  6802              LDR      r2,[r0,#0]
00006e  f0420204          ORR      r2,r2,#4
000072  6002              STR      r2,[r0,#0]
;;;521      
;;;522      /* Select STOP mode entry --------------------------------------------------*/
;;;523      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
000074  2901              CMP      r1,#1
000076  d005              BEQ      |L1.132|
;;;524      {   
;;;525        /* Request Wait For Interrupt */
;;;526        __WFI();
;;;527      }
;;;528      else
;;;529      {
;;;530        /* Request Wait For Event */
;;;531        __WFE();
000078  bf20              WFE      
                  |L1.122|
;;;532      }
;;;533      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;534      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
00007a  6801              LDR      r1,[r0,#0]
00007c  f0210104          BIC      r1,r1,#4
000080  6001              STR      r1,[r0,#0]
;;;535    }
000082  4770              BX       lr
                  |L1.132|
000084  bf30              WFI                            ;526
000086  e7f8              B        |L1.122|
;;;536    
                          ENDP

                  PWR_EnterSTANDBYMode PROC
;;;547      */
;;;548    void PWR_EnterSTANDBYMode(void)
000088  480f              LDR      r0,|L1.200|
;;;549    {
;;;550      /* Clear Wakeup flag */
;;;551      PWR->CR |= PWR_CR_CWUF;
00008a  6801              LDR      r1,[r0,#0]
00008c  f0410104          ORR      r1,r1,#4
000090  6001              STR      r1,[r0,#0]
;;;552      
;;;553      /* Select STANDBY mode */
;;;554      PWR->CR |= PWR_CR_PDDS;
000092  6801              LDR      r1,[r0,#0]
000094  f0410102          ORR      r1,r1,#2
000098  6001              STR      r1,[r0,#0]
;;;555      
;;;556      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;557      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
00009a  480c              LDR      r0,|L1.204|
00009c  6801              LDR      r1,[r0,#0]
00009e  f0410104          ORR      r1,r1,#4
0000a2  6001              STR      r1,[r0,#0]
;;;558      
;;;559    /* This option is used to ensure that store operations are completed */
;;;560    #if defined ( __CC_ARM   )
;;;561      __force_stores();
;;;562    #endif
;;;563      /* Request Wait For Interrupt */
;;;564      __WFI();
0000a4  bf30              WFI      
;;;565    }
0000a6  4770              BX       lr
;;;566    
                          ENDP

                  PWR_GetFlagStatus PROC
;;;604      */
;;;605    FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
0000a8  4a07              LDR      r2,|L1.200|
;;;606    {
0000aa  4601              MOV      r1,r0
;;;607      FlagStatus bitstatus = RESET;
0000ac  2000              MOVS     r0,#0
;;;608      
;;;609      /* Check the parameters */
;;;610      assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
;;;611      
;;;612      if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
0000ae  6852              LDR      r2,[r2,#4]
0000b0  420a              TST      r2,r1
0000b2  d000              BEQ      |L1.182|
;;;613      {
;;;614        bitstatus = SET;
0000b4  2001              MOVS     r0,#1
                  |L1.182|
;;;615      }
;;;616      else
;;;617      {
;;;618        bitstatus = RESET;
;;;619      }
;;;620      /* Return the flag status */
;;;621      return bitstatus;
;;;622    }
0000b6  4770              BX       lr
;;;623    
                          ENDP

                  PWR_ClearFlag PROC
;;;631      */
;;;632    void PWR_ClearFlag(uint32_t PWR_FLAG)
0000b8  4903              LDR      r1,|L1.200|
;;;633    {
;;;634      /* Check the parameters */
;;;635      assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
;;;636             
;;;637      PWR->CR |=  PWR_FLAG << 2;
0000ba  680a              LDR      r2,[r1,#0]
0000bc  ea420080          ORR      r0,r2,r0,LSL #2
0000c0  6008              STR      r0,[r1,#0]
;;;638    }
0000c2  4770              BX       lr
;;;639    
                          ENDP

                  |L1.196|
                          DCD      0x420e0000
                  |L1.200|
                          DCD      0x40007000
                  |L1.204|
                          DCD      0xe000ed10

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_pwr.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____REVSH|
#line 128
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
