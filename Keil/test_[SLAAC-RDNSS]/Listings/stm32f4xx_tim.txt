; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\objects\stm32f4xx_tim.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_tim.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\test_[SLAAC-RDNSS] -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\io6Library\Application\loopback -I..\..\Libraries\io6Library\Ethernet -I..\..\Libraries\io6Library\Ethernet\W6100 -I..\..\Libraries\io6Library\Internet\DHCP -I..\..\Libraries\io6Library\Internet\DNS -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\io6Library\Internet\DHCP6 -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Ic:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F4XX -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f4xx_tim.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;193      */
;;;194    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  49fe              LDR      r1,|L1.1020|
;;;195    {
000002  b510              PUSH     {r4,lr}
;;;196      /* Check the parameters */
;;;197      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;198     
;;;199      if (TIMx == TIM1)
000004  4288              CMP      r0,r1
000006  d106              BNE      |L1.22|
;;;200      {
;;;201        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;202        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000010  2100              MOVS     r1,#0
000012  2001              MOVS     r0,#1
000014  e05b              B        |L1.206|
                  |L1.22|
;;;203      } 
;;;204      else if (TIMx == TIM2) 
000016  f1b04f80          CMP      r0,#0x40000000
00001a  d009              BEQ      |L1.48|
;;;205      {     
;;;206        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;207        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;208      }  
;;;209      else if (TIMx == TIM3)
00001c  49f8              LDR      r1,|L1.1024|
00001e  4288              CMP      r0,r1
000020  d10d              BNE      |L1.62|
;;;210      { 
;;;211        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
000022  2101              MOVS     r1,#1
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;212        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2002              MOVS     r0,#2
00002e  e070              B        |L1.274|
                  |L1.48|
000030  2101              MOVS     r1,#1                 ;206
000032  4608              MOV      r0,r1                 ;206
000034  f7fffffe          BL       RCC_APB1PeriphResetCmd
000038  2100              MOVS     r1,#0                 ;207
00003a  2001              MOVS     r0,#1                 ;207
00003c  e069              B        |L1.274|
                  |L1.62|
;;;213      }  
;;;214      else if (TIMx == TIM4)
00003e  49f1              LDR      r1,|L1.1028|
000040  4288              CMP      r0,r1
000042  d106              BNE      |L1.82|
;;;215      { 
;;;216        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000044  2101              MOVS     r1,#1
000046  2004              MOVS     r0,#4
000048  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;217        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00004c  2100              MOVS     r1,#0
00004e  2004              MOVS     r0,#4
000050  e05f              B        |L1.274|
                  |L1.82|
;;;218      }  
;;;219      else if (TIMx == TIM5)
000052  49ed              LDR      r1,|L1.1032|
000054  4288              CMP      r0,r1
000056  d106              BNE      |L1.102|
;;;220      {      
;;;221        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000058  2101              MOVS     r1,#1
00005a  2008              MOVS     r0,#8
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;222        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000060  2100              MOVS     r1,#0
000062  2008              MOVS     r0,#8
000064  e055              B        |L1.274|
                  |L1.102|
;;;223      }  
;;;224      else if (TIMx == TIM6)  
000066  49e9              LDR      r1,|L1.1036|
000068  4288              CMP      r0,r1
00006a  d106              BNE      |L1.122|
;;;225      {    
;;;226        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  2010              MOVS     r0,#0x10
000070  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;227        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
000074  2100              MOVS     r1,#0
000076  2010              MOVS     r0,#0x10
000078  e04b              B        |L1.274|
                  |L1.122|
;;;228      }  
;;;229      else if (TIMx == TIM7)
00007a  49e5              LDR      r1,|L1.1040|
00007c  4288              CMP      r0,r1
00007e  d106              BNE      |L1.142|
;;;230      {      
;;;231        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
000080  2101              MOVS     r1,#1
000082  2020              MOVS     r0,#0x20
000084  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;232        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
000088  2100              MOVS     r1,#0
00008a  2020              MOVS     r0,#0x20
00008c  e041              B        |L1.274|
                  |L1.142|
;;;233      }  
;;;234      else if (TIMx == TIM8)
00008e  49e1              LDR      r1,|L1.1044|
000090  4288              CMP      r0,r1
000092  d106              BNE      |L1.162|
;;;235      {      
;;;236        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
000094  2101              MOVS     r1,#1
000096  2002              MOVS     r0,#2
000098  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;237        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
00009c  2100              MOVS     r1,#0
00009e  2002              MOVS     r0,#2
0000a0  e015              B        |L1.206|
                  |L1.162|
;;;238      }  
;;;239      else if (TIMx == TIM9)
0000a2  49dd              LDR      r1,|L1.1048|
0000a4  4288              CMP      r0,r1
0000a6  d102              BNE      |L1.174|
;;;240      {      
;;;241        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
0000a8  2101              MOVS     r1,#1
0000aa  040c              LSLS     r4,r1,#16
;;;242        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
0000ac  e00a              B        |L1.196|
                  |L1.174|
;;;243       }  
;;;244      else if (TIMx == TIM10)
0000ae  49db              LDR      r1,|L1.1052|
0000b0  4288              CMP      r0,r1
0000b2  d102              BNE      |L1.186|
;;;245      {      
;;;246        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
0000b4  2101              MOVS     r1,#1
0000b6  044c              LSLS     r4,r1,#17
;;;247        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
0000b8  e004              B        |L1.196|
                  |L1.186|
;;;248      }  
;;;249      else if (TIMx == TIM11) 
0000ba  49d9              LDR      r1,|L1.1056|
0000bc  4288              CMP      r0,r1
0000be  d10a              BNE      |L1.214|
;;;250      {     
;;;251        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
0000c0  2101              MOVS     r1,#1
0000c2  048c              LSLS     r4,r1,#18
                  |L1.196|
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;252        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
0000ca  2100              MOVS     r1,#0
0000cc  4620              MOV      r0,r4
                  |L1.206|
0000ce  e8bd4010          POP      {r4,lr}
0000d2  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.214|
;;;253      }  
;;;254      else if (TIMx == TIM12)
0000d6  49d3              LDR      r1,|L1.1060|
0000d8  4288              CMP      r0,r1
0000da  d106              BNE      |L1.234|
;;;255      {      
;;;256        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
0000dc  2101              MOVS     r1,#1
0000de  2040              MOVS     r0,#0x40
0000e0  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;257        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
0000e4  2100              MOVS     r1,#0
0000e6  2040              MOVS     r0,#0x40
0000e8  e013              B        |L1.274|
                  |L1.234|
;;;258      }  
;;;259      else if (TIMx == TIM13) 
0000ea  49cf              LDR      r1,|L1.1064|
0000ec  4288              CMP      r0,r1
0000ee  d106              BNE      |L1.254|
;;;260      {       
;;;261        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
0000f0  2101              MOVS     r1,#1
0000f2  2080              MOVS     r0,#0x80
0000f4  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;262        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
0000f8  2100              MOVS     r1,#0
0000fa  2080              MOVS     r0,#0x80
0000fc  e009              B        |L1.274|
                  |L1.254|
;;;263      }  
;;;264      else
;;;265      { 
;;;266        if (TIMx == TIM14) 
0000fe  49cb              LDR      r1,|L1.1068|
000100  4288              CMP      r0,r1
000102  d10a              BNE      |L1.282|
;;;267        {     
;;;268          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
000104  1584              ASRS     r4,r0,#22
000106  2101              MOVS     r1,#1
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;269          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
00010e  2100              MOVS     r1,#0
000110  4620              MOV      r0,r4
                  |L1.274|
000112  e8bd4010          POP      {r4,lr}
000116  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.282|
;;;270        }   
;;;271      }
;;;272    }
00011a  bd10              POP      {r4,pc}
;;;273    
                          ENDP

                  TIM_TimeBaseInit PROC
;;;281      */
;;;282    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
00011c  b530              PUSH     {r4,r5,lr}
;;;283    {
;;;284      uint16_t tmpcr1 = 0;
;;;285    
;;;286      /* Check the parameters */
;;;287      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;288      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;289      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;290    
;;;291      tmpcr1 = TIMx->CR1;  
00011e  8802              LDRH     r2,[r0,#0]
;;;292    
;;;293      if((TIMx == TIM1) || (TIMx == TIM8)||
000120  4cb6              LDR      r4,|L1.1020|
000122  4dbc              LDR      r5,|L1.1044|
000124  42a0              CMP      r0,r4
000126  d00d              BEQ      |L1.324|
000128  42a8              CMP      r0,r5
00012a  d00b              BEQ      |L1.324|
;;;294         (TIMx == TIM2) || (TIMx == TIM3)||
00012c  f1b04f80          CMP      r0,#0x40000000
000130  d008              BEQ      |L1.324|
000132  4bb3              LDR      r3,|L1.1024|
000134  4298              CMP      r0,r3
000136  d005              BEQ      |L1.324|
;;;295         (TIMx == TIM4) || (TIMx == TIM5)) 
000138  4bb2              LDR      r3,|L1.1028|
00013a  4298              CMP      r0,r3
00013c  d002              BEQ      |L1.324|
00013e  4bb2              LDR      r3,|L1.1032|
000140  4298              CMP      r0,r3
000142  d103              BNE      |L1.332|
                  |L1.324|
;;;296      {
;;;297        /* Select the Counter Mode */
;;;298        tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
000144  f0220370          BIC      r3,r2,#0x70
;;;299        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
000148  884a              LDRH     r2,[r1,#2]
00014a  431a              ORRS     r2,r2,r3
                  |L1.332|
;;;300      }
;;;301     
;;;302      if((TIMx != TIM6) && (TIMx != TIM7))
00014c  4baf              LDR      r3,|L1.1036|
00014e  4298              CMP      r0,r3
000150  d006              BEQ      |L1.352|
000152  4baf              LDR      r3,|L1.1040|
000154  4298              CMP      r0,r3
000156  d003              BEQ      |L1.352|
;;;303      {
;;;304        /* Set the clock division */
;;;305        tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
000158  f4227340          BIC      r3,r2,#0x300
;;;306        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
00015c  890a              LDRH     r2,[r1,#8]
00015e  431a              ORRS     r2,r2,r3
                  |L1.352|
;;;307      }
;;;308    
;;;309      TIMx->CR1 = tmpcr1;
000160  8002              STRH     r2,[r0,#0]
;;;310    
;;;311      /* Set the Autoreload value */
;;;312      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000162  684a              LDR      r2,[r1,#4]
000164  62c2              STR      r2,[r0,#0x2c]
;;;313     
;;;314      /* Set the Prescaler value */
;;;315      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
000166  880a              LDRH     r2,[r1,#0]
000168  8502              STRH     r2,[r0,#0x28]
;;;316        
;;;317      if ((TIMx == TIM1) || (TIMx == TIM8))  
00016a  42a0              CMP      r0,r4
00016c  d001              BEQ      |L1.370|
00016e  42a8              CMP      r0,r5
000170  d101              BNE      |L1.374|
                  |L1.370|
;;;318      {
;;;319        /* Set the Repetition Counter value */
;;;320        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000172  7a89              LDRB     r1,[r1,#0xa]
000174  8601              STRH     r1,[r0,#0x30]
                  |L1.374|
;;;321      }
;;;322    
;;;323      /* Generate an update event to reload the Prescaler 
;;;324         and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;325      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
000176  2101              MOVS     r1,#1
000178  8281              STRH     r1,[r0,#0x14]
;;;326    }
00017a  bd30              POP      {r4,r5,pc}
;;;327    
                          ENDP

                  TIM_TimeBaseStructInit PROC
;;;333      */
;;;334    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
00017c  f04f31ff          MOV      r1,#0xffffffff
;;;335    {
;;;336      /* Set the default configuration */
;;;337      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
;;;338      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000180  6041              STR      r1,[r0,#4]
000182  2100              MOVS     r1,#0
000184  8001              STRH     r1,[r0,#0]
;;;339      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
000186  8101              STRH     r1,[r0,#8]
;;;340      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
000188  8041              STRH     r1,[r0,#2]
;;;341      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00018a  7281              STRB     r1,[r0,#0xa]
;;;342    }
00018c  4770              BX       lr
;;;343    
                          ENDP

                  TIM_PrescalerConfig PROC
;;;353      */
;;;354    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
00018e  8501              STRH     r1,[r0,#0x28]
;;;355    {
;;;356      /* Check the parameters */
;;;357      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;358      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;359      /* Set the Prescaler value */
;;;360      TIMx->PSC = Prescaler;
;;;361      /* Set or reset the UG Bit */
;;;362      TIMx->EGR = TIM_PSCReloadMode;
000190  8282              STRH     r2,[r0,#0x14]
;;;363    }
000192  4770              BX       lr
;;;364    
                          ENDP

                  TIM_CounterModeConfig PROC
;;;376      */
;;;377    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000194  8802              LDRH     r2,[r0,#0]
;;;378    {
;;;379      uint16_t tmpcr1 = 0;
;;;380    
;;;381      /* Check the parameters */
;;;382      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;383      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;384    
;;;385      tmpcr1 = TIMx->CR1;
;;;386    
;;;387      /* Reset the CMS and DIR Bits */
;;;388      tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
000196  f0220270          BIC      r2,r2,#0x70
;;;389    
;;;390      /* Set the Counter Mode */
;;;391      tmpcr1 |= TIM_CounterMode;
00019a  430a              ORRS     r2,r2,r1
;;;392    
;;;393      /* Write to TIMx CR1 register */
;;;394      TIMx->CR1 = tmpcr1;
00019c  8002              STRH     r2,[r0,#0]
;;;395    }
00019e  4770              BX       lr
;;;396    
                          ENDP

                  TIM_SetCounter PROC
;;;402      */
;;;403    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
0001a0  6241              STR      r1,[r0,#0x24]
;;;404    {
;;;405      /* Check the parameters */
;;;406       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;407    
;;;408      /* Set the Counter Register value */
;;;409      TIMx->CNT = Counter;
;;;410    }
0001a2  4770              BX       lr
;;;411    
                          ENDP

                  TIM_SetAutoreload PROC
;;;417      */
;;;418    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
0001a4  62c1              STR      r1,[r0,#0x2c]
;;;419    {
;;;420      /* Check the parameters */
;;;421      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;422      
;;;423      /* Set the Autoreload Register value */
;;;424      TIMx->ARR = Autoreload;
;;;425    }
0001a6  4770              BX       lr
;;;426    
                          ENDP

                  TIM_GetCounter PROC
;;;431      */
;;;432    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
0001a8  6a40              LDR      r0,[r0,#0x24]
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;436    
;;;437      /* Get the Counter Register value */
;;;438      return TIMx->CNT;
;;;439    }
0001aa  4770              BX       lr
;;;440    
                          ENDP

                  TIM_GetPrescaler PROC
;;;445      */
;;;446    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
0001ac  8d00              LDRH     r0,[r0,#0x28]
;;;447    {
;;;448      /* Check the parameters */
;;;449      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;450    
;;;451      /* Get the Prescaler Register value */
;;;452      return TIMx->PSC;
;;;453    }
0001ae  4770              BX       lr
;;;454    
                          ENDP

                  TIM_UpdateDisableConfig PROC
;;;461      */
;;;462    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
0001b0  2900              CMP      r1,#0
;;;463    {
;;;464      /* Check the parameters */
;;;465      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;466      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;467    
;;;468      if (NewState != DISABLE)
;;;469      {
;;;470        /* Set the Update Disable Bit */
;;;471        TIMx->CR1 |= TIM_CR1_UDIS;
;;;472      }
;;;473      else
;;;474      {
;;;475        /* Reset the Update Disable Bit */
;;;476        TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
0001b2  8801              LDRH     r1,[r0,#0]
0001b4  d002              BEQ      |L1.444|
0001b6  f0410102          ORR      r1,r1,#2              ;471
0001ba  e001              B        |L1.448|
                  |L1.444|
0001bc  f0210102          BIC      r1,r1,#2
                  |L1.448|
0001c0  8001              STRH     r1,[r0,#0]            ;471
;;;477      }
;;;478    }
0001c2  4770              BX       lr
;;;479    
                          ENDP

                  TIM_UpdateRequestConfig PROC
;;;490      */
;;;491    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
0001c4  2900              CMP      r1,#0
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;495      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;496    
;;;497      if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;498      {
;;;499        /* Set the URS Bit */
;;;500        TIMx->CR1 |= TIM_CR1_URS;
;;;501      }
;;;502      else
;;;503      {
;;;504        /* Reset the URS Bit */
;;;505        TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
0001c6  8801              LDRH     r1,[r0,#0]
0001c8  d002              BEQ      |L1.464|
0001ca  f0410104          ORR      r1,r1,#4              ;500
0001ce  e001              B        |L1.468|
                  |L1.464|
0001d0  f0210104          BIC      r1,r1,#4
                  |L1.468|
0001d4  8001              STRH     r1,[r0,#0]            ;500
;;;506      }
;;;507    }
0001d6  4770              BX       lr
;;;508    
                          ENDP

                  TIM_ARRPreloadConfig PROC
;;;515      */
;;;516    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
0001d8  2900              CMP      r1,#0
;;;517    {
;;;518      /* Check the parameters */
;;;519      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;520      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;521    
;;;522      if (NewState != DISABLE)
;;;523      {
;;;524        /* Set the ARR Preload Bit */
;;;525        TIMx->CR1 |= TIM_CR1_ARPE;
;;;526      }
;;;527      else
;;;528      {
;;;529        /* Reset the ARR Preload Bit */
;;;530        TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
0001da  8801              LDRH     r1,[r0,#0]
0001dc  d002              BEQ      |L1.484|
0001de  f0410180          ORR      r1,r1,#0x80           ;525
0001e2  e001              B        |L1.488|
                  |L1.484|
0001e4  f0210180          BIC      r1,r1,#0x80
                  |L1.488|
0001e8  8001              STRH     r1,[r0,#0]            ;525
;;;531      }
;;;532    }
0001ea  4770              BX       lr
;;;533    
                          ENDP

                  TIM_SelectOnePulseMode PROC
;;;542      */
;;;543    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
0001ec  8802              LDRH     r2,[r0,#0]
;;;544    {
;;;545      /* Check the parameters */
;;;546      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;547      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;548    
;;;549      /* Reset the OPM Bit */
;;;550      TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
0001ee  f0220208          BIC      r2,r2,#8
0001f2  8002              STRH     r2,[r0,#0]
;;;551    
;;;552      /* Configure the OPM Mode */
;;;553      TIMx->CR1 |= TIM_OPMode;
0001f4  8802              LDRH     r2,[r0,#0]
0001f6  430a              ORRS     r2,r2,r1
0001f8  8002              STRH     r2,[r0,#0]
;;;554    }
0001fa  4770              BX       lr
;;;555    
                          ENDP

                  TIM_SetClockDivision PROC
;;;565      */
;;;566    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
0001fc  8802              LDRH     r2,[r0,#0]
;;;567    {
;;;568      /* Check the parameters */
;;;569      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;570      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;571    
;;;572      /* Reset the CKD Bits */
;;;573      TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
0001fe  f4227240          BIC      r2,r2,#0x300
000202  8002              STRH     r2,[r0,#0]
;;;574    
;;;575      /* Set the CKD value */
;;;576      TIMx->CR1 |= TIM_CKD;
000204  8802              LDRH     r2,[r0,#0]
000206  430a              ORRS     r2,r2,r1
000208  8002              STRH     r2,[r0,#0]
;;;577    }
00020a  4770              BX       lr
;;;578    
                          ENDP

                  TIM_Cmd PROC
;;;585      */
;;;586    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
00020c  2900              CMP      r1,#0
;;;587    {
;;;588      /* Check the parameters */
;;;589      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;590      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;591      
;;;592      if (NewState != DISABLE)
;;;593      {
;;;594        /* Enable the TIM Counter */
;;;595        TIMx->CR1 |= TIM_CR1_CEN;
;;;596      }
;;;597      else
;;;598      {
;;;599        /* Disable the TIM Counter */
;;;600        TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
00020e  8801              LDRH     r1,[r0,#0]
000210  d002              BEQ      |L1.536|
000212  f0410101          ORR      r1,r1,#1              ;595
000216  e001              B        |L1.540|
                  |L1.536|
000218  f0210101          BIC      r1,r1,#1
                  |L1.540|
00021c  8001              STRH     r1,[r0,#0]            ;595
;;;601      }
;;;602    }
00021e  4770              BX       lr
;;;603    /**
                          ENDP

                  TIM_OC1Init PROC
;;;664      */
;;;665    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000220  b530              PUSH     {r4,r5,lr}
;;;666    {
;;;667      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;668       
;;;669      /* Check the parameters */
;;;670      assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;671      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;672      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;673      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;674    
;;;675      /* Disable the Channel 1: Reset the CC1E Bit */
;;;676      TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
000222  8c02              LDRH     r2,[r0,#0x20]
000224  f0220201          BIC      r2,r2,#1
000228  8402              STRH     r2,[r0,#0x20]
;;;677      
;;;678      /* Get the TIMx CCER register value */
;;;679      tmpccer = TIMx->CCER;
00022a  8c02              LDRH     r2,[r0,#0x20]
;;;680      /* Get the TIMx CR2 register value */
;;;681      tmpcr2 =  TIMx->CR2;
00022c  8883              LDRH     r3,[r0,#4]
;;;682      
;;;683      /* Get the TIMx CCMR1 register value */
;;;684      tmpccmrx = TIMx->CCMR1;
00022e  8b04              LDRH     r4,[r0,#0x18]
;;;685        
;;;686      /* Reset the Output Compare Mode Bits */
;;;687      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
;;;688      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
;;;689      /* Select the Output Compare Mode */
;;;690      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
;;;691      
;;;692      /* Reset the Output Polarity level */
;;;693      tmpccer &= (uint16_t)~TIM_CCER_CC1P;
000230  f0220202          BIC      r2,r2,#2
000234  f0240573          BIC      r5,r4,#0x73           ;688
000238  880c              LDRH     r4,[r1,#0]            ;690
00023a  432c              ORRS     r4,r4,r5              ;690
;;;694      /* Set the Output Compare Polarity */
;;;695      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00023c  898d              LDRH     r5,[r1,#0xc]
00023e  4315              ORRS     r5,r5,r2
;;;696      
;;;697      /* Set the Output State */
;;;698      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000240  884a              LDRH     r2,[r1,#2]
000242  432a              ORRS     r2,r2,r5
;;;699        
;;;700      if((TIMx == TIM1) || (TIMx == TIM8))
000244  4d6d              LDR      r5,|L1.1020|
000246  42a8              CMP      r0,r5
000248  d002              BEQ      |L1.592|
00024a  4d72              LDR      r5,|L1.1044|
00024c  42a8              CMP      r0,r5
00024e  d10d              BNE      |L1.620|
                  |L1.592|
;;;701      {
;;;702        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;703        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;704        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;705        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;706        
;;;707        /* Reset the Output N Polarity level */
;;;708        tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
000250  f0220508          BIC      r5,r2,#8
;;;709        /* Set the Output N Polarity */
;;;710        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000254  89ca              LDRH     r2,[r1,#0xe]
;;;711        /* Reset the Output N State */
;;;712        tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
;;;713        
;;;714        /* Set the Output N State */
;;;715        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
;;;716        /* Reset the Output Compare and Output Compare N IDLE State */
;;;717        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
;;;718        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
000256  f4237340          BIC      r3,r3,#0x300
00025a  432a              ORRS     r2,r2,r5              ;710
00025c  f0220504          BIC      r5,r2,#4              ;712
000260  888a              LDRH     r2,[r1,#4]            ;715
000262  432a              ORRS     r2,r2,r5              ;715
;;;719        /* Set the Output Idle state */
;;;720        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000264  8a0d              LDRH     r5,[r1,#0x10]
000266  431d              ORRS     r5,r5,r3
;;;721        /* Set the Output N Idle state */
;;;722        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000268  8a4b              LDRH     r3,[r1,#0x12]
00026a  432b              ORRS     r3,r3,r5
                  |L1.620|
;;;723      }
;;;724      /* Write to TIMx CR2 */
;;;725      TIMx->CR2 = tmpcr2;
00026c  8083              STRH     r3,[r0,#4]
;;;726      
;;;727      /* Write to TIMx CCMR1 */
;;;728      TIMx->CCMR1 = tmpccmrx;
00026e  8304              STRH     r4,[r0,#0x18]
;;;729      
;;;730      /* Set the Capture Compare Register value */
;;;731      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
000270  6889              LDR      r1,[r1,#8]
000272  6341              STR      r1,[r0,#0x34]
;;;732      
;;;733      /* Write to TIMx CCER */
;;;734      TIMx->CCER = tmpccer;
000274  8402              STRH     r2,[r0,#0x20]
;;;735    }
000276  bd30              POP      {r4,r5,pc}
;;;736    
                          ENDP

                  TIM_OC2Init PROC
;;;745      */
;;;746    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000278  b570              PUSH     {r4-r6,lr}
;;;747    {
;;;748      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;749       
;;;750      /* Check the parameters */
;;;751      assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;752      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;753      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;754      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;755    
;;;756      /* Disable the Channel 2: Reset the CC2E Bit */
;;;757      TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
00027a  8c02              LDRH     r2,[r0,#0x20]
00027c  f0220210          BIC      r2,r2,#0x10
000280  8402              STRH     r2,[r0,#0x20]
;;;758      
;;;759      /* Get the TIMx CCER register value */  
;;;760      tmpccer = TIMx->CCER;
000282  8c02              LDRH     r2,[r0,#0x20]
;;;761      /* Get the TIMx CR2 register value */
;;;762      tmpcr2 =  TIMx->CR2;
000284  8883              LDRH     r3,[r0,#4]
;;;763      
;;;764      /* Get the TIMx CCMR1 register value */
;;;765      tmpccmrx = TIMx->CCMR1;
000286  8b04              LDRH     r4,[r0,#0x18]
;;;766        
;;;767      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;768      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
;;;769      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
;;;770      
;;;771      /* Select the Output Compare Mode */
;;;772      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000288  880d              LDRH     r5,[r1,#0]
00028a  f42446e6          BIC      r6,r4,#0x7300         ;769
00028e  f64f74ff          MOV      r4,#0xffff
000292  ea042505          AND      r5,r4,r5,LSL #8
000296  4335              ORRS     r5,r5,r6
;;;773      
;;;774      /* Reset the Output Polarity level */
;;;775      tmpccer &= (uint16_t)~TIM_CCER_CC2P;
;;;776      /* Set the Output Compare Polarity */
;;;777      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000298  898e              LDRH     r6,[r1,#0xc]
00029a  f0220220          BIC      r2,r2,#0x20           ;775
00029e  ea041606          AND      r6,r4,r6,LSL #4
0002a2  4316              ORRS     r6,r6,r2
;;;778      
;;;779      /* Set the Output State */
;;;780      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
0002a4  884a              LDRH     r2,[r1,#2]
0002a6  ea041202          AND      r2,r4,r2,LSL #4
0002aa  4332              ORRS     r2,r2,r6
;;;781        
;;;782      if((TIMx == TIM1) || (TIMx == TIM8))
0002ac  4e53              LDR      r6,|L1.1020|
0002ae  42b0              CMP      r0,r6
0002b0  d002              BEQ      |L1.696|
0002b2  4e58              LDR      r6,|L1.1044|
0002b4  42b0              CMP      r0,r6
0002b6  d115              BNE      |L1.740|
                  |L1.696|
;;;783      {
;;;784        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;785        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;786        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;787        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;788        
;;;789        /* Reset the Output N Polarity level */
;;;790        tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
0002b8  f0220680          BIC      r6,r2,#0x80
;;;791        /* Set the Output N Polarity */
;;;792        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
0002bc  89ca              LDRH     r2,[r1,#0xe]
;;;793        /* Reset the Output N State */
;;;794        tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
;;;795        
;;;796        /* Set the Output N State */
;;;797        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
;;;798        /* Reset the Output Compare and Output Compare N IDLE State */
;;;799        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
;;;800        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
0002be  f4236340          BIC      r3,r3,#0xc00
0002c2  ea041202          AND      r2,r4,r2,LSL #4       ;792
0002c6  4332              ORRS     r2,r2,r6              ;792
0002c8  f0220640          BIC      r6,r2,#0x40           ;794
0002cc  888a              LDRH     r2,[r1,#4]            ;797
0002ce  ea041202          AND      r2,r4,r2,LSL #4       ;797
0002d2  4332              ORRS     r2,r2,r6              ;797
;;;801        /* Set the Output Idle state */
;;;802        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
0002d4  8a0e              LDRH     r6,[r1,#0x10]
0002d6  ea040686          AND      r6,r4,r6,LSL #2
0002da  431e              ORRS     r6,r6,r3
;;;803        /* Set the Output N Idle state */
;;;804        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
0002dc  8a4b              LDRH     r3,[r1,#0x12]
0002de  ea040383          AND      r3,r4,r3,LSL #2
0002e2  4333              ORRS     r3,r3,r6
                  |L1.740|
;;;805      }
;;;806      /* Write to TIMx CR2 */
;;;807      TIMx->CR2 = tmpcr2;
0002e4  8083              STRH     r3,[r0,#4]
;;;808      
;;;809      /* Write to TIMx CCMR1 */
;;;810      TIMx->CCMR1 = tmpccmrx;
0002e6  8305              STRH     r5,[r0,#0x18]
;;;811      
;;;812      /* Set the Capture Compare Register value */
;;;813      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
0002e8  6889              LDR      r1,[r1,#8]
0002ea  6381              STR      r1,[r0,#0x38]
;;;814      
;;;815      /* Write to TIMx CCER */
;;;816      TIMx->CCER = tmpccer;
0002ec  8402              STRH     r2,[r0,#0x20]
;;;817    }
0002ee  bd70              POP      {r4-r6,pc}
;;;818    
                          ENDP

                  TIM_OC3Init PROC
;;;826      */
;;;827    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
0002f0  b570              PUSH     {r4-r6,lr}
;;;828    {
;;;829      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;830       
;;;831      /* Check the parameters */
;;;832      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;833      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;834      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;835      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;836    
;;;837      /* Disable the Channel 3: Reset the CC2E Bit */
;;;838      TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
0002f2  8c02              LDRH     r2,[r0,#0x20]
0002f4  f4227280          BIC      r2,r2,#0x100
0002f8  8402              STRH     r2,[r0,#0x20]
;;;839      
;;;840      /* Get the TIMx CCER register value */
;;;841      tmpccer = TIMx->CCER;
0002fa  8c02              LDRH     r2,[r0,#0x20]
;;;842      /* Get the TIMx CR2 register value */
;;;843      tmpcr2 =  TIMx->CR2;
0002fc  8883              LDRH     r3,[r0,#4]
;;;844      
;;;845      /* Get the TIMx CCMR2 register value */
;;;846      tmpccmrx = TIMx->CCMR2;
0002fe  8b84              LDRH     r4,[r0,#0x1c]
;;;847        
;;;848      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;849      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
;;;850      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
;;;851      /* Select the Output Compare Mode */
;;;852      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000300  880d              LDRH     r5,[r1,#0]
000302  f0240473          BIC      r4,r4,#0x73           ;850
000306  4325              ORRS     r5,r5,r4
;;;853      
;;;854      /* Reset the Output Polarity level */
;;;855      tmpccer &= (uint16_t)~TIM_CCER_CC3P;
;;;856      /* Set the Output Compare Polarity */
;;;857      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000308  898e              LDRH     r6,[r1,#0xc]
00030a  f64f74ff          MOV      r4,#0xffff
00030e  f4227200          BIC      r2,r2,#0x200          ;855
000312  ea042606          AND      r6,r4,r6,LSL #8
000316  4316              ORRS     r6,r6,r2
;;;858      
;;;859      /* Set the Output State */
;;;860      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000318  884a              LDRH     r2,[r1,#2]
00031a  ea042202          AND      r2,r4,r2,LSL #8
00031e  4332              ORRS     r2,r2,r6
;;;861        
;;;862      if((TIMx == TIM1) || (TIMx == TIM8))
000320  4e36              LDR      r6,|L1.1020|
000322  42b0              CMP      r0,r6
000324  d002              BEQ      |L1.812|
000326  4e3b              LDR      r6,|L1.1044|
000328  42b0              CMP      r0,r6
00032a  d115              BNE      |L1.856|
                  |L1.812|
;;;863      {
;;;864        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;865        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;866        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;867        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;868        
;;;869        /* Reset the Output N Polarity level */
;;;870        tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
00032c  f4226600          BIC      r6,r2,#0x800
;;;871        /* Set the Output N Polarity */
;;;872        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000330  89ca              LDRH     r2,[r1,#0xe]
;;;873        /* Reset the Output N State */
;;;874        tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
;;;875        
;;;876        /* Set the Output N State */
;;;877        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
;;;878        /* Reset the Output Compare and Output Compare N IDLE State */
;;;879        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
;;;880        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
000332  f4235340          BIC      r3,r3,#0x3000
000336  ea042202          AND      r2,r4,r2,LSL #8       ;872
00033a  4332              ORRS     r2,r2,r6              ;872
00033c  f4226680          BIC      r6,r2,#0x400          ;874
000340  888a              LDRH     r2,[r1,#4]            ;877
000342  ea042202          AND      r2,r4,r2,LSL #8       ;877
000346  4332              ORRS     r2,r2,r6              ;877
;;;881        /* Set the Output Idle state */
;;;882        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000348  8a0e              LDRH     r6,[r1,#0x10]
00034a  ea041606          AND      r6,r4,r6,LSL #4
00034e  431e              ORRS     r6,r6,r3
;;;883        /* Set the Output N Idle state */
;;;884        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000350  8a4b              LDRH     r3,[r1,#0x12]
000352  ea041303          AND      r3,r4,r3,LSL #4
000356  4333              ORRS     r3,r3,r6
                  |L1.856|
;;;885      }
;;;886      /* Write to TIMx CR2 */
;;;887      TIMx->CR2 = tmpcr2;
000358  8083              STRH     r3,[r0,#4]
;;;888      
;;;889      /* Write to TIMx CCMR2 */
;;;890      TIMx->CCMR2 = tmpccmrx;
00035a  8385              STRH     r5,[r0,#0x1c]
;;;891      
;;;892      /* Set the Capture Compare Register value */
;;;893      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00035c  6889              LDR      r1,[r1,#8]
00035e  63c1              STR      r1,[r0,#0x3c]
;;;894      
;;;895      /* Write to TIMx CCER */
;;;896      TIMx->CCER = tmpccer;
000360  8402              STRH     r2,[r0,#0x20]
;;;897    }
000362  bd70              POP      {r4-r6,pc}
;;;898    
                          ENDP

                  TIM_OC4Init PROC
;;;906      */
;;;907    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000364  b570              PUSH     {r4-r6,lr}
;;;908    {
;;;909      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;910       
;;;911      /* Check the parameters */
;;;912      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;913      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;914      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;915      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;916    
;;;917      /* Disable the Channel 4: Reset the CC4E Bit */
;;;918      TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
000366  8c02              LDRH     r2,[r0,#0x20]
000368  f4225280          BIC      r2,r2,#0x1000
00036c  8402              STRH     r2,[r0,#0x20]
;;;919      
;;;920      /* Get the TIMx CCER register value */
;;;921      tmpccer = TIMx->CCER;
00036e  8c05              LDRH     r5,[r0,#0x20]
;;;922      /* Get the TIMx CR2 register value */
;;;923      tmpcr2 =  TIMx->CR2;
000370  8882              LDRH     r2,[r0,#4]
;;;924      
;;;925      /* Get the TIMx CCMR2 register value */
;;;926      tmpccmrx = TIMx->CCMR2;
000372  8b83              LDRH     r3,[r0,#0x1c]
;;;927        
;;;928      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;929      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
;;;930      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
;;;931      
;;;932      /* Select the Output Compare Mode */
;;;933      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000374  880c              LDRH     r4,[r1,#0]
000376  f42346e6          BIC      r6,r3,#0x7300         ;930
00037a  f64f73ff          MOV      r3,#0xffff
00037e  ea032404          AND      r4,r3,r4,LSL #8
000382  4334              ORRS     r4,r4,r6
;;;934      
;;;935      /* Reset the Output Polarity level */
;;;936      tmpccer &= (uint16_t)~TIM_CCER_CC4P;
000384  f4255600          BIC      r6,r5,#0x2000
;;;937      /* Set the Output Compare Polarity */
;;;938      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000388  898d              LDRH     r5,[r1,#0xc]
00038a  ea033505          AND      r5,r3,r5,LSL #12
00038e  4335              ORRS     r5,r5,r6
;;;939      
;;;940      /* Set the Output State */
;;;941      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
000390  884e              LDRH     r6,[r1,#2]
000392  ea033606          AND      r6,r3,r6,LSL #12
000396  432e              ORRS     r6,r6,r5
;;;942      
;;;943      if((TIMx == TIM1) || (TIMx == TIM8))
000398  4d18              LDR      r5,|L1.1020|
00039a  42a8              CMP      r0,r5
00039c  d002              BEQ      |L1.932|
00039e  4d1d              LDR      r5,|L1.1044|
0003a0  42a8              CMP      r0,r5
0003a2  d105              BNE      |L1.944|
                  |L1.932|
;;;944      {
;;;945        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;946        /* Reset the Output Compare IDLE State */
;;;947        tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
0003a4  f4224580          BIC      r5,r2,#0x4000
;;;948        /* Set the Output Idle state */
;;;949        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
0003a8  8a0a              LDRH     r2,[r1,#0x10]
0003aa  ea031282          AND      r2,r3,r2,LSL #6
0003ae  432a              ORRS     r2,r2,r5
                  |L1.944|
;;;950      }
;;;951      /* Write to TIMx CR2 */
;;;952      TIMx->CR2 = tmpcr2;
0003b0  8082              STRH     r2,[r0,#4]
;;;953      
;;;954      /* Write to TIMx CCMR2 */  
;;;955      TIMx->CCMR2 = tmpccmrx;
0003b2  8384              STRH     r4,[r0,#0x1c]
;;;956        
;;;957      /* Set the Capture Compare Register value */
;;;958      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
0003b4  6889              LDR      r1,[r1,#8]
0003b6  6401              STR      r1,[r0,#0x40]
;;;959      
;;;960      /* Write to TIMx CCER */
;;;961      TIMx->CCER = tmpccer;
0003b8  8406              STRH     r6,[r0,#0x20]
;;;962    }
0003ba  bd70              POP      {r4-r6,pc}
;;;963    
                          ENDP

                  TIM_OCStructInit PROC
;;;969      */
;;;970    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
0003bc  2100              MOVS     r1,#0
;;;971    {
;;;972      /* Set the default configuration */
;;;973      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
0003be  8001              STRH     r1,[r0,#0]
;;;974      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
0003c0  8041              STRH     r1,[r0,#2]
;;;975      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
0003c2  8081              STRH     r1,[r0,#4]
;;;976      TIM_OCInitStruct->TIM_Pulse = 0x00000000;
;;;977      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
0003c4  6081              STR      r1,[r0,#8]
0003c6  8181              STRH     r1,[r0,#0xc]
;;;978      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
0003c8  81c1              STRH     r1,[r0,#0xe]
;;;979      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
0003ca  8201              STRH     r1,[r0,#0x10]
;;;980      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
0003cc  8241              STRH     r1,[r0,#0x12]
;;;981    }
0003ce  4770              BX       lr
;;;982    
                          ENDP

                  TIM_SelectOCxM PROC
;;;1005     */
;;;1006   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
0003d0  b530              PUSH     {r4,r5,lr}
;;;1007   {
;;;1008     uint32_t tmp = 0;
;;;1009     uint16_t tmp1 = 0;
;;;1010   
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1013     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1014     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;1015   
;;;1016     tmp = (uint32_t) TIMx;
;;;1017     tmp += CCMR_OFFSET;
;;;1018   
;;;1019     tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
0003d2  2401              MOVS     r4,#1
;;;1020   
;;;1021     /* Disable the Channel: Reset the CCxE Bit */
;;;1022     TIMx->CCER &= (uint16_t) ~tmp1;
0003d4  8c05              LDRH     r5,[r0,#0x20]
0003d6  f1000318          ADD      r3,r0,#0x18           ;1017
0003da  408c              LSLS     r4,r4,r1              ;1019
0003dc  43a5              BICS     r5,r5,r4
0003de  8405              STRH     r5,[r0,#0x20]
0003e0  b331              CBZ      r1,|L1.1072|
;;;1023   
;;;1024     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
0003e2  2908              CMP      r1,#8
0003e4  d02c              BEQ      |L1.1088|
0003e6  1f09              SUBS     r1,r1,#4
;;;1025     {
;;;1026       tmp += (TIM_Channel>>1);
;;;1027   
;;;1028       /* Reset the OCxM bits in the CCMRx register */
;;;1029       *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
;;;1030      
;;;1031       /* Configure the OCxM bits in the CCMRx register */
;;;1032       *(__IO uint32_t *) tmp |= TIM_OCMode;
;;;1033     }
;;;1034     else
;;;1035     {
;;;1036       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
0003e8  f3c1004e          UBFX     r0,r1,#1,#15
0003ec  4418              ADD      r0,r0,r3
;;;1037   
;;;1038       /* Reset the OCxM bits in the CCMRx register */
;;;1039       *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
0003ee  6801              LDR      r1,[r0,#0]
0003f0  f64873ff          MOV      r3,#0x8fff
0003f4  4019              ANDS     r1,r1,r3
0003f6  6001              STR      r1,[r0,#0]
;;;1040       
;;;1041       /* Configure the OCxM bits in the CCMRx register */
;;;1042       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
0003f8  6801              LDR      r1,[r0,#0]
0003fa  e01a              B        |L1.1074|
                  |L1.1020|
                          DCD      0x40010000
                  |L1.1024|
                          DCD      0x40000400
                  |L1.1028|
                          DCD      0x40000800
                  |L1.1032|
                          DCD      0x40000c00
                  |L1.1036|
                          DCD      0x40001000
                  |L1.1040|
                          DCD      0x40001400
                  |L1.1044|
                          DCD      0x40010400
                  |L1.1048|
                          DCD      0x40014000
                  |L1.1052|
                          DCD      0x40014400
                  |L1.1056|
                          DCD      0x40014800
                  |L1.1060|
                          DCD      0x40001800
                  |L1.1064|
                          DCD      0x40001c00
                  |L1.1068|
                          DCD      0x40002000
                  |L1.1072|
000430  e006              B        |L1.1088|
                  |L1.1074|
000432  f64f73ff          MOV      r3,#0xffff
000436  ea032202          AND      r2,r3,r2,LSL #8
                  |L1.1082|
00043a  4311              ORRS     r1,r1,r2              ;1032
00043c  6001              STR      r1,[r0,#0]            ;1032
;;;1043     }
;;;1044   }
00043e  bd30              POP      {r4,r5,pc}
                  |L1.1088|
000440  eb030051          ADD      r0,r3,r1,LSR #1       ;1026
000444  6801              LDR      r1,[r0,#0]            ;1029
000446  f64f738f          MOV      r3,#0xff8f            ;1029
00044a  4019              ANDS     r1,r1,r3              ;1029
00044c  6001              STR      r1,[r0,#0]            ;1029
00044e  6801              LDR      r1,[r0,#0]            ;1032
000450  e7f3              B        |L1.1082|
;;;1045   
                          ENDP

                  TIM_SetCompare1 PROC
;;;1051     */
;;;1052   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
000452  6341              STR      r1,[r0,#0x34]
;;;1053   {
;;;1054     /* Check the parameters */
;;;1055     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1056   
;;;1057     /* Set the Capture Compare1 Register value */
;;;1058     TIMx->CCR1 = Compare1;
;;;1059   }
000454  4770              BX       lr
;;;1060   
                          ENDP

                  TIM_SetCompare2 PROC
;;;1067     */
;;;1068   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
000456  6381              STR      r1,[r0,#0x38]
;;;1069   {
;;;1070     /* Check the parameters */
;;;1071     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1072   
;;;1073     /* Set the Capture Compare2 Register value */
;;;1074     TIMx->CCR2 = Compare2;
;;;1075   }
000458  4770              BX       lr
;;;1076   
                          ENDP

                  TIM_SetCompare3 PROC
;;;1082     */
;;;1083   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
00045a  63c1              STR      r1,[r0,#0x3c]
;;;1084   {
;;;1085     /* Check the parameters */
;;;1086     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1087   
;;;1088     /* Set the Capture Compare3 Register value */
;;;1089     TIMx->CCR3 = Compare3;
;;;1090   }
00045c  4770              BX       lr
;;;1091   
                          ENDP

                  TIM_SetCompare4 PROC
;;;1097     */
;;;1098   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
00045e  6401              STR      r1,[r0,#0x40]
;;;1099   {
;;;1100     /* Check the parameters */
;;;1101     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1102   
;;;1103     /* Set the Capture Compare4 Register value */
;;;1104     TIMx->CCR4 = Compare4;
;;;1105   }
000460  4770              BX       lr
;;;1106   
                          ENDP

                  TIM_ForcedOC1Config PROC
;;;1115     */
;;;1116   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000462  8b02              LDRH     r2,[r0,#0x18]
;;;1117   {
;;;1118     uint16_t tmpccmr1 = 0;
;;;1119   
;;;1120     /* Check the parameters */
;;;1121     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1122     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1123     tmpccmr1 = TIMx->CCMR1;
;;;1124   
;;;1125     /* Reset the OC1M Bits */
;;;1126     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
000464  f0220270          BIC      r2,r2,#0x70
;;;1127   
;;;1128     /* Configure The Forced output Mode */
;;;1129     tmpccmr1 |= TIM_ForcedAction;
000468  430a              ORRS     r2,r2,r1
;;;1130   
;;;1131     /* Write to TIMx CCMR1 register */
;;;1132     TIMx->CCMR1 = tmpccmr1;
00046a  8302              STRH     r2,[r0,#0x18]
;;;1133   }
00046c  4770              BX       lr
;;;1134   
                          ENDP

                  TIM_ForcedOC2Config PROC
;;;1144     */
;;;1145   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
00046e  8b02              LDRH     r2,[r0,#0x18]
;;;1146   {
;;;1147     uint16_t tmpccmr1 = 0;
;;;1148   
;;;1149     /* Check the parameters */
;;;1150     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1151     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1152     tmpccmr1 = TIMx->CCMR1;
;;;1153   
;;;1154     /* Reset the OC2M Bits */
;;;1155     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
;;;1156   
;;;1157     /* Configure The Forced output Mode */
;;;1158     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000470  f64f73ff          MOV      r3,#0xffff
000474  f42242e0          BIC      r2,r2,#0x7000         ;1155
000478  ea032101          AND      r1,r3,r1,LSL #8
00047c  4311              ORRS     r1,r1,r2
;;;1159   
;;;1160     /* Write to TIMx CCMR1 register */
;;;1161     TIMx->CCMR1 = tmpccmr1;
00047e  8301              STRH     r1,[r0,#0x18]
;;;1162   }
000480  4770              BX       lr
;;;1163   
                          ENDP

                  TIM_ForcedOC3Config PROC
;;;1172     */
;;;1173   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000482  8b82              LDRH     r2,[r0,#0x1c]
;;;1174   {
;;;1175     uint16_t tmpccmr2 = 0;
;;;1176   
;;;1177     /* Check the parameters */
;;;1178     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1179     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1180   
;;;1181     tmpccmr2 = TIMx->CCMR2;
;;;1182   
;;;1183     /* Reset the OC1M Bits */
;;;1184     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
000484  f0220270          BIC      r2,r2,#0x70
;;;1185   
;;;1186     /* Configure The Forced output Mode */
;;;1187     tmpccmr2 |= TIM_ForcedAction;
000488  430a              ORRS     r2,r2,r1
;;;1188   
;;;1189     /* Write to TIMx CCMR2 register */
;;;1190     TIMx->CCMR2 = tmpccmr2;
00048a  8382              STRH     r2,[r0,#0x1c]
;;;1191   }
00048c  4770              BX       lr
;;;1192   
                          ENDP

                  TIM_ForcedOC4Config PROC
;;;1201     */
;;;1202   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
00048e  8b82              LDRH     r2,[r0,#0x1c]
;;;1203   {
;;;1204     uint16_t tmpccmr2 = 0;
;;;1205   
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1208     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1209     tmpccmr2 = TIMx->CCMR2;
;;;1210   
;;;1211     /* Reset the OC2M Bits */
;;;1212     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
;;;1213   
;;;1214     /* Configure The Forced output Mode */
;;;1215     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
000490  f64f73ff          MOV      r3,#0xffff
000494  f42242e0          BIC      r2,r2,#0x7000         ;1212
000498  ea032101          AND      r1,r3,r1,LSL #8
00049c  4311              ORRS     r1,r1,r2
;;;1216   
;;;1217     /* Write to TIMx CCMR2 register */
;;;1218     TIMx->CCMR2 = tmpccmr2;
00049e  8381              STRH     r1,[r0,#0x1c]
;;;1219   }
0004a0  4770              BX       lr
;;;1220   
                          ENDP

                  TIM_OC1PreloadConfig PROC
;;;1229     */
;;;1230   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
0004a2  8b02              LDRH     r2,[r0,#0x18]
;;;1231   {
;;;1232     uint16_t tmpccmr1 = 0;
;;;1233   
;;;1234     /* Check the parameters */
;;;1235     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1236     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1237   
;;;1238     tmpccmr1 = TIMx->CCMR1;
;;;1239   
;;;1240     /* Reset the OC1PE Bit */
;;;1241     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
0004a4  f0220208          BIC      r2,r2,#8
;;;1242   
;;;1243     /* Enable or Disable the Output Compare Preload feature */
;;;1244     tmpccmr1 |= TIM_OCPreload;
0004a8  430a              ORRS     r2,r2,r1
;;;1245   
;;;1246     /* Write to TIMx CCMR1 register */
;;;1247     TIMx->CCMR1 = tmpccmr1;
0004aa  8302              STRH     r2,[r0,#0x18]
;;;1248   }
0004ac  4770              BX       lr
;;;1249   
                          ENDP

                  TIM_OC2PreloadConfig PROC
;;;1259     */
;;;1260   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
0004ae  8b02              LDRH     r2,[r0,#0x18]
;;;1261   {
;;;1262     uint16_t tmpccmr1 = 0;
;;;1263   
;;;1264     /* Check the parameters */
;;;1265     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1266     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1267   
;;;1268     tmpccmr1 = TIMx->CCMR1;
;;;1269   
;;;1270     /* Reset the OC2PE Bit */
;;;1271     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
;;;1272   
;;;1273     /* Enable or Disable the Output Compare Preload feature */
;;;1274     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
0004b0  f64f73ff          MOV      r3,#0xffff
0004b4  f4226200          BIC      r2,r2,#0x800          ;1271
0004b8  ea032101          AND      r1,r3,r1,LSL #8
0004bc  4311              ORRS     r1,r1,r2
;;;1275   
;;;1276     /* Write to TIMx CCMR1 register */
;;;1277     TIMx->CCMR1 = tmpccmr1;
0004be  8301              STRH     r1,[r0,#0x18]
;;;1278   }
0004c0  4770              BX       lr
;;;1279   
                          ENDP

                  TIM_OC3PreloadConfig PROC
;;;1288     */
;;;1289   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
0004c2  8b82              LDRH     r2,[r0,#0x1c]
;;;1290   {
;;;1291     uint16_t tmpccmr2 = 0;
;;;1292   
;;;1293     /* Check the parameters */
;;;1294     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1295     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1296   
;;;1297     tmpccmr2 = TIMx->CCMR2;
;;;1298   
;;;1299     /* Reset the OC3PE Bit */
;;;1300     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
0004c4  f0220208          BIC      r2,r2,#8
;;;1301   
;;;1302     /* Enable or Disable the Output Compare Preload feature */
;;;1303     tmpccmr2 |= TIM_OCPreload;
0004c8  430a              ORRS     r2,r2,r1
;;;1304   
;;;1305     /* Write to TIMx CCMR2 register */
;;;1306     TIMx->CCMR2 = tmpccmr2;
0004ca  8382              STRH     r2,[r0,#0x1c]
;;;1307   }
0004cc  4770              BX       lr
;;;1308   
                          ENDP

                  TIM_OC4PreloadConfig PROC
;;;1317     */
;;;1318   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
0004ce  8b82              LDRH     r2,[r0,#0x1c]
;;;1319   {
;;;1320     uint16_t tmpccmr2 = 0;
;;;1321   
;;;1322     /* Check the parameters */
;;;1323     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1324     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1325   
;;;1326     tmpccmr2 = TIMx->CCMR2;
;;;1327   
;;;1328     /* Reset the OC4PE Bit */
;;;1329     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
;;;1330   
;;;1331     /* Enable or Disable the Output Compare Preload feature */
;;;1332     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
0004d0  f64f73ff          MOV      r3,#0xffff
0004d4  f4226200          BIC      r2,r2,#0x800          ;1329
0004d8  ea032101          AND      r1,r3,r1,LSL #8
0004dc  4311              ORRS     r1,r1,r2
;;;1333   
;;;1334     /* Write to TIMx CCMR2 register */
;;;1335     TIMx->CCMR2 = tmpccmr2;
0004de  8381              STRH     r1,[r0,#0x1c]
;;;1336   }
0004e0  4770              BX       lr
;;;1337   
                          ENDP

                  TIM_OC1FastConfig PROC
;;;1346     */
;;;1347   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0004e2  8b02              LDRH     r2,[r0,#0x18]
;;;1348   {
;;;1349     uint16_t tmpccmr1 = 0;
;;;1350   
;;;1351     /* Check the parameters */
;;;1352     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1353     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1354   
;;;1355     /* Get the TIMx CCMR1 register value */
;;;1356     tmpccmr1 = TIMx->CCMR1;
;;;1357   
;;;1358     /* Reset the OC1FE Bit */
;;;1359     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
0004e4  f0220204          BIC      r2,r2,#4
;;;1360   
;;;1361     /* Enable or Disable the Output Compare Fast Bit */
;;;1362     tmpccmr1 |= TIM_OCFast;
0004e8  430a              ORRS     r2,r2,r1
;;;1363   
;;;1364     /* Write to TIMx CCMR1 */
;;;1365     TIMx->CCMR1 = tmpccmr1;
0004ea  8302              STRH     r2,[r0,#0x18]
;;;1366   }
0004ec  4770              BX       lr
;;;1367   
                          ENDP

                  TIM_OC2FastConfig PROC
;;;1377     */
;;;1378   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0004ee  8b02              LDRH     r2,[r0,#0x18]
;;;1379   {
;;;1380     uint16_t tmpccmr1 = 0;
;;;1381   
;;;1382     /* Check the parameters */
;;;1383     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1384     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1385   
;;;1386     /* Get the TIMx CCMR1 register value */
;;;1387     tmpccmr1 = TIMx->CCMR1;
;;;1388   
;;;1389     /* Reset the OC2FE Bit */
;;;1390     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
;;;1391   
;;;1392     /* Enable or Disable the Output Compare Fast Bit */
;;;1393     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
0004f0  f64f73ff          MOV      r3,#0xffff
0004f4  f4226280          BIC      r2,r2,#0x400          ;1390
0004f8  ea032101          AND      r1,r3,r1,LSL #8
0004fc  4311              ORRS     r1,r1,r2
;;;1394   
;;;1395     /* Write to TIMx CCMR1 */
;;;1396     TIMx->CCMR1 = tmpccmr1;
0004fe  8301              STRH     r1,[r0,#0x18]
;;;1397   }
000500  4770              BX       lr
;;;1398   
                          ENDP

                  TIM_OC3FastConfig PROC
;;;1407     */
;;;1408   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000502  8b82              LDRH     r2,[r0,#0x1c]
;;;1409   {
;;;1410     uint16_t tmpccmr2 = 0;
;;;1411     
;;;1412     /* Check the parameters */
;;;1413     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1414     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1415   
;;;1416     /* Get the TIMx CCMR2 register value */
;;;1417     tmpccmr2 = TIMx->CCMR2;
;;;1418   
;;;1419     /* Reset the OC3FE Bit */
;;;1420     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
000504  f0220204          BIC      r2,r2,#4
;;;1421   
;;;1422     /* Enable or Disable the Output Compare Fast Bit */
;;;1423     tmpccmr2 |= TIM_OCFast;
000508  430a              ORRS     r2,r2,r1
;;;1424   
;;;1425     /* Write to TIMx CCMR2 */
;;;1426     TIMx->CCMR2 = tmpccmr2;
00050a  8382              STRH     r2,[r0,#0x1c]
;;;1427   }
00050c  4770              BX       lr
;;;1428   
                          ENDP

                  TIM_OC4FastConfig PROC
;;;1437     */
;;;1438   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
00050e  8b82              LDRH     r2,[r0,#0x1c]
;;;1439   {
;;;1440     uint16_t tmpccmr2 = 0;
;;;1441   
;;;1442     /* Check the parameters */
;;;1443     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1444     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1445   
;;;1446     /* Get the TIMx CCMR2 register value */
;;;1447     tmpccmr2 = TIMx->CCMR2;
;;;1448   
;;;1449     /* Reset the OC4FE Bit */
;;;1450     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
;;;1451   
;;;1452     /* Enable or Disable the Output Compare Fast Bit */
;;;1453     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
000510  f64f73ff          MOV      r3,#0xffff
000514  f4226280          BIC      r2,r2,#0x400          ;1450
000518  ea032101          AND      r1,r3,r1,LSL #8
00051c  4311              ORRS     r1,r1,r2
;;;1454   
;;;1455     /* Write to TIMx CCMR2 */
;;;1456     TIMx->CCMR2 = tmpccmr2;
00051e  8381              STRH     r1,[r0,#0x1c]
;;;1457   }
000520  4770              BX       lr
;;;1458   
                          ENDP

                  TIM_ClearOC1Ref PROC
;;;1467     */
;;;1468   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000522  8b02              LDRH     r2,[r0,#0x18]
;;;1469   {
;;;1470     uint16_t tmpccmr1 = 0;
;;;1471   
;;;1472     /* Check the parameters */
;;;1473     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1474     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1475   
;;;1476     tmpccmr1 = TIMx->CCMR1;
;;;1477   
;;;1478     /* Reset the OC1CE Bit */
;;;1479     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
000524  f0220280          BIC      r2,r2,#0x80
;;;1480   
;;;1481     /* Enable or Disable the Output Compare Clear Bit */
;;;1482     tmpccmr1 |= TIM_OCClear;
000528  430a              ORRS     r2,r2,r1
;;;1483   
;;;1484     /* Write to TIMx CCMR1 register */
;;;1485     TIMx->CCMR1 = tmpccmr1;
00052a  8302              STRH     r2,[r0,#0x18]
;;;1486   }
00052c  4770              BX       lr
;;;1487   
                          ENDP

                  TIM_ClearOC2Ref PROC
;;;1497     */
;;;1498   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
00052e  8b02              LDRH     r2,[r0,#0x18]
;;;1499   {
;;;1500     uint16_t tmpccmr1 = 0;
;;;1501   
;;;1502     /* Check the parameters */
;;;1503     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1504     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1505   
;;;1506     tmpccmr1 = TIMx->CCMR1;
;;;1507   
;;;1508     /* Reset the OC2CE Bit */
;;;1509     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
;;;1510   
;;;1511     /* Enable or Disable the Output Compare Clear Bit */
;;;1512     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
000530  f64f73ff          MOV      r3,#0xffff
000534  f3c2020e          UBFX     r2,r2,#0,#15          ;1509
000538  ea032101          AND      r1,r3,r1,LSL #8
00053c  4311              ORRS     r1,r1,r2
;;;1513   
;;;1514     /* Write to TIMx CCMR1 register */
;;;1515     TIMx->CCMR1 = tmpccmr1;
00053e  8301              STRH     r1,[r0,#0x18]
;;;1516   }
000540  4770              BX       lr
;;;1517   
                          ENDP

                  TIM_ClearOC3Ref PROC
;;;1526     */
;;;1527   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000542  8b82              LDRH     r2,[r0,#0x1c]
;;;1528   {
;;;1529     uint16_t tmpccmr2 = 0;
;;;1530   
;;;1531     /* Check the parameters */
;;;1532     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1533     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1534   
;;;1535     tmpccmr2 = TIMx->CCMR2;
;;;1536   
;;;1537     /* Reset the OC3CE Bit */
;;;1538     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
000544  f0220280          BIC      r2,r2,#0x80
;;;1539   
;;;1540     /* Enable or Disable the Output Compare Clear Bit */
;;;1541     tmpccmr2 |= TIM_OCClear;
000548  430a              ORRS     r2,r2,r1
;;;1542   
;;;1543     /* Write to TIMx CCMR2 register */
;;;1544     TIMx->CCMR2 = tmpccmr2;
00054a  8382              STRH     r2,[r0,#0x1c]
;;;1545   }
00054c  4770              BX       lr
;;;1546   
                          ENDP

                  TIM_ClearOC4Ref PROC
;;;1555     */
;;;1556   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
00054e  8b82              LDRH     r2,[r0,#0x1c]
;;;1557   {
;;;1558     uint16_t tmpccmr2 = 0;
;;;1559   
;;;1560     /* Check the parameters */
;;;1561     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1562     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1563   
;;;1564     tmpccmr2 = TIMx->CCMR2;
;;;1565   
;;;1566     /* Reset the OC4CE Bit */
;;;1567     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
;;;1568   
;;;1569     /* Enable or Disable the Output Compare Clear Bit */
;;;1570     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
000550  f64f73ff          MOV      r3,#0xffff
000554  f3c2020e          UBFX     r2,r2,#0,#15          ;1567
000558  ea032101          AND      r1,r3,r1,LSL #8
00055c  4311              ORRS     r1,r1,r2
;;;1571   
;;;1572     /* Write to TIMx CCMR2 register */
;;;1573     TIMx->CCMR2 = tmpccmr2;
00055e  8381              STRH     r1,[r0,#0x1c]
;;;1574   }
000560  4770              BX       lr
;;;1575   
                          ENDP

                  TIM_OC1PolarityConfig PROC
;;;1584     */
;;;1585   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000562  8c02              LDRH     r2,[r0,#0x20]
;;;1586   {
;;;1587     uint16_t tmpccer = 0;
;;;1588   
;;;1589     /* Check the parameters */
;;;1590     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1591     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1592   
;;;1593     tmpccer = TIMx->CCER;
;;;1594   
;;;1595     /* Set or Reset the CC1P Bit */
;;;1596     tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
000564  f0220202          BIC      r2,r2,#2
;;;1597     tmpccer |= TIM_OCPolarity;
000568  430a              ORRS     r2,r2,r1
;;;1598   
;;;1599     /* Write to TIMx CCER register */
;;;1600     TIMx->CCER = tmpccer;
00056a  8402              STRH     r2,[r0,#0x20]
;;;1601   }
00056c  4770              BX       lr
;;;1602   
                          ENDP

                  TIM_OC1NPolarityConfig PROC
;;;1611     */
;;;1612   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
00056e  8c02              LDRH     r2,[r0,#0x20]
;;;1613   {
;;;1614     uint16_t tmpccer = 0;
;;;1615     /* Check the parameters */
;;;1616     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1617     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1618      
;;;1619     tmpccer = TIMx->CCER;
;;;1620   
;;;1621     /* Set or Reset the CC1NP Bit */
;;;1622     tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
000570  f0220208          BIC      r2,r2,#8
;;;1623     tmpccer |= TIM_OCNPolarity;
000574  430a              ORRS     r2,r2,r1
;;;1624   
;;;1625     /* Write to TIMx CCER register */
;;;1626     TIMx->CCER = tmpccer;
000576  8402              STRH     r2,[r0,#0x20]
;;;1627   }
000578  4770              BX       lr
;;;1628   
                          ENDP

                  TIM_OC2PolarityConfig PROC
;;;1638     */
;;;1639   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
00057a  8c02              LDRH     r2,[r0,#0x20]
;;;1640   {
;;;1641     uint16_t tmpccer = 0;
;;;1642   
;;;1643     /* Check the parameters */
;;;1644     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1645     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1646   
;;;1647     tmpccer = TIMx->CCER;
;;;1648   
;;;1649     /* Set or Reset the CC2P Bit */
;;;1650     tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
;;;1651     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
00057c  f64f73ff          MOV      r3,#0xffff
000580  f0220220          BIC      r2,r2,#0x20           ;1650
000584  ea031101          AND      r1,r3,r1,LSL #4
000588  4311              ORRS     r1,r1,r2
;;;1652   
;;;1653     /* Write to TIMx CCER register */
;;;1654     TIMx->CCER = tmpccer;
00058a  8401              STRH     r1,[r0,#0x20]
;;;1655   }
00058c  4770              BX       lr
;;;1656   
                          ENDP

                  TIM_OC2NPolarityConfig PROC
;;;1665     */
;;;1666   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
00058e  8c02              LDRH     r2,[r0,#0x20]
;;;1667   {
;;;1668     uint16_t tmpccer = 0;
;;;1669   
;;;1670     /* Check the parameters */
;;;1671     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1672     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1673     
;;;1674     tmpccer = TIMx->CCER;
;;;1675   
;;;1676     /* Set or Reset the CC2NP Bit */
;;;1677     tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
;;;1678     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000590  f64f73ff          MOV      r3,#0xffff
000594  f0220280          BIC      r2,r2,#0x80           ;1677
000598  ea031101          AND      r1,r3,r1,LSL #4
00059c  4311              ORRS     r1,r1,r2
;;;1679   
;;;1680     /* Write to TIMx CCER register */
;;;1681     TIMx->CCER = tmpccer;
00059e  8401              STRH     r1,[r0,#0x20]
;;;1682   }
0005a0  4770              BX       lr
;;;1683   
                          ENDP

                  TIM_OC3PolarityConfig PROC
;;;1692     */
;;;1693   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
0005a2  8c02              LDRH     r2,[r0,#0x20]
;;;1694   {
;;;1695     uint16_t tmpccer = 0;
;;;1696   
;;;1697     /* Check the parameters */
;;;1698     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1699     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1700   
;;;1701     tmpccer = TIMx->CCER;
;;;1702   
;;;1703     /* Set or Reset the CC3P Bit */
;;;1704     tmpccer &= (uint16_t)~TIM_CCER_CC3P;
;;;1705     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
0005a4  f64f73ff          MOV      r3,#0xffff
0005a8  f4227200          BIC      r2,r2,#0x200          ;1704
0005ac  ea032101          AND      r1,r3,r1,LSL #8
0005b0  4311              ORRS     r1,r1,r2
;;;1706   
;;;1707     /* Write to TIMx CCER register */
;;;1708     TIMx->CCER = tmpccer;
0005b2  8401              STRH     r1,[r0,#0x20]
;;;1709   }
0005b4  4770              BX       lr
;;;1710   
                          ENDP

                  TIM_OC3NPolarityConfig PROC
;;;1719     */
;;;1720   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
0005b6  8c02              LDRH     r2,[r0,#0x20]
;;;1721   {
;;;1722     uint16_t tmpccer = 0;
;;;1723    
;;;1724     /* Check the parameters */
;;;1725     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1726     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1727       
;;;1728     tmpccer = TIMx->CCER;
;;;1729   
;;;1730     /* Set or Reset the CC3NP Bit */
;;;1731     tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
;;;1732     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
0005b8  f64f73ff          MOV      r3,#0xffff
0005bc  f4226200          BIC      r2,r2,#0x800          ;1731
0005c0  ea032101          AND      r1,r3,r1,LSL #8
0005c4  4311              ORRS     r1,r1,r2
;;;1733   
;;;1734     /* Write to TIMx CCER register */
;;;1735     TIMx->CCER = tmpccer;
0005c6  8401              STRH     r1,[r0,#0x20]
;;;1736   }
0005c8  4770              BX       lr
;;;1737   
                          ENDP

                  TIM_OC4PolarityConfig PROC
;;;1746     */
;;;1747   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
0005ca  8c02              LDRH     r2,[r0,#0x20]
;;;1748   {
;;;1749     uint16_t tmpccer = 0;
;;;1750   
;;;1751     /* Check the parameters */
;;;1752     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1753     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1754   
;;;1755     tmpccer = TIMx->CCER;
;;;1756   
;;;1757     /* Set or Reset the CC4P Bit */
;;;1758     tmpccer &= (uint16_t)~TIM_CCER_CC4P;
;;;1759     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
0005cc  f64f73ff          MOV      r3,#0xffff
0005d0  f4225200          BIC      r2,r2,#0x2000         ;1758
0005d4  ea033101          AND      r1,r3,r1,LSL #12
0005d8  4311              ORRS     r1,r1,r2
;;;1760   
;;;1761     /* Write to TIMx CCER register */
;;;1762     TIMx->CCER = tmpccer;
0005da  8401              STRH     r1,[r0,#0x20]
;;;1763   }
0005dc  4770              BX       lr
;;;1764   
                          ENDP

                  TIM_CCxCmd PROC
;;;1777     */
;;;1778   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
0005de  b510              PUSH     {r4,lr}
;;;1779   {
;;;1780     uint16_t tmp = 0;
;;;1781   
;;;1782     /* Check the parameters */
;;;1783     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;1784     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1785     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1786   
;;;1787     tmp = CCER_CCE_SET << TIM_Channel;
0005e0  2301              MOVS     r3,#1
;;;1788   
;;;1789     /* Reset the CCxE Bit */
;;;1790     TIMx->CCER &= (uint16_t)~ tmp;
0005e2  8c04              LDRH     r4,[r0,#0x20]
0005e4  408b              LSLS     r3,r3,r1              ;1787
0005e6  439c              BICS     r4,r4,r3
0005e8  8404              STRH     r4,[r0,#0x20]
;;;1791   
;;;1792     /* Set or reset the CCxE Bit */ 
;;;1793     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
0005ea  8c03              LDRH     r3,[r0,#0x20]
0005ec  408a              LSLS     r2,r2,r1
0005ee  4313              ORRS     r3,r3,r2
0005f0  8403              STRH     r3,[r0,#0x20]
;;;1794   }
0005f2  bd10              POP      {r4,pc}
;;;1795   
                          ENDP

                  TIM_CCxNCmd PROC
;;;1807     */
;;;1808   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
0005f4  b510              PUSH     {r4,lr}
;;;1809   {
;;;1810     uint16_t tmp = 0;
;;;1811   
;;;1812     /* Check the parameters */
;;;1813     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1814     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1815     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1816   
;;;1817     tmp = CCER_CCNE_SET << TIM_Channel;
0005f6  2304              MOVS     r3,#4
;;;1818   
;;;1819     /* Reset the CCxNE Bit */
;;;1820     TIMx->CCER &= (uint16_t) ~tmp;
0005f8  8c04              LDRH     r4,[r0,#0x20]
0005fa  408b              LSLS     r3,r3,r1              ;1817
0005fc  439c              BICS     r4,r4,r3
0005fe  8404              STRH     r4,[r0,#0x20]
;;;1821   
;;;1822     /* Set or reset the CCxNE Bit */ 
;;;1823     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000600  8c03              LDRH     r3,[r0,#0x20]
000602  408a              LSLS     r2,r2,r1
000604  4313              ORRS     r3,r3,r2
000606  8403              STRH     r3,[r0,#0x20]
;;;1824   }
000608  bd10              POP      {r4,pc}
;;;1825   /**
                          ENDP

                  TIM_SetIC4Prescaler PROC
;;;2157     */
;;;2158   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
00060a  8b82              LDRH     r2,[r0,#0x1c]
;;;2159   {  
;;;2160     /* Check the parameters */
;;;2161     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2162     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2163   
;;;2164     /* Reset the IC4PSC Bits */
;;;2165     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
00060c  f4226240          BIC      r2,r2,#0xc00
000610  8382              STRH     r2,[r0,#0x1c]
;;;2166   
;;;2167     /* Set the IC4PSC value */
;;;2168     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
000612  8b82              LDRH     r2,[r0,#0x1c]
000614  f64f73ff          MOV      r3,#0xffff
000618  ea032101          AND      r1,r3,r1,LSL #8
00061c  430a              ORRS     r2,r2,r1
00061e  8382              STRH     r2,[r0,#0x1c]
;;;2169   }
000620  4770              BX       lr
;;;2170   /**
                          ENDP

                  TIM_SetIC3Prescaler PROC
;;;2133     */
;;;2134   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000622  8b82              LDRH     r2,[r0,#0x1c]
;;;2135   {
;;;2136     /* Check the parameters */
;;;2137     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2138     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2139   
;;;2140     /* Reset the IC3PSC Bits */
;;;2141     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
000624  f022020c          BIC      r2,r2,#0xc
000628  8382              STRH     r2,[r0,#0x1c]
;;;2142   
;;;2143     /* Set the IC3PSC value */
;;;2144     TIMx->CCMR2 |= TIM_ICPSC;
00062a  8b82              LDRH     r2,[r0,#0x1c]
00062c  430a              ORRS     r2,r2,r1
00062e  8382              STRH     r2,[r0,#0x1c]
;;;2145   }
000630  4770              BX       lr
;;;2146   
                          ENDP

                  TIM_SetIC2Prescaler PROC
;;;2109     */
;;;2110   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000632  8b02              LDRH     r2,[r0,#0x18]
;;;2111   {
;;;2112     /* Check the parameters */
;;;2113     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2114     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2115   
;;;2116     /* Reset the IC2PSC Bits */
;;;2117     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
000634  f4226240          BIC      r2,r2,#0xc00
000638  8302              STRH     r2,[r0,#0x18]
;;;2118   
;;;2119     /* Set the IC2PSC value */
;;;2120     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
00063a  8b02              LDRH     r2,[r0,#0x18]
00063c  f64f73ff          MOV      r3,#0xffff
000640  ea032101          AND      r1,r3,r1,LSL #8
000644  430a              ORRS     r2,r2,r1
000646  8302              STRH     r2,[r0,#0x18]
;;;2121   }
000648  4770              BX       lr
;;;2122   
                          ENDP

                  TI2_Config PROC
;;;3231     */
;;;3232   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
00064a  b5f0              PUSH     {r4-r7,lr}
;;;3233                          uint16_t TIM_ICFilter)
;;;3234   {
;;;3235     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
;;;3236   
;;;3237     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3238     TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
00064c  8c04              LDRH     r4,[r0,#0x20]
00064e  f0240410          BIC      r4,r4,#0x10
000652  8404              STRH     r4,[r0,#0x20]
;;;3239     tmpccmr1 = TIMx->CCMR1;
000654  8b07              LDRH     r7,[r0,#0x18]
;;;3240     tmpccer = TIMx->CCER;
000656  8c06              LDRH     r6,[r0,#0x20]
;;;3241     tmp = (uint16_t)(TIM_ICPolarity << 4);
000658  f64f74ff          MOV      r4,#0xffff
00065c  ea041501          AND      r5,r4,r1,LSL #4
;;;3242   
;;;3243     /* Select the Input and set the filter */
;;;3244     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
000660  f4274773          BIC      r7,r7,#0xf300
;;;3245     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
000664  ea043103          AND      r1,r4,r3,LSL #12
000668  4339              ORRS     r1,r1,r7
;;;3246     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
00066a  ea042202          AND      r2,r4,r2,LSL #8
00066e  430a              ORRS     r2,r2,r1
;;;3247   
;;;3248     /* Select the Polarity and set the CC2E Bit */
;;;3249     tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000670  f02601a0          BIC      r1,r6,#0xa0
;;;3250     tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
000674  4329              ORRS     r1,r1,r5
000676  f0410110          ORR      r1,r1,#0x10
;;;3251   
;;;3252     /* Write to TIMx CCMR1 and CCER registers */
;;;3253     TIMx->CCMR1 = tmpccmr1 ;
00067a  8302              STRH     r2,[r0,#0x18]
;;;3254     TIMx->CCER = tmpccer;
00067c  8401              STRH     r1,[r0,#0x20]
;;;3255   }
00067e  bdf0              POP      {r4-r7,pc}
;;;3256   
                          ENDP

                  TIM_SetIC1Prescaler PROC
;;;2084     */
;;;2085   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000680  8b02              LDRH     r2,[r0,#0x18]
;;;2086   {
;;;2087     /* Check the parameters */
;;;2088     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2089     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2090   
;;;2091     /* Reset the IC1PSC Bits */
;;;2092     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
000682  f022020c          BIC      r2,r2,#0xc
000686  8302              STRH     r2,[r0,#0x18]
;;;2093   
;;;2094     /* Set the IC1PSC value */
;;;2095     TIMx->CCMR1 |= TIM_ICPSC;
000688  8b02              LDRH     r2,[r0,#0x18]
00068a  430a              ORRS     r2,r2,r1
00068c  8302              STRH     r2,[r0,#0x18]
;;;2096   }
00068e  4770              BX       lr
;;;2097   
                          ENDP

                  TIM_ICInit PROC
;;;1889     */
;;;1890   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000690  e92d41f0          PUSH     {r4-r8,lr}
;;;1891   {
000694  460c              MOV      r4,r1
;;;1892     /* Check the parameters */
;;;1893     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1894     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1895     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1896     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1897     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1898     
;;;1899     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000696  880e              LDRH     r6,[r1,#0]
;;;1900     {
;;;1901       /* TI1 Configuration */
;;;1902       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000698  8849              LDRH     r1,[r1,#2]
00069a  88a2              LDRH     r2,[r4,#4]
00069c  8923              LDRH     r3,[r4,#8]
00069e  4605              MOV      r5,r0                 ;1891
0006a0  b30e              CBZ      r6,|L1.1766|
;;;1903                  TIM_ICInitStruct->TIM_ICSelection,
;;;1904                  TIM_ICInitStruct->TIM_ICFilter);
;;;1905       /* Set the Input Capture Prescaler value */
;;;1906       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1907     }
;;;1908     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
0006a2  2e04              CMP      r6,#4
0006a4  d026              BEQ      |L1.1780|
;;;1909     {
;;;1910       /* TI2 Configuration */
;;;1911       assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1912       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1913                  TIM_ICInitStruct->TIM_ICSelection,
;;;1914                  TIM_ICInitStruct->TIM_ICFilter);
;;;1915       /* Set the Input Capture Prescaler value */
;;;1916       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1917     }
;;;1918     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
0006a6  2e08              CMP      r6,#8
0006a8  8c2e              LDRH     r6,[r5,#0x20]
0006aa  f64f70ff          MOV      r0,#0xffff
0006ae  d028              BEQ      |L1.1794|
0006b0  f4265680          BIC      r6,r6,#0x1000
0006b4  842e              STRH     r6,[r5,#0x20]
0006b6  8baf              LDRH     r7,[r5,#0x1c]
0006b8  8c2e              LDRH     r6,[r5,#0x20]
0006ba  ea002202          AND      r2,r0,r2,LSL #8
0006be  ea003101          AND      r1,r0,r1,LSL #12
0006c2  f4274773          BIC      r7,r7,#0xf300
0006c6  433a              ORRS     r2,r2,r7
0006c8  ea003003          AND      r0,r0,r3,LSL #12
0006cc  4310              ORRS     r0,r0,r2
0006ce  f4264220          BIC      r2,r6,#0xa000
0006d2  430a              ORRS     r2,r2,r1
0006d4  f4425180          ORR      r1,r2,#0x1000
0006d8  83a8              STRH     r0,[r5,#0x1c]
0006da  8429              STRH     r1,[r5,#0x20]
;;;1919     {
;;;1920       /* TI3 Configuration */
;;;1921       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1922       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;1923                  TIM_ICInitStruct->TIM_ICSelection,
;;;1924                  TIM_ICInitStruct->TIM_ICFilter);
;;;1925       /* Set the Input Capture Prescaler value */
;;;1926       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1927     }
;;;1928     else
;;;1929     {
;;;1930       /* TI4 Configuration */
;;;1931       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1932       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1933                  TIM_ICInitStruct->TIM_ICSelection,
;;;1934                  TIM_ICInitStruct->TIM_ICFilter);
;;;1935       /* Set the Input Capture Prescaler value */
;;;1936       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0006dc  88e1              LDRH     r1,[r4,#6]
0006de  4628              MOV      r0,r5
0006e0  e8bd41f0          POP      {r4-r8,lr}
0006e4  e7fe              B        TIM_SetIC4Prescaler
                  |L1.1766|
0006e6  f7fffffe          BL       TI1_Config
0006ea  88e1              LDRH     r1,[r4,#6]            ;1906
0006ec  4628              MOV      r0,r5                 ;1906
0006ee  e8bd41f0          POP      {r4-r8,lr}            ;1906
0006f2  e7fe              B        TIM_SetIC1Prescaler
                  |L1.1780|
0006f4  f7fffffe          BL       TI2_Config
0006f8  88e1              LDRH     r1,[r4,#6]            ;1916
0006fa  4628              MOV      r0,r5                 ;1916
0006fc  e8bd41f0          POP      {r4-r8,lr}            ;1916
000700  e7fe              B        TIM_SetIC2Prescaler
                  |L1.1794|
000702  f4267680          BIC      r6,r6,#0x100          ;1916
000706  842e              STRH     r6,[r5,#0x20]         ;1916
000708  8baf              LDRH     r7,[r5,#0x1c]         ;1916
00070a  8c2e              LDRH     r6,[r5,#0x20]         ;1916
00070c  ea002101          AND      r1,r0,r1,LSL #8       ;1916
000710  ea001003          AND      r0,r0,r3,LSL #4       ;1916
000714  4310              ORRS     r0,r0,r2              ;1916
000716  f02707f3          BIC      r7,r7,#0xf3           ;1916
00071a  4338              ORRS     r0,r0,r7              ;1916
00071c  f4266220          BIC      r2,r6,#0xa00          ;1916
000720  430a              ORRS     r2,r2,r1              ;1916
000722  f4427180          ORR      r1,r2,#0x100          ;1916
000726  83a8              STRH     r0,[r5,#0x1c]         ;1916
000728  8429              STRH     r1,[r5,#0x20]         ;1916
00072a  88e1              LDRH     r1,[r4,#6]            ;1926
00072c  4628              MOV      r0,r5                 ;1926
00072e  e8bd41f0          POP      {r4-r8,lr}            ;1926
000732  e7fe              B        TIM_SetIC3Prescaler
;;;1937     }
;;;1938   }
;;;1939   
                          ENDP

                  TIM_ICStructInit PROC
;;;1945     */
;;;1946   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000734  2100              MOVS     r1,#0
;;;1947   {
;;;1948     /* Set the default configuration */
;;;1949     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000736  8001              STRH     r1,[r0,#0]
;;;1950     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000738  8041              STRH     r1,[r0,#2]
;;;1951     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
00073a  2201              MOVS     r2,#1
00073c  8082              STRH     r2,[r0,#4]
;;;1952     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00073e  80c1              STRH     r1,[r0,#6]
;;;1953     TIM_ICInitStruct->TIM_ICFilter = 0x00;
000740  8101              STRH     r1,[r0,#8]
;;;1954   }
000742  4770              BX       lr
;;;1955   
                          ENDP

                  TIM_PWMIConfig PROC
;;;1964     */
;;;1965   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000744  e92d41f0          PUSH     {r4-r8,lr}
;;;1966   {
000748  460c              MOV      r4,r1
;;;1967     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
00074a  2600              MOVS     r6,#0
;;;1968     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
;;;1969   
;;;1970     /* Check the parameters */
;;;1971     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1972   
;;;1973     /* Select the Opposite Input Polarity */
;;;1974     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00074c  8849              LDRH     r1,[r1,#2]
00074e  4607              MOV      r7,r0                 ;1966
000750  2501              MOVS     r5,#1                 ;1968
000752  b901              CBNZ     r1,|L1.1878|
;;;1975     {
;;;1976       icoppositepolarity = TIM_ICPolarity_Falling;
000754  2602              MOVS     r6,#2
                  |L1.1878|
;;;1977     }
;;;1978     else
;;;1979     {
;;;1980       icoppositepolarity = TIM_ICPolarity_Rising;
;;;1981     }
;;;1982     /* Select the Opposite Input */
;;;1983     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000756  88a2              LDRH     r2,[r4,#4]
000758  2a01              CMP      r2,#1
00075a  d100              BNE      |L1.1886|
;;;1984     {
;;;1985       icoppositeselection = TIM_ICSelection_IndirectTI;
00075c  2502              MOVS     r5,#2
                  |L1.1886|
;;;1986     }
;;;1987     else
;;;1988     {
;;;1989       icoppositeselection = TIM_ICSelection_DirectTI;
;;;1990     }
;;;1991     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00075e  8820              LDRH     r0,[r4,#0]
;;;1992     {
;;;1993       /* TI1 Configuration */
;;;1994       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000760  8923              LDRH     r3,[r4,#8]
000762  2800              CMP      r0,#0                 ;1991
;;;1995                  TIM_ICInitStruct->TIM_ICFilter);
;;;1996       /* Set the Input Capture Prescaler value */
;;;1997       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1998       /* TI2 Configuration */
;;;1999       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;2000       /* Set the Input Capture Prescaler value */
;;;2001       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2002     }
;;;2003     else
;;;2004     { 
;;;2005       /* TI2 Configuration */
;;;2006       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000764  4638              MOV      r0,r7
000766  d010              BEQ      |L1.1930|
000768  f7fffffe          BL       TI2_Config
;;;2007                  TIM_ICInitStruct->TIM_ICFilter);
;;;2008       /* Set the Input Capture Prescaler value */
;;;2009       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00076c  88e1              LDRH     r1,[r4,#6]
00076e  4638              MOV      r0,r7
000770  f7fffffe          BL       TIM_SetIC2Prescaler
;;;2010       /* TI1 Configuration */
;;;2011       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000774  8923              LDRH     r3,[r4,#8]
000776  462a              MOV      r2,r5
000778  4631              MOV      r1,r6
00077a  4638              MOV      r0,r7
00077c  f7fffffe          BL       TI1_Config
;;;2012       /* Set the Input Capture Prescaler value */
;;;2013       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000780  88e1              LDRH     r1,[r4,#6]
000782  4638              MOV      r0,r7
000784  e8bd41f0          POP      {r4-r8,lr}
000788  e7fe              B        TIM_SetIC1Prescaler
                  |L1.1930|
00078a  f7fffffe          BL       TI1_Config
00078e  88e1              LDRH     r1,[r4,#6]            ;1997
000790  4638              MOV      r0,r7                 ;1997
000792  f7fffffe          BL       TIM_SetIC1Prescaler
000796  8923              LDRH     r3,[r4,#8]            ;1999
000798  462a              MOV      r2,r5                 ;1999
00079a  4631              MOV      r1,r6                 ;1999
00079c  4638              MOV      r0,r7                 ;1999
00079e  f7fffffe          BL       TI2_Config
0007a2  88e1              LDRH     r1,[r4,#6]            ;2001
0007a4  4638              MOV      r0,r7                 ;2001
0007a6  e8bd41f0          POP      {r4-r8,lr}            ;2001
0007aa  e7fe              B        TIM_SetIC2Prescaler
;;;2014     }
;;;2015   }
;;;2016   
                          ENDP

                  TIM_GetCapture1 PROC
;;;2021     */
;;;2022   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
0007ac  6b40              LDR      r0,[r0,#0x34]
;;;2023   {
;;;2024     /* Check the parameters */
;;;2025     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2026   
;;;2027     /* Get the Capture 1 Register value */
;;;2028     return TIMx->CCR1;
;;;2029   }
0007ae  4770              BX       lr
;;;2030   
                          ENDP

                  TIM_GetCapture2 PROC
;;;2036     */
;;;2037   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
0007b0  6b80              LDR      r0,[r0,#0x38]
;;;2038   {
;;;2039     /* Check the parameters */
;;;2040     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2041   
;;;2042     /* Get the Capture 2 Register value */
;;;2043     return TIMx->CCR2;
;;;2044   }
0007b2  4770              BX       lr
;;;2045   
                          ENDP

                  TIM_GetCapture3 PROC
;;;2050     */
;;;2051   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
0007b4  6bc0              LDR      r0,[r0,#0x3c]
;;;2052   {
;;;2053     /* Check the parameters */
;;;2054     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2055   
;;;2056     /* Get the Capture 3 Register value */
;;;2057     return TIMx->CCR3;
;;;2058   }
0007b6  4770              BX       lr
;;;2059   
                          ENDP

                  TIM_GetCapture4 PROC
;;;2064     */
;;;2065   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
0007b8  6c00              LDR      r0,[r0,#0x40]
;;;2066   {
;;;2067     /* Check the parameters */
;;;2068     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2069   
;;;2070     /* Get the Capture 4 Register value */
;;;2071     return TIMx->CCR4;
;;;2072   }
0007ba  4770              BX       lr
;;;2073   
                          ENDP

                  TIM_BDTRConfig PROC
;;;2210     */
;;;2211   void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
0007bc  b510              PUSH     {r4,lr}
;;;2212   {
;;;2213     /* Check the parameters */
;;;2214     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2215     assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;2216     assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;2217     assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;2218     assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;2219     assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;2220     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;2221   
;;;2222     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;2223        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;2224     TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
0007be  880a              LDRH     r2,[r1,#0]
0007c0  884b              LDRH     r3,[r1,#2]
0007c2  88cc              LDRH     r4,[r1,#6]
0007c4  431a              ORRS     r2,r2,r3
0007c6  888b              LDRH     r3,[r1,#4]
0007c8  4323              ORRS     r3,r3,r4
0007ca  431a              ORRS     r2,r2,r3
0007cc  890b              LDRH     r3,[r1,#8]
0007ce  431a              ORRS     r2,r2,r3
0007d0  894b              LDRH     r3,[r1,#0xa]
0007d2  8989              LDRH     r1,[r1,#0xc]
0007d4  431a              ORRS     r2,r2,r3
0007d6  430a              ORRS     r2,r2,r1
0007d8  f8a02044          STRH     r2,[r0,#0x44]
;;;2225                TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;2226                TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;2227                TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;2228   }
0007dc  bd10              POP      {r4,pc}
;;;2229   
                          ENDP

                  TIM_BDTRStructInit PROC
;;;2235     */
;;;2236   void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
0007de  2100              MOVS     r1,#0
;;;2237   {
;;;2238     /* Set the default configuration */
;;;2239     TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
0007e0  8001              STRH     r1,[r0,#0]
;;;2240     TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
0007e2  8041              STRH     r1,[r0,#2]
;;;2241     TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
0007e4  8081              STRH     r1,[r0,#4]
;;;2242     TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
0007e6  80c1              STRH     r1,[r0,#6]
;;;2243     TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
0007e8  8101              STRH     r1,[r0,#8]
;;;2244     TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
0007ea  8141              STRH     r1,[r0,#0xa]
;;;2245     TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
0007ec  8181              STRH     r1,[r0,#0xc]
;;;2246   }
0007ee  4770              BX       lr
;;;2247   
                          ENDP

                  TIM_CtrlPWMOutputs PROC
;;;2254     */
;;;2255   void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
0007f0  2900              CMP      r1,#0
;;;2256   {
;;;2257     /* Check the parameters */
;;;2258     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2259     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2260   
;;;2261     if (NewState != DISABLE)
;;;2262     {
;;;2263       /* Enable the TIM Main Output */
;;;2264       TIMx->BDTR |= TIM_BDTR_MOE;
;;;2265     }
;;;2266     else
;;;2267     {
;;;2268       /* Disable the TIM Main Output */
;;;2269       TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
0007f2  f8301f44          LDRH     r1,[r0,#0x44]!
0007f6  d002              BEQ      |L1.2046|
0007f8  f4414100          ORR      r1,r1,#0x8000         ;2264
0007fc  e001              B        |L1.2050|
                  |L1.2046|
0007fe  f3c1010e          UBFX     r1,r1,#0,#15
                  |L1.2050|
000802  8001              STRH     r1,[r0,#0]            ;2264
;;;2270     }  
;;;2271   }
000804  4770              BX       lr
;;;2272   
                          ENDP

                  TIM_SelectCOM PROC
;;;2279     */
;;;2280   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000806  2900              CMP      r1,#0
;;;2281   {
;;;2282     /* Check the parameters */
;;;2283     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2284     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2285   
;;;2286     if (NewState != DISABLE)
;;;2287     {
;;;2288       /* Set the COM Bit */
;;;2289       TIMx->CR2 |= TIM_CR2_CCUS;
;;;2290     }
;;;2291     else
;;;2292     {
;;;2293       /* Reset the COM Bit */
;;;2294       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
000808  8881              LDRH     r1,[r0,#4]
00080a  d002              BEQ      |L1.2066|
00080c  f0410104          ORR      r1,r1,#4              ;2289
000810  e001              B        |L1.2070|
                  |L1.2066|
000812  f0210104          BIC      r1,r1,#4
                  |L1.2070|
000816  8081              STRH     r1,[r0,#4]            ;2289
;;;2295     }
;;;2296   }
000818  4770              BX       lr
;;;2297   
                          ENDP

                  TIM_CCPreloadControl PROC
;;;2304     */
;;;2305   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
00081a  2900              CMP      r1,#0
;;;2306   { 
;;;2307     /* Check the parameters */
;;;2308     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2309     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2310     if (NewState != DISABLE)
;;;2311     {
;;;2312       /* Set the CCPC Bit */
;;;2313       TIMx->CR2 |= TIM_CR2_CCPC;
;;;2314     }
;;;2315     else
;;;2316     {
;;;2317       /* Reset the CCPC Bit */
;;;2318       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
00081c  8881              LDRH     r1,[r0,#4]
00081e  d002              BEQ      |L1.2086|
000820  f0410101          ORR      r1,r1,#1              ;2313
000824  e001              B        |L1.2090|
                  |L1.2086|
000826  f0210101          BIC      r1,r1,#1
                  |L1.2090|
00082a  8081              STRH     r1,[r0,#4]            ;2313
;;;2319     }
;;;2320   }
00082c  4770              BX       lr
;;;2321   /**
                          ENDP

                  TIM_ITConfig PROC
;;;2361     */
;;;2362   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
00082e  2a00              CMP      r2,#0
;;;2363   {  
;;;2364     /* Check the parameters */
;;;2365     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2366     assert_param(IS_TIM_IT(TIM_IT));
;;;2367     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2368     
;;;2369     if (NewState != DISABLE)
;;;2370     {
;;;2371       /* Enable the Interrupt sources */
;;;2372       TIMx->DIER |= TIM_IT;
;;;2373     }
;;;2374     else
;;;2375     {
;;;2376       /* Disable the Interrupt sources */
;;;2377       TIMx->DIER &= (uint16_t)~TIM_IT;
000830  8982              LDRH     r2,[r0,#0xc]
000832  d001              BEQ      |L1.2104|
000834  430a              ORRS     r2,r2,r1              ;2372
000836  e000              B        |L1.2106|
                  |L1.2104|
000838  438a              BICS     r2,r2,r1
                  |L1.2106|
00083a  8182              STRH     r2,[r0,#0xc]          ;2372
;;;2378     }
;;;2379   }
00083c  4770              BX       lr
;;;2380   
                          ENDP

                  TIM_GenerateEvent PROC
;;;2399     */
;;;2400   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
00083e  8281              STRH     r1,[r0,#0x14]
;;;2401   { 
;;;2402     /* Check the parameters */
;;;2403     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2404     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;2405    
;;;2406     /* Set the event sources */
;;;2407     TIMx->EGR = TIM_EventSource;
;;;2408   }
000840  4770              BX       lr
;;;2409   
                          ENDP

                  TIM_GetFlagStatus PROC
;;;2432     */
;;;2433   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000842  4602              MOV      r2,r0
;;;2434   { 
;;;2435     ITStatus bitstatus = RESET;  
000844  2000              MOVS     r0,#0
;;;2436     /* Check the parameters */
;;;2437     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2438     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2439   
;;;2440     
;;;2441     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000846  8a12              LDRH     r2,[r2,#0x10]
000848  420a              TST      r2,r1
00084a  d000              BEQ      |L1.2126|
;;;2442     {
;;;2443       bitstatus = SET;
00084c  2001              MOVS     r0,#1
                  |L1.2126|
;;;2444     }
;;;2445     else
;;;2446     {
;;;2447       bitstatus = RESET;
;;;2448     }
;;;2449     return bitstatus;
;;;2450   }
00084e  4770              BX       lr
;;;2451   
                          ENDP

                  TIM_ClearFlag PROC
;;;2474     */
;;;2475   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000850  43c9              MVNS     r1,r1
;;;2476   {  
;;;2477     /* Check the parameters */
;;;2478     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2479      
;;;2480     /* Clear the flags */
;;;2481     TIMx->SR = (uint16_t)~TIM_FLAG;
000852  8201              STRH     r1,[r0,#0x10]
;;;2482   }
000854  4770              BX       lr
;;;2483   
                          ENDP

                  TIM_GetITStatus PROC
;;;2502     */
;;;2503   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000856  4602              MOV      r2,r0
;;;2504   {
;;;2505     ITStatus bitstatus = RESET;  
000858  2000              MOVS     r0,#0
;;;2506     uint16_t itstatus = 0x0, itenable = 0x0;
;;;2507     /* Check the parameters */
;;;2508     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2509     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2510      
;;;2511     itstatus = TIMx->SR & TIM_IT;
00085a  8a13              LDRH     r3,[r2,#0x10]
;;;2512     
;;;2513     itenable = TIMx->DIER & TIM_IT;
00085c  8992              LDRH     r2,[r2,#0xc]
00085e  420b              TST      r3,r1                 ;2511
000860  ea020201          AND      r2,r2,r1
000864  d002              BEQ      |L1.2156|
;;;2514     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000866  2a00              CMP      r2,#0
000868  d000              BEQ      |L1.2156|
;;;2515     {
;;;2516       bitstatus = SET;
00086a  2001              MOVS     r0,#1
                  |L1.2156|
;;;2517     }
;;;2518     else
;;;2519     {
;;;2520       bitstatus = RESET;
;;;2521     }
;;;2522     return bitstatus;
;;;2523   }
00086c  4770              BX       lr
;;;2524   
                          ENDP

                  TIM_ClearITPendingBit PROC
;;;2543     */
;;;2544   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
00086e  43c9              MVNS     r1,r1
;;;2545   {
;;;2546     /* Check the parameters */
;;;2547     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2548   
;;;2549     /* Clear the IT pending Bit */
;;;2550     TIMx->SR = (uint16_t)~TIM_IT;
000870  8201              STRH     r1,[r0,#0x10]
;;;2551   }
000872  4770              BX       lr
;;;2552   
                          ENDP

                  TIM_DMAConfig PROC
;;;2580     */
;;;2581   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000874  4311              ORRS     r1,r1,r2
;;;2582   {
;;;2583     /* Check the parameters */
;;;2584     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2585     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2586     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2587   
;;;2588     /* Set the DMA Base and the DMA Burst Length */
;;;2589     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000876  f8a01048          STRH     r1,[r0,#0x48]
;;;2590   }
00087a  4770              BX       lr
;;;2591   
                          ENDP

                  TIM_DMACmd PROC
;;;2607     */
;;;2608   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
00087c  2a00              CMP      r2,#0
;;;2609   { 
;;;2610     /* Check the parameters */
;;;2611     assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
;;;2612     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2613     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2614     
;;;2615     if (NewState != DISABLE)
;;;2616     {
;;;2617       /* Enable the DMA sources */
;;;2618       TIMx->DIER |= TIM_DMASource; 
;;;2619     }
;;;2620     else
;;;2621     {
;;;2622       /* Disable the DMA sources */
;;;2623       TIMx->DIER &= (uint16_t)~TIM_DMASource;
00087e  8982              LDRH     r2,[r0,#0xc]
000880  d001              BEQ      |L1.2182|
000882  430a              ORRS     r2,r2,r1              ;2618
000884  e000              B        |L1.2184|
                  |L1.2182|
000886  438a              BICS     r2,r2,r1
                  |L1.2184|
000888  8182              STRH     r2,[r0,#0xc]          ;2618
;;;2624     }
;;;2625   }
00088a  4770              BX       lr
;;;2626   
                          ENDP

                  TIM_SelectCCDMA PROC
;;;2633     */
;;;2634   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
00088c  2900              CMP      r1,#0
;;;2635   {
;;;2636     /* Check the parameters */
;;;2637     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2638     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2639   
;;;2640     if (NewState != DISABLE)
;;;2641     {
;;;2642       /* Set the CCDS Bit */
;;;2643       TIMx->CR2 |= TIM_CR2_CCDS;
;;;2644     }
;;;2645     else
;;;2646     {
;;;2647       /* Reset the CCDS Bit */
;;;2648       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
00088e  8881              LDRH     r1,[r0,#4]
000890  d002              BEQ      |L1.2200|
000892  f0410108          ORR      r1,r1,#8              ;2643
000896  e001              B        |L1.2204|
                  |L1.2200|
000898  f0210108          BIC      r1,r1,#8
                  |L1.2204|
00089c  8081              STRH     r1,[r0,#4]            ;2643
;;;2649     }
;;;2650   }
00089e  4770              BX       lr
;;;2651   /**
                          ENDP

                  TIM_InternalClockConfig PROC
;;;2672     */
;;;2673   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
0008a0  8901              LDRH     r1,[r0,#8]
;;;2674   {
;;;2675     /* Check the parameters */
;;;2676     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2677   
;;;2678     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2679     TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
0008a2  f0210107          BIC      r1,r1,#7
0008a6  8101              STRH     r1,[r0,#8]
;;;2680   }
0008a8  4770              BX       lr
;;;2681   
                          ENDP

                  TIM_SelectInputTrigger PROC
;;;2878     */
;;;2879   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
0008aa  8902              LDRH     r2,[r0,#8]
;;;2880   {
;;;2881     uint16_t tmpsmcr = 0;
;;;2882   
;;;2883     /* Check the parameters */
;;;2884     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;2885     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2886   
;;;2887     /* Get the TIMx SMCR register value */
;;;2888     tmpsmcr = TIMx->SMCR;
;;;2889   
;;;2890     /* Reset the TS Bits */
;;;2891     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
0008ac  f0220270          BIC      r2,r2,#0x70
;;;2892   
;;;2893     /* Set the Input Trigger source */
;;;2894     tmpsmcr |= TIM_InputTriggerSource;
0008b0  430a              ORRS     r2,r2,r1
;;;2895   
;;;2896     /* Write to TIMx SMCR */
;;;2897     TIMx->SMCR = tmpsmcr;
0008b2  8102              STRH     r2,[r0,#8]
;;;2898   }
0008b4  4770              BX       lr
;;;2899   
                          ENDP

                  TIM_ITRxExternalClockConfig PROC
;;;2693     */
;;;2694   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
0008b6  b500              PUSH     {lr}
;;;2695   {
0008b8  4603              MOV      r3,r0
;;;2696     /* Check the parameters */
;;;2697     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2698     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2699   
;;;2700     /* Select the Internal Trigger */
;;;2701     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
0008ba  f7fffffe          BL       TIM_SelectInputTrigger
;;;2702   
;;;2703     /* Select the External clock mode1 */
;;;2704     TIMx->SMCR |= TIM_SlaveMode_External1;
0008be  8918              LDRH     r0,[r3,#8]
0008c0  f0400007          ORR      r0,r0,#7
0008c4  8118              STRH     r0,[r3,#8]
;;;2705   }
0008c6  bd00              POP      {pc}
;;;2706   
                          ENDP

                  TIM_TIxExternalClockConfig PROC
;;;2723     */
;;;2724   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
0008c8  b570              PUSH     {r4-r6,lr}
;;;2725                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2726   {
0008ca  4616              MOV      r6,r2
0008cc  460d              MOV      r5,r1
;;;2727     /* Check the parameters */
;;;2728     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2729     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2730     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2731   
;;;2732     /* Configure the Timer Input Clock Source */
;;;2733     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
0008ce  2960              CMP      r1,#0x60
0008d0  4604              MOV      r4,r0                 ;2726
;;;2734     {
;;;2735       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;2736     }
;;;2737     else
;;;2738     {
;;;2739       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
0008d2  f04f0201          MOV      r2,#1
0008d6  4631              MOV      r1,r6
0008d8  d00a              BEQ      |L1.2288|
0008da  f7fffffe          BL       TI1_Config
                  |L1.2270|
;;;2740     }
;;;2741     /* Select the Trigger source */
;;;2742     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
0008de  4629              MOV      r1,r5
0008e0  4620              MOV      r0,r4
0008e2  f7fffffe          BL       TIM_SelectInputTrigger
;;;2743     /* Select the External clock mode1 */
;;;2744     TIMx->SMCR |= TIM_SlaveMode_External1;
0008e6  8920              LDRH     r0,[r4,#8]
0008e8  f0400007          ORR      r0,r0,#7
0008ec  8120              STRH     r0,[r4,#8]
;;;2745   }
0008ee  bd70              POP      {r4-r6,pc}
                  |L1.2288|
0008f0  f7fffffe          BL       TI2_Config
0008f4  e7f3              B        |L1.2270|
;;;2746   
                          ENDP

                  TIM_ETRConfig PROC
;;;2998     */
;;;2999   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
0008f6  b530              PUSH     {r4,r5,lr}
;;;3000                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;3001   {
;;;3002     uint16_t tmpsmcr = 0;
;;;3003   
;;;3004     /* Check the parameters */
;;;3005     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3006     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;3007     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;3008     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;3009   
;;;3010     tmpsmcr = TIMx->SMCR;
0008f8  8904              LDRH     r4,[r0,#8]
;;;3011   
;;;3012     /* Reset the ETR Bits */
;;;3013     tmpsmcr &= SMCR_ETR_MASK;
;;;3014   
;;;3015     /* Set the Prescaler, the Filter value and the Polarity */
;;;3016     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
0008fa  f64f75ff          MOV      r5,#0xffff
0008fe  ea052303          AND      r3,r5,r3,LSL #8
000902  4313              ORRS     r3,r3,r2
000904  b2e4              UXTB     r4,r4                 ;3013
000906  430b              ORRS     r3,r3,r1
000908  4323              ORRS     r3,r3,r4
;;;3017   
;;;3018     /* Write to TIMx SMCR */
;;;3019     TIMx->SMCR = tmpsmcr;
00090a  8103              STRH     r3,[r0,#8]
;;;3020   }
00090c  bd30              POP      {r4,r5,pc}
;;;3021   /**
                          ENDP

                  TIM_ETRClockMode1Config PROC
;;;2763     */
;;;2764   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
00090e  b510              PUSH     {r4,lr}
;;;2765                               uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2766   {
000910  4604              MOV      r4,r0
;;;2767     uint16_t tmpsmcr = 0;
;;;2768   
;;;2769     /* Check the parameters */
;;;2770     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2771     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2772     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2773     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2774     /* Configure the ETR Clock source */
;;;2775     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000912  f7fffffe          BL       TIM_ETRConfig
;;;2776     
;;;2777     /* Get the TIMx SMCR register value */
;;;2778     tmpsmcr = TIMx->SMCR;
000916  8920              LDRH     r0,[r4,#8]
;;;2779   
;;;2780     /* Reset the SMS Bits */
;;;2781     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
;;;2782   
;;;2783     /* Select the External clock mode1 */
;;;2784     tmpsmcr |= TIM_SlaveMode_External1;
;;;2785   
;;;2786     /* Select the Trigger selection : ETRF */
;;;2787     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
;;;2788     tmpsmcr |= TIM_TS_ETRF;
000918  f0400077          ORR      r0,r0,#0x77
;;;2789   
;;;2790     /* Write to TIMx SMCR */
;;;2791     TIMx->SMCR = tmpsmcr;
00091c  8120              STRH     r0,[r4,#8]
;;;2792   }
00091e  bd10              POP      {r4,pc}
;;;2793   
                          ENDP

                  TIM_ETRClockMode2Config PROC
;;;2810     */
;;;2811   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000920  b510              PUSH     {r4,lr}
;;;2812                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2813   {
000922  4604              MOV      r4,r0
;;;2814     /* Check the parameters */
;;;2815     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2816     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2817     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2818     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2819   
;;;2820     /* Configure the ETR Clock source */
;;;2821     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000924  f7fffffe          BL       TIM_ETRConfig
;;;2822   
;;;2823     /* Enable the External clock mode2 */
;;;2824     TIMx->SMCR |= TIM_SMCR_ECE;
000928  8920              LDRH     r0,[r4,#8]
00092a  f4404080          ORR      r0,r0,#0x4000
00092e  8120              STRH     r0,[r4,#8]
;;;2825   }
000930  bd10              POP      {r4,pc}
;;;2826   /**
                          ENDP

                  TIM_SelectOutputTrigger PROC
;;;2921     */
;;;2922   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000932  8882              LDRH     r2,[r0,#4]
;;;2923   {
;;;2924     /* Check the parameters */
;;;2925     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2926     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2927   
;;;2928     /* Reset the MMS Bits */
;;;2929     TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
000934  f0220270          BIC      r2,r2,#0x70
000938  8082              STRH     r2,[r0,#4]
;;;2930     /* Select the TRGO source */
;;;2931     TIMx->CR2 |=  TIM_TRGOSource;
00093a  8882              LDRH     r2,[r0,#4]
00093c  430a              ORRS     r2,r2,r1
00093e  8082              STRH     r2,[r0,#4]
;;;2932   }
000940  4770              BX       lr
;;;2933   
                          ENDP

                  TIM_SelectSlaveMode PROC
;;;2945     */
;;;2946   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000942  8902              LDRH     r2,[r0,#8]
;;;2947   {
;;;2948     /* Check the parameters */
;;;2949     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2950     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2951   
;;;2952     /* Reset the SMS Bits */
;;;2953     TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
000944  f0220207          BIC      r2,r2,#7
000948  8102              STRH     r2,[r0,#8]
;;;2954   
;;;2955     /* Select the Slave Mode */
;;;2956     TIMx->SMCR |= TIM_SlaveMode;
00094a  8902              LDRH     r2,[r0,#8]
00094c  430a              ORRS     r2,r2,r1
00094e  8102              STRH     r2,[r0,#8]
;;;2957   }
000950  4770              BX       lr
;;;2958   
                          ENDP

                  TIM_SelectMasterSlaveMode PROC
;;;2968     */
;;;2969   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000952  8902              LDRH     r2,[r0,#8]
;;;2970   {
;;;2971     /* Check the parameters */
;;;2972     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2973     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2974   
;;;2975     /* Reset the MSM Bit */
;;;2976     TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
000954  f0220280          BIC      r2,r2,#0x80
000958  8102              STRH     r2,[r0,#8]
;;;2977     
;;;2978     /* Set or Reset the MSM Bit */
;;;2979     TIMx->SMCR |= TIM_MasterSlaveMode;
00095a  8902              LDRH     r2,[r0,#8]
00095c  430a              ORRS     r2,r2,r1
00095e  8102              STRH     r2,[r0,#8]
;;;2980   }
000960  4770              BX       lr
;;;2981   
                          ENDP

                  TIM_EncoderInterfaceConfig PROC
;;;3056     */
;;;3057   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000962  b570              PUSH     {r4-r6,lr}
;;;3058                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;3059   {
;;;3060     uint16_t tmpsmcr = 0;
;;;3061     uint16_t tmpccmr1 = 0;
;;;3062     uint16_t tmpccer = 0;
;;;3063       
;;;3064     /* Check the parameters */
;;;3065     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3066     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;3067     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;3068     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;3069   
;;;3070     /* Get the TIMx SMCR register value */
;;;3071     tmpsmcr = TIMx->SMCR;
000964  8905              LDRH     r5,[r0,#8]
;;;3072   
;;;3073     /* Get the TIMx CCMR1 register value */
;;;3074     tmpccmr1 = TIMx->CCMR1;
000966  8b04              LDRH     r4,[r0,#0x18]
;;;3075   
;;;3076     /* Get the TIMx CCER register value */
;;;3077     tmpccer = TIMx->CCER;
000968  8c06              LDRH     r6,[r0,#0x20]
;;;3078   
;;;3079     /* Set the encoder Mode */
;;;3080     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
00096a  f0250507          BIC      r5,r5,#7
;;;3081     tmpsmcr |= TIM_EncoderMode;
00096e  430d              ORRS     r5,r5,r1
;;;3082   
;;;3083     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;3084     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
000970  f64f41fc          MOV      r1,#0xfcfc
000974  400c              ANDS     r4,r4,r1
;;;3085     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000976  f2401101          MOV      r1,#0x101
00097a  430c              ORRS     r4,r4,r1
;;;3086   
;;;3087     /* Set the TI1 and the TI2 Polarities */
;;;3088     tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
;;;3089     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00097c  f64f71ff          MOV      r1,#0xffff
000980  ea011103          AND      r1,r1,r3,LSL #4
000984  f0260622          BIC      r6,r6,#0x22           ;3088
000988  4311              ORRS     r1,r1,r2
00098a  4331              ORRS     r1,r1,r6
;;;3090   
;;;3091     /* Write to TIMx SMCR */
;;;3092     TIMx->SMCR = tmpsmcr;
00098c  8105              STRH     r5,[r0,#8]
;;;3093   
;;;3094     /* Write to TIMx CCMR1 */
;;;3095     TIMx->CCMR1 = tmpccmr1;
00098e  8304              STRH     r4,[r0,#0x18]
;;;3096   
;;;3097     /* Write to TIMx CCER */
;;;3098     TIMx->CCER = tmpccer;
000990  8401              STRH     r1,[r0,#0x20]
;;;3099   }
000992  bd70              POP      {r4-r6,pc}
;;;3100   
                          ENDP

                  TIM_SelectHallSensor PROC
;;;3108     */
;;;3109   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000994  2900              CMP      r1,#0
;;;3110   {
;;;3111     /* Check the parameters */
;;;3112     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3113     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3114   
;;;3115     if (NewState != DISABLE)
;;;3116     {
;;;3117       /* Set the TI1S Bit */
;;;3118       TIMx->CR2 |= TIM_CR2_TI1S;
;;;3119     }
;;;3120     else
;;;3121     {
;;;3122       /* Reset the TI1S Bit */
;;;3123       TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
000996  8881              LDRH     r1,[r0,#4]
000998  d002              BEQ      |L1.2464|
00099a  f0410180          ORR      r1,r1,#0x80           ;3118
00099e  e001              B        |L1.2468|
                  |L1.2464|
0009a0  f0210180          BIC      r1,r1,#0x80
                  |L1.2468|
0009a4  8081              STRH     r1,[r0,#4]            ;3118
;;;3124     }
;;;3125   }
0009a6  4770              BX       lr
;;;3126   /**
                          ENDP

                  TIM_RemapConfig PROC
;;;3159     */
;;;3160   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
0009a8  f8a01050          STRH     r1,[r0,#0x50]
;;;3161   {
;;;3162    /* Check the parameters */
;;;3163     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;3164     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;3165   
;;;3166     /* Set the Timer remapping configuration */
;;;3167     TIMx->OR =  TIM_Remap;
;;;3168   }
0009ac  4770              BX       lr
;;;3169   /**
                          ENDP

                  TI1_Config PROC
;;;3190     */
;;;3191   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
0009ae  b570              PUSH     {r4-r6,lr}
;;;3192                          uint16_t TIM_ICFilter)
;;;3193   {
;;;3194     uint16_t tmpccmr1 = 0, tmpccer = 0;
;;;3195   
;;;3196     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3197     TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
0009b0  8c04              LDRH     r4,[r0,#0x20]
0009b2  f0240401          BIC      r4,r4,#1
0009b6  8404              STRH     r4,[r0,#0x20]
;;;3198     tmpccmr1 = TIMx->CCMR1;
0009b8  8b05              LDRH     r5,[r0,#0x18]
;;;3199     tmpccer = TIMx->CCER;
0009ba  8c04              LDRH     r4,[r0,#0x20]
;;;3200   
;;;3201     /* Select the Input and set the filter */
;;;3202     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
;;;3203     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
0009bc  f64f76ff          MOV      r6,#0xffff
0009c0  ea061303          AND      r3,r6,r3,LSL #4
0009c4  4313              ORRS     r3,r3,r2
0009c6  f02505f3          BIC      r5,r5,#0xf3           ;3202
0009ca  432b              ORRS     r3,r3,r5
;;;3204   
;;;3205     /* Select the Polarity and set the CC1E Bit */
;;;3206     tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
0009cc  f024020a          BIC      r2,r4,#0xa
;;;3207     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
0009d0  430a              ORRS     r2,r2,r1
0009d2  f0420101          ORR      r1,r2,#1
;;;3208   
;;;3209     /* Write to TIMx CCMR1 and CCER registers */
;;;3210     TIMx->CCMR1 = tmpccmr1;
0009d6  8303              STRH     r3,[r0,#0x18]
;;;3211     TIMx->CCER = tmpccer;
0009d8  8401              STRH     r1,[r0,#0x20]
;;;3212   }
0009da  bd70              POP      {r4-r6,pc}
;;;3213   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_tim.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_tim_c_c458916b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REVSH|
#line 128
|__asm___15_stm32f4xx_tim_c_c458916b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
