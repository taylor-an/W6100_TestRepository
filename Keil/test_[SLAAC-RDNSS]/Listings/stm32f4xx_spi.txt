; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\objects\stm32f4xx_spi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_spi.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\test_[SLAAC-RDNSS] -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\io6Library\Application\loopback -I..\..\Libraries\io6Library\Ethernet -I..\..\Libraries\io6Library\Ethernet\W6100 -I..\..\Libraries\io6Library\Internet\DHCP -I..\..\Libraries\io6Library\Internet\DNS -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\io6Library\Internet\DHCP6 -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Ic:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F4XX -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f4xx_spi.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SPI_I2S_DeInit PROC
;;;217      */
;;;218    void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
000000  49b6              LDR      r1,|L1.732|
;;;219    {
000002  b510              PUSH     {r4,lr}
;;;220      /* Check the parameters */
;;;221      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;222    
;;;223      if (SPIx == SPI1)
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L1.30|
;;;224      {
;;;225        /* Enable SPI1 reset state */
;;;226        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
000008  1484              ASRS     r4,r0,#18
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;227        /* Release SPI1 from reset state */
;;;228        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.30|
;;;229      }
;;;230      else if (SPIx == SPI2)
00001e  49b0              LDR      r1,|L1.736|
000020  4288              CMP      r0,r1
000022  d102              BNE      |L1.42|
;;;231      {
;;;232        /* Enable SPI2 reset state */
;;;233        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
000024  2101              MOVS     r1,#1
000026  1404              ASRS     r4,r0,#16
;;;234        /* Release SPI2 from reset state */
;;;235        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
000028  e004              B        |L1.52|
                  |L1.42|
;;;236        }
;;;237      else
;;;238      {
;;;239        if (SPIx == SPI3)
00002a  49ae              LDR      r1,|L1.740|
00002c  4288              CMP      r0,r1
00002e  d10a              BNE      |L1.70|
;;;240        {
;;;241          /* Enable SPI3 reset state */
;;;242          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
000030  2101              MOVS     r1,#1
000032  13c4              ASRS     r4,r0,#15
                  |L1.52|
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;243          /* Release SPI3 from reset state */
;;;244          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
00003a  4620              MOV      r0,r4
00003c  e8bd4010          POP      {r4,lr}
000040  2100              MOVS     r1,#0
000042  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.70|
;;;245        }
;;;246      }
;;;247    }
000046  bd10              POP      {r4,pc}
;;;248    
                          ENDP

                  SPI_Init PROC
;;;256      */
;;;257    void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
000048  b530              PUSH     {r4,r5,lr}
;;;258    {
;;;259      uint16_t tmpreg = 0;
;;;260      
;;;261      /* check the parameters */
;;;262      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;263      
;;;264      /* Check the SPI parameters */
;;;265      assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
;;;266      assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
;;;267      assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
;;;268      assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
;;;269      assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
;;;270      assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
;;;271      assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
;;;272      assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
;;;273      assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
;;;274    
;;;275    /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;276      /* Get the SPIx CR1 value */
;;;277      tmpreg = SPIx->CR1;
00004a  8802              LDRH     r2,[r0,#0]
;;;278      /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
;;;279      tmpreg &= CR1_CLEAR_MASK;
;;;280      /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
;;;281         master/salve mode, CPOL and CPHA */
;;;282      /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
;;;283      /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
;;;284      /* Set LSBFirst bit according to SPI_FirstBit value */
;;;285      /* Set BR bits according to SPI_BaudRatePrescaler value */
;;;286      /* Set CPOL bit according to SPI_CPOL value */
;;;287      /* Set CPHA bit according to SPI_CPHA value */
;;;288      tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
00004c  884c              LDRH     r4,[r1,#2]
00004e  f4025341          AND      r3,r2,#0x3040         ;279
000052  880a              LDRH     r2,[r1,#0]
000054  88cd              LDRH     r5,[r1,#6]
000056  4322              ORRS     r2,r2,r4
000058  888c              LDRH     r4,[r1,#4]
00005a  432c              ORRS     r4,r4,r5
00005c  4322              ORRS     r2,r2,r4
00005e  890c              LDRH     r4,[r1,#8]
000060  4322              ORRS     r2,r2,r4
000062  894c              LDRH     r4,[r1,#0xa]
000064  4322              ORRS     r2,r2,r4
000066  898c              LDRH     r4,[r1,#0xc]
000068  4322              ORRS     r2,r2,r4
00006a  89cc              LDRH     r4,[r1,#0xe]
00006c  4322              ORRS     r2,r2,r4
00006e  431a              ORRS     r2,r2,r3
;;;289                      SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
;;;290                      SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
;;;291                      SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
;;;292      /* Write to SPIx CR1 */
;;;293      SPIx->CR1 = tmpreg;
000070  8002              STRH     r2,[r0,#0]
;;;294    
;;;295      /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;296      SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
000072  8b82              LDRH     r2,[r0,#0x1c]
000074  f4226200          BIC      r2,r2,#0x800
000078  8382              STRH     r2,[r0,#0x1c]
;;;297    /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;298      /* Write to SPIx CRCPOLY */
;;;299      SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
00007a  8a09              LDRH     r1,[r1,#0x10]
00007c  8201              STRH     r1,[r0,#0x10]
;;;300    }
00007e  bd30              POP      {r4,r5,pc}
;;;301    
                          ENDP

                  I2S_Init PROC
;;;320      */
;;;321    void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
000080  b5f0              PUSH     {r4-r7,lr}
;;;322    {
;;;323      uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
000082  2202              MOVS     r2,#2
000084  2300              MOVS     r3,#0
;;;324      uint32_t tmp = 0, i2sclk = 0;
;;;325    #ifndef I2S_EXTERNAL_CLOCK_VAL
;;;326      uint32_t pllm = 0, plln = 0, pllr = 0;
;;;327    #endif /* I2S_EXTERNAL_CLOCK_VAL */
;;;328      
;;;329      /* Check the I2S parameters */
;;;330      assert_param(IS_SPI_23_PERIPH(SPIx));
;;;331      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
;;;332      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
;;;333      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
;;;334      assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
;;;335      assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
;;;336      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
;;;337    
;;;338    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;339      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;340      SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
000086  8b85              LDRH     r5,[r0,#0x1c]
000088  2401              MOVS     r4,#1                 ;323
00008a  f24f0640          MOV      r6,#0xf040
00008e  4035              ANDS     r5,r5,r6
000090  8385              STRH     r5,[r0,#0x1c]
;;;341      SPIx->I2SPR = 0x0002;
000092  8402              STRH     r2,[r0,#0x20]
;;;342      
;;;343      /* Get the I2SCFGR register value */
;;;344      tmpreg = SPIx->I2SCFGR;
000094  8b85              LDRH     r5,[r0,#0x1c]
;;;345      
;;;346      /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
;;;347      if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
000096  688e              LDR      r6,[r1,#8]
000098  2e02              CMP      r6,#2
00009a  d038              BEQ      |L1.270|
;;;348      {
;;;349        i2sodd = (uint16_t)0;
;;;350        i2sdiv = (uint16_t)2;   
;;;351      }
;;;352      /* If the requested audio frequency is not the default, compute the prescaler */
;;;353      else
;;;354      {
;;;355        /* Check the frame length (For the Prescaler computing) *******************/
;;;356        if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
00009c  888a              LDRH     r2,[r1,#4]
00009e  b102              CBZ      r2,|L1.162|
;;;357        {
;;;358          /* Packet length is 16 bits */
;;;359          packetlength = 1;
;;;360        }
;;;361        else
;;;362        {
;;;363          /* Packet length is 32 bits */
;;;364          packetlength = 2;
0000a0  2402              MOVS     r4,#2
                  |L1.162|
;;;365        }
;;;366    
;;;367        /* Get I2S source Clock frequency  ****************************************/
;;;368          
;;;369        /* If an external I2S clock has to be used, this define should be set  
;;;370           in the project configuration or in the stm32f4xx_conf.h file */
;;;371      #ifdef I2S_EXTERNAL_CLOCK_VAL     
;;;372        /* Set external clock as I2S clock source */
;;;373        if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
;;;374        {
;;;375          RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
;;;376        }
;;;377        
;;;378        /* Set the I2S clock to the external clock  value */
;;;379        i2sclk = I2S_EXTERNAL_CLOCK_VAL;
;;;380    
;;;381      #else /* There is no define for External I2S clock source */
;;;382        /* Set PLLI2S as I2S clock source */
;;;383        if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
0000a2  4a91              LDR      r2,|L1.744|
0000a4  6813              LDR      r3,[r2,#0]
0000a6  021b              LSLS     r3,r3,#8
0000a8  d503              BPL      |L1.178|
;;;384        {
;;;385          RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
0000aa  6813              LDR      r3,[r2,#0]
0000ac  f4230300          BIC      r3,r3,#0x800000
0000b0  6013              STR      r3,[r2,#0]
                  |L1.178|
;;;386        }    
;;;387        
;;;388        /* Get the PLLI2SN value */
;;;389        plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
0000b2  4a8d              LDR      r2,|L1.744|
0000b4  327c              ADDS     r2,r2,#0x7c
0000b6  6813              LDR      r3,[r2,#0]
;;;390                          (RCC_PLLI2SCFGR_PLLI2SN >> 6));
;;;391        
;;;392        /* Get the PLLI2SR value */
;;;393        pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
0000b8  6812              LDR      r2,[r2,#0]
0000ba  f3c31388          UBFX     r3,r3,#6,#9           ;389
;;;394                          (RCC_PLLI2SCFGR_PLLI2SR >> 28));
;;;395        
;;;396        /* Get the PLLM value */
;;;397        pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
0000be  4e8a              LDR      r6,|L1.744|
0000c0  f3c27202          UBFX     r2,r2,#28,#3          ;393
0000c4  1f36              SUBS     r6,r6,#4
0000c6  6836              LDR      r6,[r6,#0]
;;;398        
;;;399        /* Get the I2S source clock value */
;;;400        i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
0000c8  4f88              LDR      r7,|L1.748|
0000ca  f006063f          AND      r6,r6,#0x3f           ;397
0000ce  fbb7f6f6          UDIV     r6,r7,r6
0000d2  435e              MULS     r6,r3,r6
0000d4  fbb6f2f2          UDIV     r2,r6,r2
;;;401      #endif /* I2S_EXTERNAL_CLOCK_VAL */
;;;402        
;;;403        /* Compute the Real divider depending on the MCLK output state, with a floating point */
;;;404        if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
0000d8  88cb              LDRH     r3,[r1,#6]
0000da  f5b37f00          CMP      r3,#0x200
0000de  d02b              BEQ      |L1.312|
;;;405        {
;;;406          /* MCLK output is enabled */
;;;407          tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
;;;408        }
;;;409        else
;;;410        {
;;;411          /* MCLK output is disabled */
;;;412          tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
0000e0  0163              LSLS     r3,r4,#5
0000e2  fbb2f2f3          UDIV     r2,r2,r3
                  |L1.230|
0000e6  eb020282          ADD      r2,r2,r2,LSL #2
0000ea  688b              LDR      r3,[r1,#8]
0000ec  0052              LSLS     r2,r2,#1
0000ee  fbb2f2f3          UDIV     r2,r2,r3
0000f2  1d52              ADDS     r2,r2,#5
0000f4  b292              UXTH     r2,r2
;;;413        }
;;;414        
;;;415        /* Remove the flatting point */
;;;416        tmp = tmp / 10;  
0000f6  230a              MOVS     r3,#0xa
0000f8  fbb2f2f3          UDIV     r2,r2,r3
;;;417          
;;;418        /* Check the parity of the divider */
;;;419        i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
0000fc  f0020301          AND      r3,r2,#1
;;;420       
;;;421        /* Compute the i2sdiv prescaler */
;;;422        i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
000100  1ad2              SUBS     r2,r2,r3
;;;423       
;;;424        /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
;;;425        i2sodd = (uint16_t) (i2sodd << 8);
000102  f64f74ff          MOV      r4,#0xffff
000106  f3c2024f          UBFX     r2,r2,#1,#16          ;422
00010a  ea042303          AND      r3,r4,r3,LSL #8
                  |L1.270|
;;;426      }
;;;427    
;;;428      /* Test if the divider is 1 or 0 or greater than 0xFF */
;;;429      if ((i2sdiv < 2) || (i2sdiv > 0xFF))
00010e  1e94              SUBS     r4,r2,#2
000110  2cfe              CMP      r4,#0xfe
000112  d301              BCC      |L1.280|
;;;430      {
;;;431        /* Set the default values */
;;;432        i2sdiv = 2;
000114  2202              MOVS     r2,#2
;;;433        i2sodd = 0;
000116  2300              MOVS     r3,#0
                  |L1.280|
;;;434      }
;;;435    
;;;436      /* Write to SPIx I2SPR register the computed value */
;;;437      SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
000118  88cc              LDRH     r4,[r1,#6]
00011a  431a              ORRS     r2,r2,r3
00011c  4314              ORRS     r4,r4,r2
00011e  8404              STRH     r4,[r0,#0x20]
;;;438     
;;;439      /* Configure the I2S with the SPI_InitStruct values */
;;;440      tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
000120  880a              LDRH     r2,[r1,#0]
000122  884b              LDRH     r3,[r1,#2]
000124  431a              ORRS     r2,r2,r3
000126  888b              LDRH     r3,[r1,#4]
000128  8989              LDRH     r1,[r1,#0xc]
00012a  430b              ORRS     r3,r3,r1
00012c  431a              ORRS     r2,r2,r3
00012e  432a              ORRS     r2,r2,r5
000130  f4426100          ORR      r1,r2,#0x800
;;;441                      (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
;;;442                      (uint16_t)I2S_InitStruct->I2S_CPOL))));
;;;443     
;;;444      /* Write to SPIx I2SCFGR */  
;;;445      SPIx->I2SCFGR = tmpreg;
000134  8381              STRH     r1,[r0,#0x1c]
;;;446    }
000136  bdf0              POP      {r4-r7,pc}
                  |L1.312|
000138  0a12              LSRS     r2,r2,#8              ;407
00013a  e7d4              B        |L1.230|
;;;447    
                          ENDP

                  SPI_StructInit PROC
;;;452      */
;;;453    void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
00013c  2100              MOVS     r1,#0
;;;454    {
;;;455    /*--------------- Reset SPI init structure parameters values -----------------*/
;;;456      /* Initialize the SPI_Direction member */
;;;457      SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
00013e  8001              STRH     r1,[r0,#0]
;;;458      /* initialize the SPI_Mode member */
;;;459      SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
000140  8041              STRH     r1,[r0,#2]
;;;460      /* initialize the SPI_DataSize member */
;;;461      SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
000142  8081              STRH     r1,[r0,#4]
;;;462      /* Initialize the SPI_CPOL member */
;;;463      SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
000144  80c1              STRH     r1,[r0,#6]
;;;464      /* Initialize the SPI_CPHA member */
;;;465      SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
000146  8101              STRH     r1,[r0,#8]
;;;466      /* Initialize the SPI_NSS member */
;;;467      SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
000148  8141              STRH     r1,[r0,#0xa]
;;;468      /* Initialize the SPI_BaudRatePrescaler member */
;;;469      SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
00014a  8181              STRH     r1,[r0,#0xc]
;;;470      /* Initialize the SPI_FirstBit member */
;;;471      SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
00014c  81c1              STRH     r1,[r0,#0xe]
;;;472      /* Initialize the SPI_CRCPolynomial member */
;;;473      SPI_InitStruct->SPI_CRCPolynomial = 7;
00014e  2107              MOVS     r1,#7
000150  8201              STRH     r1,[r0,#0x10]
;;;474    }
000152  4770              BX       lr
;;;475    
                          ENDP

                  I2S_StructInit PROC
;;;480      */
;;;481    void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
000154  2100              MOVS     r1,#0
;;;482    {
;;;483    /*--------------- Reset I2S init structure parameters values -----------------*/
;;;484      /* Initialize the I2S_Mode member */
;;;485      I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
000156  8001              STRH     r1,[r0,#0]
;;;486      
;;;487      /* Initialize the I2S_Standard member */
;;;488      I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
000158  8041              STRH     r1,[r0,#2]
;;;489      
;;;490      /* Initialize the I2S_DataFormat member */
;;;491      I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
00015a  8081              STRH     r1,[r0,#4]
;;;492      
;;;493      /* Initialize the I2S_MCLKOutput member */
;;;494      I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
00015c  80c1              STRH     r1,[r0,#6]
;;;495      
;;;496      /* Initialize the I2S_AudioFreq member */
;;;497      I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
00015e  2202              MOVS     r2,#2
;;;498      
;;;499      /* Initialize the I2S_CPOL member */
;;;500      I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
000160  6082              STR      r2,[r0,#8]
000162  8181              STRH     r1,[r0,#0xc]
;;;501    }
000164  4770              BX       lr
;;;502    
                          ENDP

                  SPI_Cmd PROC
;;;509      */
;;;510    void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000166  2900              CMP      r1,#0
;;;511    {
;;;512      /* Check the parameters */
;;;513      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;514      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;515      if (NewState != DISABLE)
;;;516      {
;;;517        /* Enable the selected SPI peripheral */
;;;518        SPIx->CR1 |= SPI_CR1_SPE;
;;;519      }
;;;520      else
;;;521      {
;;;522        /* Disable the selected SPI peripheral */
;;;523        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
000168  8801              LDRH     r1,[r0,#0]
00016a  d002              BEQ      |L1.370|
00016c  f0410140          ORR      r1,r1,#0x40           ;518
000170  e001              B        |L1.374|
                  |L1.370|
000172  f0210140          BIC      r1,r1,#0x40
                  |L1.374|
000176  8001              STRH     r1,[r0,#0]            ;518
;;;524      }
;;;525    }
000178  4770              BX       lr
;;;526    
                          ENDP

                  I2S_Cmd PROC
;;;534      */
;;;535    void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
00017a  2900              CMP      r1,#0
;;;536    {
;;;537      /* Check the parameters */
;;;538      assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
;;;539      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;540      
;;;541      if (NewState != DISABLE)
;;;542      {
;;;543        /* Enable the selected SPI peripheral (in I2S mode) */
;;;544        SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
;;;545      }
;;;546      else
;;;547      {
;;;548        /* Disable the selected SPI peripheral in I2S mode */
;;;549        SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
00017c  8b81              LDRH     r1,[r0,#0x1c]
00017e  d002              BEQ      |L1.390|
000180  f4416180          ORR      r1,r1,#0x400          ;544
000184  e001              B        |L1.394|
                  |L1.390|
000186  f4216180          BIC      r1,r1,#0x400
                  |L1.394|
00018a  8381              STRH     r1,[r0,#0x1c]         ;544
;;;550      }
;;;551    }
00018c  4770              BX       lr
;;;552    
                          ENDP

                  SPI_DataSizeConfig PROC
;;;561      */
;;;562    void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
00018e  8802              LDRH     r2,[r0,#0]
;;;563    {
;;;564      /* Check the parameters */
;;;565      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;566      assert_param(IS_SPI_DATASIZE(SPI_DataSize));
;;;567      /* Clear DFF bit */
;;;568      SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
000190  f4226200          BIC      r2,r2,#0x800
000194  8002              STRH     r2,[r0,#0]
;;;569      /* Set new DFF bit value */
;;;570      SPIx->CR1 |= SPI_DataSize;
000196  8802              LDRH     r2,[r0,#0]
000198  430a              ORRS     r2,r2,r1
00019a  8002              STRH     r2,[r0,#0]
;;;571    }
00019c  4770              BX       lr
;;;572    
                          ENDP

                  SPI_BiDirectionalLineConfig PROC
;;;581      */
;;;582    void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
00019e  f5b14f80          CMP      r1,#0x4000
;;;583    {
;;;584      /* Check the parameters */
;;;585      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;586      assert_param(IS_SPI_DIRECTION(SPI_Direction));
;;;587      if (SPI_Direction == SPI_Direction_Tx)
;;;588      {
;;;589        /* Set the Tx only mode */
;;;590        SPIx->CR1 |= SPI_Direction_Tx;
;;;591      }
;;;592      else
;;;593      {
;;;594        /* Set the Rx only mode */
;;;595        SPIx->CR1 &= SPI_Direction_Rx;
0001a2  8801              LDRH     r1,[r0,#0]
0001a4  d003              BEQ      |L1.430|
0001a6  f4214180          BIC      r1,r1,#0x4000
                  |L1.426|
0001aa  8001              STRH     r1,[r0,#0]            ;590
;;;596      }
;;;597    }
0001ac  4770              BX       lr
                  |L1.430|
0001ae  f4414180          ORR      r1,r1,#0x4000         ;590
0001b2  e7fa              B        |L1.426|
;;;598    
                          ENDP

                  SPI_NSSInternalSoftwareConfig PROC
;;;607      */
;;;608    void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
0001b4  f5a1427e          SUB      r2,r1,#0xfe00
;;;609    {
;;;610      /* Check the parameters */
;;;611      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;612      assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
;;;613      if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
;;;614      {
;;;615        /* Set NSS pin internally by software */
;;;616        SPIx->CR1 |= SPI_NSSInternalSoft_Set;
;;;617      }
;;;618      else
;;;619      {
;;;620        /* Reset NSS pin internally by software */
;;;621        SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
0001b8  8801              LDRH     r1,[r0,#0]
0001ba  3aff              SUBS     r2,r2,#0xff           ;613
0001bc  d002              BEQ      |L1.452|
0001be  f4417180          ORR      r1,r1,#0x100          ;616
0001c2  e001              B        |L1.456|
                  |L1.452|
0001c4  f4217180          BIC      r1,r1,#0x100
                  |L1.456|
0001c8  8001              STRH     r1,[r0,#0]            ;616
;;;622      }
;;;623    }
0001ca  4770              BX       lr
;;;624    
                          ENDP

                  SPI_SSOutputCmd PROC
;;;631      */
;;;632    void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
0001cc  2900              CMP      r1,#0
;;;633    {
;;;634      /* Check the parameters */
;;;635      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;636      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;637      if (NewState != DISABLE)
;;;638      {
;;;639        /* Enable the selected SPI SS output */
;;;640        SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
;;;641      }
;;;642      else
;;;643      {
;;;644        /* Disable the selected SPI SS output */
;;;645        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
0001ce  8881              LDRH     r1,[r0,#4]
0001d0  d002              BEQ      |L1.472|
0001d2  f0410104          ORR      r1,r1,#4              ;640
0001d6  e001              B        |L1.476|
                  |L1.472|
0001d8  f0210104          BIC      r1,r1,#4
                  |L1.476|
0001dc  8081              STRH     r1,[r0,#4]            ;640
;;;646      }
;;;647    }
0001de  4770              BX       lr
;;;648    
                          ENDP

                  SPI_TIModeCmd PROC
;;;662      */
;;;663    void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
0001e0  2900              CMP      r1,#0
;;;664    {
;;;665      /* Check the parameters */
;;;666      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;667      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;668    
;;;669      if (NewState != DISABLE)
;;;670      {
;;;671        /* Enable the TI mode for the selected SPI peripheral */
;;;672        SPIx->CR2 |= SPI_CR2_FRF;
;;;673      }
;;;674      else
;;;675      {
;;;676        /* Disable the TI mode for the selected SPI peripheral */
;;;677        SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
0001e2  8881              LDRH     r1,[r0,#4]
0001e4  d002              BEQ      |L1.492|
0001e6  f0410110          ORR      r1,r1,#0x10           ;672
0001ea  e001              B        |L1.496|
                  |L1.492|
0001ec  f0210110          BIC      r1,r1,#0x10
                  |L1.496|
0001f0  8081              STRH     r1,[r0,#4]            ;672
;;;678      }
;;;679    }
0001f2  4770              BX       lr
;;;680    
                          ENDP

                  I2S_FullDuplexConfig PROC
;;;699      */
;;;700    void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
0001f4  b530              PUSH     {r4,r5,lr}
;;;701    {
;;;702      uint16_t tmpreg = 0, tmp = 0;
;;;703      
;;;704      /* Check the I2S parameters */
;;;705      assert_param(IS_I2S_EXT_PERIPH(I2Sxext));
;;;706      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
;;;707      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
;;;708      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
;;;709      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
;;;710    
;;;711    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;712      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;713      I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
0001f6  8b82              LDRH     r2,[r0,#0x1c]
0001f8  2300              MOVS     r3,#0                 ;702
0001fa  f24f0440          MOV      r4,#0xf040
0001fe  4022              ANDS     r2,r2,r4
000200  8382              STRH     r2,[r0,#0x1c]
;;;714      I2Sxext->I2SPR = 0x0002;
000202  2202              MOVS     r2,#2
000204  8402              STRH     r2,[r0,#0x20]
;;;715      
;;;716      /* Get the I2SCFGR register value */
;;;717      tmpreg = I2Sxext->I2SCFGR;
000206  8b84              LDRH     r4,[r0,#0x1c]
;;;718      
;;;719      /* Get the mode to be configured for the extended I2S */
;;;720      if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
000208  880a              LDRH     r2,[r1,#0]
;;;721      {
;;;722        tmp = I2S_Mode_SlaveRx;
00020a  f44f7580          MOV      r5,#0x100
00020e  f5b27f00          CMP      r2,#0x200             ;720
000212  d000              BEQ      |L1.534|
000214  b902              CBNZ     r2,|L1.536|
                  |L1.534|
000216  462b              MOV      r3,r5
                  |L1.536|
;;;723      }
;;;724      else
;;;725      {
;;;726        if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
;;;727        {
;;;728          tmp = I2S_Mode_SlaveTx;
;;;729        }
;;;730      }
;;;731    
;;;732     
;;;733      /* Configure the I2S with the SPI_InitStruct values */
;;;734      tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
000218  884a              LDRH     r2,[r1,#2]
00021a  888d              LDRH     r5,[r1,#4]
00021c  8989              LDRH     r1,[r1,#0xc]
00021e  432a              ORRS     r2,r2,r5
000220  4319              ORRS     r1,r1,r3
000222  430a              ORRS     r2,r2,r1
000224  4322              ORRS     r2,r2,r4
000226  f4426100          ORR      r1,r2,#0x800
;;;735                      (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
;;;736                      (uint16_t)I2S_InitStruct->I2S_CPOL))));
;;;737     
;;;738      /* Write to SPIx I2SCFGR */  
;;;739      I2Sxext->I2SCFGR = tmpreg;
00022a  8381              STRH     r1,[r0,#0x1c]
;;;740    }
00022c  bd30              POP      {r4,r5,pc}
;;;741    
                          ENDP

                  SPI_I2S_ReceiveData PROC
;;;774      */
;;;775    uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
00022e  8980              LDRH     r0,[r0,#0xc]
;;;776    {
;;;777      /* Check the parameters */
;;;778      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;779      
;;;780      /* Return the data in the DR register */
;;;781      return SPIx->DR;
;;;782    }
000230  4770              BX       lr
;;;783    
                          ENDP

                  SPI_I2S_SendData PROC
;;;790      */
;;;791    void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
000232  8181              STRH     r1,[r0,#0xc]
;;;792    {
;;;793      /* Check the parameters */
;;;794      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;795      
;;;796      /* Write in the DR register the data to be sent */
;;;797      SPIx->DR = Data;
;;;798    }
000234  4770              BX       lr
;;;799    
                          ENDP

                  SPI_CalculateCRC PROC
;;;879      */
;;;880    void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
000236  2900              CMP      r1,#0
;;;881    {
;;;882      /* Check the parameters */
;;;883      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;884      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;885      if (NewState != DISABLE)
;;;886      {
;;;887        /* Enable the selected SPI CRC calculation */
;;;888        SPIx->CR1 |= SPI_CR1_CRCEN;
;;;889      }
;;;890      else
;;;891      {
;;;892        /* Disable the selected SPI CRC calculation */
;;;893        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
000238  8801              LDRH     r1,[r0,#0]
00023a  d002              BEQ      |L1.578|
00023c  f4415100          ORR      r1,r1,#0x2000         ;888
000240  e001              B        |L1.582|
                  |L1.578|
000242  f4215100          BIC      r1,r1,#0x2000
                  |L1.582|
000246  8001              STRH     r1,[r0,#0]            ;888
;;;894      }
;;;895    }
000248  4770              BX       lr
;;;896    
                          ENDP

                  SPI_TransmitCRC PROC
;;;901      */
;;;902    void SPI_TransmitCRC(SPI_TypeDef* SPIx)
00024a  8801              LDRH     r1,[r0,#0]
;;;903    {
;;;904      /* Check the parameters */
;;;905      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;906      
;;;907      /* Enable the selected SPI CRC transmission */
;;;908      SPIx->CR1 |= SPI_CR1_CRCNEXT;
00024c  f4415180          ORR      r1,r1,#0x1000
000250  8001              STRH     r1,[r0,#0]
;;;909    }
000252  4770              BX       lr
;;;910    
                          ENDP

                  SPI_GetCRC PROC
;;;919      */
;;;920    uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
000254  2901              CMP      r1,#1
;;;921    {
000256  d001              BEQ      |L1.604|
;;;922      uint16_t crcreg = 0;
;;;923      /* Check the parameters */
;;;924      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;925      assert_param(IS_SPI_CRC(SPI_CRC));
;;;926      if (SPI_CRC != SPI_CRC_Rx)
;;;927      {
;;;928        /* Get the Tx CRC register */
;;;929        crcreg = SPIx->TXCRCR;
000258  8b00              LDRH     r0,[r0,#0x18]
;;;930      }
;;;931      else
;;;932      {
;;;933        /* Get the Rx CRC register */
;;;934        crcreg = SPIx->RXCRCR;
;;;935      }
;;;936      /* Return the selected CRC register */
;;;937      return crcreg;
;;;938    }
00025a  4770              BX       lr
                  |L1.604|
00025c  8a80              LDRH     r0,[r0,#0x14]         ;934
00025e  4770              BX       lr
;;;939    
                          ENDP

                  SPI_GetCRCPolynomial PROC
;;;944      */
;;;945    uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
000260  8a00              LDRH     r0,[r0,#0x10]
;;;946    {
;;;947      /* Check the parameters */
;;;948      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;949      
;;;950      /* Return the CRC polynomial register */
;;;951      return SPIx->CRCPR;
;;;952    }
000262  4770              BX       lr
;;;953    
                          ENDP

                  SPI_I2S_DMACmd PROC
;;;981      */
;;;982    void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
000264  2a00              CMP      r2,#0
;;;983    {
;;;984      /* Check the parameters */
;;;985      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;986      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;987      assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
;;;988    
;;;989      if (NewState != DISABLE)
;;;990      {
;;;991        /* Enable the selected SPI DMA requests */
;;;992        SPIx->CR2 |= SPI_I2S_DMAReq;
;;;993      }
;;;994      else
;;;995      {
;;;996        /* Disable the selected SPI DMA requests */
;;;997        SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
000266  8882              LDRH     r2,[r0,#4]
000268  d001              BEQ      |L1.622|
00026a  430a              ORRS     r2,r2,r1              ;992
00026c  e000              B        |L1.624|
                  |L1.622|
00026e  438a              BICS     r2,r2,r1
                  |L1.624|
000270  8082              STRH     r2,[r0,#4]            ;992
;;;998      }
;;;999    }
000272  4770              BX       lr
;;;1000   
                          ENDP

                  SPI_I2S_ITConfig PROC
;;;1090     */
;;;1091   void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
000274  0909              LSRS     r1,r1,#4
;;;1092   {
;;;1093     uint16_t itpos = 0, itmask = 0 ;
;;;1094     
;;;1095     /* Check the parameters */
;;;1096     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1097     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1098     assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
;;;1099   
;;;1100     /* Get the SPI IT index */
;;;1101     itpos = SPI_I2S_IT >> 4;
;;;1102   
;;;1103     /* Set the IT mask */
;;;1104     itmask = (uint16_t)1 << (uint16_t)itpos;
000276  2301              MOVS     r3,#1
000278  408b              LSLS     r3,r3,r1
;;;1105   
;;;1106     if (NewState != DISABLE)
00027a  2a00              CMP      r2,#0
;;;1107     {
;;;1108       /* Enable the selected SPI interrupt */
;;;1109       SPIx->CR2 |= itmask;
;;;1110     }
;;;1111     else
;;;1112     {
;;;1113       /* Disable the selected SPI interrupt */
;;;1114       SPIx->CR2 &= (uint16_t)~itmask;
00027c  8882              LDRH     r2,[r0,#4]
00027e  b299              UXTH     r1,r3                 ;1104
000280  d001              BEQ      |L1.646|
000282  430a              ORRS     r2,r2,r1              ;1109
000284  e000              B        |L1.648|
                  |L1.646|
000286  438a              BICS     r2,r2,r1
                  |L1.648|
000288  8082              STRH     r2,[r0,#4]            ;1109
;;;1115     }
;;;1116   }
00028a  4770              BX       lr
;;;1117   
                          ENDP

                  SPI_I2S_GetFlagStatus PROC
;;;1134     */
;;;1135   FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
00028c  4602              MOV      r2,r0
;;;1136   {
;;;1137     FlagStatus bitstatus = RESET;
00028e  2000              MOVS     r0,#0
;;;1138     /* Check the parameters */
;;;1139     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1140     assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
;;;1141     
;;;1142     /* Check the status of the specified SPI flag */
;;;1143     if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
000290  8912              LDRH     r2,[r2,#8]
000292  420a              TST      r2,r1
000294  d000              BEQ      |L1.664|
;;;1144     {
;;;1145       /* SPI_I2S_FLAG is set */
;;;1146       bitstatus = SET;
000296  2001              MOVS     r0,#1
                  |L1.664|
;;;1147     }
;;;1148     else
;;;1149     {
;;;1150       /* SPI_I2S_FLAG is reset */
;;;1151       bitstatus = RESET;
;;;1152     }
;;;1153     /* Return the SPI_I2S_FLAG status */
;;;1154     return  bitstatus;
;;;1155   }
000298  4770              BX       lr
;;;1156   
                          ENDP

                  SPI_I2S_ClearFlag PROC
;;;1175     */
;;;1176   void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
00029a  43c9              MVNS     r1,r1
;;;1177   {
;;;1178     /* Check the parameters */
;;;1179     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1180     assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
;;;1181       
;;;1182     /* Clear the selected SPI CRC Error (CRCERR) flag */
;;;1183     SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
00029c  8101              STRH     r1,[r0,#8]
;;;1184   }
00029e  4770              BX       lr
;;;1185   
                          ENDP

                  SPI_I2S_GetITStatus PROC
;;;1200     */
;;;1201   ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
0002a0  b530              PUSH     {r4,r5,lr}
;;;1202   {
;;;1203     ITStatus bitstatus = RESET;
;;;1204     uint16_t itpos = 0, itmask = 0, enablestatus = 0;
;;;1205   
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1208     assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
;;;1209   
;;;1210     /* Get the SPI_I2S_IT index */
;;;1211     itpos = 0x01 << (SPI_I2S_IT & 0x0F);
0002a2  f001030f          AND      r3,r1,#0xf
0002a6  2501              MOVS     r5,#1
0002a8  4602              MOV      r2,r0                 ;1202
0002aa  fa05f403          LSL      r4,r5,r3
0002ae  2000              MOVS     r0,#0                 ;1203
0002b0  b2a3              UXTH     r3,r4
;;;1212   
;;;1213     /* Get the SPI_I2S_IT IT mask */
;;;1214     itmask = SPI_I2S_IT >> 4;
0002b2  0909              LSRS     r1,r1,#4
;;;1215   
;;;1216     /* Set the IT mask */
;;;1217     itmask = 0x01 << itmask;
0002b4  fa05f401          LSL      r4,r5,r1
;;;1218   
;;;1219     /* Get the SPI_I2S_IT enable bit status */
;;;1220     enablestatus = (SPIx->CR2 & itmask) ;
0002b8  8891              LDRH     r1,[r2,#4]
0002ba  b2a4              UXTH     r4,r4                 ;1217
;;;1221   
;;;1222     /* Check the status of the specified SPI interrupt */
;;;1223     if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
0002bc  8912              LDRH     r2,[r2,#8]
0002be  4021              ANDS     r1,r1,r4              ;1220
0002c0  421a              TST      r2,r3
0002c2  d002              BEQ      |L1.714|
0002c4  2900              CMP      r1,#0
0002c6  d000              BEQ      |L1.714|
;;;1224     {
;;;1225       /* SPI_I2S_IT is set */
;;;1226       bitstatus = SET;
0002c8  2001              MOVS     r0,#1
                  |L1.714|
;;;1227     }
;;;1228     else
;;;1229     {
;;;1230       /* SPI_I2S_IT is reset */
;;;1231       bitstatus = RESET;
;;;1232     }
;;;1233     /* Return the SPI_I2S_IT status */
;;;1234     return bitstatus;
;;;1235   }
0002ca  bd30              POP      {r4,r5,pc}
;;;1236   
                          ENDP

                  SPI_I2S_ClearITPendingBit PROC
;;;1255     */
;;;1256   void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
0002cc  f001020f          AND      r2,r1,#0xf
;;;1257   {
;;;1258     uint16_t itpos = 0;
;;;1259     /* Check the parameters */
;;;1260     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1261     assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
;;;1262   
;;;1263     /* Get the SPI_I2S IT index */
;;;1264     itpos = 0x01 << (SPI_I2S_IT & 0x0F);
0002d0  2101              MOVS     r1,#1
0002d2  4091              LSLS     r1,r1,r2
;;;1265   
;;;1266     /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
;;;1267     SPIx->SR = (uint16_t)~itpos;
0002d4  43c9              MVNS     r1,r1
0002d6  8101              STRH     r1,[r0,#8]
;;;1268   }
0002d8  4770              BX       lr
;;;1269   
                          ENDP

0002da  0000              DCW      0x0000
                  |L1.732|
                          DCD      0x40013000
                  |L1.736|
                          DCD      0x40003800
                  |L1.740|
                          DCD      0x40003c00
                  |L1.744|
                          DCD      0x40023808
                  |L1.748|
                          DCD      0x007a1200

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_spi.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_spi_c_2b928927____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_spi_c_2b928927____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_spi_c_2b928927____REVSH|
#line 128
|__asm___15_stm32f4xx_spi_c_2b928927____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
