; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\objects\stm32f4xx_rcc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_rcc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\test_[SLAAC-RDNSS] -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\io6Library\Application\loopback -I..\..\Libraries\io6Library\Ethernet -I..\..\Libraries\io6Library\Ethernet\W6100 -I..\..\Libraries\io6Library\Internet\DHCP -I..\..\Libraries\io6Library\Internet\DNS -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\io6Library\Internet\DHCP6 -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Ic:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DSTM32F407xx -DSTM32F4XX -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f4xx_rcc.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;195      */
;;;196    void RCC_DeInit(void)
000000  48ea              LDR      r0,|L1.940|
;;;197    {
;;;198      /* Set HSION bit */
;;;199      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;200    
;;;201      /* Reset CFGR register */
;;;202      RCC->CFGR = 0x00000000;
00000a  4ae8              LDR      r2,|L1.940|
00000c  2100              MOVS     r1,#0
00000e  3208              ADDS     r2,r2,#8
000010  6011              STR      r1,[r2,#0]
;;;203    
;;;204      /* Reset HSEON, CSSON and PLLON bits */
;;;205      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6802              LDR      r2,[r0,#0]
000014  4be6              LDR      r3,|L1.944|
000016  401a              ANDS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
;;;206    
;;;207      /* Reset PLLCFGR register */
;;;208      RCC->PLLCFGR = 0x24003010;
00001a  1d03              ADDS     r3,r0,#4
00001c  4ae5              LDR      r2,|L1.948|
00001e  601a              STR      r2,[r3,#0]
;;;209    
;;;210      /* Reset HSEBYP bit */
;;;211      RCC->CR &= (uint32_t)0xFFFBFFFF;
000020  6802              LDR      r2,[r0,#0]
000022  f4222280          BIC      r2,r2,#0x40000
000026  6002              STR      r2,[r0,#0]
;;;212    
;;;213      /* Disable all interrupts */
;;;214      RCC->CIR = 0x00000000;
000028  48e0              LDR      r0,|L1.940|
00002a  300c              ADDS     r0,r0,#0xc
00002c  6001              STR      r1,[r0,#0]
;;;215    }
00002e  4770              BX       lr
;;;216    
                          ENDP

                  RCC_HSEConfig PROC
;;;236      */
;;;237    void RCC_HSEConfig(uint8_t RCC_HSE)
000030  49de              LDR      r1,|L1.940|
;;;238    {
;;;239      /* Check the parameters */
;;;240      assert_param(IS_RCC_HSE(RCC_HSE));
;;;241    
;;;242      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;243      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000032  2200              MOVS     r2,#0
000034  1c89              ADDS     r1,r1,#2
000036  700a              STRB     r2,[r1,#0]
;;;244    
;;;245      /* Set the new HSE configuration -------------------------------------------*/
;;;246      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000038  7008              STRB     r0,[r1,#0]
;;;247    }
00003a  4770              BX       lr
;;;248    
                          ENDP

                  RCC_GetFlagStatus PROC
;;;1684     */
;;;1685   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
00003c  4602              MOV      r2,r0
;;;1686   {
;;;1687     uint32_t tmp = 0;
;;;1688     uint32_t statusreg = 0;
;;;1689     FlagStatus bitstatus = RESET;
00003e  2000              MOVS     r0,#0
;;;1690   
;;;1691     /* Check the parameters */
;;;1692     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1693   
;;;1694     /* Get the RCC register index */
;;;1695     tmp = RCC_FLAG >> 5;
000040  0951              LSRS     r1,r2,#5
;;;1696     if (tmp == 1)               /* The flag to check is in CR register */
000042  2901              CMP      r1,#1
000044  d00c              BEQ      |L1.96|
;;;1697     {
;;;1698       statusreg = RCC->CR;
;;;1699     }
;;;1700     else if (tmp == 2)          /* The flag to check is in BDCR register */
000046  2902              CMP      r1,#2
000048  d00c              BEQ      |L1.100|
;;;1701     {
;;;1702       statusreg = RCC->BDCR;
;;;1703     }
;;;1704     else                       /* The flag to check is in CSR register */
;;;1705     {
;;;1706       statusreg = RCC->CSR;
00004a  49d8              LDR      r1,|L1.940|
00004c  3174              ADDS     r1,r1,#0x74
                  |L1.78|
00004e  6809              LDR      r1,[r1,#0]            ;1702
;;;1707     }
;;;1708   
;;;1709     /* Get the flag position */
;;;1710     tmp = RCC_FLAG & FLAG_MASK;
000050  f002021f          AND      r2,r2,#0x1f
;;;1711     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000054  2301              MOVS     r3,#1
000056  4093              LSLS     r3,r3,r2
000058  420b              TST      r3,r1
00005a  d000              BEQ      |L1.94|
;;;1712     {
;;;1713       bitstatus = SET;
00005c  2001              MOVS     r0,#1
                  |L1.94|
;;;1714     }
;;;1715     else
;;;1716     {
;;;1717       bitstatus = RESET;
;;;1718     }
;;;1719     /* Return the flag status */
;;;1720     return bitstatus;
;;;1721   }
00005e  4770              BX       lr
                  |L1.96|
000060  49d2              LDR      r1,|L1.940|
000062  e7f4              B        |L1.78|
                  |L1.100|
000064  49d1              LDR      r1,|L1.940|
000066  3170              ADDS     r1,r1,#0x70           ;1702
000068  e7f1              B        |L1.78|
;;;1722   
                          ENDP

                  RCC_WaitForHSEStartUp PROC
;;;260      */
;;;261    ErrorStatus RCC_WaitForHSEStartUp(void)
00006a  b518              PUSH     {r3,r4,lr}
;;;262    {
;;;263      __IO uint32_t startupcounter = 0;
00006c  2000              MOVS     r0,#0
;;;264      ErrorStatus status = ERROR;
;;;265      FlagStatus hsestatus = RESET;
;;;266      /* Wait till HSE is ready and if Time out is reached exit */
;;;267      do
;;;268      {
;;;269        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;270        startupcounter++;
;;;271      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
00006e  f44f64a0          MOV      r4,#0x500
000072  9000              STR      r0,[sp,#0]
                  |L1.116|
000074  2031              MOVS     r0,#0x31              ;269
000076  f7fffffe          BL       RCC_GetFlagStatus
00007a  9900              LDR      r1,[sp,#0]            ;270
00007c  1c49              ADDS     r1,r1,#1              ;270
00007e  9100              STR      r1,[sp,#0]
000080  42a1              CMP      r1,r4
000082  d001              BEQ      |L1.136|
000084  2800              CMP      r0,#0
000086  d0f5              BEQ      |L1.116|
                  |L1.136|
;;;272    
;;;273      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000088  2031              MOVS     r0,#0x31
00008a  f7fffffe          BL       RCC_GetFlagStatus
00008e  2800              CMP      r0,#0
000090  d000              BEQ      |L1.148|
;;;274      {
;;;275        status = SUCCESS;
000092  2001              MOVS     r0,#1
                  |L1.148|
;;;276      }
;;;277      else
;;;278      {
;;;279        status = ERROR;
;;;280      }
;;;281      return (status);
;;;282    }
000094  bd18              POP      {r3,r4,pc}
;;;283    
                          ENDP

                  RCC_AdjustHSICalibrationValue PROC
;;;291      */
;;;292    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000096  4ac5              LDR      r2,|L1.940|
;;;293    {
;;;294      uint32_t tmpreg = 0;
;;;295      /* Check the parameters */
;;;296      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;297    
;;;298      tmpreg = RCC->CR;
000098  6811              LDR      r1,[r2,#0]
;;;299    
;;;300      /* Clear HSITRIM[4:0] bits */
;;;301      tmpreg &= ~RCC_CR_HSITRIM;
00009a  f02101f8          BIC      r1,r1,#0xf8
;;;302    
;;;303      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;304      tmpreg |= (uint32_t)HSICalibrationValue << 3;
00009e  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;305    
;;;306      /* Store the new value */
;;;307      RCC->CR = tmpreg;
0000a2  6010              STR      r0,[r2,#0]
;;;308    }
0000a4  4770              BX       lr
;;;309    
                          ENDP

                  RCC_HSICmd PROC
;;;327      */
;;;328    void RCC_HSICmd(FunctionalState NewState)
0000a6  49c4              LDR      r1,|L1.952|
;;;329    {
;;;330      /* Check the parameters */
;;;331      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;332    
;;;333      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
0000a8  6008              STR      r0,[r1,#0]
;;;334    }
0000aa  4770              BX       lr
;;;335    
                          ENDP

                  RCC_LSEConfig PROC
;;;352      */
;;;353    void RCC_LSEConfig(uint8_t RCC_LSE)
0000ac  49bf              LDR      r1,|L1.940|
;;;354    {
;;;355      /* Check the parameters */
;;;356      assert_param(IS_RCC_LSE(RCC_LSE));
;;;357    
;;;358      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;359      /* Reset LSEON bit */
;;;360      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0000ae  2200              MOVS     r2,#0
0000b0  3170              ADDS     r1,r1,#0x70
0000b2  700a              STRB     r2,[r1,#0]
;;;361    
;;;362      /* Reset LSEBYP bit */
;;;363      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
0000b4  700a              STRB     r2,[r1,#0]
;;;364    
;;;365      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;366      switch (RCC_LSE)
0000b6  2801              CMP      r0,#1
0000b8  d002              BEQ      |L1.192|
0000ba  2804              CMP      r0,#4
0000bc  d101              BNE      |L1.194|
;;;367      {
;;;368        case RCC_LSE_ON:
;;;369          /* Set LSEON bit */
;;;370          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;371          break;
;;;372        case RCC_LSE_Bypass:
;;;373          /* Set LSEBYP and LSEON bits */
;;;374          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
0000be  2005              MOVS     r0,#5
                  |L1.192|
0000c0  7008              STRB     r0,[r1,#0]
                  |L1.194|
;;;375          break;
;;;376        default:
;;;377          break;
;;;378      }
;;;379    }
0000c2  4770              BX       lr
;;;380    
                          ENDP

                  RCC_LSICmd PROC
;;;392      */
;;;393    void RCC_LSICmd(FunctionalState NewState)
0000c4  49bd              LDR      r1,|L1.956|
;;;394    {
;;;395      /* Check the parameters */
;;;396      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;397    
;;;398      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
0000c6  6008              STR      r0,[r1,#0]
;;;399    }
0000c8  4770              BX       lr
;;;400    
                          ENDP

                  RCC_PLLConfig PROC
;;;435      */
;;;436    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
0000ca  ea411182          ORR      r1,r1,r2,LSL #6
;;;437    {
;;;438      /* Check the parameters */
;;;439      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;440      assert_param(IS_RCC_PLLM_VALUE(PLLM));
;;;441      assert_param(IS_RCC_PLLN_VALUE(PLLN));
;;;442      assert_param(IS_RCC_PLLP_VALUE(PLLP));
;;;443      assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
;;;444    
;;;445      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
0000ce  085a              LSRS     r2,r3,#1
0000d0  b510              PUSH     {r4,lr}               ;437
0000d2  4bbb              LDR      r3,|L1.960|
0000d4  9c02              LDR      r4,[sp,#8]
0000d6  eb034202          ADD      r2,r3,r2,LSL #16
0000da  4311              ORRS     r1,r1,r2
0000dc  4301              ORRS     r1,r1,r0
0000de  ea416004          ORR      r0,r1,r4,LSL #24
0000e2  49b2              LDR      r1,|L1.940|
0000e4  1d09              ADDS     r1,r1,#4
0000e6  6008              STR      r0,[r1,#0]
;;;446                     (PLLQ << 24);
;;;447    }
0000e8  bd10              POP      {r4,pc}
;;;448    
                          ENDP

                  RCC_PLLCmd PROC
;;;458      */
;;;459    void RCC_PLLCmd(FunctionalState NewState)
0000ea  49b3              LDR      r1,|L1.952|
;;;460    {
;;;461      /* Check the parameters */
;;;462      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;463      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
0000ec  6608              STR      r0,[r1,#0x60]
;;;464    }
0000ee  4770              BX       lr
;;;465    
                          ENDP

                  RCC_PLLI2SConfig PROC
;;;484      */
;;;485    void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
0000f0  0180              LSLS     r0,r0,#6
;;;486    {
;;;487      /* Check the parameters */
;;;488      assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
;;;489      assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
;;;490    
;;;491      RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
0000f2  ea407001          ORR      r0,r0,r1,LSL #28
0000f6  49ad              LDR      r1,|L1.940|
0000f8  3184              ADDS     r1,r1,#0x84
0000fa  6008              STR      r0,[r1,#0]
;;;492    }
0000fc  4770              BX       lr
;;;493    
                          ENDP

                  RCC_PLLI2SCmd PROC
;;;499      */
;;;500    void RCC_PLLI2SCmd(FunctionalState NewState)
0000fe  49ae              LDR      r1,|L1.952|
;;;501    {
;;;502      /* Check the parameters */
;;;503      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;504      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000100  6688              STR      r0,[r1,#0x68]
;;;505    }
000102  4770              BX       lr
;;;506    
                          ENDP

                  RCC_ClockSecuritySystemCmd PROC
;;;517      */
;;;518    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000104  49ac              LDR      r1,|L1.952|
;;;519    {
;;;520      /* Check the parameters */
;;;521      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;522      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000106  64c8              STR      r0,[r1,#0x4c]
;;;523    }
000108  4770              BX       lr
;;;524    
                          ENDP

                  RCC_MCO1Config PROC
;;;542      */
;;;543    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
00010a  4ba8              LDR      r3,|L1.940|
;;;544    {
;;;545      uint32_t tmpreg = 0;
;;;546      
;;;547      /* Check the parameters */
;;;548      assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
;;;549      assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
;;;550    
;;;551      tmpreg = RCC->CFGR;
00010c  3308              ADDS     r3,r3,#8
00010e  681a              LDR      r2,[r3,#0]
;;;552    
;;;553      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;554      tmpreg &= CFGR_MCO1_RESET_MASK;
;;;555    
;;;556      /* Select MCO1 clock source and prescaler */
;;;557      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
000110  4308              ORRS     r0,r0,r1
000112  f02262ec          BIC      r2,r2,#0x7600000      ;554
000116  4310              ORRS     r0,r0,r2
;;;558    
;;;559      /* Store the new value */
;;;560      RCC->CFGR = tmpreg;  
000118  6018              STR      r0,[r3,#0]
;;;561    }
00011a  4770              BX       lr
;;;562    
                          ENDP

                  RCC_MCO2Config PROC
;;;580      */
;;;581    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
00011c  4ba3              LDR      r3,|L1.940|
;;;582    {
;;;583      uint32_t tmpreg = 0;
;;;584      
;;;585      /* Check the parameters */
;;;586      assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
;;;587      assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
;;;588      
;;;589      tmpreg = RCC->CFGR;
00011e  3308              ADDS     r3,r3,#8
000120  681a              LDR      r2,[r3,#0]
;;;590      
;;;591      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;592      tmpreg &= CFGR_MCO2_RESET_MASK;
;;;593    
;;;594      /* Select MCO2 clock source and prescaler */
;;;595      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
000122  4308              ORRS     r0,r0,r1
000124  f0224278          BIC      r2,r2,#0xf8000000     ;592
000128  4310              ORRS     r0,r0,r2
;;;596    
;;;597      /* Store the new value */
;;;598      RCC->CFGR = tmpreg;  
00012a  6018              STR      r0,[r3,#0]
;;;599    }
00012c  4770              BX       lr
;;;600    
                          ENDP

                  RCC_SYSCLKConfig PROC
;;;686      */
;;;687    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
00012e  4a9f              LDR      r2,|L1.940|
;;;688    {
;;;689      uint32_t tmpreg = 0;
;;;690    
;;;691      /* Check the parameters */
;;;692      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;693    
;;;694      tmpreg = RCC->CFGR;
000130  3208              ADDS     r2,r2,#8
000132  6811              LDR      r1,[r2,#0]
;;;695    
;;;696      /* Clear SW[1:0] bits */
;;;697      tmpreg &= ~RCC_CFGR_SW;
000134  f0210103          BIC      r1,r1,#3
;;;698    
;;;699      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;700      tmpreg |= RCC_SYSCLKSource;
000138  4301              ORRS     r1,r1,r0
;;;701    
;;;702      /* Store the new value */
;;;703      RCC->CFGR = tmpreg;
00013a  6011              STR      r1,[r2,#0]
;;;704    }
00013c  4770              BX       lr
;;;705    
                          ENDP

                  RCC_GetSYSCLKSource PROC
;;;714      */
;;;715    uint8_t RCC_GetSYSCLKSource(void)
00013e  489b              LDR      r0,|L1.940|
;;;716    {
;;;717      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000140  3008              ADDS     r0,r0,#8
000142  6800              LDR      r0,[r0,#0]
000144  f000000c          AND      r0,r0,#0xc
;;;718    }
000148  4770              BX       lr
;;;719    
                          ENDP

                  RCC_HCLKConfig PROC
;;;739      */
;;;740    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
00014a  4a98              LDR      r2,|L1.940|
;;;741    {
;;;742      uint32_t tmpreg = 0;
;;;743      
;;;744      /* Check the parameters */
;;;745      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;746    
;;;747      tmpreg = RCC->CFGR;
00014c  3208              ADDS     r2,r2,#8
00014e  6811              LDR      r1,[r2,#0]
;;;748    
;;;749      /* Clear HPRE[3:0] bits */
;;;750      tmpreg &= ~RCC_CFGR_HPRE;
000150  f02101f0          BIC      r1,r1,#0xf0
;;;751    
;;;752      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;753      tmpreg |= RCC_SYSCLK;
000154  4301              ORRS     r1,r1,r0
;;;754    
;;;755      /* Store the new value */
;;;756      RCC->CFGR = tmpreg;
000156  6011              STR      r1,[r2,#0]
;;;757    }
000158  4770              BX       lr
;;;758    
                          ENDP

                  RCC_PCLK1Config PROC
;;;771      */
;;;772    void RCC_PCLK1Config(uint32_t RCC_HCLK)
00015a  4a94              LDR      r2,|L1.940|
;;;773    {
;;;774      uint32_t tmpreg = 0;
;;;775    
;;;776      /* Check the parameters */
;;;777      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;778    
;;;779      tmpreg = RCC->CFGR;
00015c  3208              ADDS     r2,r2,#8
00015e  6811              LDR      r1,[r2,#0]
;;;780    
;;;781      /* Clear PPRE1[2:0] bits */
;;;782      tmpreg &= ~RCC_CFGR_PPRE1;
000160  f42151e0          BIC      r1,r1,#0x1c00
;;;783    
;;;784      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;785      tmpreg |= RCC_HCLK;
000164  4301              ORRS     r1,r1,r0
;;;786    
;;;787      /* Store the new value */
;;;788      RCC->CFGR = tmpreg;
000166  6011              STR      r1,[r2,#0]
;;;789    }
000168  4770              BX       lr
;;;790    
                          ENDP

                  RCC_PCLK2Config PROC
;;;802      */
;;;803    void RCC_PCLK2Config(uint32_t RCC_HCLK)
00016a  4a90              LDR      r2,|L1.940|
;;;804    {
;;;805      uint32_t tmpreg = 0;
;;;806    
;;;807      /* Check the parameters */
;;;808      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;809    
;;;810      tmpreg = RCC->CFGR;
00016c  3208              ADDS     r2,r2,#8
00016e  6811              LDR      r1,[r2,#0]
;;;811    
;;;812      /* Clear PPRE2[2:0] bits */
;;;813      tmpreg &= ~RCC_CFGR_PPRE2;
000170  f4214160          BIC      r1,r1,#0xe000
;;;814    
;;;815      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;816      tmpreg |= RCC_HCLK << 3;
000174  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;817    
;;;818      /* Store the new value */
;;;819      RCC->CFGR = tmpreg;
000178  6010              STR      r0,[r2,#0]
;;;820    }
00017a  4770              BX       lr
;;;821    
                          ENDP

                  RCC_GetClocksFreq PROC
;;;854      */
;;;855    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
00017c  b570              PUSH     {r4-r6,lr}
;;;856    {
;;;857      uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
;;;858    
;;;859      /* Get SYSCLK source -------------------------------------------------------*/
;;;860      tmp = RCC->CFGR & RCC_CFGR_SWS;
00017e  4b8b              LDR      r3,|L1.940|
000180  3308              ADDS     r3,r3,#8
000182  6819              LDR      r1,[r3,#0]
;;;861    
;;;862      switch (tmp)
;;;863      {
;;;864        case 0x00:  /* HSI used as system clock source */
;;;865          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000184  4c8f              LDR      r4,|L1.964|
000186  f011010c          ANDS     r1,r1,#0xc            ;860
00018a  d004              BEQ      |L1.406|
;;;866          break;
;;;867        case 0x04:  /* HSE used as system clock  source */
;;;868          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
00018c  1066              ASRS     r6,r4,#1
00018e  2904              CMP      r1,#4                 ;862
000190  d003              BEQ      |L1.410|
000192  2908              CMP      r1,#8                 ;862
000194  d003              BEQ      |L1.414|
                  |L1.406|
000196  6004              STR      r4,[r0,#0]            ;866
000198  e01b              B        |L1.466|
                  |L1.410|
;;;869          break;
00019a  6006              STR      r6,[r0,#0]
00019c  e019              B        |L1.466|
                  |L1.414|
;;;870        case 0x08:  /* PLL used as system clock  source */
;;;871    
;;;872          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;873             SYSCLK = PLL_VCO / PLLP
;;;874             */    
;;;875          pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
00019e  4a83              LDR      r2,|L1.940|
0001a0  1d12              ADDS     r2,r2,#4
0001a2  6811              LDR      r1,[r2,#0]
0001a4  f3c15580          UBFX     r5,r1,#22,#1
;;;876          pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
0001a8  6811              LDR      r1,[r2,#0]
0001aa  f001013f          AND      r1,r1,#0x3f
;;;877          
;;;878          if (pllsource != 0)
0001ae  b115              CBZ      r5,|L1.438|
;;;879          {
;;;880            /* HSE used as PLL clock source */
;;;881            pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
0001b0  fbb6f1f1          UDIV     r1,r6,r1
0001b4  e001              B        |L1.442|
                  |L1.438|
;;;882          }
;;;883          else
;;;884          {
;;;885            /* HSI used as PLL clock source */
;;;886            pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
0001b6  fbb4f1f1          UDIV     r1,r4,r1
                  |L1.442|
0001ba  6814              LDR      r4,[r2,#0]
;;;887          }
;;;888    
;;;889          pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
0001bc  6812              LDR      r2,[r2,#0]
0001be  f3c41488          UBFX     r4,r4,#6,#9           ;886
0001c2  4361              MULS     r1,r4,r1              ;886
0001c4  f3c24201          UBFX     r2,r2,#16,#2
0001c8  1c52              ADDS     r2,r2,#1
0001ca  0052              LSLS     r2,r2,#1
;;;890          RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
0001cc  fbb1f1f2          UDIV     r1,r1,r2
0001d0  6001              STR      r1,[r0,#0]
                  |L1.466|
;;;891          break;
;;;892        default:
;;;893          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;894          break;
;;;895      }
;;;896      /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;897    
;;;898      /* Get HCLK prescaler */
;;;899      tmp = RCC->CFGR & RCC_CFGR_HPRE;
0001d2  6819              LDR      r1,[r3,#0]
;;;900      tmp = tmp >> 4;
;;;901      presc = APBAHBPrescTable[tmp];
;;;902      /* HCLK clock frequency */
;;;903      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;904    
;;;905      /* Get PCLK1 prescaler */
;;;906      tmp = RCC->CFGR & RCC_CFGR_PPRE1;
;;;907      tmp = tmp >> 10;
;;;908      presc = APBAHBPrescTable[tmp];
;;;909      /* PCLK1 clock frequency */
;;;910      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;911    
;;;912      /* Get PCLK2 prescaler */
;;;913      tmp = RCC->CFGR & RCC_CFGR_PPRE2;
;;;914      tmp = tmp >> 13;
;;;915      presc = APBAHBPrescTable[tmp];
;;;916      /* PCLK2 clock frequency */
;;;917      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;918    }
0001d4  220f              MOVS     r2,#0xf
0001d6  ea021111          AND      r1,r2,r1,LSR #4
0001da  4a7b              LDR      r2,|L1.968|
0001dc  5c54              LDRB     r4,[r2,r1]            ;901
0001de  6801              LDR      r1,[r0,#0]            ;903
0001e0  40e1              LSRS     r1,r1,r4              ;903
0001e2  6041              STR      r1,[r0,#4]            ;906
0001e4  681c              LDR      r4,[r3,#0]            ;906
0001e6  2507              MOVS     r5,#7
0001e8  ea052494          AND      r4,r5,r4,LSR #10
0001ec  5d14              LDRB     r4,[r2,r4]            ;908
0001ee  fa21f404          LSR      r4,r1,r4              ;910
0001f2  6084              STR      r4,[r0,#8]            ;913
0001f4  681b              LDR      r3,[r3,#0]            ;913
0001f6  ea053353          AND      r3,r5,r3,LSR #13
0001fa  5cd2              LDRB     r2,[r2,r3]            ;915
0001fc  40d1              LSRS     r1,r1,r2              ;917
0001fe  60c1              STR      r1,[r0,#0xc]          ;917
000200  bd70              POP      {r4-r6,pc}
;;;919    
                          ENDP

                  RCC_RTCCLKConfig PROC
;;;979      */
;;;980    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000202  f3c02101          UBFX     r1,r0,#8,#2
;;;981    {
;;;982      uint32_t tmpreg = 0;
;;;983    
;;;984      /* Check the parameters */
;;;985      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;986    
;;;987      if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
000206  2903              CMP      r1,#3
000208  d108              BNE      |L1.540|
;;;988      { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;989        tmpreg = RCC->CFGR;
00020a  4b68              LDR      r3,|L1.940|
00020c  3308              ADDS     r3,r3,#8
00020e  6819              LDR      r1,[r3,#0]
;;;990    
;;;991        /* Clear RTCPRE[4:0] bits */
;;;992        tmpreg &= ~RCC_CFGR_RTCPRE;
;;;993    
;;;994        /* Configure HSE division factor for RTC clock */
;;;995        tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
000210  4a6e              LDR      r2,|L1.972|
000212  f42111f8          BIC      r1,r1,#0x1f0000       ;992
000216  4002              ANDS     r2,r2,r0
000218  430a              ORRS     r2,r2,r1
;;;996    
;;;997        /* Store the new value */
;;;998        RCC->CFGR = tmpreg;
00021a  601a              STR      r2,[r3,#0]
                  |L1.540|
;;;999      }
;;;1000       
;;;1001     /* Select the RTC clock source */
;;;1002     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
00021c  4963              LDR      r1,|L1.940|
00021e  3170              ADDS     r1,r1,#0x70
000220  680a              LDR      r2,[r1,#0]
000222  f3c0000b          UBFX     r0,r0,#0,#12
000226  4302              ORRS     r2,r2,r0
000228  600a              STR      r2,[r1,#0]
;;;1003   }
00022a  4770              BX       lr
;;;1004   
                          ENDP

                  RCC_RTCCLKCmd PROC
;;;1011     */
;;;1012   void RCC_RTCCLKCmd(FunctionalState NewState)
00022c  4963              LDR      r1,|L1.956|
;;;1013   {
;;;1014     /* Check the parameters */
;;;1015     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1016   
;;;1017     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
00022e  3944              SUBS     r1,r1,#0x44
000230  6008              STR      r0,[r1,#0]
;;;1018   }
000232  4770              BX       lr
;;;1019   
                          ENDP

                  RCC_BackupResetCmd PROC
;;;1028     */
;;;1029   void RCC_BackupResetCmd(FunctionalState NewState)
000234  4961              LDR      r1,|L1.956|
;;;1030   {
;;;1031     /* Check the parameters */
;;;1032     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1033     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000236  3940              SUBS     r1,r1,#0x40
000238  6008              STR      r0,[r1,#0]
;;;1034   }
00023a  4770              BX       lr
;;;1035   
                          ENDP

                  RCC_I2SCLKConfig PROC
;;;1045     */
;;;1046   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
00023c  495e              LDR      r1,|L1.952|
;;;1047   {
;;;1048     /* Check the parameters */
;;;1049     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1050   
;;;1051     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
00023e  f8c1015c          STR      r0,[r1,#0x15c]
;;;1052   }
000242  4770              BX       lr
;;;1053   
                          ENDP

                  RCC_AHB1PeriphClockCmd PROC
;;;1084     */
;;;1085   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000244  4a59              LDR      r2,|L1.940|
;;;1086   {
;;;1087     /* Check the parameters */
;;;1088     assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
;;;1089   
;;;1090     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1091     if (NewState != DISABLE)
;;;1092     {
;;;1093       RCC->AHB1ENR |= RCC_AHB1Periph;
000246  3230              ADDS     r2,r2,#0x30
000248  2900              CMP      r1,#0                 ;1091
;;;1094     }
;;;1095     else
;;;1096     {
;;;1097       RCC->AHB1ENR &= ~RCC_AHB1Periph;
00024a  6811              LDR      r1,[r2,#0]
00024c  d001              BEQ      |L1.594|
00024e  4301              ORRS     r1,r1,r0              ;1093
000250  e000              B        |L1.596|
                  |L1.594|
000252  4381              BICS     r1,r1,r0
                  |L1.596|
000254  6011              STR      r1,[r2,#0]            ;1093
;;;1098     }
;;;1099   }
000256  4770              BX       lr
;;;1100   
                          ENDP

                  RCC_AHB2PeriphClockCmd PROC
;;;1116     */
;;;1117   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000258  4a54              LDR      r2,|L1.940|
;;;1118   {
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1121     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1122   
;;;1123     if (NewState != DISABLE)
;;;1124     {
;;;1125       RCC->AHB2ENR |= RCC_AHB2Periph;
00025a  3234              ADDS     r2,r2,#0x34
00025c  2900              CMP      r1,#0                 ;1123
;;;1126     }
;;;1127     else
;;;1128     {
;;;1129       RCC->AHB2ENR &= ~RCC_AHB2Periph;
00025e  6811              LDR      r1,[r2,#0]
000260  d001              BEQ      |L1.614|
000262  4301              ORRS     r1,r1,r0              ;1125
000264  e000              B        |L1.616|
                  |L1.614|
000266  4381              BICS     r1,r1,r0
                  |L1.616|
000268  6011              STR      r1,[r2,#0]            ;1125
;;;1130     }
;;;1131   }
00026a  4770              BX       lr
;;;1132   
                          ENDP

                  RCC_AHB3PeriphClockCmd PROC
;;;1143     */
;;;1144   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
00026c  4a4f              LDR      r2,|L1.940|
;;;1145   {
;;;1146     /* Check the parameters */
;;;1147     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
;;;1148     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1149   
;;;1150     if (NewState != DISABLE)
;;;1151     {
;;;1152       RCC->AHB3ENR |= RCC_AHB3Periph;
00026e  3238              ADDS     r2,r2,#0x38
000270  2900              CMP      r1,#0                 ;1150
;;;1153     }
;;;1154     else
;;;1155     {
;;;1156       RCC->AHB3ENR &= ~RCC_AHB3Periph;
000272  6811              LDR      r1,[r2,#0]
000274  d001              BEQ      |L1.634|
000276  4301              ORRS     r1,r1,r0              ;1152
000278  e000              B        |L1.636|
                  |L1.634|
00027a  4381              BICS     r1,r1,r0
                  |L1.636|
00027c  6011              STR      r1,[r2,#0]            ;1152
;;;1157     }
;;;1158   }
00027e  4770              BX       lr
;;;1159   
                          ENDP

                  RCC_APB1PeriphClockCmd PROC
;;;1193     */
;;;1194   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000280  4a4a              LDR      r2,|L1.940|
;;;1195   {
;;;1196     /* Check the parameters */
;;;1197     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
;;;1198     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1199   
;;;1200     if (NewState != DISABLE)
;;;1201     {
;;;1202       RCC->APB1ENR |= RCC_APB1Periph;
000282  3240              ADDS     r2,r2,#0x40
000284  2900              CMP      r1,#0                 ;1200
;;;1203     }
;;;1204     else
;;;1205     {
;;;1206       RCC->APB1ENR &= ~RCC_APB1Periph;
000286  6811              LDR      r1,[r2,#0]
000288  d001              BEQ      |L1.654|
00028a  4301              ORRS     r1,r1,r0              ;1202
00028c  e000              B        |L1.656|
                  |L1.654|
00028e  4381              BICS     r1,r1,r0
                  |L1.656|
000290  6011              STR      r1,[r2,#0]            ;1202
;;;1207     }
;;;1208   }
000292  4770              BX       lr
;;;1209   
                          ENDP

                  RCC_APB2PeriphClockCmd PROC
;;;1233     */
;;;1234   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000294  4a45              LDR      r2,|L1.940|
;;;1235   {
;;;1236     /* Check the parameters */
;;;1237     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1238     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1239   
;;;1240     if (NewState != DISABLE)
;;;1241     {
;;;1242       RCC->APB2ENR |= RCC_APB2Periph;
000296  3244              ADDS     r2,r2,#0x44
000298  2900              CMP      r1,#0                 ;1240
;;;1243     }
;;;1244     else
;;;1245     {
;;;1246       RCC->APB2ENR &= ~RCC_APB2Periph;
00029a  6811              LDR      r1,[r2,#0]
00029c  d001              BEQ      |L1.674|
00029e  4301              ORRS     r1,r1,r0              ;1242
0002a0  e000              B        |L1.676|
                  |L1.674|
0002a2  4381              BICS     r1,r1,r0
                  |L1.676|
0002a4  6011              STR      r1,[r2,#0]            ;1242
;;;1247     }
;;;1248   }
0002a6  4770              BX       lr
;;;1249   
                          ENDP

                  RCC_AHB1PeriphResetCmd PROC
;;;1272     */
;;;1273   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
0002a8  4a40              LDR      r2,|L1.940|
;;;1274   {
;;;1275     /* Check the parameters */
;;;1276     assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
;;;1277     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1278   
;;;1279     if (NewState != DISABLE)
;;;1280     {
;;;1281       RCC->AHB1RSTR |= RCC_AHB1Periph;
0002aa  3210              ADDS     r2,r2,#0x10
0002ac  2900              CMP      r1,#0                 ;1279
;;;1282     }
;;;1283     else
;;;1284     {
;;;1285       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
0002ae  6811              LDR      r1,[r2,#0]
0002b0  d001              BEQ      |L1.694|
0002b2  4301              ORRS     r1,r1,r0              ;1281
0002b4  e000              B        |L1.696|
                  |L1.694|
0002b6  4381              BICS     r1,r1,r0
                  |L1.696|
0002b8  6011              STR      r1,[r2,#0]            ;1281
;;;1286     }
;;;1287   }
0002ba  4770              BX       lr
;;;1288   
                          ENDP

                  RCC_AHB2PeriphResetCmd PROC
;;;1301     */
;;;1302   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
0002bc  4a3b              LDR      r2,|L1.940|
;;;1303   {
;;;1304     /* Check the parameters */
;;;1305     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1306     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1307   
;;;1308     if (NewState != DISABLE)
;;;1309     {
;;;1310       RCC->AHB2RSTR |= RCC_AHB2Periph;
0002be  3214              ADDS     r2,r2,#0x14
0002c0  2900              CMP      r1,#0                 ;1308
;;;1311     }
;;;1312     else
;;;1313     {
;;;1314       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
0002c2  6811              LDR      r1,[r2,#0]
0002c4  d001              BEQ      |L1.714|
0002c6  4301              ORRS     r1,r1,r0              ;1310
0002c8  e000              B        |L1.716|
                  |L1.714|
0002ca  4381              BICS     r1,r1,r0
                  |L1.716|
0002cc  6011              STR      r1,[r2,#0]            ;1310
;;;1315     }
;;;1316   }
0002ce  4770              BX       lr
;;;1317   
                          ENDP

                  RCC_AHB3PeriphResetCmd PROC
;;;1325     */
;;;1326   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
0002d0  4a36              LDR      r2,|L1.940|
;;;1327   {
;;;1328     /* Check the parameters */
;;;1329     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1330     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1331   
;;;1332     if (NewState != DISABLE)
;;;1333     {
;;;1334       RCC->AHB3RSTR |= RCC_AHB3Periph;
0002d2  3218              ADDS     r2,r2,#0x18
0002d4  2900              CMP      r1,#0                 ;1332
;;;1335     }
;;;1336     else
;;;1337     {
;;;1338       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
0002d6  6811              LDR      r1,[r2,#0]
0002d8  d001              BEQ      |L1.734|
0002da  4301              ORRS     r1,r1,r0              ;1334
0002dc  e000              B        |L1.736|
                  |L1.734|
0002de  4381              BICS     r1,r1,r0
                  |L1.736|
0002e0  6011              STR      r1,[r2,#0]            ;1334
;;;1339     }
;;;1340   }
0002e2  4770              BX       lr
;;;1341   
                          ENDP

                  RCC_APB1PeriphResetCmd PROC
;;;1372     */
;;;1373   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
0002e4  4a31              LDR      r2,|L1.940|
;;;1374   {
;;;1375     /* Check the parameters */
;;;1376     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1377     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1378     if (NewState != DISABLE)
;;;1379     {
;;;1380       RCC->APB1RSTR |= RCC_APB1Periph;
0002e6  3220              ADDS     r2,r2,#0x20
0002e8  2900              CMP      r1,#0                 ;1378
;;;1381     }
;;;1382     else
;;;1383     {
;;;1384       RCC->APB1RSTR &= ~RCC_APB1Periph;
0002ea  6811              LDR      r1,[r2,#0]
0002ec  d001              BEQ      |L1.754|
0002ee  4301              ORRS     r1,r1,r0              ;1380
0002f0  e000              B        |L1.756|
                  |L1.754|
0002f2  4381              BICS     r1,r1,r0
                  |L1.756|
0002f4  6011              STR      r1,[r2,#0]            ;1380
;;;1385     }
;;;1386   }
0002f6  4770              BX       lr
;;;1387   
                          ENDP

                  RCC_APB2PeriphResetCmd PROC
;;;1408     */
;;;1409   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
0002f8  4a2c              LDR      r2,|L1.940|
;;;1410   {
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
;;;1413     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1414     if (NewState != DISABLE)
;;;1415     {
;;;1416       RCC->APB2RSTR |= RCC_APB2Periph;
0002fa  3224              ADDS     r2,r2,#0x24
0002fc  2900              CMP      r1,#0                 ;1414
;;;1417     }
;;;1418     else
;;;1419     {
;;;1420       RCC->APB2RSTR &= ~RCC_APB2Periph;
0002fe  6811              LDR      r1,[r2,#0]
000300  d001              BEQ      |L1.774|
000302  4301              ORRS     r1,r1,r0              ;1416
000304  e000              B        |L1.776|
                  |L1.774|
000306  4381              BICS     r1,r1,r0
                  |L1.776|
000308  6011              STR      r1,[r2,#0]            ;1416
;;;1421     }
;;;1422   }
00030a  4770              BX       lr
;;;1423   
                          ENDP

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;1454     */
;;;1455   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
00030c  4a27              LDR      r2,|L1.940|
;;;1456   {
;;;1457     /* Check the parameters */
;;;1458     assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
;;;1459     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1460     if (NewState != DISABLE)
;;;1461     {
;;;1462       RCC->AHB1LPENR |= RCC_AHB1Periph;
00030e  3250              ADDS     r2,r2,#0x50
000310  2900              CMP      r1,#0                 ;1460
;;;1463     }
;;;1464     else
;;;1465     {
;;;1466       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
000312  6811              LDR      r1,[r2,#0]
000314  d001              BEQ      |L1.794|
000316  4301              ORRS     r1,r1,r0              ;1462
000318  e000              B        |L1.796|
                  |L1.794|
00031a  4381              BICS     r1,r1,r0
                  |L1.796|
00031c  6011              STR      r1,[r2,#0]            ;1462
;;;1467     }
;;;1468   }
00031e  4770              BX       lr
;;;1469   
                          ENDP

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;1486     */
;;;1487   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000320  4a22              LDR      r2,|L1.940|
;;;1488   {
;;;1489     /* Check the parameters */
;;;1490     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1491     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1492     if (NewState != DISABLE)
;;;1493     {
;;;1494       RCC->AHB2LPENR |= RCC_AHB2Periph;
000322  3254              ADDS     r2,r2,#0x54
000324  2900              CMP      r1,#0                 ;1492
;;;1495     }
;;;1496     else
;;;1497     {
;;;1498       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
000326  6811              LDR      r1,[r2,#0]
000328  d001              BEQ      |L1.814|
00032a  4301              ORRS     r1,r1,r0              ;1494
00032c  e000              B        |L1.816|
                  |L1.814|
00032e  4381              BICS     r1,r1,r0
                  |L1.816|
000330  6011              STR      r1,[r2,#0]            ;1494
;;;1499     }
;;;1500   }
000332  4770              BX       lr
;;;1501   
                          ENDP

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;1513     */
;;;1514   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000334  4a1d              LDR      r2,|L1.940|
;;;1515   {
;;;1516     /* Check the parameters */
;;;1517     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1518     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1519     if (NewState != DISABLE)
;;;1520     {
;;;1521       RCC->AHB3LPENR |= RCC_AHB3Periph;
000336  3258              ADDS     r2,r2,#0x58
000338  2900              CMP      r1,#0                 ;1519
;;;1522     }
;;;1523     else
;;;1524     {
;;;1525       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
00033a  6811              LDR      r1,[r2,#0]
00033c  d001              BEQ      |L1.834|
00033e  4301              ORRS     r1,r1,r0              ;1521
000340  e000              B        |L1.836|
                  |L1.834|
000342  4381              BICS     r1,r1,r0
                  |L1.836|
000344  6011              STR      r1,[r2,#0]            ;1521
;;;1526     }
;;;1527   }
000346  4770              BX       lr
;;;1528   
                          ENDP

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;1563     */
;;;1564   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000348  4a18              LDR      r2,|L1.940|
;;;1565   {
;;;1566     /* Check the parameters */
;;;1567     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1568     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1569     if (NewState != DISABLE)
;;;1570     {
;;;1571       RCC->APB1LPENR |= RCC_APB1Periph;
00034a  3260              ADDS     r2,r2,#0x60
00034c  2900              CMP      r1,#0                 ;1569
;;;1572     }
;;;1573     else
;;;1574     {
;;;1575       RCC->APB1LPENR &= ~RCC_APB1Periph;
00034e  6811              LDR      r1,[r2,#0]
000350  d001              BEQ      |L1.854|
000352  4301              ORRS     r1,r1,r0              ;1571
000354  e000              B        |L1.856|
                  |L1.854|
000356  4381              BICS     r1,r1,r0
                  |L1.856|
000358  6011              STR      r1,[r2,#0]            ;1571
;;;1576     }
;;;1577   }
00035a  4770              BX       lr
;;;1578   
                          ENDP

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;1603     */
;;;1604   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
00035c  4a13              LDR      r2,|L1.940|
;;;1605   {
;;;1606     /* Check the parameters */
;;;1607     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1608     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1609     if (NewState != DISABLE)
;;;1610     {
;;;1611       RCC->APB2LPENR |= RCC_APB2Periph;
00035e  3264              ADDS     r2,r2,#0x64
000360  2900              CMP      r1,#0                 ;1609
;;;1612     }
;;;1613     else
;;;1614     {
;;;1615       RCC->APB2LPENR &= ~RCC_APB2Periph;
000362  6811              LDR      r1,[r2,#0]
000364  d001              BEQ      |L1.874|
000366  4301              ORRS     r1,r1,r0              ;1611
000368  e000              B        |L1.876|
                  |L1.874|
00036a  4381              BICS     r1,r1,r0
                  |L1.876|
00036c  6011              STR      r1,[r2,#0]            ;1611
;;;1616     }
;;;1617   }
00036e  4770              BX       lr
;;;1618   
                          ENDP

                  RCC_ITConfig PROC
;;;1648     */
;;;1649   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000370  4a0e              LDR      r2,|L1.940|
;;;1650   {
;;;1651     /* Check the parameters */
;;;1652     assert_param(IS_RCC_IT(RCC_IT));
;;;1653     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1654     if (NewState != DISABLE)
;;;1655     {
;;;1656       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;1657       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
000372  320d              ADDS     r2,r2,#0xd
000374  2900              CMP      r1,#0                 ;1654
;;;1658     }
;;;1659     else
;;;1660     {
;;;1661       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;1662       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000376  7811              LDRB     r1,[r2,#0]
000378  d001              BEQ      |L1.894|
00037a  4301              ORRS     r1,r1,r0              ;1657
00037c  e000              B        |L1.896|
                  |L1.894|
00037e  4381              BICS     r1,r1,r0
                  |L1.896|
000380  7011              STRB     r1,[r2,#0]            ;1657
;;;1663     }
;;;1664   }
000382  4770              BX       lr
;;;1665   
                          ENDP

                  RCC_ClearFlag PROC
;;;1729     */
;;;1730   void RCC_ClearFlag(void)
000384  4809              LDR      r0,|L1.940|
;;;1731   {
;;;1732     /* Set RMVF bit to clear the reset flags */
;;;1733     RCC->CSR |= RCC_CSR_RMVF;
000386  3074              ADDS     r0,r0,#0x74
000388  6801              LDR      r1,[r0,#0]
00038a  f0417180          ORR      r1,r1,#0x1000000
00038e  6001              STR      r1,[r0,#0]
;;;1734   }
000390  4770              BX       lr
;;;1735   
                          ENDP

                  RCC_GetITStatus PROC
;;;1748     */
;;;1749   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000392  4601              MOV      r1,r0
;;;1750   {
;;;1751     ITStatus bitstatus = RESET;
;;;1752   
;;;1753     /* Check the parameters */
;;;1754     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1755   
;;;1756     /* Check the status of the specified RCC interrupt */
;;;1757     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000394  4a05              LDR      r2,|L1.940|
000396  2000              MOVS     r0,#0                 ;1751
000398  320c              ADDS     r2,r2,#0xc
00039a  6812              LDR      r2,[r2,#0]
00039c  420a              TST      r2,r1
00039e  d000              BEQ      |L1.930|
;;;1758     {
;;;1759       bitstatus = SET;
0003a0  2001              MOVS     r0,#1
                  |L1.930|
;;;1760     }
;;;1761     else
;;;1762     {
;;;1763       bitstatus = RESET;
;;;1764     }
;;;1765     /* Return the RCC_IT status */
;;;1766     return  bitstatus;
;;;1767   }
0003a2  4770              BX       lr
;;;1768   
                          ENDP

                  RCC_ClearITPendingBit PROC
;;;1781     */
;;;1782   void RCC_ClearITPendingBit(uint8_t RCC_IT)
0003a4  4901              LDR      r1,|L1.940|
;;;1783   {
;;;1784     /* Check the parameters */
;;;1785     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1786   
;;;1787     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1788        pending bits */
;;;1789     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
0003a6  310e              ADDS     r1,r1,#0xe
0003a8  7008              STRB     r0,[r1,#0]
;;;1790   }
0003aa  4770              BX       lr
;;;1791   
                          ENDP

                  |L1.940|
                          DCD      0x40023800
                  |L1.944|
                          DCD      0xfef6ffff
                  |L1.948|
                          DCD      0x24003010
                  |L1.952|
                          DCD      0x42470000
                  |L1.956|
                          DCD      0x42470e80
                  |L1.960|
                          DCD      0xffff0000
                  |L1.964|
                          DCD      0x00f42400
                  |L1.968|
                          DCD      ||.data||
                  |L1.972|
                          DCD      0x0ffffcff

                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_rcc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_rcc_c_49e27980____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REVSH|
#line 128
|__asm___15_stm32f4xx_rcc_c_49e27980____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
